1.1          (drh      26-May-04): /*
1.1          (drh      26-May-04): ** 2004 May 26
1.1          (drh      26-May-04): **
1.1          (drh      26-May-04): ** The author disclaims copyright to this source code.  In place of
1.1          (drh      26-May-04): ** a legal notice, here is a blessing:
1.1          (drh      26-May-04): **
1.1          (drh      26-May-04): **    May you do good and not evil.
1.1          (drh      26-May-04): **    May you find forgiveness for yourself and forgive others.
1.1          (drh      26-May-04): **    May you share freely, never taking more than you give.
1.1          (drh      26-May-04): **
1.1          (drh      26-May-04): *************************************************************************
1.1          (drh      26-May-04): **
1.1          (drh      26-May-04): ** This file contains code use to manipulate "Mem" structure.  A "Mem"
1.1          (drh      26-May-04): ** stores a single value in the VDBE.  Mem is an opaque structure visible
1.1          (drh      26-May-04): ** only within the VDBE.  Interface routines refer to a Mem using the
1.1          (drh      26-May-04): ** name sqlite_value
1.115        (danielk1 16-May-08): **
1.134        (drh      05-Jan-09): ** $Id: vdbemem.c,v 1.133 2008/12/10 19:26:24 drh Exp $
1.1          (drh      26-May-04): */
1.1          (drh      26-May-04): #include "sqliteInt.h"
1.1          (drh      26-May-04): #include <ctype.h>
1.1          (drh      26-May-04): #include "vdbeInt.h"
1.1          (drh      26-May-04): 
1.1          (drh      26-May-04): /*
1.69         (danielk1 16-May-07): ** Call sqlite3VdbeMemExpandBlob() on the supplied value (type Mem*)
1.69         (danielk1 16-May-07): ** P if required.
1.69         (danielk1 16-May-07): */
1.80         (drh      21-Aug-07): #define expandBlob(P) (((P)->flags&MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0)
1.69         (danielk1 16-May-07): 
1.69         (danielk1 16-May-07): /*
1.19         (danielk1 18-Jun-04): ** If pMem is an object with a valid string representation, this routine
1.19         (danielk1 18-Jun-04): ** ensures the internal encoding for the string representation is
1.19         (danielk1 18-Jun-04): ** 'desiredEnc', one of SQLITE_UTF8, SQLITE_UTF16LE or SQLITE_UTF16BE.
1.1          (drh      26-May-04): **
1.19         (danielk1 18-Jun-04): ** If pMem is not a string object, or the encoding of the string
1.19         (danielk1 18-Jun-04): ** representation is already stored using the requested encoding, then this
1.19         (danielk1 18-Jun-04): ** routine is a no-op.
1.1          (drh      26-May-04): **
1.1          (drh      26-May-04): ** SQLITE_OK is returned if the conversion is successful (or not required).
1.1          (drh      26-May-04): ** SQLITE_NOMEM may be returned if a malloc() fails during conversion
1.1          (drh      26-May-04): ** between formats.
1.1          (drh      26-May-04): */
1.80         (drh      21-Aug-07): int sqlite3VdbeChangeEncoding(Mem *pMem, int desiredEnc){
1.30         (danielk1 13-Jan-05):   int rc;
1.127        (drh      04-Dec-08):   assert( (pMem->flags&MEM_RowSet)==0 );
1.132        (drh      10-Dec-08):   assert( desiredEnc==SQLITE_UTF8 || desiredEnc==SQLITE_UTF16LE
1.132        (drh      10-Dec-08):            || desiredEnc==SQLITE_UTF16BE );
1.2          (drh      27-May-04):   if( !(pMem->flags&MEM_Str) || pMem->enc==desiredEnc ){
1.1          (drh      26-May-04):     return SQLITE_OK;
1.1          (drh      26-May-04):   }
1.80         (drh      21-Aug-07):   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
1.28         (drh      14-Nov-04): #ifdef SQLITE_OMIT_UTF16
1.28         (drh      14-Nov-04):   return SQLITE_ERROR;
1.28         (drh      14-Nov-04): #else
1.44         (danielk1 07-Dec-05): 
1.44         (danielk1 07-Dec-05):   /* MemTranslate() may return SQLITE_OK or SQLITE_NOMEM. If NOMEM is returned,
1.44         (danielk1 07-Dec-05):   ** then the encoding of the value may not have changed.
1.44         (danielk1 07-Dec-05):   */
1.132        (drh      10-Dec-08):   rc = sqlite3VdbeMemTranslate(pMem, (u8)desiredEnc);
1.44         (danielk1 07-Dec-05):   assert(rc==SQLITE_OK    || rc==SQLITE_NOMEM);
1.44         (danielk1 07-Dec-05):   assert(rc==SQLITE_OK    || pMem->enc!=desiredEnc);
1.44         (danielk1 07-Dec-05):   assert(rc==SQLITE_NOMEM || pMem->enc==desiredEnc);
1.30         (danielk1 13-Jan-05):   return rc;
1.28         (drh      14-Nov-04): #endif
1.2          (drh      27-May-04): }
1.2          (drh      27-May-04): 
1.2          (drh      27-May-04): /*
1.93         (danielk1 13-Feb-08): ** Make sure pMem->z points to a writable allocation of at least 
1.93         (danielk1 13-Feb-08): ** n bytes.
1.93         (danielk1 13-Feb-08): **
1.93         (danielk1 13-Feb-08): ** If the memory cell currently contains string or blob data
1.93         (danielk1 13-Feb-08): ** and the third argument passed to this function is true, the 
1.93         (danielk1 13-Feb-08): ** current content of the cell is preserved. Otherwise, it may
1.93         (danielk1 13-Feb-08): ** be discarded.  
1.93         (danielk1 13-Feb-08): **
1.93         (danielk1 13-Feb-08): ** This function sets the MEM_Dyn flag and clears any xDel callback.
1.93         (danielk1 13-Feb-08): ** It also clears MEM_Ephem and MEM_Static. If the preserve flag is 
1.93         (danielk1 13-Feb-08): ** not set, Mem.n is zeroed.
1.93         (danielk1 13-Feb-08): */
1.93         (danielk1 13-Feb-08): int sqlite3VdbeMemGrow(Mem *pMem, int n, int preserve){
1.105        (danielk1 28-Mar-08):   assert( 1 >=
1.105        (danielk1 28-Mar-08):     ((pMem->zMalloc && pMem->zMalloc==pMem->z) ? 1 : 0) +
1.105        (danielk1 28-Mar-08):     (((pMem->flags&MEM_Dyn)&&pMem->xDel) ? 1 : 0) + 
1.105        (danielk1 28-Mar-08):     ((pMem->flags&MEM_Ephem) ? 1 : 0) + 
1.105        (danielk1 28-Mar-08):     ((pMem->flags&MEM_Static) ? 1 : 0)
1.93         (danielk1 13-Feb-08):   );
1.127        (drh      04-Dec-08):   assert( (pMem->flags&MEM_RowSet)==0 );
1.93         (danielk1 13-Feb-08): 
1.118        (drh      09-Jul-08):   if( n<32 ) n = 32;
1.119        (drh      28-Jul-08):   if( sqlite3DbMallocSize(pMem->db, pMem->zMalloc)<n ){
1.105        (danielk1 28-Mar-08):     if( preserve && pMem->z==pMem->zMalloc ){
1.105        (danielk1 28-Mar-08):       pMem->z = pMem->zMalloc = sqlite3DbReallocOrFree(pMem->db, pMem->z, n);
1.105        (danielk1 28-Mar-08):       preserve = 0;
1.105        (danielk1 28-Mar-08):     }else{
1.119        (drh      28-Jul-08):       sqlite3DbFree(pMem->db, pMem->zMalloc);
1.105        (danielk1 28-Mar-08):       pMem->zMalloc = sqlite3DbMallocRaw(pMem->db, n);
1.93         (danielk1 13-Feb-08):     }
1.105        (danielk1 28-Mar-08):   }
1.93         (danielk1 13-Feb-08): 
1.105        (danielk1 28-Mar-08):   if( preserve && pMem->z && pMem->zMalloc && pMem->z!=pMem->zMalloc ){
1.105        (danielk1 28-Mar-08):     memcpy(pMem->zMalloc, pMem->z, pMem->n);
1.105        (danielk1 28-Mar-08):   }
1.111        (drh      16-Apr-08):   if( pMem->flags&MEM_Dyn && pMem->xDel ){
1.105        (danielk1 28-Mar-08):     pMem->xDel((void *)(pMem->z));
1.105        (danielk1 28-Mar-08):   }
1.93         (danielk1 13-Feb-08): 
1.105        (danielk1 28-Mar-08):   pMem->z = pMem->zMalloc;
1.126        (drh      11-Nov-08):   if( pMem->z==0 ){
1.126        (drh      11-Nov-08):     pMem->flags = MEM_Null;
1.126        (drh      11-Nov-08):   }else{
1.126        (drh      11-Nov-08):     pMem->flags &= ~(MEM_Ephem|MEM_Static);
1.126        (drh      11-Nov-08):   }
1.105        (danielk1 28-Mar-08):   pMem->xDel = 0;
1.105        (danielk1 28-Mar-08):   return (pMem->z ? SQLITE_OK : SQLITE_NOMEM);
1.93         (danielk1 13-Feb-08): }
1.93         (danielk1 13-Feb-08): 
1.93         (danielk1 13-Feb-08): /*
1.120        (drh      30-Jul-08): ** Make the given Mem object MEM_Dyn.  In other words, make it so
1.120        (drh      30-Jul-08): ** that any TEXT or BLOB content is stored in memory obtained from
1.120        (drh      30-Jul-08): ** malloc().  In this way, we know that the memory is safe to be
1.120        (drh      30-Jul-08): ** overwritten or altered.
1.2          (drh      27-May-04): **
1.2          (drh      27-May-04): ** Return SQLITE_OK on success or SQLITE_NOMEM if malloc fails.
1.2          (drh      27-May-04): */
1.120        (drh      30-Jul-08): int sqlite3VdbeMemMakeWriteable(Mem *pMem){
1.93         (danielk1 13-Feb-08):   int f;
1.80         (drh      21-Aug-07):   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
1.127        (drh      04-Dec-08):   assert( (pMem->flags&MEM_RowSet)==0 );
1.80         (drh      21-Aug-07):   expandBlob(pMem);
1.93         (danielk1 13-Feb-08):   f = pMem->flags;
1.105        (danielk1 28-Mar-08):   if( (f&(MEM_Str|MEM_Blob)) && pMem->z!=pMem->zMalloc ){
1.93         (danielk1 13-Feb-08):     if( sqlite3VdbeMemGrow(pMem, pMem->n + 2, 1) ){
1.93         (danielk1 13-Feb-08):       return SQLITE_NOMEM;
1.93         (danielk1 13-Feb-08):     }
1.93         (danielk1 13-Feb-08):     pMem->z[pMem->n] = 0;
1.93         (danielk1 13-Feb-08):     pMem->z[pMem->n+1] = 0;
1.93         (danielk1 13-Feb-08):     pMem->flags |= MEM_Term;
1.2          (drh      27-May-04):   }
1.93         (danielk1 13-Feb-08): 
1.3          (drh      27-May-04):   return SQLITE_OK;
1.2          (drh      27-May-04): }
1.1          (drh      26-May-04): 
1.2          (drh      27-May-04): /*
1.61         (drh      02-May-07): ** If the given Mem* has a zero-filled tail, turn it into an ordinary
1.60         (drh      02-May-07): ** blob stored in dynamically allocated space.
1.60         (drh      02-May-07): */
1.68         (danielk1 16-May-07): #ifndef SQLITE_OMIT_INCRBLOB
1.80         (drh      21-Aug-07): int sqlite3VdbeMemExpandBlob(Mem *pMem){
1.60         (drh      02-May-07):   if( pMem->flags & MEM_Zero ){
1.72         (drh      07-Jun-07):     int nByte;
1.93         (danielk1 13-Feb-08):     assert( pMem->flags&MEM_Blob );
1.127        (drh      04-Dec-08):     assert( (pMem->flags&MEM_RowSet)==0 );
1.93         (danielk1 13-Feb-08):     assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
1.93         (danielk1 13-Feb-08): 
1.93         (danielk1 13-Feb-08):     /* Set nByte to the number of bytes required to store the expanded blob. */
1.130        (drh      09-Dec-08):     nByte = pMem->n + pMem->u.nZero;
1.93         (danielk1 13-Feb-08):     if( nByte<=0 ){
1.93         (danielk1 13-Feb-08):       nByte = 1;
1.93         (danielk1 13-Feb-08):     }
1.93         (danielk1 13-Feb-08):     if( sqlite3VdbeMemGrow(pMem, nByte, 1) ){
1.60         (drh      02-May-07):       return SQLITE_NOMEM;
1.60         (drh      02-May-07):     }
1.93         (danielk1 13-Feb-08): 
1.130        (drh      09-Dec-08):     memset(&pMem->z[pMem->n], 0, pMem->u.nZero);
1.130        (drh      09-Dec-08):     pMem->n += pMem->u.nZero;
1.93         (danielk1 13-Feb-08):     pMem->flags &= ~(MEM_Zero|MEM_Term);
1.60         (drh      02-May-07):   }
1.60         (drh      02-May-07):   return SQLITE_OK;
1.60         (drh      02-May-07): }
1.68         (danielk1 16-May-07): #endif
1.60         (drh      02-May-07): 
1.60         (drh      02-May-07): 
1.60         (drh      02-May-07): /*
1.2          (drh      27-May-04): ** Make sure the given Mem is \u0000 terminated.
1.2          (drh      27-May-04): */
1.80         (drh      21-Aug-07): int sqlite3VdbeMemNulTerminate(Mem *pMem){
1.80         (drh      21-Aug-07):   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
1.23         (danielk1 30-Jun-04):   if( (pMem->flags & MEM_Term)!=0 || (pMem->flags & MEM_Str)==0 ){
1.2          (drh      27-May-04):     return SQLITE_OK;   /* Nothing to do */
1.2          (drh      27-May-04):   }
1.93         (danielk1 13-Feb-08):   if( sqlite3VdbeMemGrow(pMem, pMem->n+2, 1) ){
1.93         (danielk1 13-Feb-08):     return SQLITE_NOMEM;
1.18         (danielk1 17-Jun-04):   }
1.93         (danielk1 13-Feb-08):   pMem->z[pMem->n] = 0;
1.93         (danielk1 13-Feb-08):   pMem->z[pMem->n+1] = 0;
1.93         (danielk1 13-Feb-08):   pMem->flags |= MEM_Term;
1.18         (danielk1 17-Jun-04):   return SQLITE_OK;
1.2          (drh      27-May-04): }
1.2          (drh      27-May-04): 
1.2          (drh      27-May-04): /*
1.23         (danielk1 30-Jun-04): ** Add MEM_Str to the set of representations for the given Mem.  Numbers
1.23         (danielk1 30-Jun-04): ** are converted using sqlite3_snprintf().  Converting a BLOB to a string
1.23         (danielk1 30-Jun-04): ** is a no-op.
1.2          (drh      27-May-04): **
1.2          (drh      27-May-04): ** Existing representations MEM_Int and MEM_Real are *not* invalidated.
1.23         (danielk1 30-Jun-04): **
1.23         (danielk1 30-Jun-04): ** A MEM_Null value will never be passed to this function. This function is
1.23         (danielk1 30-Jun-04): ** used for converting values to text for returning to the user (i.e. via
1.23         (danielk1 30-Jun-04): ** sqlite3_value_text()), or for ensuring that values to be used as btree
1.23         (danielk1 30-Jun-04): ** keys are strings. In the former case a NULL pointer is returned the
1.23         (danielk1 30-Jun-04): ** user and the later is an internal programming error.
1.2          (drh      27-May-04): */
1.80         (drh      21-Aug-07): int sqlite3VdbeMemStringify(Mem *pMem, int enc){
1.2          (drh      27-May-04):   int rc = SQLITE_OK;
1.2          (drh      27-May-04):   int fg = pMem->flags;
1.93         (danielk1 13-Feb-08):   const int nByte = 32;
1.2          (drh      27-May-04): 
1.80         (drh      21-Aug-07):   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
1.64         (danielk1 10-May-07):   assert( !(fg&MEM_Zero) );
1.2          (drh      27-May-04):   assert( !(fg&(MEM_Str|MEM_Blob)) );
1.23         (danielk1 30-Jun-04):   assert( fg&(MEM_Int|MEM_Real) );
1.127        (drh      04-Dec-08):   assert( (pMem->flags&MEM_RowSet)==0 );
1.127        (drh      04-Dec-08): 
1.2          (drh      27-May-04): 
1.93         (danielk1 13-Feb-08):   if( sqlite3VdbeMemGrow(pMem, nByte, 0) ){
1.93         (danielk1 13-Feb-08):     return SQLITE_NOMEM;
1.93         (danielk1 13-Feb-08):   }
1.93         (danielk1 13-Feb-08): 
1.93         (danielk1 13-Feb-08):   /* For a Real or Integer, use sqlite3_mprintf() to produce the UTF-8
1.23         (danielk1 30-Jun-04):   ** string representation of the value. Then, if the required encoding
1.23         (danielk1 30-Jun-04):   ** is UTF-16le or UTF-16be do a translation.
1.23         (danielk1 30-Jun-04):   ** 
1.23         (danielk1 30-Jun-04):   ** FIX ME: It would be better if sqlite3_snprintf() could do UTF-16.
1.23         (danielk1 30-Jun-04):   */
1.41         (drh      01-Nov-05):   if( fg & MEM_Int ){
1.93         (danielk1 13-Feb-08):     sqlite3_snprintf(nByte, pMem->z, "%lld", pMem->u.i);
1.41         (drh      01-Nov-05):   }else{
1.41         (drh      01-Nov-05):     assert( fg & MEM_Real );
1.93         (danielk1 13-Feb-08):     sqlite3_snprintf(nByte, pMem->z, "%!.15g", pMem->r);
1.2          (drh      27-May-04):   }
1.133        (drh      10-Dec-08):   pMem->n = sqlite3Strlen30(pMem->z);
1.23         (danielk1 30-Jun-04):   pMem->enc = SQLITE_UTF8;
1.93         (danielk1 13-Feb-08):   pMem->flags |= MEM_Str|MEM_Term;
1.80         (drh      21-Aug-07):   sqlite3VdbeChangeEncoding(pMem, enc);
1.2          (drh      27-May-04):   return rc;
1.2          (drh      27-May-04): }
1.1          (drh      26-May-04): 
1.2          (drh      27-May-04): /*
1.36         (drh      06-Sep-05): ** Memory cell pMem contains the context of an aggregate function.
1.36         (drh      06-Sep-05): ** This routine calls the finalize method for that function.  The
1.36         (drh      06-Sep-05): ** result of the aggregate is stored back into pMem.
1.51         (drh      20-Jan-06): **
1.51         (drh      20-Jan-06): ** Return SQLITE_ERROR if the finalizer reports an error.  SQLITE_OK
1.51         (drh      20-Jan-06): ** otherwise.
1.36         (drh      06-Sep-05): */
1.51         (drh      20-Jan-06): int sqlite3VdbeMemFinalize(Mem *pMem, FuncDef *pFunc){
1.51         (drh      20-Jan-06):   int rc = SQLITE_OK;
1.38         (drh      07-Sep-05):   if( pFunc && pFunc->xFinalize ){
1.38         (drh      07-Sep-05):     sqlite3_context ctx;
1.58         (drh      30-Mar-07):     assert( (pMem->flags & MEM_Null)!=0 || pFunc==pMem->u.pDef );
1.80         (drh      21-Aug-07):     assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
1.122        (drh      22-Aug-08):     memset(&ctx, 0, sizeof(ctx));
1.38         (drh      07-Sep-05):     ctx.s.flags = MEM_Null;
1.80         (drh      21-Aug-07):     ctx.s.db = pMem->db;
1.38         (drh      07-Sep-05):     ctx.pMem = pMem;
1.38         (drh      07-Sep-05):     ctx.pFunc = pFunc;
1.38         (drh      07-Sep-05):     pFunc->xFinalize(&ctx);
1.111        (drh      16-Apr-08):     assert( 0==(pMem->flags&MEM_Dyn) && !pMem->xDel );
1.119        (drh      28-Jul-08):     sqlite3DbFree(pMem->db, pMem->zMalloc);
1.131        (drh      10-Dec-08):     memcpy(pMem, &ctx.s, sizeof(ctx.s));
1.82         (danielk1 29-Aug-07):     rc = (ctx.isError?SQLITE_ERROR:SQLITE_OK);
1.36         (drh      06-Sep-05):   }
1.51         (drh      20-Jan-06):   return rc;
1.36         (drh      06-Sep-05): }
1.36         (drh      06-Sep-05): 
1.36         (drh      06-Sep-05): /*
1.105        (danielk1 28-Mar-08): ** If the memory cell contains a string value that must be freed by
1.105        (danielk1 28-Mar-08): ** invoking an external callback, free it now. Calling this function
1.105        (danielk1 28-Mar-08): ** does not free any Mem.zMalloc buffer.
1.105        (danielk1 28-Mar-08): */
1.105        (danielk1 28-Mar-08): void sqlite3VdbeMemReleaseExternal(Mem *p){
1.105        (danielk1 28-Mar-08):   assert( p->db==0 || sqlite3_mutex_held(p->db->mutex) );
1.105        (danielk1 28-Mar-08):   if( p->flags&MEM_Agg ){
1.105        (danielk1 28-Mar-08):     sqlite3VdbeMemFinalize(p, p->u.pDef);
1.105        (danielk1 28-Mar-08):     assert( (p->flags & MEM_Agg)==0 );
1.105        (danielk1 28-Mar-08):     sqlite3VdbeMemRelease(p);
1.111        (drh      16-Apr-08):   }else if( p->flags&MEM_Dyn && p->xDel ){
1.127        (drh      04-Dec-08):     assert( (p->flags&MEM_RowSet)==0 );
1.105        (danielk1 28-Mar-08):     p->xDel((void *)p->z);
1.105        (danielk1 28-Mar-08):     p->xDel = 0;
1.127        (drh      04-Dec-08):   }else if( p->flags&MEM_RowSet ){
1.127        (drh      04-Dec-08):     sqlite3RowSetClear(p->u.pRowSet);
1.105        (danielk1 28-Mar-08):   }
1.105        (danielk1 28-Mar-08): }
1.105        (danielk1 28-Mar-08): 
1.105        (danielk1 28-Mar-08): /*
1.16         (danielk1 12-Jun-04): ** Release any memory held by the Mem. This may leave the Mem in an
1.16         (danielk1 12-Jun-04): ** inconsistent state, for example with (Mem.z==0) and
1.16         (danielk1 12-Jun-04): ** (Mem.type==SQLITE_TEXT).
1.3          (drh      27-May-04): */
1.16         (danielk1 12-Jun-04): void sqlite3VdbeMemRelease(Mem *p){
1.105        (danielk1 28-Mar-08):   sqlite3VdbeMemReleaseExternal(p);
1.119        (drh      28-Jul-08):   sqlite3DbFree(p->db, p->zMalloc);
1.105        (danielk1 28-Mar-08):   p->z = 0;
1.105        (danielk1 28-Mar-08):   p->zMalloc = 0;
1.105        (danielk1 28-Mar-08):   p->xDel = 0;
1.3          (drh      27-May-04): }
1.3          (drh      27-May-04): 
1.3          (drh      27-May-04): /*
1.87         (drh      11-Jan-08): ** Convert a 64-bit IEEE double into a 64-bit signed integer.
1.87         (drh      11-Jan-08): ** If the double is too large, return 0x8000000000000000.
1.87         (drh      11-Jan-08): **
1.87         (drh      11-Jan-08): ** Most systems appear to do this simply by assigning
1.87         (drh      11-Jan-08): ** variables and without the extra range tests.  But
1.87         (drh      11-Jan-08): ** there are reports that windows throws an expection
1.87         (drh      11-Jan-08): ** if the floating point value is out of range. (See ticket #2880.)
1.87         (drh      11-Jan-08): ** Because we do not completely understand the problem, we will
1.87         (drh      11-Jan-08): ** take the conservative approach and always do range tests
1.87         (drh      11-Jan-08): ** before attempting the conversion.
1.87         (drh      11-Jan-08): */
1.87         (drh      11-Jan-08): static i64 doubleToInt64(double r){
1.87         (drh      11-Jan-08):   /*
1.87         (drh      11-Jan-08):   ** Many compilers we encounter do not define constants for the
1.87         (drh      11-Jan-08):   ** minimum and maximum 64-bit integers, or they define them
1.87         (drh      11-Jan-08):   ** inconsistently.  And many do not understand the "LL" notation.
1.87         (drh      11-Jan-08):   ** So we define our own static constants here using nothing
1.87         (drh      11-Jan-08):   ** larger than a 32-bit integer constant.
1.87         (drh      11-Jan-08):   */
1.114        (drh      09-May-08):   static const i64 maxInt = LARGEST_INT64;
1.114        (drh      09-May-08):   static const i64 minInt = SMALLEST_INT64;
1.87         (drh      11-Jan-08): 
1.87         (drh      11-Jan-08):   if( r<(double)minInt ){
1.87         (drh      11-Jan-08):     return minInt;
1.87         (drh      11-Jan-08):   }else if( r>(double)maxInt ){
1.87         (drh      11-Jan-08):     return minInt;
1.87         (drh      11-Jan-08):   }else{
1.87         (drh      11-Jan-08):     return (i64)r;
1.87         (drh      11-Jan-08):   }
1.87         (drh      11-Jan-08): }
1.87         (drh      11-Jan-08): 
1.87         (drh      11-Jan-08): /*
1.21         (drh      27-Jun-04): ** Return some kind of integer value which is the best we can do
1.21         (drh      27-Jun-04): ** at representing the value that *pMem describes as an integer.
1.21         (drh      27-Jun-04): ** If pMem is an integer, then the value is exact.  If pMem is
1.21         (drh      27-Jun-04): ** a floating-point then the value returned is the integer part.
1.21         (drh      27-Jun-04): ** If pMem is a string or blob, then we make an attempt to convert
1.21         (drh      27-Jun-04): ** it into a integer and return that.  If pMem is NULL, return 0.
1.21         (drh      27-Jun-04): **
1.21         (drh      27-Jun-04): ** If pMem is a string, its encoding might be changed.
1.2          (drh      27-May-04): */
1.21         (drh      27-Jun-04): i64 sqlite3VdbeIntValue(Mem *pMem){
1.80         (drh      21-Aug-07):   int flags;
1.80         (drh      21-Aug-07):   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
1.80         (drh      21-Aug-07):   flags = pMem->flags;
1.8          (drh      30-May-04):   if( flags & MEM_Int ){
1.58         (drh      30-Mar-07):     return pMem->u.i;
1.8          (drh      30-May-04):   }else if( flags & MEM_Real ){
1.87         (drh      11-Jan-08):     return doubleToInt64(pMem->r);
1.8          (drh      30-May-04):   }else if( flags & (MEM_Str|MEM_Blob) ){
1.21         (drh      27-Jun-04):     i64 value;
1.70         (danielk1 17-May-07):     pMem->flags |= MEM_Str;
1.80         (drh      21-Aug-07):     if( sqlite3VdbeChangeEncoding(pMem, SQLITE_UTF8)
1.80         (drh      21-Aug-07):        || sqlite3VdbeMemNulTerminate(pMem) ){
1.42         (drh      03-Nov-05):       return 0;
1.1          (drh      26-May-04):     }
1.2          (drh      27-May-04):     assert( pMem->z );
1.75         (drh      26-Jun-07):     sqlite3Atoi64(pMem->z, &value);
1.21         (drh      27-Jun-04):     return value;
1.2          (drh      27-May-04):   }else{
1.21         (drh      27-Jun-04):     return 0;
1.2          (drh      27-May-04):   }
1.21         (drh      27-Jun-04): }
1.21         (drh      27-Jun-04): 
1.21         (drh      27-Jun-04): /*
1.21         (drh      27-Jun-04): ** Return the best representation of pMem that we can get into a
1.21         (drh      27-Jun-04): ** double.  If pMem is already a double or an integer, return its
1.21         (drh      27-Jun-04): ** value.  If it is a string or blob, try to convert it to a double.
1.21         (drh      27-Jun-04): ** If it is a NULL, return 0.0.
1.2          (drh      27-May-04): */
1.21         (drh      27-Jun-04): double sqlite3VdbeRealValue(Mem *pMem){
1.80         (drh      21-Aug-07):   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
1.5          (danielk1 27-May-04):   if( pMem->flags & MEM_Real ){
1.21         (drh      27-Jun-04):     return pMem->r;
1.21         (drh      27-Jun-04):   }else if( pMem->flags & MEM_Int ){
1.58         (drh      30-Mar-07):     return (double)pMem->u.i;
1.2          (drh      27-May-04):   }else if( pMem->flags & (MEM_Str|MEM_Blob) ){
1.33         (drh      25-Jun-05):     double val = 0.0;
1.70         (danielk1 17-May-07):     pMem->flags |= MEM_Str;
1.80         (drh      21-Aug-07):     if( sqlite3VdbeChangeEncoding(pMem, SQLITE_UTF8)
1.80         (drh      21-Aug-07):        || sqlite3VdbeMemNulTerminate(pMem) ){
1.42         (drh      03-Nov-05):       return 0.0;
1.2          (drh      27-May-04):     }
1.2          (drh      27-May-04):     assert( pMem->z );
1.33         (drh      25-Jun-05):     sqlite3AtoF(pMem->z, &val);
1.33         (drh      25-Jun-05):     return val;
1.2          (drh      27-May-04):   }else{
1.21         (drh      27-Jun-04):     return 0.0;
1.1          (drh      26-May-04):   }
1.21         (drh      27-Jun-04): }
1.21         (drh      27-Jun-04): 
1.21         (drh      27-Jun-04): /*
1.41         (drh      01-Nov-05): ** The MEM structure is already a MEM_Real.  Try to also make it a
1.41         (drh      01-Nov-05): ** MEM_Int if we can.
1.41         (drh      01-Nov-05): */
1.41         (drh      01-Nov-05): void sqlite3VdbeIntegerAffinity(Mem *pMem){
1.41         (drh      01-Nov-05):   assert( pMem->flags & MEM_Real );
1.127        (drh      04-Dec-08):   assert( (pMem->flags & MEM_RowSet)==0 );
1.80         (drh      21-Aug-07):   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
1.86         (drh      11-Jan-08): 
1.87         (drh      11-Jan-08):   pMem->u.i = doubleToInt64(pMem->r);
1.87         (drh      11-Jan-08):   if( pMem->r==(double)pMem->u.i ){
1.41         (drh      01-Nov-05):     pMem->flags |= MEM_Int;
1.41         (drh      01-Nov-05):   }
1.41         (drh      01-Nov-05): }
1.41         (drh      01-Nov-05): 
1.43         (drh      14-Nov-05): /*
1.43         (drh      14-Nov-05): ** Convert pMem to type integer.  Invalidate any prior representations.
1.43         (drh      14-Nov-05): */
1.43         (drh      14-Nov-05): int sqlite3VdbeMemIntegerify(Mem *pMem){
1.80         (drh      21-Aug-07):   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
1.127        (drh      04-Dec-08):   assert( (pMem->flags & MEM_RowSet)==0 );
1.58         (drh      30-Mar-07):   pMem->u.i = sqlite3VdbeIntValue(pMem);
1.127        (drh      04-Dec-08):   MemSetTypeFlag(pMem, MEM_Int);
1.43         (drh      14-Nov-05):   return SQLITE_OK;
1.43         (drh      14-Nov-05): }
1.41         (drh      01-Nov-05): 
1.41         (drh      01-Nov-05): /*
1.43         (drh      14-Nov-05): ** Convert pMem so that it is of type MEM_Real.
1.43         (drh      14-Nov-05): ** Invalidate any prior representations.
1.21         (drh      27-Jun-04): */
1.21         (drh      27-Jun-04): int sqlite3VdbeMemRealify(Mem *pMem){
1.80         (drh      21-Aug-07):   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
1.21         (drh      27-Jun-04):   pMem->r = sqlite3VdbeRealValue(pMem);
1.127        (drh      04-Dec-08):   MemSetTypeFlag(pMem, MEM_Real);
1.43         (drh      14-Nov-05):   return SQLITE_OK;
1.43         (drh      14-Nov-05): }
1.43         (drh      14-Nov-05): 
1.43         (drh      14-Nov-05): /*
1.43         (drh      14-Nov-05): ** Convert pMem so that it has types MEM_Real or MEM_Int or both.
1.43         (drh      14-Nov-05): ** Invalidate any prior representations.
1.43         (drh      14-Nov-05): */
1.43         (drh      14-Nov-05): int sqlite3VdbeMemNumerify(Mem *pMem){
1.67         (drh      16-May-07):   double r1, r2;
1.67         (drh      16-May-07):   i64 i;
1.67         (drh      16-May-07):   assert( (pMem->flags & (MEM_Int|MEM_Real|MEM_Null))==0 );
1.67         (drh      16-May-07):   assert( (pMem->flags & (MEM_Blob|MEM_Str))!=0 );
1.80         (drh      21-Aug-07):   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
1.67         (drh      16-May-07):   r1 = sqlite3VdbeRealValue(pMem);
1.87         (drh      11-Jan-08):   i = doubleToInt64(r1);
1.67         (drh      16-May-07):   r2 = (double)i;
1.67         (drh      16-May-07):   if( r1==r2 ){
1.67         (drh      16-May-07):     sqlite3VdbeMemIntegerify(pMem);
1.67         (drh      16-May-07):   }else{
1.67         (drh      16-May-07):     pMem->r = r1;
1.127        (drh      04-Dec-08):     MemSetTypeFlag(pMem, MEM_Real);
1.67         (drh      16-May-07):   }
1.3          (drh      27-May-04):   return SQLITE_OK;
1.1          (drh      26-May-04): }
1.1          (drh      26-May-04): 
1.1          (drh      26-May-04): /*
1.1          (drh      26-May-04): ** Delete any previous value and set the value stored in *pMem to NULL.
1.1          (drh      26-May-04): */
1.1          (drh      26-May-04): void sqlite3VdbeMemSetNull(Mem *pMem){
1.127        (drh      04-Dec-08):   if( pMem->flags & MEM_RowSet ){
1.127        (drh      04-Dec-08):     sqlite3RowSetClear(pMem->u.pRowSet);
1.127        (drh      04-Dec-08):   }
1.127        (drh      04-Dec-08):   MemSetTypeFlag(pMem, MEM_Null);
1.10         (drh      31-May-04):   pMem->type = SQLITE_NULL;
1.1          (drh      26-May-04): }
1.1          (drh      26-May-04): 
1.1          (drh      26-May-04): /*
1.60         (drh      02-May-07): ** Delete any previous value and set the value to be a BLOB of length
1.60         (drh      02-May-07): ** n containing all zeros.
1.60         (drh      02-May-07): */
1.60         (drh      02-May-07): void sqlite3VdbeMemSetZeroBlob(Mem *pMem, int n){
1.60         (drh      02-May-07):   sqlite3VdbeMemRelease(pMem);
1.93         (danielk1 13-Feb-08):   pMem->flags = MEM_Blob|MEM_Zero;
1.60         (drh      02-May-07):   pMem->type = SQLITE_BLOB;
1.60         (drh      02-May-07):   pMem->n = 0;
1.72         (drh      07-Jun-07):   if( n<0 ) n = 0;
1.130        (drh      09-Dec-08):   pMem->u.nZero = n;
1.64         (danielk1 10-May-07):   pMem->enc = SQLITE_UTF8;
1.60         (drh      02-May-07): }
1.60         (drh      02-May-07): 
1.60         (drh      02-May-07): /*
1.1          (drh      26-May-04): ** Delete any previous value and set the value stored in *pMem to val,
1.1          (drh      26-May-04): ** manifest type INTEGER.
1.1          (drh      26-May-04): */
1.2          (drh      27-May-04): void sqlite3VdbeMemSetInt64(Mem *pMem, i64 val){
1.16         (danielk1 12-Jun-04):   sqlite3VdbeMemRelease(pMem);
1.58         (drh      30-Mar-07):   pMem->u.i = val;
1.1          (drh      26-May-04):   pMem->flags = MEM_Int;
1.10         (drh      31-May-04):   pMem->type = SQLITE_INTEGER;
1.1          (drh      26-May-04): }
1.1          (drh      26-May-04): 
1.1          (drh      26-May-04): /*
1.1          (drh      26-May-04): ** Delete any previous value and set the value stored in *pMem to val,
1.1          (drh      26-May-04): ** manifest type REAL.
1.1          (drh      26-May-04): */
1.2          (drh      27-May-04): void sqlite3VdbeMemSetDouble(Mem *pMem, double val){
1.113        (drh      28-Apr-08):   if( sqlite3IsNaN(val) ){
1.65         (drh      10-May-07):     sqlite3VdbeMemSetNull(pMem);
1.65         (drh      10-May-07):   }else{
1.65         (drh      10-May-07):     sqlite3VdbeMemRelease(pMem);
1.65         (drh      10-May-07):     pMem->r = val;
1.65         (drh      10-May-07):     pMem->flags = MEM_Real;
1.65         (drh      10-May-07):     pMem->type = SQLITE_FLOAT;
1.65         (drh      10-May-07):   }
1.1          (drh      26-May-04): }
1.1          (drh      26-May-04): 
1.1          (drh      26-May-04): /*
1.127        (drh      04-Dec-08): ** Delete any previous value and set the value of pMem to be an
1.127        (drh      04-Dec-08): ** empty boolean index.
1.127        (drh      04-Dec-08): */
1.127        (drh      04-Dec-08): void sqlite3VdbeMemSetRowSet(Mem *pMem){
1.127        (drh      04-Dec-08):   sqlite3 *db = pMem->db;
1.127        (drh      04-Dec-08):   assert( db!=0 );
1.127        (drh      04-Dec-08):   if( pMem->flags & MEM_RowSet ){
1.127        (drh      04-Dec-08):     sqlite3RowSetClear(pMem->u.pRowSet);
1.127        (drh      04-Dec-08):   }else{
1.127        (drh      04-Dec-08):     sqlite3VdbeMemRelease(pMem);
1.129        (drh      05-Dec-08):     pMem->zMalloc = sqlite3DbMallocRaw(db, 64);
1.127        (drh      04-Dec-08):   }
1.128        (drh      04-Dec-08):   if( db->mallocFailed ){
1.128        (drh      04-Dec-08):     pMem->flags = MEM_Null;
1.128        (drh      04-Dec-08):   }else{
1.127        (drh      04-Dec-08):     assert( pMem->zMalloc );
1.127        (drh      04-Dec-08):     pMem->u.pRowSet = sqlite3RowSetInit(db, pMem->zMalloc, 
1.127        (drh      04-Dec-08):                                        sqlite3DbMallocSize(db, pMem->zMalloc));
1.127        (drh      04-Dec-08):     assert( pMem->u.pRowSet!=0 );
1.128        (drh      04-Dec-08):     pMem->flags = MEM_RowSet;
1.127        (drh      04-Dec-08):   }
1.127        (drh      04-Dec-08): }
1.127        (drh      04-Dec-08): 
1.127        (drh      04-Dec-08): /*
1.62         (drh      08-May-07): ** Return true if the Mem object contains a TEXT or BLOB that is
1.62         (drh      08-May-07): ** too large - whose size exceeds SQLITE_MAX_LENGTH.
1.62         (drh      08-May-07): */
1.62         (drh      08-May-07): int sqlite3VdbeMemTooBig(Mem *p){
1.102        (drh      19-Mar-08):   assert( p->db!=0 );
1.62         (drh      08-May-07):   if( p->flags & (MEM_Str|MEM_Blob) ){
1.62         (drh      08-May-07):     int n = p->n;
1.62         (drh      08-May-07):     if( p->flags & MEM_Zero ){
1.130        (drh      09-Dec-08):       n += p->u.nZero;
1.62         (drh      08-May-07):     }
1.103        (drh      20-Mar-08):     return n>p->db->aLimit[SQLITE_LIMIT_LENGTH];
1.62         (drh      08-May-07):   }
1.62         (drh      08-May-07):   return 0; 
1.62         (drh      08-May-07): }
1.62         (drh      08-May-07): 
1.106        (danielk1 28-Mar-08): /*
1.106        (danielk1 28-Mar-08): ** Size of struct Mem not including the Mem.zMalloc member.
1.106        (danielk1 28-Mar-08): */
1.108        (mlcreech 29-Mar-08): #define MEMCELLSIZE (size_t)(&(((Mem *)0)->zMalloc))
1.105        (danielk1 28-Mar-08): 
1.62         (drh      08-May-07): /*
1.26         (drh      28-Aug-04): ** Make an shallow copy of pFrom into pTo.  Prior contents of
1.89         (drh      19-Jan-08): ** pTo are freed.  The pFrom->z field is not duplicated.  If
1.26         (drh      28-Aug-04): ** pFrom->z is used, then pTo->z points to the same thing as pFrom->z
1.26         (drh      28-Aug-04): ** and flags gets srcType (either MEM_Ephem or MEM_Static).
1.1          (drh      26-May-04): */
1.26         (drh      28-Aug-04): void sqlite3VdbeMemShallowCopy(Mem *pTo, const Mem *pFrom, int srcType){
1.127        (drh      04-Dec-08):   assert( (pFrom->flags & MEM_RowSet)==0 );
1.105        (danielk1 28-Mar-08):   sqlite3VdbeMemReleaseExternal(pTo);
1.105        (danielk1 28-Mar-08):   memcpy(pTo, pFrom, MEMCELLSIZE);
1.16         (danielk1 12-Jun-04):   pTo->xDel = 0;
1.111        (drh      16-Apr-08):   if( (pFrom->flags&MEM_Dyn)!=0 || pFrom->z==pFrom->zMalloc ){
1.93         (danielk1 13-Feb-08):     pTo->flags &= ~(MEM_Dyn|MEM_Static|MEM_Ephem);
1.26         (drh      28-Aug-04):     assert( srcType==MEM_Ephem || srcType==MEM_Static );
1.26         (drh      28-Aug-04):     pTo->flags |= srcType;
1.26         (drh      28-Aug-04):   }
1.26         (drh      28-Aug-04): }
1.26         (drh      28-Aug-04): 
1.26         (drh      28-Aug-04): /*
1.26         (drh      28-Aug-04): ** Make a full copy of pFrom into pTo.  Prior contents of pTo are
1.26         (drh      28-Aug-04): ** freed before the copy is made.
1.26         (drh      28-Aug-04): */
1.80         (drh      21-Aug-07): int sqlite3VdbeMemCopy(Mem *pTo, const Mem *pFrom){
1.93         (danielk1 13-Feb-08):   int rc = SQLITE_OK;
1.93         (danielk1 13-Feb-08): 
1.127        (drh      04-Dec-08):   assert( (pFrom->flags & MEM_RowSet)==0 );
1.105        (danielk1 28-Mar-08):   sqlite3VdbeMemReleaseExternal(pTo);
1.105        (danielk1 28-Mar-08):   memcpy(pTo, pFrom, MEMCELLSIZE);
1.105        (danielk1 28-Mar-08):   pTo->flags &= ~MEM_Dyn;
1.105        (danielk1 28-Mar-08): 
1.105        (danielk1 28-Mar-08):   if( pTo->flags&(MEM_Str|MEM_Blob) ){
1.105        (danielk1 28-Mar-08):     if( 0==(pFrom->flags&MEM_Static) ){
1.105        (danielk1 28-Mar-08):       pTo->flags |= MEM_Ephem;
1.105        (danielk1 28-Mar-08):       rc = sqlite3VdbeMemMakeWriteable(pTo);
1.94         (danielk1 14-Feb-08):     }
1.93         (danielk1 13-Feb-08):   }
1.93         (danielk1 13-Feb-08): 
1.25         (drh      08-Aug-04):   return rc;
1.1          (drh      26-May-04): }
1.1          (drh      26-May-04): 
1.2          (drh      27-May-04): /*
1.17         (danielk1 15-Jun-04): ** Transfer the contents of pFrom to pTo. Any existing value in pTo is
1.26         (drh      28-Aug-04): ** freed. If pFrom contains ephemeral data, a copy is made.
1.26         (drh      28-Aug-04): **
1.91         (drh      22-Jan-08): ** pFrom contains an SQL NULL when this routine returns.
1.17         (danielk1 15-Jun-04): */
1.91         (drh      22-Jan-08): void sqlite3VdbeMemMove(Mem *pTo, Mem *pFrom){
1.80         (drh      21-Aug-07):   assert( pFrom->db==0 || sqlite3_mutex_held(pFrom->db->mutex) );
1.80         (drh      21-Aug-07):   assert( pTo->db==0 || sqlite3_mutex_held(pTo->db->mutex) );
1.80         (drh      21-Aug-07):   assert( pFrom->db==0 || pTo->db==0 || pFrom->db==pTo->db );
1.105        (danielk1 28-Mar-08): 
1.105        (danielk1 28-Mar-08):   sqlite3VdbeMemRelease(pTo);
1.23         (danielk1 30-Jun-04):   memcpy(pTo, pFrom, sizeof(Mem));
1.23         (danielk1 30-Jun-04):   pFrom->flags = MEM_Null;
1.23         (danielk1 30-Jun-04):   pFrom->xDel = 0;
1.105        (danielk1 28-Mar-08):   pFrom->zMalloc = 0;
1.17         (danielk1 15-Jun-04): }
1.17         (danielk1 15-Jun-04): 
1.17         (danielk1 15-Jun-04): /*
1.2          (drh      27-May-04): ** Change the value of a Mem to be a string or a BLOB.
1.93         (danielk1 13-Feb-08): **
1.93         (danielk1 13-Feb-08): ** The memory management strategy depends on the value of the xDel
1.93         (danielk1 13-Feb-08): ** parameter. If the value passed is SQLITE_TRANSIENT, then the 
1.93         (danielk1 13-Feb-08): ** string is copied into a (possibly existing) buffer managed by the 
1.93         (danielk1 13-Feb-08): ** Mem structure. Otherwise, any existing buffer is freed and the
1.93         (danielk1 13-Feb-08): ** pointer copied.
1.2          (drh      27-May-04): */
1.1          (drh      26-May-04): int sqlite3VdbeMemSetStr(
1.1          (drh      26-May-04):   Mem *pMem,          /* Memory cell to set to string value */
1.1          (drh      26-May-04):   const char *z,      /* String pointer */
1.1          (drh      26-May-04):   int n,              /* Bytes in string, or negative */
1.2          (drh      27-May-04):   u8 enc,             /* Encoding of z.  0 for BLOBs */
1.16         (danielk1 12-Jun-04):   void (*xDel)(void*) /* Destructor function */
1.1          (drh      26-May-04): ){
1.93         (danielk1 13-Feb-08):   int nByte = n;      /* New value for pMem->n */
1.116        (drh      08-Jul-08):   int iLimit;         /* Maximum allowed string or blob size */
1.130        (drh      09-Dec-08):   u16 flags = 0;      /* New value for pMem->flags */
1.93         (danielk1 13-Feb-08): 
1.80         (drh      21-Aug-07):   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
1.127        (drh      04-Dec-08):   assert( (pMem->flags & MEM_RowSet)==0 );
1.93         (danielk1 13-Feb-08): 
1.93         (danielk1 13-Feb-08):   /* If z is a NULL pointer, set pMem to contain an SQL NULL. */
1.1          (drh      26-May-04):   if( !z ){
1.93         (danielk1 13-Feb-08):     sqlite3VdbeMemSetNull(pMem);
1.1          (drh      26-May-04):     return SQLITE_OK;
1.1          (drh      26-May-04):   }
1.93         (danielk1 13-Feb-08): 
1.116        (drh      08-Jul-08):   if( pMem->db ){
1.116        (drh      08-Jul-08):     iLimit = pMem->db->aLimit[SQLITE_LIMIT_LENGTH];
1.116        (drh      08-Jul-08):   }else{
1.116        (drh      08-Jul-08):     iLimit = SQLITE_MAX_LENGTH;
1.116        (drh      08-Jul-08):   }
1.93         (danielk1 13-Feb-08):   flags = (enc==0?MEM_Blob:MEM_Str);
1.93         (danielk1 13-Feb-08):   if( nByte<0 ){
1.93         (danielk1 13-Feb-08):     assert( enc!=0 );
1.95         (drh      19-Feb-08):     if( enc==SQLITE_UTF8 ){
1.116        (drh      08-Jul-08):       for(nByte=0; nByte<=iLimit && z[nByte]; nByte++){}
1.95         (drh      19-Feb-08):     }else{
1.116        (drh      08-Jul-08):       for(nByte=0; nByte<=iLimit && (z[nByte] | z[nByte+1]); nByte+=2){}
1.95         (drh      19-Feb-08):     }
1.93         (danielk1 13-Feb-08):     flags |= MEM_Term;
1.93         (danielk1 13-Feb-08):   }
1.93         (danielk1 13-Feb-08): 
1.93         (danielk1 13-Feb-08):   /* The following block sets the new values of Mem.z and Mem.xDel. It
1.93         (danielk1 13-Feb-08):   ** also sets a flag in local variable "flags" to indicate the memory
1.93         (danielk1 13-Feb-08):   ** management (one of MEM_Dyn or MEM_Static).
1.93         (danielk1 13-Feb-08):   */
1.93         (danielk1 13-Feb-08):   if( xDel==SQLITE_TRANSIENT ){
1.93         (danielk1 13-Feb-08):     int nAlloc = nByte;
1.93         (danielk1 13-Feb-08):     if( flags&MEM_Term ){
1.93         (danielk1 13-Feb-08):       nAlloc += (enc==SQLITE_UTF8?1:2);
1.93         (danielk1 13-Feb-08):     }
1.125        (drh      05-Nov-08):     if( nByte>iLimit ){
1.125        (drh      05-Nov-08):       return SQLITE_TOOBIG;
1.125        (drh      05-Nov-08):     }
1.93         (danielk1 13-Feb-08):     if( sqlite3VdbeMemGrow(pMem, nAlloc, 0) ){
1.93         (danielk1 13-Feb-08):       return SQLITE_NOMEM;
1.93         (danielk1 13-Feb-08):     }
1.93         (danielk1 13-Feb-08):     memcpy(pMem->z, z, nAlloc);
1.119        (drh      28-Jul-08):   }else if( xDel==SQLITE_DYNAMIC ){
1.119        (drh      28-Jul-08):     sqlite3VdbeMemRelease(pMem);
1.119        (drh      28-Jul-08):     pMem->zMalloc = pMem->z = (char *)z;
1.119        (drh      28-Jul-08):     pMem->xDel = 0;
1.1          (drh      26-May-04):   }else{
1.93         (danielk1 13-Feb-08):     sqlite3VdbeMemRelease(pMem);
1.93         (danielk1 13-Feb-08):     pMem->z = (char *)z;
1.121        (drh      01-Aug-08):     pMem->xDel = xDel;
1.121        (drh      01-Aug-08):     flags |= ((xDel==SQLITE_STATIC)?MEM_Static:MEM_Dyn);
1.1          (drh      26-May-04):   }
1.125        (drh      05-Nov-08):   if( nByte>iLimit ){
1.125        (drh      05-Nov-08):     return SQLITE_TOOBIG;
1.125        (drh      05-Nov-08):   }
1.16         (danielk1 12-Jun-04): 
1.93         (danielk1 13-Feb-08):   pMem->n = nByte;
1.93         (danielk1 13-Feb-08):   pMem->flags = flags;
1.93         (danielk1 13-Feb-08):   pMem->enc = (enc==0 ? SQLITE_UTF8 : enc);
1.93         (danielk1 13-Feb-08):   pMem->type = (enc==0 ? SQLITE_BLOB : SQLITE_TEXT);
1.1          (drh      26-May-04): 
1.28         (drh      14-Nov-04): #ifndef SQLITE_OMIT_UTF16
1.93         (danielk1 13-Feb-08):   if( pMem->enc!=SQLITE_UTF8 && sqlite3VdbeMemHandleBom(pMem) ){
1.93         (danielk1 13-Feb-08):     return SQLITE_NOMEM;
1.1          (drh      26-May-04):   }
1.93         (danielk1 13-Feb-08): #endif
1.93         (danielk1 13-Feb-08): 
1.3          (drh      27-May-04):   return SQLITE_OK;
1.1          (drh      26-May-04): }
1.1          (drh      26-May-04): 
1.1          (drh      26-May-04): /*
1.1          (drh      26-May-04): ** Compare the values contained by the two memory cells, returning
1.1          (drh      26-May-04): ** negative, zero or positive if pMem1 is less than, equal to, or greater
1.1          (drh      26-May-04): ** than pMem2. Sorting order is NULL's first, followed by numbers (integers
1.1          (drh      26-May-04): ** and reals) sorted numerically, followed by text ordered by the collating
1.1          (drh      26-May-04): ** sequence pColl and finally blob's ordered by memcmp().
1.1          (drh      26-May-04): **
1.1          (drh      26-May-04): ** Two NULL values are considered equal by this function.
1.1          (drh      26-May-04): */
1.1          (drh      26-May-04): int sqlite3MemCompare(const Mem *pMem1, const Mem *pMem2, const CollSeq *pColl){
1.1          (drh      26-May-04):   int rc;
1.1          (drh      26-May-04):   int f1, f2;
1.1          (drh      26-May-04):   int combined_flags;
1.1          (drh      26-May-04): 
1.1          (drh      26-May-04):   /* Interchange pMem1 and pMem2 if the collating sequence specifies
1.1          (drh      26-May-04):   ** DESC order.
1.1          (drh      26-May-04):   */
1.1          (drh      26-May-04):   f1 = pMem1->flags;
1.1          (drh      26-May-04):   f2 = pMem2->flags;
1.1          (drh      26-May-04):   combined_flags = f1|f2;
1.127        (drh      04-Dec-08):   assert( (combined_flags & MEM_RowSet)==0 );
1.1          (drh      26-May-04):  
1.1          (drh      26-May-04):   /* If one value is NULL, it is less than the other. If both values
1.1          (drh      26-May-04):   ** are NULL, return 0.
1.1          (drh      26-May-04):   */
1.1          (drh      26-May-04):   if( combined_flags&MEM_Null ){
1.1          (drh      26-May-04):     return (f2&MEM_Null) - (f1&MEM_Null);
1.1          (drh      26-May-04):   }
1.1          (drh      26-May-04): 
1.1          (drh      26-May-04):   /* If one value is a number and the other is not, the number is less.
1.1          (drh      26-May-04):   ** If both are numbers, compare as reals if one is a real, or as integers
1.1          (drh      26-May-04):   ** if both values are integers.
1.1          (drh      26-May-04):   */
1.1          (drh      26-May-04):   if( combined_flags&(MEM_Int|MEM_Real) ){
1.1          (drh      26-May-04):     if( !(f1&(MEM_Int|MEM_Real)) ){
1.1          (drh      26-May-04):       return 1;
1.1          (drh      26-May-04):     }
1.1          (drh      26-May-04):     if( !(f2&(MEM_Int|MEM_Real)) ){
1.1          (drh      26-May-04):       return -1;
1.1          (drh      26-May-04):     }
1.1          (drh      26-May-04):     if( (f1 & f2 & MEM_Int)==0 ){
1.1          (drh      26-May-04):       double r1, r2;
1.1          (drh      26-May-04):       if( (f1&MEM_Real)==0 ){
1.130        (drh      09-Dec-08):         r1 = (double)pMem1->u.i;
1.1          (drh      26-May-04):       }else{
1.1          (drh      26-May-04):         r1 = pMem1->r;
1.1          (drh      26-May-04):       }
1.1          (drh      26-May-04):       if( (f2&MEM_Real)==0 ){
1.130        (drh      09-Dec-08):         r2 = (double)pMem2->u.i;
1.1          (drh      26-May-04):       }else{
1.1          (drh      26-May-04):         r2 = pMem2->r;
1.1          (drh      26-May-04):       }
1.1          (drh      26-May-04):       if( r1<r2 ) return -1;
1.1          (drh      26-May-04):       if( r1>r2 ) return 1;
1.1          (drh      26-May-04):       return 0;
1.1          (drh      26-May-04):     }else{
1.1          (drh      26-May-04):       assert( f1&MEM_Int );
1.1          (drh      26-May-04):       assert( f2&MEM_Int );
1.58         (drh      30-Mar-07):       if( pMem1->u.i < pMem2->u.i ) return -1;
1.58         (drh      30-Mar-07):       if( pMem1->u.i > pMem2->u.i ) return 1;
1.1          (drh      26-May-04):       return 0;
1.1          (drh      26-May-04):     }
1.1          (drh      26-May-04):   }
1.1          (drh      26-May-04): 
1.1          (drh      26-May-04):   /* If one value is a string and the other is a blob, the string is less.
1.1          (drh      26-May-04):   ** If both are strings, compare using the collating functions.
1.1          (drh      26-May-04):   */
1.1          (drh      26-May-04):   if( combined_flags&MEM_Str ){
1.1          (drh      26-May-04):     if( (f1 & MEM_Str)==0 ){
1.1          (drh      26-May-04):       return 1;
1.1          (drh      26-May-04):     }
1.1          (drh      26-May-04):     if( (f2 & MEM_Str)==0 ){
1.1          (drh      26-May-04):       return -1;
1.1          (drh      26-May-04):     }
1.11         (danielk1 09-Jun-04): 
1.11         (danielk1 09-Jun-04):     assert( pMem1->enc==pMem2->enc );
1.15         (danielk1 12-Jun-04):     assert( pMem1->enc==SQLITE_UTF8 || 
1.15         (danielk1 12-Jun-04):             pMem1->enc==SQLITE_UTF16LE || pMem1->enc==SQLITE_UTF16BE );
1.11         (danielk1 09-Jun-04): 
1.47         (danielk1 10-Jan-06):     /* The collation sequence must be defined at this point, even if
1.47         (danielk1 10-Jan-06):     ** the user deletes the collation sequence after the vdbe program is
1.47         (danielk1 10-Jan-06):     ** compiled (this was not always the case).
1.11         (danielk1 09-Jun-04):     */
1.12         (danielk1 10-Jun-04):     assert( !pColl || pColl->xCmp );
1.11         (danielk1 09-Jun-04): 
1.11         (danielk1 09-Jun-04):     if( pColl ){
1.12         (danielk1 10-Jun-04):       if( pMem1->enc==pColl->enc ){
1.52         (drh      16-Feb-06):         /* The strings are already in the correct encoding.  Call the
1.52         (drh      16-Feb-06):         ** comparison function directly */
1.12         (danielk1 10-Jun-04):         return pColl->xCmp(pColl->pUser,pMem1->n,pMem1->z,pMem2->n,pMem2->z);
1.11         (danielk1 09-Jun-04):       }else{
1.52         (drh      16-Feb-06):         const void *v1, *v2;
1.52         (drh      16-Feb-06):         int n1, n2;
1.123        (danielk1 16-Sep-08):         Mem c1;
1.123        (danielk1 16-Sep-08):         Mem c2;
1.123        (danielk1 16-Sep-08):         memset(&c1, 0, sizeof(c1));
1.123        (danielk1 16-Sep-08):         memset(&c2, 0, sizeof(c2));
1.123        (danielk1 16-Sep-08):         sqlite3VdbeMemShallowCopy(&c1, pMem1, MEM_Ephem);
1.123        (danielk1 16-Sep-08):         sqlite3VdbeMemShallowCopy(&c2, pMem2, MEM_Ephem);
1.123        (danielk1 16-Sep-08):         v1 = sqlite3ValueText((sqlite3_value*)&c1, pColl->enc);
1.123        (danielk1 16-Sep-08):         n1 = v1==0 ? 0 : c1.n;
1.123        (danielk1 16-Sep-08):         v2 = sqlite3ValueText((sqlite3_value*)&c2, pColl->enc);
1.123        (danielk1 16-Sep-08):         n2 = v2==0 ? 0 : c2.n;
1.52         (drh      16-Feb-06):         rc = pColl->xCmp(pColl->pUser, n1, v1, n2, v2);
1.123        (danielk1 16-Sep-08):         sqlite3VdbeMemRelease(&c1);
1.123        (danielk1 16-Sep-08):         sqlite3VdbeMemRelease(&c2);
1.22         (danielk1 28-Jun-04):         return rc;
1.11         (danielk1 09-Jun-04):       }
1.1          (drh      26-May-04):     }
1.11         (danielk1 09-Jun-04):     /* If a NULL pointer was passed as the collate function, fall through
1.13         (danielk1 10-Jun-04):     ** to the blob case and use memcmp().  */
1.1          (drh      26-May-04):   }
1.1          (drh      26-May-04):  
1.13         (danielk1 10-Jun-04):   /* Both values must be blobs.  Compare using memcmp().  */
1.1          (drh      26-May-04):   rc = memcmp(pMem1->z, pMem2->z, (pMem1->n>pMem2->n)?pMem2->n:pMem1->n);
1.1          (drh      26-May-04):   if( rc==0 ){
1.1          (drh      26-May-04):     rc = pMem1->n - pMem2->n;
1.1          (drh      26-May-04):   }
1.1          (drh      26-May-04):   return rc;
1.1          (drh      26-May-04): }
1.4          (danielk1 27-May-04): 
1.7          (drh      28-May-04): /*
1.7          (drh      28-May-04): ** Move data out of a btree key or data field and into a Mem structure.
1.7          (drh      28-May-04): ** The data or key is taken from the entry that pCur is currently pointing
1.7          (drh      28-May-04): ** to.  offset and amt determine what portion of the data or key to retrieve.
1.7          (drh      28-May-04): ** key is true to get the key or false to get data.  The result is written
1.7          (drh      28-May-04): ** into the pMem element.
1.7          (drh      28-May-04): **
1.7          (drh      28-May-04): ** The pMem structure is assumed to be uninitialized.  Any prior content
1.7          (drh      28-May-04): ** is overwritten without being freed.
1.7          (drh      28-May-04): **
1.7          (drh      28-May-04): ** If this routine fails for any reason (malloc returns NULL or unable
1.7          (drh      28-May-04): ** to read from the disk) then the pMem is left in an inconsistent state.
1.7          (drh      28-May-04): */
1.7          (drh      28-May-04): int sqlite3VdbeMemFromBtree(
1.7          (drh      28-May-04):   BtCursor *pCur,   /* Cursor pointing at record to retrieve. */
1.7          (drh      28-May-04):   int offset,       /* Offset from the start of data to return bytes from. */
1.7          (drh      28-May-04):   int amt,          /* Number of bytes to return. */
1.7          (drh      28-May-04):   int key,          /* If true, retrieve from the btree key, not data. */
1.7          (drh      28-May-04):   Mem *pMem         /* OUT: Return data in this Mem structure. */
1.7          (drh      28-May-04): ){
1.59         (drh      01-Apr-07):   char *zData;       /* Data from the btree layer */
1.59         (drh      01-Apr-07):   int available = 0; /* Number of bytes available on the local btree page */
1.80         (drh      21-Aug-07):   sqlite3 *db;       /* Database connection */
1.93         (danielk1 13-Feb-08):   int rc = SQLITE_OK;
1.7          (drh      28-May-04): 
1.80         (drh      21-Aug-07):   db = sqlite3BtreeCursorDb(pCur);
1.80         (drh      21-Aug-07):   assert( sqlite3_mutex_held(db->mutex) );
1.127        (drh      04-Dec-08):   assert( (pMem->flags & MEM_RowSet)==0 );
1.7          (drh      28-May-04):   if( key ){
1.9          (drh      30-May-04):     zData = (char *)sqlite3BtreeKeyFetch(pCur, &available);
1.7          (drh      28-May-04):   }else{
1.9          (drh      30-May-04):     zData = (char *)sqlite3BtreeDataFetch(pCur, &available);
1.7          (drh      28-May-04):   }
1.59         (drh      01-Apr-07):   assert( zData!=0 );
1.7          (drh      28-May-04): 
1.93         (danielk1 13-Feb-08):   if( offset+amt<=available && ((pMem->flags&MEM_Dyn)==0 || pMem->xDel) ){
1.93         (danielk1 13-Feb-08):     sqlite3VdbeMemRelease(pMem);
1.7          (drh      28-May-04):     pMem->z = &zData[offset];
1.7          (drh      28-May-04):     pMem->flags = MEM_Blob|MEM_Ephem;
1.93         (danielk1 13-Feb-08):   }else if( SQLITE_OK==(rc = sqlite3VdbeMemGrow(pMem, amt+2, 0)) ){
1.93         (danielk1 13-Feb-08):     pMem->flags = MEM_Blob|MEM_Dyn|MEM_Term;
1.7          (drh      28-May-04):     pMem->enc = 0;
1.10         (drh      31-May-04):     pMem->type = SQLITE_BLOB;
1.7          (drh      28-May-04):     if( key ){
1.93         (danielk1 13-Feb-08):       rc = sqlite3BtreeKey(pCur, offset, amt, pMem->z);
1.7          (drh      28-May-04):     }else{
1.93         (danielk1 13-Feb-08):       rc = sqlite3BtreeData(pCur, offset, amt, pMem->z);
1.7          (drh      28-May-04):     }
1.93         (danielk1 13-Feb-08):     pMem->z[amt] = 0;
1.93         (danielk1 13-Feb-08):     pMem->z[amt+1] = 0;
1.7          (drh      28-May-04):     if( rc!=SQLITE_OK ){
1.93         (danielk1 13-Feb-08):       sqlite3VdbeMemRelease(pMem);
1.7          (drh      28-May-04):     }
1.7          (drh      28-May-04):   }
1.93         (danielk1 13-Feb-08):   pMem->n = amt;
1.7          (drh      28-May-04): 
1.93         (danielk1 13-Feb-08):   return rc;
1.7          (drh      28-May-04): }
1.7          (drh      28-May-04): 
1.92         (drh      31-Jan-08): #if 0
1.4          (danielk1 27-May-04): /*
1.4          (danielk1 27-May-04): ** Perform various checks on the memory cell pMem. An assert() will
1.4          (danielk1 27-May-04): ** fail if pMem is internally inconsistent.
1.4          (danielk1 27-May-04): */
1.54         (drh      24-Feb-06): void sqlite3VdbeMemSanity(Mem *pMem){
1.4          (danielk1 27-May-04):   int flags = pMem->flags;
1.4          (danielk1 27-May-04):   assert( flags!=0 );  /* Must define some type */
1.60         (drh      02-May-07):   if( flags & (MEM_Str|MEM_Blob) ){
1.60         (drh      02-May-07):     int x = flags & (MEM_Static|MEM_Dyn|MEM_Ephem|MEM_Short);
1.4          (danielk1 27-May-04):     assert( x!=0 );            /* Strings must define a string subtype */
1.4          (danielk1 27-May-04):     assert( (x & (x-1))==0 );  /* Only one string subtype can be defined */
1.61         (drh      02-May-07):     assert( pMem->z!=0 );      /* Strings must have a value */
1.4          (danielk1 27-May-04):     /* Mem.z points to Mem.zShort iff the subtype is MEM_Short */
1.60         (drh      02-May-07):     assert( (x & MEM_Short)==0 || pMem->z==pMem->zShort );
1.60         (drh      02-May-07):     assert( (x & MEM_Short)!=0 || pMem->z!=pMem->zShort );
1.20         (drh      22-Jun-04):     /* No destructor unless there is MEM_Dyn */
1.20         (drh      22-Jun-04):     assert( pMem->xDel==0 || (pMem->flags & MEM_Dyn)!=0 );
1.4          (danielk1 27-May-04): 
1.4          (danielk1 27-May-04):     if( (flags & MEM_Str) ){
1.15         (danielk1 12-Jun-04):       assert( pMem->enc==SQLITE_UTF8 || 
1.15         (danielk1 12-Jun-04):               pMem->enc==SQLITE_UTF16BE ||
1.15         (danielk1 12-Jun-04):               pMem->enc==SQLITE_UTF16LE 
1.4          (danielk1 27-May-04):       );
1.4          (danielk1 27-May-04):       /* If the string is UTF-8 encoded and nul terminated, then pMem->n
1.27         (drh      30-Aug-04):       ** must be the length of the string.  (Later:)  If the database file
1.27         (drh      30-Aug-04):       ** has been corrupted, '\000' characters might have been inserted
1.133        (drh      10-Dec-08):       ** into the middle of the string.  In that case, the sqlite3Strlen30()
1.133        (drh      10-Dec-08):       ** might be less.
1.4          (danielk1 27-May-04):       */
1.15         (danielk1 12-Jun-04):       if( pMem->enc==SQLITE_UTF8 && (flags & MEM_Term) ){ 
1.133        (drh      10-Dec-08):         assert( sqlite3Strlen30(pMem->z)<=pMem->n );
1.27         (drh      30-Aug-04):         assert( pMem->z[pMem->n]==0 );
1.4          (danielk1 27-May-04):       }
1.4          (danielk1 27-May-04):     }
1.4          (danielk1 27-May-04):   }else{
1.4          (danielk1 27-May-04):     /* Cannot define a string subtype for non-string objects */
1.4          (danielk1 27-May-04):     assert( (pMem->flags & (MEM_Static|MEM_Dyn|MEM_Ephem|MEM_Short))==0 );
1.20         (drh      22-Jun-04):     assert( pMem->xDel==0 );
1.4          (danielk1 27-May-04):   }
1.4          (danielk1 27-May-04):   /* MEM_Null excludes all other types */
1.4          (danielk1 27-May-04):   assert( (pMem->flags&(MEM_Str|MEM_Int|MEM_Real|MEM_Blob))==0
1.4          (danielk1 27-May-04):           || (pMem->flags&MEM_Null)==0 );
1.35         (drh      20-Aug-05):   /* If the MEM is both real and integer, the values are equal */
1.35         (drh      20-Aug-05):   assert( (pMem->flags & (MEM_Int|MEM_Real))!=(MEM_Int|MEM_Real) 
1.58         (drh      30-Mar-07):           || pMem->r==pMem->u.i );
1.4          (danielk1 27-May-04): }
1.4          (danielk1 27-May-04): #endif
1.13         (danielk1 10-Jun-04): 
1.13         (danielk1 10-Jun-04): /* This function is only available internally, it is not part of the
1.13         (danielk1 10-Jun-04): ** external API. It works in a similar way to sqlite3_value_text(),
1.13         (danielk1 10-Jun-04): ** except the data returned is in the encoding specified by the second
1.13         (danielk1 10-Jun-04): ** parameter, which must be one of SQLITE_UTF16BE, SQLITE_UTF16LE or
1.13         (danielk1 10-Jun-04): ** SQLITE_UTF8.
1.52         (drh      16-Feb-06): **
1.52         (drh      16-Feb-06): ** (2006-02-16:)  The enc value can be or-ed with SQLITE_UTF16_ALIGNED.
1.52         (drh      16-Feb-06): ** If that is the case, then the result must be aligned on an even byte
1.52         (drh      16-Feb-06): ** boundary.
1.13         (danielk1 10-Jun-04): */
1.80         (drh      21-Aug-07): const void *sqlite3ValueText(sqlite3_value* pVal, u8 enc){
1.19         (danielk1 18-Jun-04):   if( !pVal ) return 0;
1.80         (drh      21-Aug-07): 
1.80         (drh      21-Aug-07):   assert( pVal->db==0 || sqlite3_mutex_held(pVal->db->mutex) );
1.52         (drh      16-Feb-06):   assert( (enc&3)==(enc&~SQLITE_UTF16_ALIGNED) );
1.127        (drh      04-Dec-08):   assert( (pVal->flags & MEM_RowSet)==0 );
1.19         (danielk1 18-Jun-04): 
1.13         (danielk1 10-Jun-04):   if( pVal->flags&MEM_Null ){
1.13         (danielk1 10-Jun-04):     return 0;
1.13         (danielk1 10-Jun-04):   }
1.49         (drh      12-Jan-06):   assert( (MEM_Blob>>3) == MEM_Str );
1.49         (drh      12-Jan-06):   pVal->flags |= (pVal->flags & MEM_Blob)>>3;
1.80         (drh      21-Aug-07):   expandBlob(pVal);
1.13         (danielk1 10-Jun-04):   if( pVal->flags&MEM_Str ){
1.80         (drh      21-Aug-07):     sqlite3VdbeChangeEncoding(pVal, enc & ~SQLITE_UTF16_ALIGNED);
1.117        (shane    08-Jul-08):     if( (enc & SQLITE_UTF16_ALIGNED)!=0 && 1==(1&SQLITE_PTR_TO_INT(pVal->z)) ){
1.52         (drh      16-Feb-06):       assert( (pVal->flags & (MEM_Ephem|MEM_Static))!=0 );
1.80         (drh      21-Aug-07):       if( sqlite3VdbeMemMakeWriteable(pVal)!=SQLITE_OK ){
1.52         (drh      16-Feb-06):         return 0;
1.52         (drh      16-Feb-06):       }
1.52         (drh      16-Feb-06):     }
1.80         (drh      21-Aug-07):     sqlite3VdbeMemNulTerminate(pVal);
1.55         (drh      04-Sep-06):   }else{
1.55         (drh      04-Sep-06):     assert( (pVal->flags&MEM_Blob)==0 );
1.80         (drh      21-Aug-07):     sqlite3VdbeMemStringify(pVal, enc);
1.130        (drh      09-Dec-08):     assert( 0==(1&SQLITE_PTR_TO_INT(pVal->z)) );
1.52         (drh      16-Feb-06):   }
1.80         (drh      21-Aug-07):   assert(pVal->enc==(enc & ~SQLITE_UTF16_ALIGNED) || pVal->db==0
1.80         (drh      21-Aug-07):               || pVal->db->mallocFailed );
1.52         (drh      16-Feb-06):   if( pVal->enc==(enc & ~SQLITE_UTF16_ALIGNED) ){
1.52         (drh      16-Feb-06):     return pVal->z;
1.52         (drh      16-Feb-06):   }else{
1.52         (drh      16-Feb-06):     return 0;
1.13         (danielk1 10-Jun-04):   }
1.13         (danielk1 10-Jun-04): }
1.13         (danielk1 10-Jun-04): 
1.21         (drh      27-Jun-04): /*
1.21         (drh      27-Jun-04): ** Create a new sqlite3_value object.
1.21         (drh      27-Jun-04): */
1.76         (drh      16-Aug-07): sqlite3_value *sqlite3ValueNew(sqlite3 *db){
1.83         (danielk1 29-Aug-07):   Mem *p = sqlite3DbMallocZero(db, sizeof(*p));
1.13         (danielk1 10-Jun-04):   if( p ){
1.13         (danielk1 10-Jun-04):     p->flags = MEM_Null;
1.13         (danielk1 10-Jun-04):     p->type = SQLITE_NULL;
1.80         (drh      21-Aug-07):     p->db = db;
1.13         (danielk1 10-Jun-04):   }
1.13         (danielk1 10-Jun-04):   return p;
1.13         (danielk1 10-Jun-04): }
1.13         (danielk1 10-Jun-04): 
1.21         (drh      27-Jun-04): /*
1.31         (danielk1 09-Mar-05): ** Create a new sqlite3_value object, containing the value of pExpr.
1.31         (danielk1 09-Mar-05): **
1.31         (danielk1 09-Mar-05): ** This only works for very simple expressions that consist of one constant
1.90         (drh      22-Jan-08): ** token (i.e. "5", "5.1", "'a string'"). If the expression can
1.31         (danielk1 09-Mar-05): ** be converted directly into a value, then the value is allocated and
1.31         (danielk1 09-Mar-05): ** a pointer written to *ppVal. The caller is responsible for deallocating
1.31         (danielk1 09-Mar-05): ** the value by passing it to sqlite3ValueFree() later on. If the expression
1.31         (danielk1 09-Mar-05): ** cannot be converted to a value, then *ppVal is set to NULL.
1.31         (danielk1 09-Mar-05): */
1.31         (danielk1 09-Mar-05): int sqlite3ValueFromExpr(
1.80         (drh      21-Aug-07):   sqlite3 *db,              /* The database connection */
1.76         (drh      16-Aug-07):   Expr *pExpr,              /* The expression to evaluate */
1.76         (drh      16-Aug-07):   u8 enc,                   /* Encoding to use */
1.76         (drh      16-Aug-07):   u8 affinity,              /* Affinity to use */
1.76         (drh      16-Aug-07):   sqlite3_value **ppVal     /* Write the new value here */
1.31         (danielk1 09-Mar-05): ){
1.31         (danielk1 09-Mar-05):   int op;
1.31         (danielk1 09-Mar-05):   char *zVal = 0;
1.31         (danielk1 09-Mar-05):   sqlite3_value *pVal = 0;
1.31         (danielk1 09-Mar-05): 
1.31         (danielk1 09-Mar-05):   if( !pExpr ){
1.31         (danielk1 09-Mar-05):     *ppVal = 0;
1.31         (danielk1 09-Mar-05):     return SQLITE_OK;
1.31         (danielk1 09-Mar-05):   }
1.31         (danielk1 09-Mar-05):   op = pExpr->op;
1.31         (danielk1 09-Mar-05): 
1.31         (danielk1 09-Mar-05):   if( op==TK_STRING || op==TK_FLOAT || op==TK_INTEGER ){
1.119        (drh      28-Jul-08):     zVal = sqlite3DbStrNDup(db, (char*)pExpr->token.z, pExpr->token.n);
1.76         (drh      16-Aug-07):     pVal = sqlite3ValueNew(db);
1.31         (danielk1 09-Mar-05):     if( !zVal || !pVal ) goto no_mem;
1.31         (danielk1 09-Mar-05):     sqlite3Dequote(zVal);
1.119        (drh      28-Jul-08):     sqlite3ValueSetStr(pVal, -1, zVal, SQLITE_UTF8, SQLITE_DYNAMIC);
1.31         (danielk1 09-Mar-05):     if( (op==TK_INTEGER || op==TK_FLOAT ) && affinity==SQLITE_AFF_NONE ){
1.80         (drh      21-Aug-07):       sqlite3ValueApplyAffinity(pVal, SQLITE_AFF_NUMERIC, enc);
1.31         (danielk1 09-Mar-05):     }else{
1.80         (drh      21-Aug-07):       sqlite3ValueApplyAffinity(pVal, affinity, enc);
1.31         (danielk1 09-Mar-05):     }
1.31         (danielk1 09-Mar-05):   }else if( op==TK_UMINUS ) {
1.80         (drh      21-Aug-07):     if( SQLITE_OK==sqlite3ValueFromExpr(db,pExpr->pLeft,enc,affinity,&pVal) ){
1.58         (drh      30-Mar-07):       pVal->u.i = -1 * pVal->u.i;
1.31         (danielk1 09-Mar-05):       pVal->r = -1.0 * pVal->r;
1.31         (danielk1 09-Mar-05):     }
1.31         (danielk1 09-Mar-05):   }
1.31         (danielk1 09-Mar-05): #ifndef SQLITE_OMIT_BLOB_LITERAL
1.31         (danielk1 09-Mar-05):   else if( op==TK_BLOB ){
1.31         (danielk1 09-Mar-05):     int nVal;
1.88         (drh      18-Jan-08):     assert( pExpr->token.n>=3 );
1.88         (drh      18-Jan-08):     assert( pExpr->token.z[0]=='x' || pExpr->token.z[0]=='X' );
1.88         (drh      18-Jan-08):     assert( pExpr->token.z[1]=='\'' );
1.88         (drh      18-Jan-08):     assert( pExpr->token.z[pExpr->token.n-1]=='\'' );
1.77         (danielk1 16-Aug-07):     pVal = sqlite3ValueNew(db);
1.124        (danielk1 30-Oct-08):     if( !pVal ) goto no_mem;
1.88         (drh      18-Jan-08):     nVal = pExpr->token.n - 3;
1.88         (drh      18-Jan-08):     zVal = (char*)pExpr->token.z + 2;
1.88         (drh      18-Jan-08):     sqlite3VdbeMemSetStr(pVal, sqlite3HexToBlob(db, zVal, nVal), nVal/2,
1.119        (drh      28-Jul-08):                          0, SQLITE_DYNAMIC);
1.31         (danielk1 09-Mar-05):   }
1.31         (danielk1 09-Mar-05): #endif
1.31         (danielk1 09-Mar-05): 
1.31         (danielk1 09-Mar-05):   *ppVal = pVal;
1.31         (danielk1 09-Mar-05):   return SQLITE_OK;
1.31         (danielk1 09-Mar-05): 
1.31         (danielk1 09-Mar-05): no_mem:
1.76         (drh      16-Aug-07):   db->mallocFailed = 1;
1.119        (drh      28-Jul-08):   sqlite3DbFree(db, zVal);
1.31         (danielk1 09-Mar-05):   sqlite3ValueFree(pVal);
1.31         (danielk1 09-Mar-05):   *ppVal = 0;
1.31         (danielk1 09-Mar-05):   return SQLITE_NOMEM;
1.31         (danielk1 09-Mar-05): }
1.31         (danielk1 09-Mar-05): 
1.31         (danielk1 09-Mar-05): /*
1.21         (drh      27-Jun-04): ** Change the string value of an sqlite3_value object
1.21         (drh      27-Jun-04): */
1.19         (danielk1 18-Jun-04): void sqlite3ValueSetStr(
1.76         (drh      16-Aug-07):   sqlite3_value *v,     /* Value to be set */
1.76         (drh      16-Aug-07):   int n,                /* Length of string z */
1.76         (drh      16-Aug-07):   const void *z,        /* Text of the new string */
1.76         (drh      16-Aug-07):   u8 enc,               /* Encoding to use */
1.76         (drh      16-Aug-07):   void (*xDel)(void*)   /* Destructor for the string */
1.19         (danielk1 18-Jun-04): ){
1.80         (drh      21-Aug-07):   if( v ) sqlite3VdbeMemSetStr((Mem *)v, z, n, enc, xDel);
1.13         (danielk1 10-Jun-04): }
1.13         (danielk1 10-Jun-04): 
1.21         (drh      27-Jun-04): /*
1.21         (drh      27-Jun-04): ** Free an sqlite3_value object
1.21         (drh      27-Jun-04): */
1.13         (danielk1 10-Jun-04): void sqlite3ValueFree(sqlite3_value *v){
1.19         (danielk1 18-Jun-04):   if( !v ) return;
1.93         (danielk1 13-Feb-08):   sqlite3VdbeMemRelease((Mem *)v);
1.119        (drh      28-Jul-08):   sqlite3DbFree(((Mem*)v)->db, v);
1.13         (danielk1 10-Jun-04): }
1.13         (danielk1 10-Jun-04): 
1.21         (drh      27-Jun-04): /*
1.21         (drh      27-Jun-04): ** Return the number of bytes in the sqlite3_value object assuming
1.21         (drh      27-Jun-04): ** that it uses the encoding "enc"
1.21         (drh      27-Jun-04): */
1.80         (drh      21-Aug-07): int sqlite3ValueBytes(sqlite3_value *pVal, u8 enc){
1.13         (danielk1 10-Jun-04):   Mem *p = (Mem*)pVal;
1.80         (drh      21-Aug-07):   if( (p->flags & MEM_Blob)!=0 || sqlite3ValueText(pVal, enc) ){
1.60         (drh      02-May-07):     if( p->flags & MEM_Zero ){
1.130        (drh      09-Dec-08):       return p->n + p->u.nZero;
1.60         (drh      02-May-07):     }else{
1.60         (drh      02-May-07):       return p->n;
1.60         (drh      02-May-07):     }
1.13         (danielk1 10-Jun-04):   }
1.13         (danielk1 10-Jun-04):   return 0;
1.13         (danielk1 10-Jun-04): }
