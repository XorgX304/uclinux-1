1.1          (drh      29-May-00): /*
1.20         (drh      16-Sep-01): ** 2001 September 15
1.1          (drh      29-May-00): **
1.20         (drh      16-Sep-01): ** The author disclaims copyright to this source code.  In place of
1.20         (drh      16-Sep-01): ** a legal notice, here is a blessing:
1.1          (drh      29-May-00): **
1.20         (drh      16-Sep-01): **    May you do good and not evil.
1.20         (drh      16-Sep-01): **    May you find forgiveness for yourself and forgive others.
1.20         (drh      16-Sep-01): **    May you share freely, never taking more than you give.
1.1          (drh      29-May-00): **
1.1          (drh      29-May-00): *************************************************************************
1.1          (drh      29-May-00): ** This module contains C code that generates VDBE code used to process
1.76         (drh      20-Apr-03): ** the WHERE clause of SQL statements.
1.1          (drh      29-May-00): **
1.102        (drh      09-Jun-04): ** $Id: where.c,v 1.101 2004/05/29 11:24:50 danielk1977 Exp $
1.1          (drh      29-May-00): */
1.1          (drh      29-May-00): #include "sqliteInt.h"
1.1          (drh      29-May-00): 
1.1          (drh      29-May-00): /*
1.1          (drh      29-May-00): ** The query generator uses an array of instances of this structure to
1.1          (drh      29-May-00): ** help it analyze the subexpressions of the WHERE clause.  Each WHERE
1.1          (drh      29-May-00): ** clause subexpression is separated from the others by an AND operator.
1.1          (drh      29-May-00): */
1.1          (drh      29-May-00): typedef struct ExprInfo ExprInfo;
1.1          (drh      29-May-00): struct ExprInfo {
1.1          (drh      29-May-00):   Expr *p;                /* Pointer to the subexpression */
1.53         (drh      19-Jun-02):   u8 indexable;           /* True if this subexprssion is usable by an index */
1.53         (drh      19-Jun-02):   short int idxLeft;      /* p->pLeft is a column in this table number. -1 if
1.8          (drh      21-Jun-00):                           ** p->pLeft is not the column of any table */
1.53         (drh      19-Jun-02):   short int idxRight;     /* p->pRight is a column in this table number. -1 if
1.8          (drh      21-Jun-00):                           ** p->pRight is not the column of any table */
1.53         (drh      19-Jun-02):   unsigned prereqLeft;    /* Bitmask of tables referenced by p->pLeft */
1.53         (drh      19-Jun-02):   unsigned prereqRight;   /* Bitmask of tables referenced by p->pRight */
1.53         (drh      19-Jun-02):   unsigned prereqAll;     /* Bitmask of tables referenced by p */
1.1          (drh      29-May-00): };
1.1          (drh      29-May-00): 
1.1          (drh      29-May-00): /*
1.78         (drh      02-May-03): ** An instance of the following structure keeps track of a mapping
1.78         (drh      02-May-03): ** between VDBE cursor numbers and bitmasks.  The VDBE cursor numbers
1.78         (drh      02-May-03): ** are small integers contained in SrcList_item.iCursor and Expr.iTable
1.78         (drh      02-May-03): ** fields.  For any given WHERE clause, we want to track which cursors
1.78         (drh      02-May-03): ** are being used, so we assign a single bit in a 32-bit word to track
1.78         (drh      02-May-03): ** that cursor.  Then a 32-bit integer is able to show the set of all
1.78         (drh      02-May-03): ** cursors being used.
1.78         (drh      02-May-03): */
1.78         (drh      02-May-03): typedef struct ExprMaskSet ExprMaskSet;
1.78         (drh      02-May-03): struct ExprMaskSet {
1.78         (drh      02-May-03):   int n;          /* Number of assigned cursor values */
1.78         (drh      02-May-03):   int ix[32];     /* Cursor assigned to each bit */
1.78         (drh      02-May-03): };
1.78         (drh      02-May-03): 
1.78         (drh      02-May-03): /*
1.1          (drh      29-May-00): ** Determine the number of elements in an array.
1.1          (drh      29-May-00): */
1.1          (drh      29-May-00): #define ARRAYSIZE(X)  (sizeof(X)/sizeof(X[0]))
1.1          (drh      29-May-00): 
1.1          (drh      29-May-00): /*
1.1          (drh      29-May-00): ** This routine is used to divide the WHERE expression into subexpressions
1.1          (drh      29-May-00): ** separated by the AND operator.
1.1          (drh      29-May-00): **
1.1          (drh      29-May-00): ** aSlot[] is an array of subexpressions structures.
1.1          (drh      29-May-00): ** There are nSlot spaces left in this array.  This routine attempts to
1.1          (drh      29-May-00): ** split pExpr into subexpressions and fills aSlot[] with those subexpressions.
1.1          (drh      29-May-00): ** The return value is the number of slots filled.
1.1          (drh      29-May-00): */
1.1          (drh      29-May-00): static int exprSplit(int nSlot, ExprInfo *aSlot, Expr *pExpr){
1.1          (drh      29-May-00):   int cnt = 0;
1.1          (drh      29-May-00):   if( pExpr==0 || nSlot<1 ) return 0;
1.1          (drh      29-May-00):   if( nSlot==1 || pExpr->op!=TK_AND ){
1.1          (drh      29-May-00):     aSlot[0].p = pExpr;
1.1          (drh      29-May-00):     return 1;
1.1          (drh      29-May-00):   }
1.1          (drh      29-May-00):   if( pExpr->pLeft->op!=TK_AND ){
1.1          (drh      29-May-00):     aSlot[0].p = pExpr->pLeft;
1.1          (drh      29-May-00):     cnt = 1 + exprSplit(nSlot-1, &aSlot[1], pExpr->pRight);
1.1          (drh      29-May-00):   }else{
1.72         (drh      31-Jan-03):     cnt = exprSplit(nSlot, aSlot, pExpr->pLeft);
1.72         (drh      31-Jan-03):     cnt += exprSplit(nSlot-cnt, &aSlot[cnt], pExpr->pRight);
1.1          (drh      29-May-00):   }
1.1          (drh      29-May-00):   return cnt;
1.1          (drh      29-May-00): }
1.1          (drh      29-May-00): 
1.1          (drh      29-May-00): /*
1.78         (drh      02-May-03): ** Initialize an expression mask set
1.78         (drh      02-May-03): */
1.78         (drh      02-May-03): #define initMaskSet(P)  memset(P, 0, sizeof(*P))
1.78         (drh      02-May-03): 
1.78         (drh      02-May-03): /*
1.78         (drh      02-May-03): ** Return the bitmask for the given cursor.  Assign a new bitmask
1.78         (drh      02-May-03): ** if this is the first time the cursor has been seen.
1.78         (drh      02-May-03): */
1.78         (drh      02-May-03): static int getMask(ExprMaskSet *pMaskSet, int iCursor){
1.78         (drh      02-May-03):   int i;
1.78         (drh      02-May-03):   for(i=0; i<pMaskSet->n; i++){
1.78         (drh      02-May-03):     if( pMaskSet->ix[i]==iCursor ) return 1<<i;
1.78         (drh      02-May-03):   }
1.78         (drh      02-May-03):   if( i==pMaskSet->n && i<ARRAYSIZE(pMaskSet->ix) ){
1.78         (drh      02-May-03):     pMaskSet->n++;
1.78         (drh      02-May-03):     pMaskSet->ix[i] = iCursor;
1.78         (drh      02-May-03):     return 1<<i;
1.78         (drh      02-May-03):   }
1.78         (drh      02-May-03):   return 0;
1.78         (drh      02-May-03): }
1.78         (drh      02-May-03): 
1.78         (drh      02-May-03): /*
1.78         (drh      02-May-03): ** Destroy an expression mask set
1.78         (drh      02-May-03): */
1.78         (drh      02-May-03): #define freeMaskSet(P)   /* NO-OP */
1.78         (drh      02-May-03): 
1.78         (drh      02-May-03): /*
1.1          (drh      29-May-00): ** This routine walks (recursively) an expression tree and generates
1.1          (drh      29-May-00): ** a bitmask indicating which tables are used in that expression
1.78         (drh      02-May-03): ** tree.
1.1          (drh      29-May-00): **
1.1          (drh      29-May-00): ** In order for this routine to work, the calling function must have
1.90         (danielk1 08-May-04): ** previously invoked sqlite3ExprResolveIds() on the expression.  See
1.1          (drh      29-May-00): ** the header comment on that routine for additional information.
1.90         (danielk1 08-May-04): ** The sqlite3ExprResolveIds() routines looks for column names and
1.78         (drh      02-May-03): ** sets their opcodes to TK_COLUMN and their Expr.iTable fields to
1.78         (drh      02-May-03): ** the VDBE cursor number of the table.
1.1          (drh      29-May-00): */
1.78         (drh      02-May-03): static int exprTableUsage(ExprMaskSet *pMaskSet, Expr *p){
1.1          (drh      29-May-00):   unsigned int mask = 0;
1.1          (drh      29-May-00):   if( p==0 ) return 0;
1.8          (drh      21-Jun-00):   if( p->op==TK_COLUMN ){
1.78         (drh      02-May-03):     return getMask(pMaskSet, p->iTable);
1.1          (drh      29-May-00):   }
1.1          (drh      29-May-00):   if( p->pRight ){
1.78         (drh      02-May-03):     mask = exprTableUsage(pMaskSet, p->pRight);
1.1          (drh      29-May-00):   }
1.1          (drh      29-May-00):   if( p->pLeft ){
1.78         (drh      02-May-03):     mask |= exprTableUsage(pMaskSet, p->pLeft);
1.39         (drh      02-Apr-02):   }
1.39         (drh      02-Apr-02):   if( p->pList ){
1.39         (drh      02-Apr-02):     int i;
1.39         (drh      02-Apr-02):     for(i=0; i<p->pList->nExpr; i++){
1.78         (drh      02-May-03):       mask |= exprTableUsage(pMaskSet, p->pList->a[i].pExpr);
1.39         (drh      02-Apr-02):     }
1.1          (drh      29-May-00):   }
1.1          (drh      29-May-00):   return mask;
1.1          (drh      29-May-00): }
1.1          (drh      29-May-00): 
1.1          (drh      29-May-00): /*
1.26         (drh      08-Nov-01): ** Return TRUE if the given operator is one of the operators that is
1.26         (drh      08-Nov-01): ** allowed for an indexable WHERE clause.  The allowed operators are
1.51         (drh      14-Jun-02): ** "=", "<", ">", "<=", ">=", and "IN".
1.26         (drh      08-Nov-01): */
1.26         (drh      08-Nov-01): static int allowedOp(int op){
1.26         (drh      08-Nov-01):   switch( op ){
1.26         (drh      08-Nov-01):     case TK_LT:
1.26         (drh      08-Nov-01):     case TK_LE:
1.26         (drh      08-Nov-01):     case TK_GT:
1.26         (drh      08-Nov-01):     case TK_GE:
1.26         (drh      08-Nov-01):     case TK_EQ:
1.49         (drh      08-Jun-02):     case TK_IN:
1.26         (drh      08-Nov-01):       return 1;
1.26         (drh      08-Nov-01):     default:
1.26         (drh      08-Nov-01):       return 0;
1.26         (drh      08-Nov-01):   }
1.26         (drh      08-Nov-01): }
1.26         (drh      08-Nov-01): 
1.26         (drh      08-Nov-01): /*
1.1          (drh      29-May-00): ** The input to this routine is an ExprInfo structure with only the
1.1          (drh      29-May-00): ** "p" field filled in.  The job of this routine is to analyze the
1.1          (drh      29-May-00): ** subexpression and populate all the other fields of the ExprInfo
1.1          (drh      29-May-00): ** structure.
1.1          (drh      29-May-00): */
1.78         (drh      02-May-03): static void exprAnalyze(ExprMaskSet *pMaskSet, ExprInfo *pInfo){
1.1          (drh      29-May-00):   Expr *pExpr = pInfo->p;
1.78         (drh      02-May-03):   pInfo->prereqLeft = exprTableUsage(pMaskSet, pExpr->pLeft);
1.78         (drh      02-May-03):   pInfo->prereqRight = exprTableUsage(pMaskSet, pExpr->pRight);
1.78         (drh      02-May-03):   pInfo->prereqAll = exprTableUsage(pMaskSet, pExpr);
1.1          (drh      29-May-00):   pInfo->indexable = 0;
1.1          (drh      29-May-00):   pInfo->idxLeft = -1;
1.1          (drh      29-May-00):   pInfo->idxRight = -1;
1.26         (drh      08-Nov-01):   if( allowedOp(pExpr->op) && (pInfo->prereqRight & pInfo->prereqLeft)==0 ){
1.49         (drh      08-Jun-02):     if( pExpr->pRight && pExpr->pRight->op==TK_COLUMN ){
1.78         (drh      02-May-03):       pInfo->idxRight = pExpr->pRight->iTable;
1.1          (drh      29-May-00):       pInfo->indexable = 1;
1.1          (drh      29-May-00):     }
1.8          (drh      21-Jun-00):     if( pExpr->pLeft->op==TK_COLUMN ){
1.78         (drh      02-May-03):       pInfo->idxLeft = pExpr->pLeft->iTable;
1.1          (drh      29-May-00):       pInfo->indexable = 1;
1.1          (drh      29-May-00):     }
1.1          (drh      29-May-00):   }
1.1          (drh      29-May-00): }
1.1          (drh      29-May-00): 
1.1          (drh      29-May-00): /*
1.53         (drh      19-Jun-02): ** pOrderBy is an ORDER BY clause from a SELECT statement.  pTab is the
1.53         (drh      19-Jun-02): ** left-most table in the FROM clause of that same SELECT statement and
1.53         (drh      19-Jun-02): ** the table has a cursor number of "base".
1.53         (drh      19-Jun-02): **
1.53         (drh      19-Jun-02): ** This routine attempts to find an index for pTab that generates the
1.53         (drh      19-Jun-02): ** correct record sequence for the given ORDER BY clause.  The return value
1.53         (drh      19-Jun-02): ** is a pointer to an index that does the job.  NULL is returned if the
1.53         (drh      19-Jun-02): ** table has no index that will generate the correct sort order.
1.53         (drh      19-Jun-02): **
1.53         (drh      19-Jun-02): ** If there are two or more indices that generate the correct sort order
1.53         (drh      19-Jun-02): ** and pPreferredIdx is one of those indices, then return pPreferredIdx.
1.69         (drh      04-Dec-02): **
1.69         (drh      04-Dec-02): ** nEqCol is the number of columns of pPreferredIdx that are used as
1.69         (drh      04-Dec-02): ** equality constraints.  Any index returned must have exactly this same
1.69         (drh      04-Dec-02): ** set of columns.  The ORDER BY clause only matches index columns beyond the
1.69         (drh      04-Dec-02): ** the first nEqCol columns.
1.69         (drh      04-Dec-02): **
1.69         (drh      04-Dec-02): ** All terms of the ORDER BY clause must be either ASC or DESC.  The
1.69         (drh      04-Dec-02): ** *pbRev value is set to 1 if the ORDER BY clause is all DESC and it is
1.69         (drh      04-Dec-02): ** set to 0 if the ORDER BY clause is all ASC.
1.53         (drh      19-Jun-02): */
1.53         (drh      19-Jun-02): static Index *findSortingIndex(
1.53         (drh      19-Jun-02):   Table *pTab,            /* The table to be sorted */
1.53         (drh      19-Jun-02):   int base,               /* Cursor number for pTab */
1.53         (drh      19-Jun-02):   ExprList *pOrderBy,     /* The ORDER BY clause */
1.68         (drh      04-Dec-02):   Index *pPreferredIdx,   /* Use this index, if possible and not NULL */
1.69         (drh      04-Dec-02):   int nEqCol,             /* Number of index columns used with == constraints */
1.68         (drh      04-Dec-02):   int *pbRev              /* Set to 1 if ORDER BY is DESC */
1.53         (drh      19-Jun-02): ){
1.69         (drh      04-Dec-02):   int i, j;
1.53         (drh      19-Jun-02):   Index *pMatch;
1.53         (drh      19-Jun-02):   Index *pIdx;
1.68         (drh      04-Dec-02):   int sortOrder;
1.53         (drh      19-Jun-02): 
1.53         (drh      19-Jun-02):   assert( pOrderBy!=0 );
1.53         (drh      19-Jun-02):   assert( pOrderBy->nExpr>0 );
1.100        (drh      20-May-04):   sortOrder = pOrderBy->a[0].sortOrder;
1.53         (drh      19-Jun-02):   for(i=0; i<pOrderBy->nExpr; i++){
1.53         (drh      19-Jun-02):     Expr *p;
1.100        (drh      20-May-04):     if( pOrderBy->a[i].sortOrder!=sortOrder ){
1.68         (drh      04-Dec-02):       /* Indices can only be used if all ORDER BY terms are either
1.68         (drh      04-Dec-02):       ** DESC or ASC.  Indices cannot be used on a mixture. */
1.62         (drh      14-Aug-02):       return 0;
1.62         (drh      14-Aug-02):     }
1.100        (drh      20-May-04):     if( pOrderBy->a[i].zName!=0 ){
1.62         (drh      14-Aug-02):       /* Do not sort by index if there is a COLLATE clause */
1.53         (drh      19-Jun-02):       return 0;
1.53         (drh      19-Jun-02):     }
1.53         (drh      19-Jun-02):     p = pOrderBy->a[i].pExpr;
1.53         (drh      19-Jun-02):     if( p->op!=TK_COLUMN || p->iTable!=base ){
1.53         (drh      19-Jun-02):       /* Can not use an index sort on anything that is not a column in the
1.53         (drh      19-Jun-02):       ** left-most table of the FROM clause */
1.53         (drh      19-Jun-02):       return 0;
1.53         (drh      19-Jun-02):     }
1.53         (drh      19-Jun-02):   }
1.68         (drh      04-Dec-02):   
1.53         (drh      19-Jun-02):   /* If we get this far, it means the ORDER BY clause consists only of
1.53         (drh      19-Jun-02):   ** ascending columns in the left-most table of the FROM clause.  Now
1.53         (drh      19-Jun-02):   ** check for a matching index.
1.53         (drh      19-Jun-02):   */
1.53         (drh      19-Jun-02):   pMatch = 0;
1.53         (drh      19-Jun-02):   for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
1.69         (drh      04-Dec-02):     int nExpr = pOrderBy->nExpr;
1.69         (drh      04-Dec-02):     if( pIdx->nColumn < nEqCol || pIdx->nColumn < nExpr ) continue;
1.69         (drh      04-Dec-02):     for(i=j=0; i<nEqCol; i++){
1.69         (drh      04-Dec-02):       if( pPreferredIdx->aiColumn[i]!=pIdx->aiColumn[i] ) break;
1.69         (drh      04-Dec-02):       if( j<nExpr && pOrderBy->a[j].pExpr->iColumn==pIdx->aiColumn[i] ){ j++; }
1.69         (drh      04-Dec-02):     }
1.69         (drh      04-Dec-02):     if( i<nEqCol ) continue;
1.69         (drh      04-Dec-02):     for(i=0; i+j<nExpr; i++){
1.69         (drh      04-Dec-02):       if( pOrderBy->a[i+j].pExpr->iColumn!=pIdx->aiColumn[i+nEqCol] ) break;
1.53         (drh      19-Jun-02):     }
1.69         (drh      04-Dec-02):     if( i+j>=nExpr ){
1.53         (drh      19-Jun-02):       pMatch = pIdx;
1.53         (drh      19-Jun-02):       if( pIdx==pPreferredIdx ) break;
1.53         (drh      19-Jun-02):     }
1.53         (drh      19-Jun-02):   }
1.68         (drh      04-Dec-02):   if( pMatch && pbRev ){
1.68         (drh      04-Dec-02):     *pbRev = sortOrder==SQLITE_SO_DESC;
1.68         (drh      04-Dec-02):   }
1.53         (drh      19-Jun-02):   return pMatch;
1.53         (drh      19-Jun-02): }
1.53         (drh      19-Jun-02): 
1.53         (drh      19-Jun-02): /*
1.53         (drh      19-Jun-02): ** Generate the beginning of the loop used for WHERE clause processing.
1.1          (drh      29-May-00): ** The return value is a pointer to an (opaque) structure that contains
1.1          (drh      29-May-00): ** information needed to terminate the loop.  Later, the calling routine
1.90         (danielk1 08-May-04): ** should invoke sqlite3WhereEnd() with the return value of this function
1.1          (drh      29-May-00): ** in order to complete the WHERE clause processing.
1.1          (drh      29-May-00): **
1.1          (drh      29-May-00): ** If an error occurs, this routine returns NULL.
1.51         (drh      14-Jun-02): **
1.51         (drh      14-Jun-02): ** The basic idea is to do a nested loop, one loop for each table in
1.51         (drh      14-Jun-02): ** the FROM clause of a select.  (INSERT and UPDATE statements are the
1.51         (drh      14-Jun-02): ** same as a SELECT with only a single table in the FROM clause.)  For
1.51         (drh      14-Jun-02): ** example, if the SQL is this:
1.51         (drh      14-Jun-02): **
1.51         (drh      14-Jun-02): **       SELECT * FROM t1, t2, t3 WHERE ...;
1.51         (drh      14-Jun-02): **
1.51         (drh      14-Jun-02): ** Then the code generated is conceptually like the following:
1.51         (drh      14-Jun-02): **
1.51         (drh      14-Jun-02): **      foreach row1 in t1 do       \    Code generated
1.90         (danielk1 08-May-04): **        foreach row2 in t2 do      |-- by sqlite3WhereBegin()
1.51         (drh      14-Jun-02): **          foreach row3 in t3 do   /
1.51         (drh      14-Jun-02): **            ...
1.51         (drh      14-Jun-02): **          end                     \    Code generated
1.90         (danielk1 08-May-04): **        end                        |-- by sqlite3WhereEnd()
1.51         (drh      14-Jun-02): **      end                         /
1.51         (drh      14-Jun-02): **
1.51         (drh      14-Jun-02): ** There are Btree cursors associated with each table.  t1 uses cursor
1.78         (drh      02-May-03): ** number pTabList->a[0].iCursor.  t2 uses the cursor pTabList->a[1].iCursor.
1.78         (drh      02-May-03): ** And so forth.  This routine generates code to open those VDBE cursors
1.90         (danielk1 08-May-04): ** and sqlite3WhereEnd() generates the code to close them.
1.51         (drh      14-Jun-02): **
1.51         (drh      14-Jun-02): ** If the WHERE clause is empty, the foreach loops must each scan their
1.51         (drh      14-Jun-02): ** entire tables.  Thus a three-way join is an O(N^3) operation.  But if
1.51         (drh      14-Jun-02): ** the tables have indices and there are terms in the WHERE clause that
1.51         (drh      14-Jun-02): ** refer to those indices, a complete table scan can be avoided and the
1.51         (drh      14-Jun-02): ** code will run much faster.  Most of the work of this routine is checking
1.51         (drh      14-Jun-02): ** to see if there are indices that can be used to speed up the loop.
1.51         (drh      14-Jun-02): **
1.51         (drh      14-Jun-02): ** Terms of the WHERE clause are also used to limit which rows actually
1.51         (drh      14-Jun-02): ** make it to the "..." in the middle of the loop.  After each "foreach",
1.51         (drh      14-Jun-02): ** terms of the WHERE clause that use only terms in that loop and outer
1.51         (drh      14-Jun-02): ** loops are evaluated and if false a jump is made around all subsequent
1.51         (drh      14-Jun-02): ** inner loops (or around the "..." if the test occurs within the inner-
1.51         (drh      14-Jun-02): ** most loop)
1.51         (drh      14-Jun-02): **
1.51         (drh      14-Jun-02): ** OUTER JOINS
1.51         (drh      14-Jun-02): **
1.51         (drh      14-Jun-02): ** An outer join of tables t1 and t2 is conceptally coded as follows:
1.51         (drh      14-Jun-02): **
1.51         (drh      14-Jun-02): **    foreach row1 in t1 do
1.51         (drh      14-Jun-02): **      flag = 0
1.51         (drh      14-Jun-02): **      foreach row2 in t2 do
1.51         (drh      14-Jun-02): **        start:
1.51         (drh      14-Jun-02): **          ...
1.51         (drh      14-Jun-02): **          flag = 1
1.51         (drh      14-Jun-02): **      end
1.53         (drh      19-Jun-02): **      if flag==0 then
1.53         (drh      19-Jun-02): **        move the row2 cursor to a null row
1.53         (drh      19-Jun-02): **        goto start
1.53         (drh      19-Jun-02): **      fi
1.51         (drh      14-Jun-02): **    end
1.51         (drh      14-Jun-02): **
1.53         (drh      19-Jun-02): ** ORDER BY CLAUSE PROCESSING
1.53         (drh      19-Jun-02): **
1.53         (drh      19-Jun-02): ** *ppOrderBy is a pointer to the ORDER BY clause of a SELECT statement,
1.53         (drh      19-Jun-02): ** if there is one.  If there is no ORDER BY clause or if this routine
1.53         (drh      19-Jun-02): ** is called from an UPDATE or DELETE statement, then ppOrderBy is NULL.
1.53         (drh      19-Jun-02): **
1.53         (drh      19-Jun-02): ** If an index can be used so that the natural output order of the table
1.53         (drh      19-Jun-02): ** scan is correct for the ORDER BY clause, then that index is used and
1.53         (drh      19-Jun-02): ** *ppOrderBy is set to NULL.  This is an optimization that prevents an
1.53         (drh      19-Jun-02): ** unnecessary sort of the result set if an index appropriate for the
1.53         (drh      19-Jun-02): ** ORDER BY clause already exists.
1.53         (drh      19-Jun-02): **
1.53         (drh      19-Jun-02): ** If the where clause loops cannot be arranged to provide the correct
1.53         (drh      19-Jun-02): ** output order, then the *ppOrderBy is unchanged.
1.1          (drh      29-May-00): */
1.90         (danielk1 08-May-04): WhereInfo *sqlite3WhereBegin(
1.1          (drh      29-May-00):   Parse *pParse,       /* The parser context */
1.46         (drh      24-May-02):   SrcList *pTabList,   /* A list of all tables to be scanned */
1.1          (drh      29-May-00):   Expr *pWhere,        /* The WHERE clause */
1.53         (drh      19-Jun-02):   int pushKey,         /* If TRUE, leave the table key on the stack */
1.53         (drh      19-Jun-02):   ExprList **ppOrderBy /* An ORDER BY clause, or NULL */
1.1          (drh      29-May-00): ){
1.1          (drh      29-May-00):   int i;                     /* Loop counter */
1.1          (drh      29-May-00):   WhereInfo *pWInfo;         /* Will become the return value of this function */
1.1          (drh      29-May-00):   Vdbe *v = pParse->pVdbe;   /* The virtual database engine */
1.81         (drh      16-Jul-03):   int brk, cont = 0;         /* Addresses used during code generation */
1.1          (drh      29-May-00):   int nExpr;           /* Number of subexpressions in the WHERE clause */
1.1          (drh      29-May-00):   int loopMask;        /* One bit set for each outer loop */
1.1          (drh      29-May-00):   int haveKey;         /* True if KEY is on the stack */
1.78         (drh      02-May-03):   ExprMaskSet maskSet; /* The expression mask set */
1.29         (drh      22-Dec-01):   int iDirectEq[32];   /* Term of the form ROWID==X for the N-th table */
1.29         (drh      22-Dec-01):   int iDirectLt[32];   /* Term of the form ROWID<X or ROWID<=X */
1.29         (drh      22-Dec-01):   int iDirectGt[32];   /* Term of the form ROWID>X or ROWID>=X */
1.57         (drh      28-Jun-02):   ExprInfo aExpr[101]; /* The WHERE clause is divided into these expressions */
1.1          (drh      29-May-00): 
1.51         (drh      14-Jun-02):   /* pushKey is only allowed if there is a single table (as in an INSERT or
1.51         (drh      14-Jun-02):   ** UPDATE statement)
1.51         (drh      14-Jun-02):   */
1.51         (drh      14-Jun-02):   assert( pushKey==0 || pTabList->nSrc==1 );
1.57         (drh      28-Jun-02): 
1.57         (drh      28-Jun-02):   /* Split the WHERE clause into separate subexpressions where each
1.57         (drh      28-Jun-02):   ** subexpression is separated by an AND operator.  If the aExpr[]
1.57         (drh      28-Jun-02):   ** array fills up, the last entry might point to an expression which
1.57         (drh      28-Jun-02):   ** contains additional unfactored AND operators.
1.57         (drh      28-Jun-02):   */
1.78         (drh      02-May-03):   initMaskSet(&maskSet);
1.57         (drh      28-Jun-02):   memset(aExpr, 0, sizeof(aExpr));
1.57         (drh      28-Jun-02):   nExpr = exprSplit(ARRAYSIZE(aExpr), aExpr, pWhere);
1.57         (drh      28-Jun-02):   if( nExpr==ARRAYSIZE(aExpr) ){
1.90         (danielk1 08-May-04):     sqlite3ErrorMsg(pParse, "WHERE clause too complex - no more "
1.88         (drh      22-Feb-04):        "than %d terms allowed", (int)ARRAYSIZE(aExpr)-1);
1.57         (drh      28-Jun-02):     return 0;
1.57         (drh      28-Jun-02):   }
1.51         (drh      14-Jun-02):   
1.1          (drh      29-May-00):   /* Allocate and initialize the WhereInfo structure that will become the
1.1          (drh      29-May-00):   ** return value.
1.1          (drh      29-May-00):   */
1.46         (drh      24-May-02):   pWInfo = sqliteMalloc( sizeof(WhereInfo) + pTabList->nSrc*sizeof(WhereLevel));
1.91         (danielk1 10-May-04):   if( sqlite3_malloc_failed ){
1.14         (drh      11-Apr-01):     sqliteFree(pWInfo);
1.1          (drh      29-May-00):     return 0;
1.1          (drh      29-May-00):   }
1.1          (drh      29-May-00):   pWInfo->pParse = pParse;
1.1          (drh      29-May-00):   pWInfo->pTabList = pTabList;
1.38         (drh      02-Mar-02):   pWInfo->peakNTab = pWInfo->savedNTab = pParse->nTab;
1.90         (danielk1 08-May-04):   pWInfo->iBreak = sqlite3VdbeMakeLabel(v);
1.41         (drh      30-Apr-02): 
1.41         (drh      30-Apr-02):   /* Special case: a WHERE clause that is constant.  Evaluate the
1.41         (drh      30-Apr-02):   ** expression and either jump over all of the code or fall thru.
1.41         (drh      30-Apr-02):   */
1.90         (danielk1 08-May-04):   if( pWhere && (pTabList->nSrc==0 || sqlite3ExprIsConstant(pWhere)) ){
1.90         (danielk1 08-May-04):     sqlite3ExprIfFalse(pParse, pWhere, pWInfo->iBreak, 1);
1.52         (drh      14-Jun-02):     pWhere = 0;
1.41         (drh      30-Apr-02):   }
1.1          (drh      29-May-00): 
1.1          (drh      29-May-00):   /* Analyze all of the subexpressions.
1.1          (drh      29-May-00):   */
1.1          (drh      29-May-00):   for(i=0; i<nExpr; i++){
1.78         (drh      02-May-03):     exprAnalyze(&maskSet, &aExpr[i]);
1.45         (drh      21-May-02): 
1.45         (drh      21-May-02):     /* If we are executing a trigger body, remove all references to
1.45         (drh      21-May-02):     ** new.* and old.* tables from the prerequisite masks.
1.45         (drh      21-May-02):     */
1.45         (drh      21-May-02):     if( pParse->trigStack ){
1.45         (drh      21-May-02):       int x;
1.45         (drh      21-May-02):       if( (x = pParse->trigStack->newIdx) >= 0 ){
1.78         (drh      02-May-03):         int mask = ~getMask(&maskSet, x);
1.45         (drh      21-May-02):         aExpr[i].prereqRight &= mask;
1.45         (drh      21-May-02):         aExpr[i].prereqLeft &= mask;
1.45         (drh      21-May-02):         aExpr[i].prereqAll &= mask;
1.45         (drh      21-May-02):       }
1.45         (drh      21-May-02):       if( (x = pParse->trigStack->oldIdx) >= 0 ){
1.78         (drh      02-May-03):         int mask = ~getMask(&maskSet, x);
1.45         (drh      21-May-02):         aExpr[i].prereqRight &= mask;
1.45         (drh      21-May-02):         aExpr[i].prereqLeft &= mask;
1.45         (drh      21-May-02):         aExpr[i].prereqAll &= mask;
1.45         (drh      21-May-02):       }
1.42         (danielk1 15-May-02):     }
1.1          (drh      29-May-00):   }
1.1          (drh      29-May-00): 
1.1          (drh      29-May-00):   /* Figure out what index to use (if any) for each nested loop.
1.25         (drh      07-Nov-01):   ** Make pWInfo->a[i].pIdx point to the index to use for the i-th nested
1.46         (drh      24-May-02):   ** loop where i==0 is the outer loop and i==pTabList->nSrc-1 is the inner
1.29         (drh      22-Dec-01):   ** loop. 
1.29         (drh      22-Dec-01):   **
1.29         (drh      22-Dec-01):   ** If terms exist that use the ROWID of any table, then set the
1.29         (drh      22-Dec-01):   ** iDirectEq[], iDirectLt[], or iDirectGt[] elements for that table
1.29         (drh      22-Dec-01):   ** to the index of the term containing the ROWID.  We always prefer
1.29         (drh      22-Dec-01):   ** to use a ROWID which can directly access a table rather than an
1.36         (drh      18-Feb-02):   ** index which requires reading an index first to get the rowid then
1.36         (drh      18-Feb-02):   ** doing a second read of the actual database table.
1.1          (drh      29-May-00):   **
1.1          (drh      29-May-00):   ** Actually, if there are more than 32 tables in the join, only the
1.36         (drh      18-Feb-02):   ** first 32 tables are candidates for indices.  This is (again) due
1.36         (drh      18-Feb-02):   ** to the limit of 32 bits in an integer bitmask.
1.1          (drh      29-May-00):   */
1.1          (drh      29-May-00):   loopMask = 0;
1.63         (drh      15-Aug-02):   for(i=0; i<pTabList->nSrc && i<ARRAYSIZE(iDirectEq); i++){
1.13         (drh      04-Apr-01):     int j;
1.78         (drh      02-May-03):     int iCur = pTabList->a[i].iCursor;    /* The cursor for this table */
1.78         (drh      02-May-03):     int mask = getMask(&maskSet, iCur);   /* Cursor mask for this table */
1.78         (drh      02-May-03):     Table *pTab = pTabList->a[i].pTab;
1.1          (drh      29-May-00):     Index *pIdx;
1.1          (drh      29-May-00):     Index *pBestIdx = 0;
1.26         (drh      08-Nov-01):     int bestScore = 0;
1.1          (drh      29-May-00): 
1.13         (drh      04-Apr-01):     /* Check to see if there is an expression that uses only the
1.29         (drh      22-Dec-01):     ** ROWID field of this table.  For terms of the form ROWID==expr
1.29         (drh      22-Dec-01):     ** set iDirectEq[i] to the index of the term.  For terms of the
1.29         (drh      22-Dec-01):     ** form ROWID<expr or ROWID<=expr set iDirectLt[i] to the term index.
1.29         (drh      22-Dec-01):     ** For terms like ROWID>expr or ROWID>=expr set iDirectGt[i].
1.67         (drh      03-Dec-02):     **
1.67         (drh      03-Dec-02):     ** (Added:) Treat ROWID IN expr like ROWID=expr.
1.13         (drh      04-Apr-01):     */
1.65         (drh      30-Sep-02):     pWInfo->a[i].iCur = -1;
1.29         (drh      22-Dec-01):     iDirectEq[i] = -1;
1.29         (drh      22-Dec-01):     iDirectLt[i] = -1;
1.29         (drh      22-Dec-01):     iDirectGt[i] = -1;
1.13         (drh      04-Apr-01):     for(j=0; j<nExpr; j++){
1.78         (drh      02-May-03):       if( aExpr[j].idxLeft==iCur && aExpr[j].p->pLeft->iColumn<0
1.13         (drh      04-Apr-01):             && (aExpr[j].prereqRight & loopMask)==aExpr[j].prereqRight ){
1.29         (drh      22-Dec-01):         switch( aExpr[j].p->op ){
1.49         (drh      08-Jun-02):           case TK_IN:
1.29         (drh      22-Dec-01):           case TK_EQ: iDirectEq[i] = j; break;
1.29         (drh      22-Dec-01):           case TK_LE:
1.29         (drh      22-Dec-01):           case TK_LT: iDirectLt[i] = j; break;
1.29         (drh      22-Dec-01):           case TK_GE:
1.29         (drh      22-Dec-01):           case TK_GT: iDirectGt[i] = j;  break;
1.29         (drh      22-Dec-01):         }
1.13         (drh      04-Apr-01):       }
1.78         (drh      02-May-03):       if( aExpr[j].idxRight==iCur && aExpr[j].p->pRight->iColumn<0
1.13         (drh      04-Apr-01):             && (aExpr[j].prereqLeft & loopMask)==aExpr[j].prereqLeft ){
1.29         (drh      22-Dec-01):         switch( aExpr[j].p->op ){
1.29         (drh      22-Dec-01):           case TK_EQ: iDirectEq[i] = j;  break;
1.29         (drh      22-Dec-01):           case TK_LE:
1.29         (drh      22-Dec-01):           case TK_LT: iDirectGt[i] = j;  break;
1.29         (drh      22-Dec-01):           case TK_GE:
1.29         (drh      22-Dec-01):           case TK_GT: iDirectLt[i] = j;  break;
1.29         (drh      22-Dec-01):         }
1.13         (drh      04-Apr-01):       }
1.13         (drh      04-Apr-01):     }
1.29         (drh      22-Dec-01):     if( iDirectEq[i]>=0 ){
1.78         (drh      02-May-03):       loopMask |= mask;
1.25         (drh      07-Nov-01):       pWInfo->a[i].pIdx = 0;
1.13         (drh      04-Apr-01):       continue;
1.13         (drh      04-Apr-01):     }
1.13         (drh      04-Apr-01): 
1.1          (drh      29-May-00):     /* Do a search for usable indices.  Leave pBestIdx pointing to
1.26         (drh      08-Nov-01):     ** the "best" index.  pBestIdx is left set to NULL if no indices
1.26         (drh      08-Nov-01):     ** are usable.
1.26         (drh      08-Nov-01):     **
1.26         (drh      08-Nov-01):     ** The best index is determined as follows.  For each of the
1.26         (drh      08-Nov-01):     ** left-most terms that is fixed by an equality operator, add
1.68         (drh      04-Dec-02):     ** 8 to the score.  The right-most term of the index may be
1.26         (drh      08-Nov-01):     ** constrained by an inequality.  Add 1 if for an "x<..." constraint
1.26         (drh      08-Nov-01):     ** and add 2 for an "x>..." constraint.  Chose the index that
1.26         (drh      08-Nov-01):     ** gives the best score.
1.1          (drh      29-May-00):     **
1.26         (drh      08-Nov-01):     ** This scoring system is designed so that the score can later be
1.68         (drh      04-Dec-02):     ** used to determine how the index is used.  If the score&7 is 0
1.26         (drh      08-Nov-01):     ** then all constraints are equalities.  If score&1 is not 0 then
1.26         (drh      08-Nov-01):     ** there is an inequality used as a termination key.  (ex: "x<...")
1.26         (drh      08-Nov-01):     ** If score&2 is not 0 then there is an inequality used as the
1.68         (drh      04-Dec-02):     ** start key.  (ex: "x>...").  A score or 4 is the special case
1.68         (drh      04-Dec-02):     ** of an IN operator constraint.  (ex:  "x IN ...").
1.49         (drh      08-Jun-02):     **
1.51         (drh      14-Jun-02):     ** The IN operator (as in "<expr> IN (...)") is treated the same as
1.51         (drh      14-Jun-02):     ** an equality comparison except that it can only be used on the
1.51         (drh      14-Jun-02):     ** left-most column of an index and other terms of the WHERE clause
1.51         (drh      14-Jun-02):     ** cannot be used in conjunction with the IN operator to help satisfy
1.51         (drh      14-Jun-02):     ** other columns of the index.
1.1          (drh      29-May-00):     */
1.1          (drh      29-May-00):     for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
1.51         (drh      14-Jun-02):       int eqMask = 0;  /* Index columns covered by an x=... term */
1.51         (drh      14-Jun-02):       int ltMask = 0;  /* Index columns covered by an x<... term */
1.51         (drh      14-Jun-02):       int gtMask = 0;  /* Index columns covered by an x>... term */
1.51         (drh      14-Jun-02):       int inMask = 0;  /* Index columns covered by an x IN .. term */
1.26         (drh      08-Nov-01):       int nEq, m, score;
1.1          (drh      29-May-00): 
1.26         (drh      08-Nov-01):       if( pIdx->nColumn>32 ) continue;  /* Ignore indices too many columns */
1.1          (drh      29-May-00):       for(j=0; j<nExpr; j++){
1.78         (drh      02-May-03):         if( aExpr[j].idxLeft==iCur 
1.1          (drh      29-May-00):              && (aExpr[j].prereqRight & loopMask)==aExpr[j].prereqRight ){
1.8          (drh      21-Jun-00):           int iColumn = aExpr[j].p->pLeft->iColumn;
1.1          (drh      29-May-00):           int k;
1.95         (danielk1 17-May-04):           char idxaff = pIdx->pTable->aCol[iColumn].affinity; 
1.8          (drh      21-Jun-00):           for(k=0; k<pIdx->nColumn; k++){
1.95         (danielk1 17-May-04):             if( pIdx->aiColumn[k]==iColumn 
1.95         (danielk1 17-May-04):                 && sqlite3IndexAffinityOk(aExpr[j].p, idxaff) ){
1.26         (drh      08-Nov-01):               switch( aExpr[j].p->op ){
1.50         (drh      09-Jun-02):                 case TK_IN: {
1.50         (drh      09-Jun-02):                   if( k==0 ) inMask |= 1;
1.50         (drh      09-Jun-02):                   break;
1.50         (drh      09-Jun-02):                 }
1.26         (drh      08-Nov-01):                 case TK_EQ: {
1.26         (drh      08-Nov-01):                   eqMask |= 1<<k;
1.26         (drh      08-Nov-01):                   break;
1.26         (drh      08-Nov-01):                 }
1.26         (drh      08-Nov-01):                 case TK_LE:
1.26         (drh      08-Nov-01):                 case TK_LT: {
1.26         (drh      08-Nov-01):                   ltMask |= 1<<k;
1.26         (drh      08-Nov-01):                   break;
1.26         (drh      08-Nov-01):                 }
1.26         (drh      08-Nov-01):                 case TK_GE:
1.26         (drh      08-Nov-01):                 case TK_GT: {
1.26         (drh      08-Nov-01):                   gtMask |= 1<<k;
1.26         (drh      08-Nov-01):                   break;
1.26         (drh      08-Nov-01):                 }
1.26         (drh      08-Nov-01):                 default: {
1.26         (drh      08-Nov-01):                   /* CANT_HAPPEN */
1.26         (drh      08-Nov-01):                   assert( 0 );
1.26         (drh      08-Nov-01):                   break;
1.26         (drh      08-Nov-01):                 }
1.26         (drh      08-Nov-01):               }
1.1          (drh      29-May-00):               break;
1.1          (drh      29-May-00):             }
1.1          (drh      29-May-00):           }
1.1          (drh      29-May-00):         }
1.78         (drh      02-May-03):         if( aExpr[j].idxRight==iCur 
1.1          (drh      29-May-00):              && (aExpr[j].prereqLeft & loopMask)==aExpr[j].prereqLeft ){
1.8          (drh      21-Jun-00):           int iColumn = aExpr[j].p->pRight->iColumn;
1.1          (drh      29-May-00):           int k;
1.95         (danielk1 17-May-04):           char idxaff = pIdx->pTable->aCol[iColumn].affinity; 
1.8          (drh      21-Jun-00):           for(k=0; k<pIdx->nColumn; k++){
1.95         (danielk1 17-May-04):             if( pIdx->aiColumn[k]==iColumn 
1.95         (danielk1 17-May-04):                 && sqlite3IndexAffinityOk(aExpr[j].p, idxaff) ){
1.26         (drh      08-Nov-01):               switch( aExpr[j].p->op ){
1.26         (drh      08-Nov-01):                 case TK_EQ: {
1.26         (drh      08-Nov-01):                   eqMask |= 1<<k;
1.26         (drh      08-Nov-01):                   break;
1.26         (drh      08-Nov-01):                 }
1.26         (drh      08-Nov-01):                 case TK_LE:
1.26         (drh      08-Nov-01):                 case TK_LT: {
1.26         (drh      08-Nov-01):                   gtMask |= 1<<k;
1.26         (drh      08-Nov-01):                   break;
1.26         (drh      08-Nov-01):                 }
1.26         (drh      08-Nov-01):                 case TK_GE:
1.26         (drh      08-Nov-01):                 case TK_GT: {
1.26         (drh      08-Nov-01):                   ltMask |= 1<<k;
1.26         (drh      08-Nov-01):                   break;
1.26         (drh      08-Nov-01):                 }
1.26         (drh      08-Nov-01):                 default: {
1.26         (drh      08-Nov-01):                   /* CANT_HAPPEN */
1.26         (drh      08-Nov-01):                   assert( 0 );
1.26         (drh      08-Nov-01):                   break;
1.26         (drh      08-Nov-01):                 }
1.26         (drh      08-Nov-01):               }
1.1          (drh      29-May-00):               break;
1.1          (drh      29-May-00):             }
1.1          (drh      29-May-00):           }
1.1          (drh      29-May-00):         }
1.1          (drh      29-May-00):       }
1.68         (drh      04-Dec-02): 
1.68         (drh      04-Dec-02):       /* The following loop ends with nEq set to the number of columns
1.68         (drh      04-Dec-02):       ** on the left of the index with == constraints.
1.68         (drh      04-Dec-02):       */
1.26         (drh      08-Nov-01):       for(nEq=0; nEq<pIdx->nColumn; nEq++){
1.26         (drh      08-Nov-01):         m = (1<<(nEq+1))-1;
1.26         (drh      08-Nov-01):         if( (m & eqMask)!=m ) break;
1.26         (drh      08-Nov-01):       }
1.68         (drh      04-Dec-02):       score = nEq*8;   /* Base score is 8 times number of == constraints */
1.26         (drh      08-Nov-01):       m = 1<<nEq;
1.68         (drh      04-Dec-02):       if( m & ltMask ) score++;    /* Increase score for a < constraint */
1.68         (drh      04-Dec-02):       if( m & gtMask ) score+=2;   /* Increase score for a > constraint */
1.68         (drh      04-Dec-02):       if( score==0 && inMask ) score = 4;  /* Default score for IN constraint */
1.26         (drh      08-Nov-01):       if( score>bestScore ){
1.26         (drh      08-Nov-01):         pBestIdx = pIdx;
1.26         (drh      08-Nov-01):         bestScore = score;
1.1          (drh      29-May-00):       }
1.1          (drh      29-May-00):     }
1.25         (drh      07-Nov-01):     pWInfo->a[i].pIdx = pBestIdx;
1.26         (drh      08-Nov-01):     pWInfo->a[i].score = bestScore;
1.68         (drh      04-Dec-02):     pWInfo->a[i].bRev = 0;
1.78         (drh      02-May-03):     loopMask |= mask;
1.25         (drh      07-Nov-01):     if( pBestIdx ){
1.38         (drh      02-Mar-02):       pWInfo->a[i].iCur = pParse->nTab++;
1.38         (drh      02-Mar-02):       pWInfo->peakNTab = pParse->nTab;
1.25         (drh      07-Nov-01):     }
1.1          (drh      29-May-00):   }
1.1          (drh      29-May-00): 
1.53         (drh      19-Jun-02):   /* Check to see if the ORDER BY clause is or can be satisfied by the
1.53         (drh      19-Jun-02):   ** use of an index on the first table.
1.53         (drh      19-Jun-02):   */
1.53         (drh      19-Jun-02):   if( ppOrderBy && *ppOrderBy && pTabList->nSrc>0 ){
1.53         (drh      19-Jun-02):      Index *pSortIdx;
1.53         (drh      19-Jun-02):      Index *pIdx;
1.53         (drh      19-Jun-02):      Table *pTab;
1.68         (drh      04-Dec-02):      int bRev = 0;
1.53         (drh      19-Jun-02): 
1.53         (drh      19-Jun-02):      pTab = pTabList->a[0].pTab;
1.53         (drh      19-Jun-02):      pIdx = pWInfo->a[0].pIdx;
1.53         (drh      19-Jun-02):      if( pIdx && pWInfo->a[0].score==4 ){
1.68         (drh      04-Dec-02):        /* If there is already an IN index on the left-most table,
1.68         (drh      04-Dec-02):        ** it will not give the correct sort order.
1.68         (drh      04-Dec-02):        ** So, pretend that no suitable index is found.
1.53         (drh      19-Jun-02):        */
1.53         (drh      19-Jun-02):        pSortIdx = 0;
1.53         (drh      19-Jun-02):      }else if( iDirectEq[0]>=0 || iDirectLt[0]>=0 || iDirectGt[0]>=0 ){
1.53         (drh      19-Jun-02):        /* If the left-most column is accessed using its ROWID, then do
1.53         (drh      19-Jun-02):        ** not try to sort by index.
1.53         (drh      19-Jun-02):        */
1.53         (drh      19-Jun-02):        pSortIdx = 0;
1.53         (drh      19-Jun-02):      }else{
1.69         (drh      04-Dec-02):        int nEqCol = (pWInfo->a[0].score+4)/8;
1.78         (drh      02-May-03):        pSortIdx = findSortingIndex(pTab, pTabList->a[0].iCursor, 
1.78         (drh      02-May-03):                                    *ppOrderBy, pIdx, nEqCol, &bRev);
1.53         (drh      19-Jun-02):      }
1.53         (drh      19-Jun-02):      if( pSortIdx && (pIdx==0 || pIdx==pSortIdx) ){
1.53         (drh      19-Jun-02):        if( pIdx==0 ){
1.53         (drh      19-Jun-02):          pWInfo->a[0].pIdx = pSortIdx;
1.53         (drh      19-Jun-02):          pWInfo->a[0].iCur = pParse->nTab++;
1.53         (drh      19-Jun-02):          pWInfo->peakNTab = pParse->nTab;
1.53         (drh      19-Jun-02):        }
1.68         (drh      04-Dec-02):        pWInfo->a[0].bRev = bRev;
1.53         (drh      19-Jun-02):        *ppOrderBy = 0;
1.53         (drh      19-Jun-02):      }
1.53         (drh      19-Jun-02):   }
1.53         (drh      19-Jun-02): 
1.25         (drh      07-Nov-01):   /* Open all tables in the pTabList and all indices used by those tables.
1.1          (drh      29-May-00):   */
1.102        (drh      09-Jun-04):   sqlite3CodeVerifySchema(pParse, 1);  /* Inserts the cookie verifier Goto */
1.46         (drh      24-May-02):   for(i=0; i<pTabList->nSrc; i++){
1.22         (drh      08-Oct-01):     Table *pTab;
1.89         (drh      22-Feb-04):     Index *pIx;
1.22         (drh      08-Oct-01): 
1.22         (drh      08-Oct-01):     pTab = pTabList->a[i].pTab;
1.37         (drh      23-Feb-02):     if( pTab->isTransient || pTab->pSelect ) continue;
1.90         (danielk1 08-May-04):     sqlite3VdbeAddOp(v, OP_Integer, pTab->iDb, 0);
1.100        (drh      20-May-04):     sqlite3VdbeAddOp(v, OP_OpenRead, pTabList->a[i].iCursor, pTab->tnum);
1.96         (danielk1 18-May-04):     sqlite3VdbeAddOp(v, OP_SetNumColumns, pTabList->a[i].iCursor, pTab->nCol);
1.102        (drh      09-Jun-04):     if( pTab->tnum>1 ){
1.102        (drh      09-Jun-04):       sqlite3CodeVerifySchema(pParse, pTab->iDb);
1.102        (drh      09-Jun-04):     }
1.89         (drh      22-Feb-04):     if( (pIx = pWInfo->a[i].pIdx)!=0 ){
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_Integer, pIx->iDb, 0);
1.100        (drh      20-May-04):       sqlite3VdbeOp3(v, OP_OpenRead, pWInfo->a[i].iCur, pIx->tnum,
1.100        (drh      20-May-04):                      (char*)&pIx->keyInfo, P3_KEYINFO);
1.1          (drh      29-May-00):     }
1.1          (drh      29-May-00):   }
1.1          (drh      29-May-00): 
1.1          (drh      29-May-00):   /* Generate the code to do the search
1.1          (drh      29-May-00):   */
1.1          (drh      29-May-00):   loopMask = 0;
1.46         (drh      24-May-02):   for(i=0; i<pTabList->nSrc; i++){
1.1          (drh      29-May-00):     int j, k;
1.78         (drh      02-May-03):     int iCur = pTabList->a[i].iCursor;
1.13         (drh      04-Apr-01):     Index *pIdx;
1.25         (drh      07-Nov-01):     WhereLevel *pLevel = &pWInfo->a[i];
1.1          (drh      29-May-00): 
1.47         (drh      24-May-02):     /* If this is the right table of a LEFT OUTER JOIN, allocate and
1.67         (drh      03-Dec-02):     ** initialize a memory cell that records if this table matches any
1.51         (drh      14-Jun-02):     ** row of the left table of the join.
1.47         (drh      24-May-02):     */
1.47         (drh      24-May-02):     if( i>0 && (pTabList->a[i-1].jointype & JT_LEFT)!=0 ){
1.47         (drh      24-May-02):       if( !pParse->nMem ) pParse->nMem++;
1.47         (drh      24-May-02):       pLevel->iLeftJoin = pParse->nMem++;
1.101        (danielk1 29-May-04):       sqlite3VdbeAddOp(v, OP_String8, 0, 0);
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_MemStore, pLevel->iLeftJoin, 1);
1.47         (drh      24-May-02):     }
1.47         (drh      24-May-02): 
1.29         (drh      22-Dec-01):     pIdx = pLevel->pIdx;
1.49         (drh      08-Jun-02):     pLevel->inOp = OP_Noop;
1.29         (drh      22-Dec-01):     if( i<ARRAYSIZE(iDirectEq) && iDirectEq[i]>=0 ){
1.29         (drh      22-Dec-01):       /* Case 1:  We can directly reference a single row using an
1.51         (drh      14-Jun-02):       **          equality comparison against the ROWID field.  Or
1.51         (drh      14-Jun-02):       **          we reference multiple rows using a "rowid IN (...)"
1.51         (drh      14-Jun-02):       **          construct.
1.13         (drh      04-Apr-01):       */
1.29         (drh      22-Dec-01):       k = iDirectEq[i];
1.29         (drh      22-Dec-01):       assert( k<nExpr );
1.29         (drh      22-Dec-01):       assert( aExpr[k].p!=0 );
1.78         (drh      02-May-03):       assert( aExpr[k].idxLeft==iCur || aExpr[k].idxRight==iCur );
1.90         (danielk1 08-May-04):       brk = pLevel->brk = sqlite3VdbeMakeLabel(v);
1.78         (drh      02-May-03):       if( aExpr[k].idxLeft==iCur ){
1.49         (drh      08-Jun-02):         Expr *pX = aExpr[k].p;
1.49         (drh      08-Jun-02):         if( pX->op!=TK_IN ){
1.90         (danielk1 08-May-04):           sqlite3ExprCode(pParse, aExpr[k].p->pRight);
1.49         (drh      08-Jun-02):         }else{
1.90         (danielk1 08-May-04):           sqlite3VdbeAddOp(v, OP_Rewind, pX->iTable, brk);
1.90         (danielk1 08-May-04):           sqlite3VdbeAddOp(v, OP_KeyAsData, pX->iTable, 1);
1.95         (danielk1 17-May-04):           pLevel->inP2 = sqlite3VdbeAddOp(v, OP_IdxColumn, pX->iTable, 0);
1.49         (drh      08-Jun-02):           pLevel->inOp = OP_Next;
1.49         (drh      08-Jun-02):           pLevel->inP1 = pX->iTable;
1.49         (drh      08-Jun-02):         }
1.29         (drh      22-Dec-01):       }else{
1.90         (danielk1 08-May-04):         sqlite3ExprCode(pParse, aExpr[k].p->pLeft);
1.13         (drh      04-Apr-01):       }
1.29         (drh      22-Dec-01):       aExpr[k].p = 0;
1.90         (danielk1 08-May-04):       cont = pLevel->cont = sqlite3VdbeMakeLabel(v);
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_MustBeInt, 1, brk);
1.49         (drh      08-Jun-02):       haveKey = 0;
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_NotExists, iCur, brk);
1.25         (drh      07-Nov-01):       pLevel->op = OP_Noop;
1.53         (drh      19-Jun-02):     }else if( pIdx!=0 && pLevel->score>0 && pLevel->score%4==0 ){
1.51         (drh      14-Jun-02):       /* Case 2:  There is an index and all terms of the WHERE clause that
1.51         (drh      14-Jun-02):       **          refer to the index use the "==" or "IN" operators.
1.1          (drh      29-May-00):       */
1.25         (drh      07-Nov-01):       int start;
1.68         (drh      04-Dec-02):       int nColumn = (pLevel->score+4)/8;
1.90         (danielk1 08-May-04):       brk = pLevel->brk = sqlite3VdbeMakeLabel(v);
1.97         (drh      19-May-04): 
1.97         (drh      19-May-04):       /* For each column of the index, find the term of the WHERE clause that
1.97         (drh      19-May-04):       ** constraints that column.  If the WHERE clause term is X=expr, then
1.97         (drh      19-May-04):       ** evaluation expr and leave the result on the stack */
1.26         (drh      08-Nov-01):       for(j=0; j<nColumn; j++){
1.1          (drh      29-May-00):         for(k=0; k<nExpr; k++){
1.49         (drh      08-Jun-02):           Expr *pX = aExpr[k].p;
1.49         (drh      08-Jun-02):           if( pX==0 ) continue;
1.78         (drh      02-May-03):           if( aExpr[k].idxLeft==iCur
1.1          (drh      29-May-00):              && (aExpr[k].prereqRight & loopMask)==aExpr[k].prereqRight 
1.49         (drh      08-Jun-02):              && pX->pLeft->iColumn==pIdx->aiColumn[j]
1.1          (drh      29-May-00):           ){
1.95         (danielk1 17-May-04):             char idxaff = pIdx->pTable->aCol[pX->pLeft->iColumn].affinity;
1.95         (danielk1 17-May-04):             if( sqlite3IndexAffinityOk(aExpr[k].p, idxaff) ){
1.95         (danielk1 17-May-04):               if( pX->op==TK_EQ ){
1.95         (danielk1 17-May-04):                 sqlite3ExprCode(pParse, pX->pRight);
1.95         (danielk1 17-May-04):                 aExpr[k].p = 0;
1.95         (danielk1 17-May-04):                 break;
1.95         (danielk1 17-May-04):               }
1.95         (danielk1 17-May-04):               if( pX->op==TK_IN && nColumn==1 ){
1.90         (danielk1 08-May-04):                 sqlite3VdbeAddOp(v, OP_Rewind, pX->iTable, brk);
1.90         (danielk1 08-May-04):                 sqlite3VdbeAddOp(v, OP_KeyAsData, pX->iTable, 1);
1.95         (danielk1 17-May-04):                 pLevel->inP2 = sqlite3VdbeAddOp(v, OP_IdxColumn, pX->iTable, 0);
1.49         (drh      08-Jun-02):                 pLevel->inOp = OP_Next;
1.49         (drh      08-Jun-02):                 pLevel->inP1 = pX->iTable;
1.95         (danielk1 17-May-04):                 aExpr[k].p = 0;
1.95         (danielk1 17-May-04):                 break;
1.49         (drh      08-Jun-02):               }
1.49         (drh      08-Jun-02):             }
1.1          (drh      29-May-00):           }
1.78         (drh      02-May-03):           if( aExpr[k].idxRight==iCur
1.26         (drh      08-Nov-01):              && aExpr[k].p->op==TK_EQ
1.1          (drh      29-May-00):              && (aExpr[k].prereqLeft & loopMask)==aExpr[k].prereqLeft
1.8          (drh      21-Jun-00):              && aExpr[k].p->pRight->iColumn==pIdx->aiColumn[j]
1.1          (drh      29-May-00):           ){
1.95         (danielk1 17-May-04):             char idxaff = pIdx->pTable->aCol[pX->pRight->iColumn].affinity;
1.95         (danielk1 17-May-04):             if( sqlite3IndexAffinityOk(aExpr[k].p, idxaff) ){
1.95         (danielk1 17-May-04):               sqlite3ExprCode(pParse, aExpr[k].p->pLeft);
1.95         (danielk1 17-May-04):               aExpr[k].p = 0;
1.95         (danielk1 17-May-04):               break;
1.95         (danielk1 17-May-04):             }
1.1          (drh      29-May-00):           }
1.1          (drh      29-May-00):         }
1.1          (drh      29-May-00):       }
1.25         (drh      07-Nov-01):       pLevel->iMem = pParse->nMem++;
1.90         (danielk1 08-May-04):       cont = pLevel->cont = sqlite3VdbeMakeLabel(v);
1.97         (drh      19-May-04): 
1.97         (drh      19-May-04):       /* At this point, the top nColumn elements of the stack are the
1.97         (drh      19-May-04):       ** values of columns in the index we are using.  Check to see if
1.97         (drh      19-May-04):       ** any of these values are NULL.  If they are, they will not match any
1.97         (drh      19-May-04):       ** index entries, so skip immediately to the next iteration of the loop */
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_NotNull, -nColumn, sqlite3VdbeCurrentAddr(v)+3);
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_Pop, nColumn, 0);
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_Goto, 0, brk);
1.97         (drh      19-May-04): 
1.97         (drh      19-May-04):       /* Generate an index key from the top nColumn elements of the stack */
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_MakeKey, nColumn, 0);
1.94         (danielk1 16-May-04):       sqlite3IndexAffinityStr(v, pIdx);
1.92         (danielk1 14-May-04):       sqlite3VdbeAddOp(v, OP_MemStore, pLevel->iMem, 0);
1.97         (drh      19-May-04): 
1.97         (drh      19-May-04):       /* Generate code (1) to move to the first matching element of the table.
1.97         (drh      19-May-04):       ** Then generate code (2) that jumps to "brk" after the cursor is past
1.97         (drh      19-May-04):       ** the last matching element of the table.  The code (1) is executed
1.97         (drh      19-May-04):       ** once to initialize the search, the code (2) is executed before each
1.97         (drh      19-May-04):       ** iteration of the scan to see if the scan has finished. */
1.68         (drh      04-Dec-02):       if( pLevel->bRev ){
1.68         (drh      04-Dec-02):         /* Scan in reverse order */
1.98         (drh      19-May-04):         sqlite3VdbeAddOp(v, OP_MoveLe, pLevel->iCur, brk);
1.90         (danielk1 08-May-04):         start = sqlite3VdbeAddOp(v, OP_MemLoad, pLevel->iMem, 0);
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_IdxLT, pLevel->iCur, brk);
1.68         (drh      04-Dec-02):         pLevel->op = OP_Prev;
1.68         (drh      04-Dec-02):       }else{
1.68         (drh      04-Dec-02):         /* Scan in the forward order */
1.98         (drh      19-May-04):         sqlite3VdbeAddOp(v, OP_MoveGe, pLevel->iCur, brk);
1.90         (danielk1 08-May-04):         start = sqlite3VdbeAddOp(v, OP_MemLoad, pLevel->iMem, 0);
1.99         (drh      19-May-04):         sqlite3VdbeOp3(v, OP_IdxGE, pLevel->iCur, brk, "+", P3_STATIC);
1.68         (drh      04-Dec-02):         pLevel->op = OP_Next;
1.68         (drh      04-Dec-02):       }
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_RowKey, pLevel->iCur, 0);
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_IdxIsNull, nColumn, cont);
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_IdxRecno, pLevel->iCur, 0);
1.46         (drh      24-May-02):       if( i==pTabList->nSrc-1 && pushKey ){
1.26         (drh      08-Nov-01):         haveKey = 1;
1.26         (drh      08-Nov-01):       }else{
1.98         (drh      19-May-04):         sqlite3VdbeAddOp(v, OP_MoveGe, iCur, 0);
1.26         (drh      08-Nov-01):         haveKey = 0;
1.26         (drh      08-Nov-01):       }
1.26         (drh      08-Nov-01):       pLevel->p1 = pLevel->iCur;
1.26         (drh      08-Nov-01):       pLevel->p2 = start;
1.29         (drh      22-Dec-01):     }else if( i<ARRAYSIZE(iDirectLt) && (iDirectLt[i]>=0 || iDirectGt[i]>=0) ){
1.29         (drh      22-Dec-01):       /* Case 3:  We have an inequality comparison against the ROWID field.
1.29         (drh      22-Dec-01):       */
1.29         (drh      22-Dec-01):       int testOp = OP_Noop;
1.29         (drh      22-Dec-01):       int start;
1.29         (drh      22-Dec-01): 
1.90         (danielk1 08-May-04):       brk = pLevel->brk = sqlite3VdbeMakeLabel(v);
1.90         (danielk1 08-May-04):       cont = pLevel->cont = sqlite3VdbeMakeLabel(v);
1.29         (drh      22-Dec-01):       if( iDirectGt[i]>=0 ){
1.29         (drh      22-Dec-01):         k = iDirectGt[i];
1.29         (drh      22-Dec-01):         assert( k<nExpr );
1.29         (drh      22-Dec-01):         assert( aExpr[k].p!=0 );
1.78         (drh      02-May-03):         assert( aExpr[k].idxLeft==iCur || aExpr[k].idxRight==iCur );
1.78         (drh      02-May-03):         if( aExpr[k].idxLeft==iCur ){
1.90         (danielk1 08-May-04):           sqlite3ExprCode(pParse, aExpr[k].p->pRight);
1.29         (drh      22-Dec-01):         }else{
1.90         (danielk1 08-May-04):           sqlite3ExprCode(pParse, aExpr[k].p->pLeft);
1.29         (drh      22-Dec-01):         }
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_ForceInt,
1.87         (drh      14-Jan-04):           aExpr[k].p->op==TK_LT || aExpr[k].p->op==TK_GT, brk);
1.98         (drh      19-May-04):         sqlite3VdbeAddOp(v, OP_MoveGe, iCur, brk);
1.29         (drh      22-Dec-01):         aExpr[k].p = 0;
1.29         (drh      22-Dec-01):       }else{
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_Rewind, iCur, brk);
1.29         (drh      22-Dec-01):       }
1.29         (drh      22-Dec-01):       if( iDirectLt[i]>=0 ){
1.29         (drh      22-Dec-01):         k = iDirectLt[i];
1.29         (drh      22-Dec-01):         assert( k<nExpr );
1.29         (drh      22-Dec-01):         assert( aExpr[k].p!=0 );
1.78         (drh      02-May-03):         assert( aExpr[k].idxLeft==iCur || aExpr[k].idxRight==iCur );
1.78         (drh      02-May-03):         if( aExpr[k].idxLeft==iCur ){
1.90         (danielk1 08-May-04):           sqlite3ExprCode(pParse, aExpr[k].p->pRight);
1.29         (drh      22-Dec-01):         }else{
1.90         (danielk1 08-May-04):           sqlite3ExprCode(pParse, aExpr[k].p->pLeft);
1.29         (drh      22-Dec-01):         }
1.90         (danielk1 08-May-04):         /* sqlite3VdbeAddOp(v, OP_MustBeInt, 0, sqlite3VdbeCurrentAddr(v)+1); */
1.29         (drh      22-Dec-01):         pLevel->iMem = pParse->nMem++;
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_MemStore, pLevel->iMem, 1);
1.29         (drh      22-Dec-01):         if( aExpr[k].p->op==TK_LT || aExpr[k].p->op==TK_GT ){
1.29         (drh      22-Dec-01):           testOp = OP_Ge;
1.29         (drh      22-Dec-01):         }else{
1.29         (drh      22-Dec-01):           testOp = OP_Gt;
1.29         (drh      22-Dec-01):         }
1.29         (drh      22-Dec-01):         aExpr[k].p = 0;
1.29         (drh      22-Dec-01):       }
1.90         (danielk1 08-May-04):       start = sqlite3VdbeCurrentAddr(v);
1.29         (drh      22-Dec-01):       pLevel->op = OP_Next;
1.78         (drh      02-May-03):       pLevel->p1 = iCur;
1.29         (drh      22-Dec-01):       pLevel->p2 = start;
1.29         (drh      22-Dec-01):       if( testOp!=OP_Noop ){
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_Recno, iCur, 0);
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_MemLoad, pLevel->iMem, 0);
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, testOp, 0, brk);
1.29         (drh      22-Dec-01):       }
1.29         (drh      22-Dec-01):       haveKey = 0;
1.29         (drh      22-Dec-01):     }else if( pIdx==0 ){
1.51         (drh      14-Jun-02):       /* Case 4:  There is no usable index.  We must do a complete
1.29         (drh      22-Dec-01):       **          scan of the entire database table.
1.29         (drh      22-Dec-01):       */
1.29         (drh      22-Dec-01):       int start;
1.29         (drh      22-Dec-01): 
1.90         (danielk1 08-May-04):       brk = pLevel->brk = sqlite3VdbeMakeLabel(v);
1.90         (danielk1 08-May-04):       cont = pLevel->cont = sqlite3VdbeMakeLabel(v);
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_Rewind, iCur, brk);
1.90         (danielk1 08-May-04):       start = sqlite3VdbeCurrentAddr(v);
1.29         (drh      22-Dec-01):       pLevel->op = OP_Next;
1.78         (drh      02-May-03):       pLevel->p1 = iCur;
1.29         (drh      22-Dec-01):       pLevel->p2 = start;
1.29         (drh      22-Dec-01):       haveKey = 0;
1.26         (drh      08-Nov-01):     }else{
1.51         (drh      14-Jun-02):       /* Case 5: The WHERE clause term that refers to the right-most
1.51         (drh      14-Jun-02):       **         column of the index is an inequality.  For example, if
1.51         (drh      14-Jun-02):       **         the index is on (x,y,z) and the WHERE clause is of the
1.51         (drh      14-Jun-02):       **         form "x=5 AND y<10" then this case is used.  Only the
1.51         (drh      14-Jun-02):       **         right-most column can be an inequality - the rest must
1.51         (drh      14-Jun-02):       **         use the "==" operator.
1.53         (drh      19-Jun-02):       **
1.53         (drh      19-Jun-02):       **         This case is also used when there are no WHERE clause
1.53         (drh      19-Jun-02):       **         constraints but an index is selected anyway, in order
1.53         (drh      19-Jun-02):       **         to force the output order to conform to an ORDER BY.
1.26         (drh      08-Nov-01):       */
1.26         (drh      08-Nov-01):       int score = pLevel->score;
1.68         (drh      04-Dec-02):       int nEqColumn = score/8;
1.26         (drh      08-Nov-01):       int start;
1.26         (drh      08-Nov-01):       int leFlag, geFlag;
1.26         (drh      08-Nov-01):       int testOp;
1.26         (drh      08-Nov-01): 
1.26         (drh      08-Nov-01):       /* Evaluate the equality constraints
1.26         (drh      08-Nov-01):       */
1.26         (drh      08-Nov-01):       for(j=0; j<nEqColumn; j++){
1.26         (drh      08-Nov-01):         for(k=0; k<nExpr; k++){
1.26         (drh      08-Nov-01):           if( aExpr[k].p==0 ) continue;
1.78         (drh      02-May-03):           if( aExpr[k].idxLeft==iCur
1.26         (drh      08-Nov-01):              && aExpr[k].p->op==TK_EQ
1.26         (drh      08-Nov-01):              && (aExpr[k].prereqRight & loopMask)==aExpr[k].prereqRight 
1.26         (drh      08-Nov-01):              && aExpr[k].p->pLeft->iColumn==pIdx->aiColumn[j]
1.26         (drh      08-Nov-01):           ){
1.90         (danielk1 08-May-04):             sqlite3ExprCode(pParse, aExpr[k].p->pRight);
1.86         (drh      07-Jan-04):             aExpr[k].p = 0;
1.26         (drh      08-Nov-01):             break;
1.26         (drh      08-Nov-01):           }
1.78         (drh      02-May-03):           if( aExpr[k].idxRight==iCur
1.26         (drh      08-Nov-01):              && aExpr[k].p->op==TK_EQ
1.26         (drh      08-Nov-01):              && (aExpr[k].prereqLeft & loopMask)==aExpr[k].prereqLeft
1.26         (drh      08-Nov-01):              && aExpr[k].p->pRight->iColumn==pIdx->aiColumn[j]
1.26         (drh      08-Nov-01):           ){
1.90         (danielk1 08-May-04):             sqlite3ExprCode(pParse, aExpr[k].p->pLeft);
1.86         (drh      07-Jan-04):             aExpr[k].p = 0;
1.26         (drh      08-Nov-01):             break;
1.26         (drh      08-Nov-01):           }
1.26         (drh      08-Nov-01):         }
1.26         (drh      08-Nov-01):       }
1.26         (drh      08-Nov-01): 
1.51         (drh      14-Jun-02):       /* Duplicate the equality term values because they will all be
1.26         (drh      08-Nov-01):       ** used twice: once to make the termination key and once to make the
1.26         (drh      08-Nov-01):       ** start key.
1.26         (drh      08-Nov-01):       */
1.26         (drh      08-Nov-01):       for(j=0; j<nEqColumn; j++){
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_Dup, nEqColumn-1, 0);
1.26         (drh      08-Nov-01):       }
1.26         (drh      08-Nov-01): 
1.68         (drh      04-Dec-02):       /* Labels for the beginning and end of the loop
1.68         (drh      04-Dec-02):       */
1.90         (danielk1 08-May-04):       cont = pLevel->cont = sqlite3VdbeMakeLabel(v);
1.90         (danielk1 08-May-04):       brk = pLevel->brk = sqlite3VdbeMakeLabel(v);
1.68         (drh      04-Dec-02): 
1.26         (drh      08-Nov-01):       /* Generate the termination key.  This is the key value that
1.26         (drh      08-Nov-01):       ** will end the search.  There is no termination key if there
1.51         (drh      14-Jun-02):       ** are no equality terms and no "X<..." term.
1.68         (drh      04-Dec-02):       **
1.68         (drh      04-Dec-02):       ** 2002-Dec-04: On a reverse-order scan, the so-called "termination"
1.68         (drh      04-Dec-02):       ** key computed here really ends up being the start key.
1.26         (drh      08-Nov-01):       */
1.26         (drh      08-Nov-01):       if( (score & 1)!=0 ){
1.26         (drh      08-Nov-01):         for(k=0; k<nExpr; k++){
1.26         (drh      08-Nov-01):           Expr *pExpr = aExpr[k].p;
1.26         (drh      08-Nov-01):           if( pExpr==0 ) continue;
1.78         (drh      02-May-03):           if( aExpr[k].idxLeft==iCur
1.26         (drh      08-Nov-01):              && (pExpr->op==TK_LT || pExpr->op==TK_LE)
1.26         (drh      08-Nov-01):              && (aExpr[k].prereqRight & loopMask)==aExpr[k].prereqRight 
1.26         (drh      08-Nov-01):              && pExpr->pLeft->iColumn==pIdx->aiColumn[j]
1.26         (drh      08-Nov-01):           ){
1.90         (danielk1 08-May-04):             sqlite3ExprCode(pParse, pExpr->pRight);
1.26         (drh      08-Nov-01):             leFlag = pExpr->op==TK_LE;
1.86         (drh      07-Jan-04):             aExpr[k].p = 0;
1.26         (drh      08-Nov-01):             break;
1.26         (drh      08-Nov-01):           }
1.78         (drh      02-May-03):           if( aExpr[k].idxRight==iCur
1.26         (drh      08-Nov-01):              && (pExpr->op==TK_GT || pExpr->op==TK_GE)
1.26         (drh      08-Nov-01):              && (aExpr[k].prereqLeft & loopMask)==aExpr[k].prereqLeft
1.26         (drh      08-Nov-01):              && pExpr->pRight->iColumn==pIdx->aiColumn[j]
1.26         (drh      08-Nov-01):           ){
1.90         (danielk1 08-May-04):             sqlite3ExprCode(pParse, pExpr->pLeft);
1.26         (drh      08-Nov-01):             leFlag = pExpr->op==TK_GE;
1.86         (drh      07-Jan-04):             aExpr[k].p = 0;
1.26         (drh      08-Nov-01):             break;
1.26         (drh      08-Nov-01):           }
1.26         (drh      08-Nov-01):         }
1.26         (drh      08-Nov-01):         testOp = OP_IdxGE;
1.26         (drh      08-Nov-01):       }else{
1.26         (drh      08-Nov-01):         testOp = nEqColumn>0 ? OP_IdxGE : OP_Noop;
1.26         (drh      08-Nov-01):         leFlag = 1;
1.26         (drh      08-Nov-01):       }
1.26         (drh      08-Nov-01):       if( testOp!=OP_Noop ){
1.86         (drh      07-Jan-04):         int nCol = nEqColumn + (score & 1);
1.26         (drh      08-Nov-01):         pLevel->iMem = pParse->nMem++;
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_NotNull, -nCol, sqlite3VdbeCurrentAddr(v)+3);
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_Pop, nCol, 0);
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_Goto, 0, brk);
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_MakeKey, nCol, 0);
1.94         (danielk1 16-May-04):         sqlite3IndexAffinityStr(v, pIdx);
1.68         (drh      04-Dec-02):         if( pLevel->bRev ){
1.98         (drh      19-May-04):           int op = leFlag ? OP_MoveLe : OP_MoveLt;
1.98         (drh      19-May-04):           sqlite3VdbeAddOp(v, op, pLevel->iCur, brk);
1.68         (drh      04-Dec-02):         }else{
1.90         (danielk1 08-May-04):           sqlite3VdbeAddOp(v, OP_MemStore, pLevel->iMem, 1);
1.68         (drh      04-Dec-02):         }
1.68         (drh      04-Dec-02):       }else if( pLevel->bRev ){
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_Last, pLevel->iCur, brk);
1.26         (drh      08-Nov-01):       }
1.26         (drh      08-Nov-01): 
1.26         (drh      08-Nov-01):       /* Generate the start key.  This is the key that defines the lower
1.51         (drh      14-Jun-02):       ** bound on the search.  There is no start key if there are no
1.51         (drh      14-Jun-02):       ** equality terms and if there is no "X>..." term.  In
1.26         (drh      08-Nov-01):       ** that case, generate a "Rewind" instruction in place of the
1.26         (drh      08-Nov-01):       ** start key search.
1.68         (drh      04-Dec-02):       **
1.68         (drh      04-Dec-02):       ** 2002-Dec-04: In the case of a reverse-order search, the so-called
1.68         (drh      04-Dec-02):       ** "start" key really ends up being used as the termination key.
1.26         (drh      08-Nov-01):       */
1.26         (drh      08-Nov-01):       if( (score & 2)!=0 ){
1.26         (drh      08-Nov-01):         for(k=0; k<nExpr; k++){
1.26         (drh      08-Nov-01):           Expr *pExpr = aExpr[k].p;
1.26         (drh      08-Nov-01):           if( pExpr==0 ) continue;
1.78         (drh      02-May-03):           if( aExpr[k].idxLeft==iCur
1.26         (drh      08-Nov-01):              && (pExpr->op==TK_GT || pExpr->op==TK_GE)
1.26         (drh      08-Nov-01):              && (aExpr[k].prereqRight & loopMask)==aExpr[k].prereqRight 
1.26         (drh      08-Nov-01):              && pExpr->pLeft->iColumn==pIdx->aiColumn[j]
1.26         (drh      08-Nov-01):           ){
1.90         (danielk1 08-May-04):             sqlite3ExprCode(pParse, pExpr->pRight);
1.26         (drh      08-Nov-01):             geFlag = pExpr->op==TK_GE;
1.86         (drh      07-Jan-04):             aExpr[k].p = 0;
1.26         (drh      08-Nov-01):             break;
1.26         (drh      08-Nov-01):           }
1.78         (drh      02-May-03):           if( aExpr[k].idxRight==iCur
1.26         (drh      08-Nov-01):              && (pExpr->op==TK_LT || pExpr->op==TK_LE)
1.26         (drh      08-Nov-01):              && (aExpr[k].prereqLeft & loopMask)==aExpr[k].prereqLeft
1.26         (drh      08-Nov-01):              && pExpr->pRight->iColumn==pIdx->aiColumn[j]
1.26         (drh      08-Nov-01):           ){
1.90         (danielk1 08-May-04):             sqlite3ExprCode(pParse, pExpr->pLeft);
1.26         (drh      08-Nov-01):             geFlag = pExpr->op==TK_LE;
1.86         (drh      07-Jan-04):             aExpr[k].p = 0;
1.26         (drh      08-Nov-01):             break;
1.26         (drh      08-Nov-01):           }
1.26         (drh      08-Nov-01):         }
1.28         (drh      12-Nov-01):       }else{
1.28         (drh      12-Nov-01):         geFlag = 1;
1.26         (drh      08-Nov-01):       }
1.26         (drh      08-Nov-01):       if( nEqColumn>0 || (score&2)!=0 ){
1.86         (drh      07-Jan-04):         int nCol = nEqColumn + ((score&2)!=0);
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_NotNull, -nCol, sqlite3VdbeCurrentAddr(v)+3);
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_Pop, nCol, 0);
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_Goto, 0, brk);
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_MakeKey, nCol, 0);
1.94         (danielk1 16-May-04):         sqlite3IndexAffinityStr(v, pIdx);
1.68         (drh      04-Dec-02):         if( pLevel->bRev ){
1.68         (drh      04-Dec-02):           pLevel->iMem = pParse->nMem++;
1.90         (danielk1 08-May-04):           sqlite3VdbeAddOp(v, OP_MemStore, pLevel->iMem, 1);
1.68         (drh      04-Dec-02):           testOp = OP_IdxLT;
1.68         (drh      04-Dec-02):         }else{
1.98         (drh      19-May-04):           int op = geFlag ? OP_MoveGe : OP_MoveGt;
1.98         (drh      19-May-04):           sqlite3VdbeAddOp(v, op, pLevel->iCur, brk);
1.68         (drh      04-Dec-02):         }
1.68         (drh      04-Dec-02):       }else if( pLevel->bRev ){
1.68         (drh      04-Dec-02):         testOp = OP_Noop;
1.26         (drh      08-Nov-01):       }else{
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_Rewind, pLevel->iCur, brk);
1.26         (drh      08-Nov-01):       }
1.26         (drh      08-Nov-01): 
1.26         (drh      08-Nov-01):       /* Generate the the top of the loop.  If there is a termination
1.26         (drh      08-Nov-01):       ** key we have to test for that key and abort at the top of the
1.26         (drh      08-Nov-01):       ** loop.
1.26         (drh      08-Nov-01):       */
1.90         (danielk1 08-May-04):       start = sqlite3VdbeCurrentAddr(v);
1.26         (drh      08-Nov-01):       if( testOp!=OP_Noop ){
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_MemLoad, pLevel->iMem, 0);
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, testOp, pLevel->iCur, brk);
1.92         (danielk1 14-May-04):         if( (leFlag && !pLevel->bRev) || (!geFlag && pLevel->bRev) ){
1.92         (danielk1 14-May-04):           sqlite3VdbeChangeP3(v, -1, "+", P3_STATIC);
1.92         (danielk1 14-May-04):         }
1.26         (drh      08-Nov-01):       }
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_RowKey, pLevel->iCur, 0);
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_IdxIsNull, nEqColumn + (score & 1), cont);
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_IdxRecno, pLevel->iCur, 0);
1.46         (drh      24-May-02):       if( i==pTabList->nSrc-1 && pushKey ){
1.1          (drh      29-May-00):         haveKey = 1;
1.1          (drh      29-May-00):       }else{
1.98         (drh      19-May-04):         sqlite3VdbeAddOp(v, OP_MoveGe, iCur, 0);
1.1          (drh      29-May-00):         haveKey = 0;
1.1          (drh      29-May-00):       }
1.26         (drh      08-Nov-01): 
1.26         (drh      08-Nov-01):       /* Record the instruction used to terminate the loop.
1.26         (drh      08-Nov-01):       */
1.68         (drh      04-Dec-02):       pLevel->op = pLevel->bRev ? OP_Prev : OP_Next;
1.25         (drh      07-Nov-01):       pLevel->p1 = pLevel->iCur;
1.25         (drh      07-Nov-01):       pLevel->p2 = start;
1.1          (drh      29-May-00):     }
1.78         (drh      02-May-03):     loopMask |= getMask(&maskSet, iCur);
1.1          (drh      29-May-00): 
1.1          (drh      29-May-00):     /* Insert code to test every subexpression that can be completely
1.1          (drh      29-May-00):     ** computed using the current set of tables.
1.1          (drh      29-May-00):     */
1.1          (drh      29-May-00):     for(j=0; j<nExpr; j++){
1.1          (drh      29-May-00):       if( aExpr[j].p==0 ) continue;
1.40         (drh      02-Apr-02):       if( (aExpr[j].prereqAll & loopMask)!=aExpr[j].prereqAll ) continue;
1.66         (drh      27-Oct-02):       if( pLevel->iLeftJoin && !ExprHasProperty(aExpr[j].p,EP_FromJoin) ){
1.66         (drh      27-Oct-02):         continue;
1.66         (drh      27-Oct-02):       }
1.1          (drh      29-May-00):       if( haveKey ){
1.12         (drh      19-Feb-01):         haveKey = 0;
1.98         (drh      19-May-04):         sqlite3VdbeAddOp(v, OP_MoveGe, iCur, 0);
1.1          (drh      29-May-00):       }
1.90         (danielk1 08-May-04):       sqlite3ExprIfFalse(pParse, aExpr[j].p, cont, 1);
1.1          (drh      29-May-00):       aExpr[j].p = 0;
1.1          (drh      29-May-00):     }
1.1          (drh      29-May-00):     brk = cont;
1.47         (drh      24-May-02): 
1.47         (drh      24-May-02):     /* For a LEFT OUTER JOIN, generate code that will record the fact that
1.47         (drh      24-May-02):     ** at least one row of the right table has matched the left table.  
1.47         (drh      24-May-02):     */
1.47         (drh      24-May-02):     if( pLevel->iLeftJoin ){
1.90         (danielk1 08-May-04):       pLevel->top = sqlite3VdbeCurrentAddr(v);
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_Integer, 1, 0);
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_MemStore, pLevel->iLeftJoin, 1);
1.55         (drh      24-Jun-02):       for(j=0; j<nExpr; j++){
1.55         (drh      24-Jun-02):         if( aExpr[j].p==0 ) continue;
1.55         (drh      24-Jun-02):         if( (aExpr[j].prereqAll & loopMask)!=aExpr[j].prereqAll ) continue;
1.55         (drh      24-Jun-02):         if( haveKey ){
1.58         (drh      28-Jun-02):           /* Cannot happen.  "haveKey" can only be true if pushKey is true
1.58         (drh      28-Jun-02):           ** an pushKey can only be true for DELETE and UPDATE and there are
1.58         (drh      28-Jun-02):           ** no outer joins with DELETE and UPDATE.
1.58         (drh      28-Jun-02):           */
1.55         (drh      24-Jun-02):           haveKey = 0;
1.98         (drh      19-May-04):           sqlite3VdbeAddOp(v, OP_MoveGe, iCur, 0);
1.55         (drh      24-Jun-02):         }
1.90         (danielk1 08-May-04):         sqlite3ExprIfFalse(pParse, aExpr[j].p, cont, 1);
1.55         (drh      24-Jun-02):         aExpr[j].p = 0;
1.55         (drh      24-Jun-02):       }
1.47         (drh      24-May-02):     }
1.1          (drh      29-May-00):   }
1.1          (drh      29-May-00):   pWInfo->iContinue = cont;
1.1          (drh      29-May-00):   if( pushKey && !haveKey ){
1.90         (danielk1 08-May-04):     sqlite3VdbeAddOp(v, OP_Recno, pTabList->a[0].iCursor, 0);
1.1          (drh      29-May-00):   }
1.78         (drh      02-May-03):   freeMaskSet(&maskSet);
1.1          (drh      29-May-00):   return pWInfo;
1.1          (drh      29-May-00): }
1.1          (drh      29-May-00): 
1.1          (drh      29-May-00): /*
1.51         (drh      14-Jun-02): ** Generate the end of the WHERE loop.  See comments on 
1.90         (danielk1 08-May-04): ** sqlite3WhereBegin() for additional information.
1.1          (drh      29-May-00): */
1.90         (danielk1 08-May-04): void sqlite3WhereEnd(WhereInfo *pWInfo){
1.1          (drh      29-May-00):   Vdbe *v = pWInfo->pParse->pVdbe;
1.6          (drh      05-Jun-00):   int i;
1.25         (drh      07-Nov-01):   WhereLevel *pLevel;
1.46         (drh      24-May-02):   SrcList *pTabList = pWInfo->pTabList;
1.6          (drh      05-Jun-00): 
1.46         (drh      24-May-02):   for(i=pTabList->nSrc-1; i>=0; i--){
1.25         (drh      07-Nov-01):     pLevel = &pWInfo->a[i];
1.90         (danielk1 08-May-04):     sqlite3VdbeResolveLabel(v, pLevel->cont);
1.25         (drh      07-Nov-01):     if( pLevel->op!=OP_Noop ){
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, pLevel->op, pLevel->p1, pLevel->p2);
1.25         (drh      07-Nov-01):     }
1.90         (danielk1 08-May-04):     sqlite3VdbeResolveLabel(v, pLevel->brk);
1.49         (drh      08-Jun-02):     if( pLevel->inOp!=OP_Noop ){
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, pLevel->inOp, pLevel->inP1, pLevel->inP2);
1.49         (drh      08-Jun-02):     }
1.47         (drh      24-May-02):     if( pLevel->iLeftJoin ){
1.47         (drh      24-May-02):       int addr;
1.90         (danielk1 08-May-04):       addr = sqlite3VdbeAddOp(v, OP_MemLoad, pLevel->iLeftJoin, 0);
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_NotNull, 1, addr+4 + (pLevel->iCur>=0));
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_NullRow, pTabList->a[i].iCursor, 0);
1.60         (drh      13-Aug-02):       if( pLevel->iCur>=0 ){
1.90         (danielk1 08-May-04):         sqlite3VdbeAddOp(v, OP_NullRow, pLevel->iCur, 0);
1.60         (drh      13-Aug-02):       }
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_Goto, 0, pLevel->top);
1.47         (drh      24-May-02):     }
1.25         (drh      07-Nov-01):   }
1.90         (danielk1 08-May-04):   sqlite3VdbeResolveLabel(v, pWInfo->iBreak);
1.46         (drh      24-May-02):   for(i=0; i<pTabList->nSrc; i++){
1.77         (drh      24-Apr-03):     Table *pTab = pTabList->a[i].pTab;
1.77         (drh      24-Apr-03):     assert( pTab!=0 );
1.77         (drh      24-Apr-03):     if( pTab->isTransient || pTab->pSelect ) continue;
1.25         (drh      07-Nov-01):     pLevel = &pWInfo->a[i];
1.90         (danielk1 08-May-04):     sqlite3VdbeAddOp(v, OP_Close, pTabList->a[i].iCursor, 0);
1.25         (drh      07-Nov-01):     if( pLevel->pIdx!=0 ){
1.90         (danielk1 08-May-04):       sqlite3VdbeAddOp(v, OP_Close, pLevel->iCur, 0);
1.6          (drh      05-Jun-00):     }
1.6          (drh      05-Jun-00):   }
1.64         (drh      28-Aug-02): #if 0  /* Never reuse a cursor */
1.38         (drh      02-Mar-02):   if( pWInfo->pParse->nTab==pWInfo->peakNTab ){
1.38         (drh      02-Mar-02):     pWInfo->pParse->nTab = pWInfo->savedNTab;
1.38         (drh      02-Mar-02):   }
1.64         (drh      28-Aug-02): #endif
1.1          (drh      29-May-00):   sqliteFree(pWInfo);
1.1          (drh      29-May-00):   return;
1.1          (drh      29-May-00): }
