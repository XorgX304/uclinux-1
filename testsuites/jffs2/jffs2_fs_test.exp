#!/usr/bin/expect
log_file jffs2_fs_test_log
send_user "Starting jffs2_fs_test.exp\n"

set TITLE "JFFS2_FS Test"

set user /home/test
set uclinux_path $user/checkouts/kernel/uClinux-dist
set dxe_filename linux
set ttydev /dev/ttyS0
set send_slow {1 0.1}
set password "blackfin"

proc step { message } {

  global step_sequence_number

  puts "\n*******************************************************************"
  puts "STEP $step_sequence_number: $message\n\n"
  send_log "\n************** STEP $step_sequence_number: $message\n\n"
  incr step_sequence_number
}

set step_sequence_number    1

step "Start kermit"


#step "Start up kermit on port $ttydev"
# Now set up the kermit parameters.
#  I want these all contained in this file to make it easier for users.
#  This just builds up a list of commands which are sent to kermit.
#
set kparams     [list "set line $ttydev\r"]
lappend kparams "set speed 57600\r"
lappend kparams "set carrier-watch off\r"
lappend kparams "set handshake none\r"
lappend kparams "set flow-control none\r"
lappend kparams "robust\r"
lappend kparams "set file type bin\r"
lappend kparams "set file name lit\r"
lappend kparams "set rec pack 1000\r"
lappend kparams "set send pack 1000\r"
lappend kparams "set window 5\r"
lappend kparams "set escape 255\r"
set nkparams [llength $kparams]

set timeout 5
spawn kermit
# We need to save the id because resetting the board will overwrite it.
set kermit_spawn_id $spawn_id

while 1 {
	expect {
	        "Type ?" { }
		"ermit>" { break }
		"not found" {
                   report "ERROR: Failed to start up kermit"
                   all_done
		}
		timeout {
                   report "ERROR: Time out starting up kermit"
                   all_done
		}
	}
}

for {set i 0} {$i < $nkparams} {incr i} {
   send [lindex $kparams $i]

   while 1 {
      expect {
         "ermit>" { break }

         "\\?\[A-Z]" {
            puts "ERROR: Failed to set up kermit parameters"
         }

         timeout {
            puts "ERROR: Time out setting up kermit parameters"
         }
      }
   }
}

send "connect\r"
while 1 {
   expect {
      "ype the escape character*" {
         break
      }

      timeout {
         puts "\nERROR: Can't connect to serial port\n"
         exit
      }
   }
}

step "Restart the board."

send_user "Try to figure out if we are in u-boot or the kernel"
set where_are_we 0
send "version\r"
set timeout 20
expect {

    "U-Boot" {
	send_user "We are in u-boot\n"
	set where_are_we "uboot"
    }

    "Linux" {
	send_user "We are in the kernel\n"
	set where_are_we "kernel"
    }

    timeout {
	send_user "Can't tell if we are in u-boot or the kernel\n"
    }
}

if { $where_are_we == "uboot" } {
    set timeout 50
    expect ">"
    send_user "sending reset\n"
    send "reset\r"
} else {
    if { $where_are_we == "kernel" } {
	set timeout 60
	expect ">"
	send_user "sending reboot\n"
	send "reboot\r"
    } else {
	# If we don't know where we are, hit control-C and enter
	set timeout 10
	expect "*"
	expect "*"
	send_user "sending control-C\n"
	send "\3"
	sleep 1
	send "\r"
    }
}

 while 1 {
       expect {
         "Hit any key " {
	     send "\r"
         }

	 ">" {
	     send_user "successful reset attempt\n"
	     break
	 }

         timeout {
	     send_user "failed reset attempt\n"
             break
         }
      }
   }
	

send -s "set bootargs root=/dev/mtdblock2 rw rootfstype=jffs2\r"
expect   ">" 
send "save\r"
expect   ">" 

	send -s "tftp 0x1000000 jffs2.img\r"
        while 1 {
	expect {
	    
	    "done" {
		set tftp_flag SUCCESS
#		break
	    }
	    
            -re "Bytes transferred = \[0-9]+ \\\((\[0-9a-fA-F]+) hex\\\)" {
                set uimage_size $expect_out(1,string)
                send_user "uImage size is $uimage_size\n"
                break
            }

	    timeout {
		send_user "ERROR: Uboot locked up during tftp\n"		
		break
	    }
	}
    }
    
  
       set timeout 80
       send -s "protect off 0x20100000 0x203fffff\r"
       while 1 {
    		expect {
    
    	    	    "Un-Protected" {
				
				send_user "  unprotect success\n"
			}
	
		    ">" {
				break
			}
	
		    timeout {
	    			send_user "ERROR:  unprotect failed\n"
	    			
	    			break
			}
    		}
	}
	
      
       set timeout 240	
        	
       send -s "erase 0x20100000 0x203fffff\r"
	while 1 {
	    expect {
	    
	    	"Erased" {
	    		send_user " erase success\n"
			break
		}
				
		timeout {
		    send_user "ERROR:  erase failed\n"
		    
		    break
		}
	    }
	}
	
        set timeout 500
 	
	send -s "cp.b 0x1000000 0x20100000 0x$uimage_size\r"
	while 1 {
	    expect {
	    
	    	"done" {
	    		send_user " cp success\n"
			break
		}
		

		
		timeout {
		    send_user "ERROR:  cp failed\n"
		    
		    break
		}
	    }
	}

      expect ">"
      send -s "tftp 0x1000000 linux\r"
      while 1 {
	expect {
	    
	    "done" {
		set tftp_flag SUCCESS
		break
	    }
	    
	    	    
	    timeout {
		send_user "ERROR: Uboot locked up during tftp\n"
		
		break
	    }
	}
    }
    
   
   set timeout 180
   send -s "boote\r"
   while 1 {
      expect {

         -re "Kernel panic" {
            report "kernel panic detected... trying to recover from it"
         #   recover
            break
         }

         -re "Sash command shell.*/> " {
            puts "successful boot attempt"
          #  incr successful_boots
            break
         }
	 
	  "root:~> " {
            puts "successful boot attempt"
          #  incr successful_boots
            break
         }

         -re "Linux version (.*) " {
            set linux_version $expect_out(1,string)
         }

         # Look for gcc version N.N[.N[.N]]
         -re "gcc version (\[0-9](\.\[0-9]+)+)" {
            set gcc_version [lindex $expect_out(0,string) 2]
         }

         # Look for text followed by 1 or more spaces or tabs
         # followed by = followed by 1 or more spaces or tabs
         # followed by (0xNNNNNN-0xNNNNNN)
         -re "text\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
            set map_text $expect_out(1,string)
         }

         -re "data\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
            set map_data $expect_out(1,string)
         }

         -re "bss\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
            set map_bss $expect_out(1,string)
         }
         -re "rootfs\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
            set map_rootfs $expect_out(1,string)
         }

         # Note that here we're looking for zero or 1 space. Doh!
         -re "stack\[\x20\t]?=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
            set map_stack $expect_out(1,string)
         }

         -re "\[Ii]nstruction \[Cc]ache \[Ee]nabled" {
           # set instruction_cache_boot_flag $CACHE_ENABLED
         }

         -re "\[Ii]nstruction \[Cc]ache \[Dd]isabled" {
           # set instruction_cache_boot_flag $CACHE_DISABLED
         }

         -re "\[Dd]ata \[Cc]ache \[Ee]nabled" {
           # set data_cache_boot_flag $CACHE_ENABLED
         }

         -re "\[Dd]ata \[Cc]ache \[Dd]isabled" {
            #set data_cache_boot_flag $CACHE_DISABLED
         }

         timeout {
            puts "failed boot attempt"
	 
            break
         }
      }
   }

sleep 5
send "\r"
expect "root:~>"
set timeout 600

step "Starting test."

set case_num 0

incr case_num

set timeout 8
set flag 0
send "ifconfig eth0 10.100.4.50\r"
while 1 {
   sleep 3
   expect {
      ">" {
         set flag 1
         puts "ifconfig set success.\n"
         break
      }

      timeout {
            puts "Fail ifconfig. "
            break
         }
     }
}

send "cd /bin\r"
while 1 {
   expect {
      "bin" {
         set flag 1
         break
      }

      timeout {

            break
         }
     }
}

set timeout 500
expect "root:/bin>"

send -s  "./fs_test.sh\r" 
while 1 {
   expect {
      "Execution completed" {
         send_log "\nCase $case_num ...PASS\n"        
         break
      }

      timeout {
        send_log "\nCase $case_num ...FAIL\n"
	send_log "$TITLE ............\[FAIL\]\n"
	exit
        }
     }
}

incr case_num

send -s "ls -l TestFailed.log\r"
set timeout 10
while 1 {
   expect {
      -re "rw.* .* .* .* (\[0-9]+) .*TestFailed\.log" {
         set FileSize $expect_out(1,string)
         expect ">"
         puts " FileSize $expect_out(1,string)"	 
         break
      }

      timeout {
        break       
         }
     }
}

 if { $FileSize == 0 } {

                send_log "\nCase $case_num ...PASS\n"

 } else {
                send_log "\nCase $case_num ...FAIL\n"
                send_log "$TITLE ............\[FAIL\]\n"
                exit
 }

spawn ftp 10.100.4.50
while 1 {
    expect {
                "Name" { }
                timeout { send_user "Failed first return\n"
                        break }
        }
        send -s "root\r"
        expect {
                "Password:" { }
                timeout { send_user "Failed first return\n"
                        break }
        }
        send -s "uClinux\r"
        expect {
                "ftp>" { }
                timeout { send_user "Failed first return\n"
                        break }
        }

	send -s "cd bin\r"
        expect {
                "ftp>" { }
                timeout { send_user "Failed first return\n"
                        break }
        }
	
        send -s "get TestOverall.log\r"
        expect {
                "ftp>" { }
                timeout { send_user "Failed first return\n"
                        break }
        }

        send -s "get TestResults.log\r"
        expect {
                "ftp>" { }
                timeout { send_user "Failed first return\n"
                        break }
        }

         send -s "bye\r"
         expect {
                "Goodbye" { break }
                timeout { send_user "Failed first return\n"
                        break }
         }

   }

send_log "\n"
send_log "\n$TITLE ............\[PASS\]\n"

log_file

send_user "Ending jffs2_fs_test.exp\n"


