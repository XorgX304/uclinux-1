#!/usr/bin/expect
#
# Copyright (C) 2004 Bruce Giese
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
#
# Revision history
#
#  This program performs substantial u-boot functional testing.
#

log_file yaffs_test_log
send_user "Starting yaffs_test.exp\n"

set TITLE "Yaffs Test"
set TEST_PASS               "pass"
set TEST_FAIL               "fail"
# The term "INFO" here means the test was not run or could not be run.
# Note that the TEST_INFO value must match the tables below. Sorry.
set TEST_INFO               "notrun"

set send_slow               {1 .1}

proc step { message } {

  global step_sequence_number

  puts "\n*******************************************************************"
  puts "STEP $step_sequence_number: $message\n\n"
  send_log "\n************** STEP $step_sequence_number: $message\n\n"
  incr step_sequence_number
}

set step_sequence_number    1

#
#  This matrix contains all the tests which are run.  Note that
#  The second column must match the value of TEST_INFO above.  Also,
#  The indexes below must align with the location of the test.
#  Don't thank me for that; nothing in curly brackets gets
#  evaluated in expect so there appears to be no other way.
#
set mtd_loc	0

set result_matrix { {mtd                                notrun}}

set argc [llength $argv]
if { $argc < 1} {
    puts "Please input ttydev port."
    exit
}


# grab the user selections.
set ttydev         [lindex $argv 0]

for {set i 1} {$i<$argc} {incr i} {

    switch -glob -- [lindex $argv $i] {
	
	"--lo*" {
	    incr i
	    if {$i>=$argc} { exit }
	    set logfile [lindex $argv $i]
	}
	
	"--su*" {
	    incr i
	    if {$i>=$argc} { exit }
	    set summary_logfile [lindex $argv $i]
	}

	"--comp*" {
	    incr i
	    if {$i>=$argc} { exit }
	    set compare_file [lindex $argv $i]
	}

    }
}

step "Start kermit"

# Now set up the kermit parameters.
#  I want these all contained in this file to make it easier for users.
#  This just builds up a list of commands which are sent to kermit.
#
set kparams     [list "set line $ttydev\r"]
lappend kparams "set speed 57600\r"
lappend kparams "set carrier-watch off\r"
lappend kparams "set handshake none\r"
lappend kparams "set flow-control none\r"
lappend kparams "robust\r"
lappend kparams "set file type bin\r"
lappend kparams "set file name lit\r"
lappend kparams "set rec pack 1000\r"
lappend kparams "set send pack 1000\r"
lappend kparams "set window 5\r"
lappend kparams "set escape 255\r"
set nkparams [llength $kparams]

set timeout 5
spawn kermit
# We need to save the id because resetting the board will overwrite it.
set kermit_spawn_id $spawn_id

while 1 {
	expect {
	        "Type ?" { }
		"ermit>" { break }
		"not found" {
                   send_error "ERROR: Failed to start up kermit\n"
                   all_done
		}
		timeout {
                   send_error "ERROR: Time out starting up kermit\n"
                   all_done
		}
	}
}

for {set i 0} {$i < $nkparams} {incr i} {
    send [lindex $kparams $i]

    while 1 {
	  expect {
		 "ermit>" { break }

		 "\\?\[A-Z]" {
                   send_error "ERROR: Failed to set up kermit parameters\n"
                    all_done
		 }

		 timeout {
                    send_error "ERROR: Time out setting up kermit parameters\n"
                    all_done
		 }
	  }
    }
}

send "connect\r"
while 1 {
	expect {
		"ype the escape character*" {
		     break  }
		timeout {
		     send_error "ERROR: Can't connect to serial port\n"
		     exit }
	}
}

##############################################################################################
##############################################################################################


send_user "Try to figure out if we are in u-boot or the kernel"
set where_are_we 0
send "version\r"
set timeout 20
expect {

    "U-Boot" {
	send_user "We are in u-boot\n"
	set where_are_we "uboot"
    }

    "Linux" {
	send_user "We are in the kernel\n"
	set where_are_we "kernel"
    }

    timeout {
	send_user "Can't tell if we are in u-boot or the kernel\n"
    }
}

if { $where_are_we == "uboot" } {
    set timeout 50
    expect ">"
    send_user "sending reset\n"
    send "reset\r"
} else {
    if { $where_are_we == "kernel" } {
	set timeout 60
	expect "root:~>"
	send_user "sending reboot\n"
	send "reboot\r"
    } else {
	# If we don't know where we are, hit control-C and enter
	set timeout 10
	expect "*"
	expect "*"
	send_user "sending control-C\n"
	send "\3"
	sleep 1
	send "\r"
    }
}

 while 1 {
       expect {
         "Hit any key " {
	     send "\r"
             break
         }


         timeout {
	     send_user "failed reset attempt\n"
             break
         }
      }
   }
	

expect ">"
send -s "set bootargs root=/dev/mtdblock3 rw \r"
expect ">" 
send -s "save\r"
expect ">"

send -s "tftpboot 0x1000000 linux\r" 
while 1 {
   expect {
      "#" {         
         break
      }

      timeout {
            send_log "Fail tftp. "          
            break
         }
     }
} 
expect ">"
send -s "boote\r" 

 set timeout 180
   while 1 {
      expect {

         -re "Kernel panic" {
            report "kernel panic detected... trying to recover from it"
         #   recover
            break
         }

         -re "Sash command shell.*/> " {
            send_log "successful boot attempt"
          #  incr successful_boots
            break
         }
	 
	  "root:~> " {
            send_log "successful boot attempt"
          #  incr successful_boots
            break
         }

         -re "Linux version (.*) " {
            set linux_version $expect_out(1,string)
         }

         # Look for gcc version N.N[.N[.N]]
         -re "gcc version (\[0-9](\.\[0-9]+)+)" {
            set gcc_version [lindex $expect_out(0,string) 2]
         }

         # Look for text followed by 1 or more spaces or tabs
         # followed by = followed by 1 or more spaces or tabs
         # followed by (0xNNNNNN-0xNNNNNN)
         -re "text\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
            set map_text $expect_out(1,string)
         }

         -re "data\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
            set map_data $expect_out(1,string)
         }

         -re "bss\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
            set map_bss $expect_out(1,string)
         }
         -re "rootfs\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
            set map_rootfs $expect_out(1,string)
         }

         # Note that here we're looking for zero or 1 space. Doh!
         -re "stack\[\x20\t]?=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
            set map_stack $expect_out(1,string)
         }

         -re "\[Ii]nstruction \[Cc]ache \[Ee]nabled" {
           # set instruction_cache_boot_flag $CACHE_ENABLED
         }

         -re "\[Ii]nstruction \[Cc]ache \[Dd]isabled" {
           # set instruction_cache_boot_flag $CACHE_DISABLED
         }

         -re "\[Dd]ata \[Cc]ache \[Ee]nabled" {
           # set data_cache_boot_flag $CACHE_ENABLED
         }

         -re "\[Dd]ata \[Cc]ache \[Dd]isabled" {
            #set data_cache_boot_flag $CACHE_DISABLED
         }

         timeout {
            send_log "failed boot attempt"
	  #  recover
            break
         }
      }
   }

sleep 5
send "\r"
expect "root:~>"

set case_num 0

step "Mount modules"

incr case_num
set timeout 5

send -s "modprobe yaffs\r"
while 1 {
    expect {
        -re "yaffs.*Installing" {
                send_log "\nCase $case_num ...PASS\n"
                break;
        }

        timeout {
            	send_log "\nCase $case_num ...FAIL\n"
		send_log "$TITLE ............\[FAIL\]\n"
		exit
        }
    }
}
expect ">"

incr case_num
set timeout 5

send -s "modprobe mtdchar\r"
while 1 {
    expect {
        -re ">" {
                send_log "\nCase $case_num ...PASS\n"
                break;
        }

        timeout {
            	send_log "\nCase $case_num ...FAIL\n"
		send_log "$TITLE ............\[FAIL\]\n"
		exit
        }
    }
}

incr case_num
set timeout 5

send -s "modprobe bfin_nand\r"
while 1 {
    expect {
        -re "NAND device.*Creating .* MTD partitions" {
		expect ">"
                send_log "\nCase $case_num ...PASS\n"	
                break;
        }

        timeout {
            	send_log "\nCase $case_num ...FAIL\n"
		send_log "$TITLE ............\[FAIL\]\n"
		exit
        }
    }
}

step "Show file systems."
incr case_num

send -s "cat /proc/filesystems \r"
while 1 {
    expect {

        -re "yaffs" {
                send_log "\nCase $case_num ...PASS\n"
		expect ">"
                break;
        }

        timeout {
            	send_log "\nCase $case_num ...FAIL\n"
		send_log "$TITLE ............\[FAIL\]\n"
		exit
        }
    }
}

incr case_num

step "MTD test"

set timeout 5
set mtd_temp_result $TEST_FAIL
set mtd_result $TEST_FAIL
#send -s "\r"
send -s "cat /proc/mtd \r"
while 1 {
    expect {

	"mtd2" {
		set mtd_temp_result $TEST_PASS
		send_log "\nCase $case_num ...PASS\n"
	}

	 "root:~>" {
                break
        }


	timeout {
	    	send_log "\nCase $case_num ...FAIL\n"
		send_log "$TITLE ............\[FAIL\]\n"
		exit
	}
    }
}

sleep 1

incr case_num

step "Erase MTD "
set mtd_temp_result $TEST_FAIL
set timeout 180
send -s "flash_eraseall /dev/mtd2\r"
while 1 {
    expect {
	
	"root:~>" {
		set mtd_temp_result $TEST_PASS
		send_log "\nCase $case_num ...PASS\n"
		break
	}

	timeout {
	   	send_log "\nCase $case_num ...FAIL\n"
		send_log "$TITLE ............\[FAIL\]\n"
		exit
	}
    }
}

step "Touch file"

send_log " \n1)create file system directory\n"
send -s "mkdir -p rootfs\r"
expect ">"
send_log " \n2)create test file\n"
send -s "echo This is test for mtd driver > rootfs/test\r"
expect "root:~>"

incr case_num

step "Reading MTD "	
set mtd_temp_result $TEST_FAIL
set timeout 60
send -s "mount -t yaffs2 /dev/mtdblock2 /mnt\n"
while 1 {
    expect {
                                                                                                                                                             
        "root:~>" {
                set mtd_temp_result $TEST_PASS
		send_log "\nCase $case_num ...PASS\n"
		break
        }
                                                                                                                                                             
        timeout {
                send_log "\nCase $case_num ...FAIL\n"
		send_log "$TITLE ............\[FAIL\]\n"
		exit
        }
    }
}
   
step "cp pwd to YAFFS."
set yaffs_temp_result $TEST_FAIL
incr case_num

set timeout 60
send -s "cp /bin/pwd /mnt\r"
while 1 {
    expect {
        "root:~>" {
                send_log "\nCase $case_num ...PASS\n"
                break
        }

        timeout {
                send_log "\nCase $case_num ...FAIL\n"
		send_log "$TITLE ............\[FAIL\]\n"
		exit
        }
    }
}

sleep 1

step "YAFFS Validating data integrity"
set yaffs_temp_result $TEST_FAIL
incr case_num

set timeout 60
send "while \[ 1 \]; md5sum /mnt/pwd ; done\r"
while 1 {
   expect {
      -re "\[0-9a-z]+  /mnt/pwd" {
                sleep 3
                send "\3"
                send_log "\nCase $case_num ...PASS\n"
                break
      }

      timeout {
                send_log "\nCase $case_num ...FAIL\n"
		send_log "$TITLE ............\[FAIL\]\n"
		exit
         }
     }
}

puts "Writing YAFFS......\n"

incr case_num
set timeout 60
send -s "cp /rootfs/test /mnt\r"
while 1 {
    expect {

        ">" {
                send_log "\nCase $case_num ...PASS\n"
                break
        }

        timeout {
                send_log "\nCase $case_num ...FAIL\n"
		send_log "$TITLE ............\[FAIL\]\n"
		exit
        }
    }
}

incr case_num

step "Verify "
set timeout 2
send -s "cmp /rootfs/test /mnt/test\r"
while 1 {
    expect {
	
	"differ" {
		send_log "\nCase $case_num ...FAIL\n"
		send_log "$TITLE ............\[FAIL\]\n"
		exit
	}
	timeout {
		set mtd_results $TEST_PASS
		send_log "\nCase $case_num ...PASS\n"
		break
	}
    }
}

send_log "\n"
send_log "\n$TITLE ............\[PASS\]\n"

exit
log_file
 
send_user "\nEnding yaffs_test.exp\n"
