#!/usr/bin/expect

# Main entrance
#set logfile		"~/spimmc_testlog"
log_file spimmc_test_log
send_log "\nSPI MMC test is starting...\r"
send_user "Starting spimmc_test.exp\n"

set user /home/test
set uclinux_path $user/checkouts/kernel/uClinux-dist
set ttydev /dev/ttyS0
set send_slow {1 0.1}

set TITLE "SPI MMC/SD"

proc step { message } {
  global step_sequence_number

  puts "\n*******************************************************************"
  puts "STEP $step_sequence_number: $message\n\n"
  send_log "\n************** STEP $step_sequence_number: $message\n\n"
  incr step_sequence_number
}

set step_sequence_number    1

step "Start kermit"
#set argc [llength $argv]
#if { $argc < 1 } {
#	send_user "\nAppend /dev/ttyS0\n"
#}
#set ttydev	[lindex $argv 0]

set kparams	[list "set line $ttydev\r"]
lappend kparams "set speed 57600\r"
lappend kparams "set carrier-watch off\r"
lappend kparams "set handshake none\r"
lappend kparams "set flow-control none\r"
lappend kparams "robust\r"
lappend kparams "set file type bin\r"
lappend kparams "set file name lit\r"
lappend kparams "set rec pack 1000\r"
lappend kparams "set send pack 1000\r"
lappend kparams "set window 5\r"
lappend kparams "set escape 255\r"
set nkparams	[llength $kparams]

set timeout 5
spawn kermit
set kermit_spawn_id $spawn_id

while { 1 } {
   expect {
      "Type ?" { }
      "ermit>" {
         break
      }
      "not found" {
         send_log "\nERROR: Failed to start Kermit\n"
      }
      timeout {
         send_log "\nERROR: Time out starting up kermit\n"
      }
   }
}

for {set i 0} {$i < $nkparams} {incr i} {
   send [lindex $kparams $i]

   while 1 {
      expect {
         "ermit>" { break }
         "\\?\[A-Z]" {
            send_log "\nERROR: Failed to set up kermit parameters\n"
         }
         timeout {
            send_log "\nERROR: Time out setting up kermit parameters\n"
         }
      }
   }
}

send "connect\r"
while 1 {
   expect {
      "ype the escape character*" {
         break
      }
      timeout {
         send_log "\nERROR: Can't connect to serial port\n"
         exit
      }
   }
}

step "Restart the board."

send_user "Try to figure out if we are in u-boot or the kernel"
set where_are_we 0
send "version\r"
set timeout 20
expect {

   "U-Boot" {
      send_user "We are in u-boot\n"
      set where_are_we "uboot"
   }

   "Linux" {
      send_user "We are in the kernel\n"
      set where_are_we "kernel"
   }

   timeout {
      send_user "Can't tell if we are in u-boot or the kernel\n"
   }
}

if { $where_are_we == "uboot" } {
   set timeout 50
   expect ">"
   send_user "sending reset\n"
   send "reset\r"
} else {
   if { $where_are_we == "kernel" } {
      set timeout 60
      expect ">"
      send_user "sending reboot\n"
      send "reboot\r"
   } else {
      set timeout 10
      expect "*"
      expect "*"
      send_user "sending control-C\n"
      send "\3"
      sleep 1
      send "\r"
   }
}

while 1 {
   expect {

      "Hit any key " {
         send "\r"
      }

      ">" {
         send_user "successful reset attemp\n"
         break
      }

      timeout {
         send_user "failed reset attemp\n"
         break
      }
   }
}

send -s "set bootargs root=/dev/mtdblock0 rw\r"
expect ">"
send -s "save\r"
expect ">"

send -s "tftpboot 0x1000000 linux\r"
while 1 {
   expect {
      "#" {
         expect ">"
            break
      }
      timeout {
         puts "Fail tftp"
         break
      }
   }
}

send -s "boote\r"

set timeout 180
while 1 {
   expect {

      -re "Kernel panic" {
         report "kernel panic detected... trying to recover from it"
         break
      }

      -re "Sash command shell.*/> " {
         puts "successful boot attempt"
         break
      }

      "root:~> " {
         puts "successful boot attempt"
         break
      }

      -re "Linux version (.*) " {
         set linux_version $expect_out(1,string)
      }

      # Look for gcc version N.N[.N[.N]]
      -re "gcc version (\[0-9](\.\[0-9]+)+)" {
         set gcc_version [lindex $expect_out(0,string) 2]
      }

      # Look for text followed by 1 or more spaces or tabs
      # followed by = followed by 1 or more spaces or tabs
      # followed by (0xNNNNNN-0xNNNNNN)
      -re "text\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
         set map_text $expect_out(1,string)
      }

      -re "data\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
         set map_data $expect_out(1,string)
      }

      -re "bss\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
         set map_bss $expect_out(1,string)
      }

      -re "rootfs\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
         set map_rootfs $expect_out(1,string)
      }

      # Note that here we're looking for zero or 1 space. Doh!
      -re "stack\[\x20\t]?=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
         set map_stack $expect_out(1,string)
      }

      -re "\[Ii]nstruction \[Cc]ache \[Ee]nabled" {
         # set instruction_cache_boot_flag $CACHE_ENABLED
      }

      -re "\[Ii]nstruction \[Cc]ache \[Dd]isabled" {
         # set instruction_cache_boot_flag $CACHE_DISABLED
      }

      -re "\[Dd]ata \[Cc]ache \[Ee]nabled" {
         # set data_cache_boot_flag $CACHE_ENABLED
      }

      -re "\[Dd]ata \[Cc]ache \[Dd]isabled" {
         #set data_cache_boot_flag $CACHE_DISABLED
      }

      timeout {
         puts "failed boot attempt"
         break
      }
   }
}

sleep 5

step "Start SPI MMC/SD testing"

set test_flag 0

step "Create mount directories for testing"
send "mkdir /mnt/mmc\r"
send "mkdir /mnt/mmc1\r"
send "mkdir /mnt/mmc2\r"

set timeout 2
step "Check dmesg result"
send "dmesg | grep MMC\r"
while 1 {
   expect {
      -re ".*MMC\\\/SD card found.*" {
         send_log "\nMMC/SD card found\n"
         send_user "\nMMC/SD card found\n"
         break
      }
      timeout {
         send_log "\nNot found MMC/SD card in dmesg\n"
         send_user "\nNot found MMC/SD card in dmesg\n"
         incr test_flag
         break
      }
   }
}

step "Create dos fs"
set timeout 2
send "mkdosfs /dev/mmc\r"
while 1 {
   expect {
      -re "No such device" {
         send_log "\nNo /dev/mmc device\n"
         send_user "\nNo /dev/mmc device\n"
         break
      }
      -re "root:~>" {
         send_log "\nmkdosfs done\n"
         send_user "\nmkdosfs done\n"
         break
      }
      timeout {
         break
      }
   }
}

step "Mount dos fs on /mnt/mmc1"
set timeout 2
send "mount -t msdos /dev/mmc /mnt/mmc1\r"
while 1 {
   expect {
      -re ".*failed.*" {
         send_log "\nmount dos fs failed\n"
         send_user "\nmount dos fs failed\n"
         break
      }
      -re "root:~>" {
         send_log "\nmount dos fs done\n"
         send_user "\nmount dos fs done\n"
         break
      }
      timeout {
         break
      }
   }
}

step "Umount dos fs from /mnt/mmc1"
set timeout 2
send "umount /mnt/mmc1\r"
while 1 {
   expect {
      -re "root:~>" {
         send_log "\numount dos fs done\n"
         send_user "\numount dos fs done\n"
         break
      }
      -re ".*busy" {
         send_log "\numount dos fs failed\n"
         send_user "\numount dos fs failed\n"
         break
      }
      timeout {
         break
      }
   }
} 

step "remove old partion"

set timeout 10
send "fdisk /dev/mmc\r"
expect -re "Command.*:"
send "p\r"
set timeout 10
while 1 {
   expect {
            -re "/dev/mmc1" {
               send "d\r"
               expect -re "Partition number.*"
               send "1\r"
               expect -re "Command.*"
               send "w\r"
               break
            }
            eof {
               send "q\r"
               break
            }
            timeout {
               send "q\r"
               break
            }
   }
}

set timeout 10
send "fdisk /dev/mmc\r"
expect -re "Command.*:"
send "p\r"
set timeout 10
while 1 {
   expect {
            -re "/dev/mmc2" {
               send "d\r"
               expect -re "Partition number.*"
               send "2\r"
               expect -re "Command.*"
               send "w\r"
               expect -re "root:~>"
               break
            }
            eof {
               send "q\r"
               break
            }
            timeout {
               send "q\r"
               break
            }
   }
}


set timeout 10
send "fdisk /dev/mmc\r"
expect -re "Command.*:"
send "n\r"
expect -re "primary partition.*"
send "p\r"
expect -re "Partition number.*"
send "1\r"
expect -re "First cylinder.*"
send "\r"
expect -re "Last cylinder.*"
send "15000\r"
expect -re "Command.*"
send "n\r"
expect -re "primary partition.*"
send "p\r"
expect -re "Partition number.*"
send "2\r"
expect -re "First cylinder.*"
send "\r"
expect -re "Last cylinder.*"
send "\r"
expect -re "Command.*"
send "w\r"
expect -re "root:~>"

send_log "\ncreat 2 partitions done\n"
send_user "\ncreat 2 partitions done\n"

step "Start to try use mmc flash as rootfs"

set timeout 90 
send "mke2fs /dev/mmc1\r"
expect -re "root:~>"
set timeout 2
send "mkdir /mnt/rootfs\r"
send "mount -o sync /dev/mmc1 /mnt/rootfs\r"
expect -re "root:~>"
send "ifconfig eth0 192.168.1.2 up\r"
expect -re "root:~>"
sleep 5
exec rcp runcp.sh 192.168.1.2:/.
set timeout 120
send "./runcp.sh\r"
while 1 {
   expect {
      -re "copy rootfs done" {
         send_user "\nfinish to copy rootfs to mmc card\n"
         break
      }
      eof {
         break
      }
      timeout {
         send_user "\nruncp.sh timeout\n"
         break
      }
   }
}

set timeout 20
send "umount /mnt/rootfs\r"
while 1 {
   expect {
      -re "root:~>" {
         send_user "\rumount /dev/mmc1 done\r"
         break
      }
      timeout {
         send_user "\rumount timeout\r"
         break
      }
   }
}

send "\r"

send_user "umount /dev/mmc1 done"

step "restart board"

sleep 5
send "reboot\r"
set timeout 60
while 1 {
   expect {

      "Hit any key " {
         send "\r"
         break
      }

#      ">" {
#         send_user "successful reset attemp\n"
#         break
#      }

      timeout {
         send_user "failed reset attemp\n"
         break
      }
   }
}

sleep 5

set timeout 10
send -s "setenv mmcargs setenv bootargs root=2401 rw\r"
expect ">"
send -s "setenv mmcboot \'tftpboot 0x1000000 linux; run mmcargs; run addip; bootelf\'\r"
expect ">"
send -s "save\r"
while 1 {
   expect {
      ">" {
         send_user "\nsave!!!\n"
         break
      }
      timeout {
         send_user "\nsave timeout!!!\n"
         break
      }
   }
}
sleep 5

set timeout 180
send -s "run mmcboot\r"
while 1 {
   expect {

      -re "Kernel panic" {
         report "kernel panic detected... trying to recover from it"
         break
      }

      -re "Sash command shell.*/> " {
         puts "successful boot attempt"
         break
      }

      "root:~> " {
         puts "successful boot attempt"
         break
      }

      -re "Linux version (.*) " {
         set linux_version $expect_out(1,string)
      }

      # Look for gcc version N.N[.N[.N]]
      -re "gcc version (\[0-9](\.\[0-9]+)+)" {
         set gcc_version [lindex $expect_out(0,string) 2]
      }

      # Look for text followed by 1 or more spaces or tabs
      # followed by = followed by 1 or more spaces or tabs
      # followed by (0xNNNNNN-0xNNNNNN)
      -re "text\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
         set map_text $expect_out(1,string)
      }

      -re "data\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
         set map_data $expect_out(1,string)
      }

      -re "bss\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
         set map_bss $expect_out(1,string)
      }

      -re "rootfs\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
         set map_rootfs $expect_out(1,string)
      }

      # Note that here we're looking for zero or 1 space. Doh!
      -re "stack\[\x20\t]?=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
         set map_stack $expect_out(1,string)
      }

      -re "\[Ii]nstruction \[Cc]ache \[Ee]nabled" {
         # set instruction_cache_boot_flag $CACHE_ENABLED
      }

      -re "\[Ii]nstruction \[Cc]ache \[Dd]isabled" {
         # set instruction_cache_boot_flag $CACHE_DISABLED
      }

      -re "\[Dd]ata \[Cc]ache \[Ee]nabled" {
         # set data_cache_boot_flag $CACHE_ENABLED
      }

      -re "\[Dd]ata \[Cc]ache \[Dd]isabled" {
         #set data_cache_boot_flag $CACHE_DISABLED
      }

      timeout {
         puts "failed boot attempt"
         incr test_flag
         break
      }
   }
}

if { $test_flag==0 } {
   send_log "\n$TITLE ............\[PASS\]\n"
   send_user "\n$TITLE ............\[PASS\]\n" 
} else {
   send_log "\n$TITLE ............\[FAIL\]\n"
   send_user "\n$TITLE ............\[FAIL\]\n" 
}


log_file

send_user "\n$TITLE is finished.\n"

