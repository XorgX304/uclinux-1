#!/usr/bin/expect

# Main entrance
log_file bluetooth_test_log
send_log "\nBluetooth test is starting...\r"
send_user "Starting bluetooth_test.exp\n"

set user /home/test
set uclinux_path $user/checkouts/kernel/uClinux-dist
set ttydev /dev/ttyS0
set send_slow {1 0.1}

set TITLE "Bluetooth Test"

proc all_done { passed_case failed_case } {
	puts "\rPassed case:	[$passed_case]\r"
	puts "\rFailed case:	[$failed_case]\r"
}

proc case_done { test_result passed_case failed_case } {
	if { $test_result == "pass" } {
		incr passed_case
		puts "\r passed_case = $passed_case\r"
	}
	if { $test_result == "fail" } {
		incr failed_case
		puts "\r failed_case = $failed_case\r"
	}
}

proc step { message } {
  global step_sequence_number

  puts "\n*******************************************************************"
  puts "STEP $step_sequence_number: $message\n\n"
  send_log "\n************** STEP $step_sequence_number: $message\n\n"
  incr step_sequence_number
}

set step_sequence_number    1

step "Start kermit"
#set argc [llength $argv]
#if { $argc < 1 } {
#	send_user "\nAppend /dev/ttyS0\n"
#}
#set ttydev	[lindex $argv 0]

set kparams	[list "set line $ttydev\r"]
lappend kparams "set speed 57600\r"
lappend kparams "set carrier-watch off\r"
lappend kparams "set handshake none\r"
lappend kparams "set flow-control none\r"
lappend kparams "robust\r"
lappend kparams "set file type bin\r"
lappend kparams "set file name lit\r"
lappend kparams "set rec pack 1000\r"
lappend kparams "set send pack 1000\r"
lappend kparams "set window 5\r"
lappend kparams "set escape 255\r"
set nkparams	[llength $kparams]

set timeout 5
spawn kermit
set kermit_spawn_id $spawn_id

while { 1 } {
   expect {
      "Type ?" { }
      "ermit>" {
         break
      }
      "not found" {
         send_log "\nERROR: Failed to start Kermit\n"
      }
      timeout {
         send_log "\nERROR: Time out starting up kermit\n"
      }
   }
}

for {set i 0} {$i < $nkparams} {incr i} {
   send [lindex $kparams $i]

   while 1 {
      expect {
         "ermit>" { break }
         "\\?\[A-Z]" {
            send_log "\nERROR: Failed to set up kermit parameters\n"
         }
         timeout {
            send_log "\nERROR: Time out setting up kermit parameters\n"
         }
      }
   }
}

send "connect\r"
while 1 {
   expect {
      "ype the escape character*" {
         break
      }
      timeout {
         send_log "\nERROR: Can't connect to serial port\n"
         exit
      }
   }
}

step "Restart the board."

send_user "Try to figure out if we are in u-boot or the kernel"
set where_are_we 0
send "version\r"
set timeout 20
expect {

   "U-Boot" {
      send_user "We are in u-boot\n"
      set where_are_we "uboot"
   }

   "Linux" {
      send_user "We are in the kernel\n"
      set where_are_we "kernel"
   }

   timeout {
      send_user "Can't tell if we are in u-boot or the kernel\n"
   }
}

if { $where_are_we == "uboot" } {
   set timeout 50
   expect ">"
   send_user "sending reset\n"
   send "reset\r"
} else {
   if { $where_are_we == "kernel" } {
      set timeout 60
      expect ">"
      send_user "sending reboot\n"
      send "reboot\r"
   } else {
      set timeout 10
      expect "*"
      expect "*"
      send_user "sending control-C\n"
      send "\3"
      sleep 1
      send "\r"
   }
}

while 1 {
   expect {

      "Hit any key " {
         send "\r"
      }

      ">" {
         send_user "successful reset attemp\n"
         break
      }

      timeout {
         send_user "failed reset attemp\n"
         break
      }
   }
}

send -s "set bootargs root=/dev/mtdblock0 rw\r"
expect ">"
send -s "save\r"
expect ">"

send -s "tftpboot 0x1000000 linux\r"
while 1 {
   expect {
      "#" {
         expect ">"
            break
      }
      timeout {
         puts "Fail tftp"
         break
      }
   }
}

send -s "boote\r"

set timeout 180
while 1 {
   expect {

      -re "Kernel panic" {
         report "kernel panic detected... trying to recover from it"
         break
      }

      -re "Sash command shell.*/> " {
         puts "successful boot attempt"
         break
      }

      "root:~> " {
         puts "successful boot attempt"
         break
      }

      -re "Linux version (.*) " {
         set linux_version $expect_out(1,string)
      }

      # Look for gcc version N.N[.N[.N]]
      -re "gcc version (\[0-9](\.\[0-9]+)+)" {
         set gcc_version [lindex $expect_out(0,string) 2]
      }

      # Look for text followed by 1 or more spaces or tabs
      # followed by = followed by 1 or more spaces or tabs
      # followed by (0xNNNNNN-0xNNNNNN)
      -re "text\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
         set map_text $expect_out(1,string)
      }

      -re "data\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
         set map_data $expect_out(1,string)
      }

      -re "bss\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
         set map_bss $expect_out(1,string)
      }

      -re "rootfs\[\x20\t]+=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
         set map_rootfs $expect_out(1,string)
      }

      # Note that here we're looking for zero or 1 space. Doh!
      -re "stack\[\x20\t]?=\[\x20\t]+(0x\[0-9a-fA-F]+-0x.....\[0-9a-fA-F]+)" {
         set map_stack $expect_out(1,string)
      }

      -re "\[Ii]nstruction \[Cc]ache \[Ee]nabled" {
         # set instruction_cache_boot_flag $CACHE_ENABLED
      }

      -re "\[Ii]nstruction \[Cc]ache \[Dd]isabled" {
         # set instruction_cache_boot_flag $CACHE_DISABLED
      }

      -re "\[Dd]ata \[Cc]ache \[Ee]nabled" {
         # set data_cache_boot_flag $CACHE_ENABLED
      }

      -re "\[Dd]ata \[Cc]ache \[Dd]isabled" {
         #set data_cache_boot_flag $CACHE_DISABLED
      }

      timeout {
         puts "failed boot attempt"
         break
      }
   }
}

set SUCESS			"success"
set SERIAL_PORT_BAUD_RATE	"57600"
set TARGET_IP_ADDR		"192.168.1.2"
set MST_BD_ADDR			"00:10:60:D0:8C:41"	
set SLV_BD_ADDR			"11:11:11:11:11:11"

set logfile		"/opt/bluez/testlog"
set BLUEZ_TARGET_DIR	"/opt/bluez"
set BLUEZ_SRC_DIR	"/opt/bluez/utils"

#global passed_case
#global failed_case
set passed_case		0
set failed_case		0
set total_case		0



sleep 2
incr total_case
send "hciconfig hci0 up\r"
expect "root:~>"

puts "\r############### EXEC: hciconfig... ###############\r"
sleep 2
send "hciconfig\r"
set timeout 2
while 1 {
	expect {
		"DOWN" {
			puts "\r-- FAILED: hciconfig\r"
			case_done "fail" $passed_case $failed_case
			incr failed_case
			break
		}
		-re "BD Address.*" {
			puts "\r-- SUCCESS: hci0 is up\r"
			case_done "pass" $passed_case $failed_case
			incr passed_case
			break
		}
		timeout {
			incr failed_case
			break
		}
	}
}


incr total_case
puts "\r############### EXEC: hcitool... ###############\r"
send "hcitool scan\r"
set timeout 20
sleep 15
while 1 {
	expect {
		"Inquiry failed: Success" {
			puts "\rNo remote Bluetooth device found\r"
			case_done "fail" $passed_case $failed_case
			incr failed_case
			break
		}
		"*$SLV_BD_ADDR*" {
			puts "\rRemote Bluetooth found\r"
			incr passed_case
			case_done "pass" $passed_case $failed_case
			break
		}
		timeout {
			puts "\rScan remote device time out\r"
			case_done "fail" $passed_case $failed_case
			incr failed_case
			break
		}
	}
}

incr total_case
puts "\r############### EXEC: hcitool inq... ###############\r"
send "hcitool -i hci0 info $SLV_BD_ADDR\r"
set timeout 30
sleep 30 
while 1 {
	expect {
		"$SLV_BD_ADDR" {
			puts "\rInquire done\r"
			incr passed_case
			case_done "pass" $passed_case $failed_case
			break
		}
		timeout {
			puts "\rInquire failed\r"
			case_done "fail" $passed_case $failed_case
			incr failed_case
			break
		}	
	}
}

incr total_case
puts "\r############### EXEC: l2ping... ###############\r"
send "l2ping -i hci0 -f $SLV_BD_ADDR\r"
set timeout 10
sleep 1
while 1 {
	expect {
		"bytes" {
			send "\3\r"
			puts "\rping pass\r"
			incr passed_case
			case_done "pass" $passed_case $failed_case
			break
		}
		"Can't connect:" {
			puts "\rping failed\r"
			case_done "fail" $passed_case $failed_case
			incr failed_case
			break	
		}
		timeout {
			puts "\rtimeout\r"
			case_done "fail" $passed_case $failed_case
			incr failed_case
			break
		}
	}
}

if { $passed_case == $total_case } {
   send_log "\n$TITLE ............\[PASS\]\n"
   send_user "\n$TITLE PASS\n"
} else {
   send_log "\n$TITLE ............\[PASS\]\n"
   send_user "\n$TITLE PASS\n"
}

log_file

send_user "\n$TITLE is finished.\n"

exit
