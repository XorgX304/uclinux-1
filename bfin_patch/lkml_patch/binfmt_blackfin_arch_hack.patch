binfmt blackfin arch hack patch

From: Bryan Wu <bryan.wu@analog.com>

diff --git a/fs/binfmt_elf_fdpic.c b/fs/binfmt_elf_fdpic.c
index 9d62fba..01a7cb5 100644
--- a/fs/binfmt_elf_fdpic.c
+++ b/fs/binfmt_elf_fdpic.c
@@ -166,7 +166,7 @@ static int load_elf_fdpic_binary(struct linux_binprm *bprm,
 {
 	struct elf_fdpic_params exec_params, interp_params;
 	struct elf_phdr *phdr;
-	unsigned long stack_size, entryaddr;
+	unsigned long stack_size, entryaddr, requested_stack_size;
 #ifndef CONFIG_MMU
 	unsigned long fullsize;
 #endif
@@ -338,8 +338,10 @@ static int load_elf_fdpic_binary(struct linux_binprm *bprm,
 	/* load the executable and interpreter into memory */
 	retval = elf_fdpic_map_file(&exec_params, bprm->file, current->mm,
 				    "executable");
-	if (retval < 0)
+	if (retval < 0) {
+		printk(KERN_ERR "Unable to load executable\n");
 		goto error_kill;
+	}
 
 	if (interpreter_name) {
 		retval = elf_fdpic_map_file(&interp_params, interpreter,
@@ -367,6 +369,7 @@ static int load_elf_fdpic_binary(struct linux_binprm *bprm,
 	 * - the stack starts at the top and works down
 	 */
 	stack_size = (stack_size + PAGE_SIZE - 1) & PAGE_MASK;
+	requested_stack_size = stack_size;
 	if (stack_size < PAGE_SIZE * 2)
 		stack_size = PAGE_SIZE * 2;
 
@@ -394,6 +397,8 @@ static int load_elf_fdpic_binary(struct linux_binprm *bprm,
 	current->mm->context.end_brk = current->mm->start_brk;
 	current->mm->context.end_brk +=
 		(stack_size > PAGE_SIZE) ? (stack_size - PAGE_SIZE) : 0;
+	current->mm->context.stack_start =
+		current->mm->start_brk + stack_size - requested_stack_size;
 	current->mm->start_stack = current->mm->start_brk + stack_size;
 #endif
 
@@ -967,6 +972,8 @@ static int elf_fdpic_map_file_constdisp_on_uclinux(
 }
 #endif
 
+extern void *safe_dma_memcpy(void *, const void *, size_t);
+
 /*****************************************************************************/
 /*
  * map a binary by direct mmap() of the individual PT_LOAD segments
@@ -1066,6 +1073,63 @@ static int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *params,
 		    ELF_FDPIC_FLAG_CONTIGUOUS)
 			load_addr += PAGE_ALIGN(phdr->p_memsz + disp);
 
+		/* Hack, hack, hack */
+		/* 0xff700000, 0xff800000, 0xff900000 and 0xffa00000 are also
+		   used in Dynamic linker and GNU ld. They need to be keep
+		   synchronized.  */
+
+		if (((params->hdr.e_flags & EF_BFIN_CODE_IN_L1)
+		     || (phdr->p_vaddr == 0xffa00000))
+		    && (phdr->p_flags & PF_W) == 0
+		    && (phdr->p_flags & PF_X)) {
+			void *l1_addr;
+			l1_addr = sram_alloc_with_lsl(phdr->p_memsz, L1_INST_SRAM);
+			if (l1_addr != NULL)
+				safe_dma_memcpy(l1_addr, (const void *)(maddr + disp), phdr->p_memsz);
+			down_write(&mm->mmap_sem);
+			do_munmap(mm, maddr, phdr->p_memsz + disp);
+			up_write(&mm->mmap_sem);
+			if (l1_addr == NULL) {
+				printk(KERN_ERR "Not enough L1 instruction sram\n");
+				return -ENOMEM;
+			}
+			kdebug("[%x] -> l1_addr = %x of len = %x\n",
+			       maddr + disp, l1_addr, phdr->p_memsz);
+			maddr = (unsigned long)l1_addr;
+			disp = 0;
+		} else if (((params->hdr.e_flags & EF_BFIN_DATA_IN_L1)
+			    || phdr->p_vaddr == 0xff700000
+			    || phdr->p_vaddr == 0xff800000
+			    || phdr->p_vaddr == 0xff900000)
+			   && (phdr->p_flags & PF_X) == 0
+			   && (phdr->p_flags & PF_W)) {
+			void *l1_addr;
+			if (phdr->p_vaddr == 0xff800000)
+				l1_addr = sram_alloc_with_lsl(phdr->p_memsz, L1_DATA_A_SRAM);
+			else if (phdr->p_vaddr == 0xff900000)
+				l1_addr = sram_alloc_with_lsl(phdr->p_memsz, L1_DATA_B_SRAM);
+			else
+				l1_addr = sram_alloc_with_lsl(phdr->p_memsz, L1_DATA_SRAM);
+			if (l1_addr != NULL)
+				memcpy(l1_addr, (const void *)(maddr + disp), phdr->p_memsz);
+			down_write(&mm->mmap_sem);
+			do_munmap(mm, maddr, phdr->p_memsz + disp);
+			up_write(&mm->mmap_sem);
+			if (l1_addr == NULL) {
+				if (phdr->p_vaddr == 0xff800000)
+					printk(KERN_ERR "Not enough L1 data bank A sram\n");
+				else if (phdr->p_vaddr == 0xff900000)
+					printk(KERN_ERR "Not enough L1 data bank B sram\n");
+				else
+					printk(KERN_ERR "Not enough L1 data sram\n");
+				return -ENOMEM;
+			}
+			kdebug("[%x] -> l1_addr = %x of len = %x\n",
+			       maddr + disp, l1_addr, phdr->p_memsz);
+			maddr = (unsigned long)l1_addr;
+			disp = 0;
+		}
+
 		seg->addr = maddr + disp;
 		seg->p_vaddr = phdr->p_vaddr;
 		seg->p_memsz = phdr->p_memsz;
@@ -1607,19 +1671,20 @@ static int elf_fdpic_core_dump(long signr, struct pt_regs *regs,
 
 	if (signr) {
 		struct elf_thread_status *tmp;
-		rcu_read_lock();
+		read_lock(&tasklist_lock);
 		do_each_thread(g,p)
 			if (current->mm == p->mm && current != p) {
 				tmp = kzalloc(sizeof(*tmp), GFP_ATOMIC);
 				if (!tmp) {
-					rcu_read_unlock();
+					read_unlock(&tasklist_lock);
 					goto cleanup;
 				}
+				INIT_LIST_HEAD(&tmp->list);
 				tmp->thread = p;
 				list_add(&tmp->list, &thread_list);
 			}
 		while_each_thread(g,p);
-		rcu_read_unlock();
+		read_unlock(&tasklist_lock);
 		list_for_each(t, &thread_list) {
 			struct elf_thread_status *tmp;
 			int sz;
diff --git a/fs/binfmt_flat.c b/fs/binfmt_flat.c
index 7b0265d..be61724 100644
--- a/fs/binfmt_flat.c
+++ b/fs/binfmt_flat.c
@@ -35,13 +35,13 @@
 #include <linux/personality.h>
 #include <linux/init.h>
 #include <linux/flat.h>
-#include <linux/syscalls.h>
 
 #include <asm/byteorder.h>
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/unaligned.h>
 #include <asm/cacheflush.h>
+#include <asm/mmu_context.h>
 
 /****************************************************************************/
 
@@ -77,6 +77,8 @@ static int load_flat_shared_library(int id, struct lib_info *p);
 static int load_flat_binary(struct linux_binprm *, struct pt_regs * regs);
 static int flat_core_dump(long signr, struct pt_regs * regs, struct file *file);
 
+extern void dump_thread(struct pt_regs *, struct user *);
+
 static struct linux_binfmt flat_format = {
 	.module		= THIS_MODULE,
 	.load_binary	= load_flat_binary,
@@ -413,7 +415,9 @@ void old_reloc(unsigned long rl)
 /****************************************************************************/
 
 static int load_flat_file(struct linux_binprm * bprm,
-		struct lib_info *libinfo, int id, unsigned long *extra_stack)
+			  struct lib_info *libinfo, int id,
+			  unsigned long *extra_stack,
+			  unsigned long *stack_base)
 {
 	struct flat_hdr * hdr;
 	unsigned long textpos = 0, datapos = 0, result;
@@ -426,7 +430,6 @@ static int load_flat_file(struct linux_binprm * bprm,
 	int i, rev, relocs = 0;
 	loff_t fpos;
 	unsigned long start_code, end_code;
-	int ret;
 
 	hdr = ((struct flat_hdr *) bprm->buf);		/* exec-header */
 	inode = bprm->file->f_path.dentry->d_inode;
@@ -445,31 +448,29 @@ static int load_flat_file(struct linux_binprm * bprm,
 
 	if (strncmp(hdr->magic, "bFLT", 4)) {
 		/*
-		 * because a lot of people do not manage to produce good
-		 * flat binaries,  we leave this printk to help them realise
-		 * the problem.  We only print the error if its not a script file
+		 * Previously, here was a printk to tell people
+		 *   "BINFMT_FLAT: bad header magic".
+		 * But for the kernel which also use ELF FD-PIC format, this
+		 * error message is confusing.
 		 */
-		if (strncmp(hdr->magic, "#!", 2))
-			printk("BINFMT_FLAT: bad header magic\n");
-		ret = -ENOEXEC;
-		goto err;
+		return -ENOEXEC;
 	}
-
+#ifdef DEBUG
+	flags |= FLAT_FLAG_KTRACE;
+#endif
 	if (flags & FLAT_FLAG_KTRACE)
 		printk("BINFMT_FLAT: Loading file: %s\n", bprm->filename);
 
 	if (rev != FLAT_VERSION && rev != OLD_FLAT_VERSION) {
 		printk("BINFMT_FLAT: bad flat file version 0x%x (supported 0x%x and 0x%x)\n", rev, FLAT_VERSION, OLD_FLAT_VERSION);
-		ret = -ENOEXEC;
-		goto err;
+		return -ENOEXEC;
 	}
-	
+
 	/* Don't allow old format executables to use shared libraries */
 	if (rev == OLD_FLAT_VERSION && id != 0) {
 		printk("BINFMT_FLAT: shared libraries are not available before rev 0x%x\n",
 				(int) FLAT_VERSION);
-		ret = -ENOEXEC;
-		goto err;
+		return -ENOEXEC;
 	}
 
 	/*
@@ -482,8 +483,7 @@ static int load_flat_file(struct linux_binprm * bprm,
 #ifndef CONFIG_BINFMT_ZFLAT
 	if (flags & (FLAT_FLAG_GZIP|FLAT_FLAG_GZDATA)) {
 		printk("Support for ZFLAT executables is not enabled.\n");
-		ret = -ENOEXEC;
-		goto err;
+		return -ENOEXEC;
 	}
 #endif
 
@@ -495,18 +495,27 @@ static int load_flat_file(struct linux_binprm * bprm,
 	rlim = current->signal->rlim[RLIMIT_DATA].rlim_cur;
 	if (rlim >= RLIM_INFINITY)
 		rlim = ~0;
-	if (data_len + bss_len > rlim) {
-		ret = -ENOMEM;
-		goto err;
+	if (data_len + bss_len > rlim)
+		return -ENOMEM;
+
+	if (flags & FLAT_FLAG_L1STK) {
+		if (stack_base == 0) {
+			printk ("BINFMT_FLAT: requesting L1 stack for shared library\n");
+			return -ENOEXEC;
+		}
+		stack_len = alloc_l1stack(stack_len, stack_base);
+		if (stack_len == 0) {
+			printk("BINFMT_FLAT: stack size with arguments exceeds scratchpad memory\n");
+			return -ENOMEM;
+		}
+		*extra_stack = stack_len;
 	}
 
 	/* Flush all traces of the currently running executable */
 	if (id == 0) {
 		result = flush_old_exec(bprm);
-		if (result) {
-			ret = result;
-			goto err;
-		}
+		if (result)
+			goto out_fail;
 
 		/* OK, This is the point of no return */
 		set_personality(PER_LINUX_32BIT);
@@ -536,8 +545,8 @@ static int load_flat_file(struct linux_binprm * bprm,
 			if (!textpos)
 				textpos = (unsigned long) -ENOMEM;
 			printk("Unable to mmap process text, errno %d\n", (int)-textpos);
-			ret = textpos;
-			goto err;
+			result = textpos;
+			goto out_fail;
 		}
 
 		len = data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);
@@ -560,8 +569,8 @@ static int load_flat_file(struct linux_binprm * bprm,
 			printk("Unable to allocate RAM for process data, errno %d\n",
 					(int)-datapos);
 			do_munmap(current->mm, textpos, text_len);
-			ret = realdatastart;
-			goto err;
+			result = realdatastart;
+			goto out_fail;
 		}
 		datapos = realdatastart + MAX_SHARED_LIBS * sizeof(unsigned long);
 
@@ -583,8 +592,7 @@ static int load_flat_file(struct linux_binprm * bprm,
 			printk("Unable to read data+bss, errno %d\n", (int)-result);
 			do_munmap(current->mm, textpos, text_len);
 			do_munmap(current->mm, realdatastart, data_len + extra);
-			ret = result;
-			goto err;
+			goto out_fail;
 		}
 
 		reloc = (unsigned long *) (datapos+(ntohl(hdr->reloc_start)-text_len));
@@ -611,8 +619,8 @@ static int load_flat_file(struct linux_binprm * bprm,
 				textpos = (unsigned long) -ENOMEM;
 			printk("Unable to allocate RAM for process text/data, errno %d\n",
 					(int)-textpos);
-			ret = textpos;
-			goto err;
+			result = textpos;
+			goto out_fail;
 		}
 
 		realdatastart = textpos + ntohl(hdr->data_start);
@@ -657,8 +665,7 @@ static int load_flat_file(struct linux_binprm * bprm,
 			printk("Unable to read code+data+bss, errno %d\n",(int)-result);
 			do_munmap(current->mm, textpos, text_len + data_len + extra +
 				MAX_SHARED_LIBS * sizeof(unsigned long));
-			ret = result;
-			goto err;
+			goto out_fail;
 		}
 	}
 
@@ -682,6 +689,7 @@ static int load_flat_file(struct linux_binprm * bprm,
 		current->mm->start_brk = datapos + data_len + bss_len;
 		current->mm->brk = (current->mm->start_brk + 3) & ~3;
 		current->mm->context.end_brk = memp + ksize((void *) memp) - stack_len;
+		current->mm->context.stack_start = current->mm->context.end_brk;
 	}
 
 	if (flags & FLAT_FLAG_KTRACE)
@@ -703,7 +711,7 @@ static int load_flat_file(struct linux_binprm * bprm,
 	libinfo->lib_list[id].loaded = 1;
 	libinfo->lib_list[id].entry = (0x00ffffff & ntohl(hdr->entry)) + textpos;
 	libinfo->lib_list[id].build_date = ntohl(hdr->build_date);
-	
+
 	/*
 	 * We just load the allocations into some temporary memory to
 	 * help simplify all this mumbo jumbo
@@ -722,8 +730,8 @@ static int load_flat_file(struct linux_binprm * bprm,
 			if (*rp) {
 				addr = calc_reloc(*rp, libinfo, id, 0);
 				if (addr == RELOC_FAILED) {
-					ret = -ENOEXEC;
-					goto err;
+					result = -ENOEXEC;
+					goto out_fail;
 				}
 				*rp = addr;
 			}
@@ -742,6 +750,7 @@ static int load_flat_file(struct linux_binprm * bprm,
 	 * __start to address 4 so that is okay).
 	 */
 	if (rev > OLD_FLAT_VERSION) {
+		unsigned long persistent = 0;
 		for (i=0; i < relocs; i++) {
 			unsigned long addr, relval;
 
@@ -749,16 +758,20 @@ static int load_flat_file(struct linux_binprm * bprm,
 			   relocated (of course, the address has to be
 			   relocated first).  */
 			relval = ntohl(reloc[i]);
+			if (flat_set_persistent (relval, &persistent))
+				continue;
 			addr = flat_get_relocate_addr(relval);
 			rp = (unsigned long *) calc_reloc(addr, libinfo, id, 1);
 			if (rp == (unsigned long *)RELOC_FAILED) {
-				ret = -ENOEXEC;
-				goto err;
+				result = -ENOEXEC;
+				goto out_fail;
 			}
 
 			/* Get the pointer's value.  */
-			addr = flat_get_addr_from_rp(rp, relval, flags);
-			if (addr != 0) {
+			addr = flat_get_addr_from_rp(rp, relval, flags, &persistent);
+			if (addr == 0)
+				continue;
+			if (! flat_addr_absolute (relval)) {
 				/*
 				 * Do the relocation.  PIC relocs in the data section are
 				 * already in target order
@@ -767,30 +780,31 @@ static int load_flat_file(struct linux_binprm * bprm,
 					addr = ntohl(addr);
 				addr = calc_reloc(addr, libinfo, id, 0);
 				if (addr == RELOC_FAILED) {
-					ret = -ENOEXEC;
-					goto err;
+					result = -ENOEXEC;
+					goto out_fail;
 				}
-
-				/* Write back the relocated pointer.  */
-				flat_put_addr_at_rp(rp, addr, relval);
 			}
+			/* Write back the relocated pointer.  */
+			flat_put_addr_at_rp(rp, addr, relval);
 		}
 	} else {
 		for (i=0; i < relocs; i++)
 			old_reloc(ntohl(reloc[i]));
 	}
-	
+
 	flush_icache_range(start_code, end_code);
 
 	/* zero the BSS,  BRK and stack areas */
-	memset((void*)(datapos + data_len), 0, bss_len + 
+	memset((void*)(datapos + data_len), 0, bss_len +
 			(memp + ksize((void *) memp) - stack_len -	/* end brk */
 			libinfo->lib_list[id].start_brk) +		/* start brk */
 			stack_len);
 
 	return 0;
-err:
-	return ret;
+ out_fail:
+	if (flags & FLAT_FLAG_L1STK)
+		free_l1stack();
+	return result;
 }
 
 
@@ -821,7 +835,7 @@ static int load_flat_shared_library(int id, struct lib_info *libs)
 	res = prepare_binprm(&bprm);
 
 	if (res <= (unsigned long)-4096)
-		res = load_flat_file(&bprm, libs, id, NULL);
+		res = load_flat_file(&bprm, libs, id, NULL, NULL);
 	if (bprm.file) {
 		allow_write_access(bprm.file);
 		fput(bprm.file);
@@ -844,6 +858,7 @@ static int load_flat_binary(struct linux_binprm * bprm, struct pt_regs * regs)
 	unsigned long p = bprm->p;
 	unsigned long stack_len;
 	unsigned long start_addr;
+	unsigned long l1stack_base, ramstack_top;
 	unsigned long *sp;
 	int res;
 	int i, j;
@@ -861,11 +876,11 @@ static int load_flat_binary(struct linux_binprm * bprm, struct pt_regs * regs)
 	stack_len += (bprm->argc + 1) * sizeof(char *); /* the argv array */
 	stack_len += (bprm->envc + 1) * sizeof(char *); /* the envp array */
 
-	
-	res = load_flat_file(bprm, &libinfo, 0, &stack_len);
+	l1stack_base = 0;
+	res = load_flat_file(bprm, &libinfo, 0, &stack_len, &l1stack_base);
 	if (res > (unsigned long)-4096)
 		return res;
-	
+
 	/* Update data segment pointers for all libraries */
 	for (i=0; i<MAX_SHARED_LIBS; i++)
 		if (libinfo.lib_list[i].loaded)
@@ -880,6 +895,7 @@ static int load_flat_binary(struct linux_binprm * bprm, struct pt_regs * regs)
 	set_binfmt(&flat_format);
 
 	p = ((current->mm->context.end_brk + stack_len + 3) & ~3) - 4;
+	ramstack_top = p;
 	DBG_FLT("p=%x\n", (int)p);
 
 	/* copy the arg pages onto the stack, this could be more efficient :-) */
@@ -888,7 +904,7 @@ static int load_flat_binary(struct linux_binprm * bprm, struct pt_regs * regs)
 			((char *) page_address(bprm->page[i/PAGE_SIZE]))[i % PAGE_SIZE];
 
 	sp = (unsigned long *) create_flat_tables(p, bprm);
-	
+
 	/* Fake some return addresses to ensure the call chain will
 	 * initialise library in order for us.  We are required to call
 	 * lib 1 first, then 2, ... and finally the main program (id 0).
@@ -904,15 +920,24 @@ static int load_flat_binary(struct linux_binprm * bprm, struct pt_regs * regs)
 		}
 	}
 #endif
-	
+
 	/* Stash our initial stack pointer into the mm structure */
 	current->mm->start_stack = (unsigned long )sp;
 
-	
-	DBG_FLT("start_thread(regs=0x%x, entry=0x%x, start_stack=0x%x)\n",
-		(int)regs, (int)start_addr, (int)current->mm->start_stack);
-	
-	start_thread(regs, start_addr, current->mm->start_stack);
+	if (l1stack_base) {
+		/* Find L1 stack pointer corresponding to the current bottom
+		   of the stack in normal RAM.  */
+		l1stack_base += stack_len - (ramstack_top - (unsigned long)sp);
+		if (!activate_l1stack(current->mm, ramstack_top - stack_len))
+			l1stack_base = 0;
+	}
+
+	DBG_FLT("start_thread(regs=0x%x, entry=0x%x, start_stack=0x%x, l1stk=0x%x, len 0x%x)\n",
+		(int)regs, (int)start_addr, (int)current->mm->start_stack, l1stack_base,
+		stack_len);
+
+	start_thread(regs, start_addr,
+		     l1stack_base ? l1stack_base : current->mm->start_stack);
 
 	if (current->ptrace & PT_PTRACED)
 		send_sig(SIGTRAP, current, 0);
diff --git a/include/asm-arm/mmu.h b/include/asm-arm/mmu.h
index fe2a23b..210ad2a 100644
--- a/include/asm-arm/mmu.h
+++ b/include/asm-arm/mmu.h
@@ -26,6 +26,7 @@ typedef struct {
 typedef struct {
 	struct vm_list_struct	*vmlist;
 	unsigned long		end_brk;
+	unsigned long		stack_start;
 } mm_context_t;
 
 #endif
diff --git a/include/asm-frv/mmu.h b/include/asm-frv/mmu.h
index 22c0371..f0d8287 100644
--- a/include/asm-frv/mmu.h
+++ b/include/asm-frv/mmu.h
@@ -24,6 +24,7 @@ typedef struct {
 #else
 	struct vm_list_struct	*vmlist;
 	unsigned long		end_brk;
+	unsigned long		stack_start;
 
 #endif
 
diff --git a/include/asm-h8300/mmu.h b/include/asm-h8300/mmu.h
index 2ce06ea..9e3e1b6 100644
--- a/include/asm-h8300/mmu.h
+++ b/include/asm-h8300/mmu.h
@@ -6,6 +6,7 @@
 typedef struct {
 	struct vm_list_struct	*vmlist;
 	unsigned long		end_brk;
+	unsigned long		stack_start;
 } mm_context_t;
 
 #endif
diff --git a/include/asm-m32r/mmu.h b/include/asm-m32r/mmu.h
index d9bd724..9d6e686 100644
--- a/include/asm-m32r/mmu.h
+++ b/include/asm-m32r/mmu.h
@@ -6,6 +6,7 @@
 typedef struct {
 	struct vm_list_struct	*vmlist;
 	unsigned long		end_brk;
+	unsigned long		stack_start;
 } mm_context_t;
 
 #else /* CONFIG_MMU */
diff --git a/include/asm-m68knommu/mmu.h b/include/asm-m68knommu/mmu.h
index 5fa6b68..2867a6c 100644
--- a/include/asm-m68knommu/mmu.h
+++ b/include/asm-m68knommu/mmu.h
@@ -6,6 +6,7 @@
 typedef struct {
 	struct vm_list_struct	*vmlist;
 	unsigned long		end_brk;
+	unsigned long		stack_start;
 } mm_context_t;
 
 #endif /* __M68KNOMMU_MMU_H */
diff --git a/include/asm-sh/mmu.h b/include/asm-sh/mmu.h
index eb0358c..50eff04 100644
--- a/include/asm-sh/mmu.h
+++ b/include/asm-sh/mmu.h
@@ -11,6 +11,7 @@ typedef struct {
 #else
 	struct vm_list_struct	*vmlist;
 	unsigned long		end_brk;
+	unsigned long		stack_start;
 #endif
 } mm_context_t;
 
diff --git a/include/asm-v850/mmu.h b/include/asm-v850/mmu.h
index 267768c..c7ddba8 100644
--- a/include/asm-v850/mmu.h
+++ b/include/asm-v850/mmu.h
@@ -6,6 +6,7 @@
 typedef struct {
 	struct vm_list_struct	*vmlist;
 	unsigned long		end_brk;
+	unsigned long		stack_start;
 } mm_context_t;
 
 #endif /* __V850_MMU_H__ */
diff --git a/include/linux/flat.h b/include/linux/flat.h
index ec56852..d41a2e0 100644
--- a/include/linux/flat.h
+++ b/include/linux/flat.h
@@ -10,6 +10,13 @@
 #ifndef _LINUX_FLAT_H
 #define _LINUX_FLAT_H
 
+#define FLAT_FLAG_RAM    0x0001 /* load program entirely into RAM */
+#define FLAT_FLAG_GOTPIC 0x0002 /* program is PIC with GOT */
+#define FLAT_FLAG_GZIP   0x0004 /* all but the header is compressed */
+#define FLAT_FLAG_GZDATA 0x0008 /* only data/relocs are compressed (for XIP) */
+#define FLAT_FLAG_KTRACE 0x0010 /* output useful kernel trace for debugging */
+#define FLAT_FLAG_L1STK  0x0020 /* use a 4k stack in L1 scratch memory.  */
+
 #ifdef __KERNEL__
 #include <asm/flat.h>
 #endif
@@ -50,12 +57,6 @@ struct flat_hdr {
 	unsigned long filler[5];    /* Reservered, set to zero */
 };
 
-#define FLAT_FLAG_RAM    0x0001 /* load program entirely into RAM */
-#define FLAT_FLAG_GOTPIC 0x0002 /* program is PIC with GOT */
-#define FLAT_FLAG_GZIP   0x0004 /* all but the header is compressed */
-#define FLAT_FLAG_GZDATA 0x0008 /* only data/relocs are compressed (for XIP) */
-#define FLAT_FLAG_KTRACE 0x0010 /* output useful kernel trace for debugging */
-
 
 #ifdef __KERNEL__ /* so systems without linux headers can compile the apps */
 /*
