Index: git/linux-2.6/fs/binfmt_flat.c
===================================================================
--- git.orig/linux-2.6/fs/binfmt_flat.c	2005-12-15 11:37:17.000000000 +0800
+++ git/linux-2.6/fs/binfmt_flat.c	2005-12-15 11:51:47.000000000 +0800
@@ -62,6 +62,9 @@
 	struct {
 		unsigned long start_code;		/* Start of text segment */
 		unsigned long start_data;		/* Start of data segment */
+#ifdef CONFIG_BFIN
+		unsigned long end_data;			/* Start of bss */
+#endif
 		unsigned long start_brk;		/* End of data segment */
 		unsigned long text_len;			/* Length of text segment */
 		unsigned long entry;			/* Start address for this module */
@@ -370,6 +373,273 @@
 }
 
 /****************************************************************************/
+#ifdef CONFIG_BFIN
+#ifdef CONFIG_BINFMT_SHARED_FLAT
+static int
+load_library(int curid, int id, struct lib_info *p, flat_v5_reloc_t *r)
+{
+	if ( ! p->lib_list[id].loaded &&
+		   load_flat_shared_library(id, p) > (unsigned long) -4096) {
+		printk("BINFMT_FLAT: failed to load library %d", id);
+		return 0;
+	}
+	/* Check versioning information (i.e. time stamps) */
+	if (p->lib_list[id].build_date && p->lib_list[curid].build_date &&
+			p->lib_list[curid].build_date < p->lib_list[id].build_date) {
+		printk("BINFMT_FLAT: library %d is younger than %d", id, curid);
+		return 0;
+	}
+	return 1;
+}
+#endif
+
+int calc_v5_reloc(int i, unsigned long *rlp, struct lib_info *p, int curid, int internalp)
+{
+	/*
+	 * This was flat_reloc_t, but since it changes based on version, and this
+	 * routine is for version 5 only.  This is now flat_v5_reloc_t.
+	 * Faisal Akber 2001-11-28
+	 */
+	flat_v5_reloc_t r;
+	unsigned long rl = ntohl (*(rlp + i));
+	unsigned long *ptr;
+	unsigned short *usptr;
+	unsigned long offset=0;
+	unsigned long start_brk;
+	unsigned long start_data;
+	unsigned long end_data;
+	unsigned long text_len;
+	unsigned long start_code;
+	int id;
+
+	r.value = rl;
+#ifdef CONFIG_BINFMT_SHARED_FLAT
+	if (r.reloc.offset == 0)
+		id = curid;	/* Relocs of 0 are always self referring */
+	else {
+		id = (r.reloc.offset >> 24) & 0x03;	/* Find ID for this reloc */
+		r.reloc.offset &= 0x00ffffff;	/* Trim ID off here */
+	}
+	if (id >= MAX_SHARED_LIBS) {
+		printk("BINFMT_FLAT: reference 0x%x to shared library %d",
+				(unsigned) r.reloc.offset, id);
+		goto failed;
+	}
+	if (curid != id) {
+		if (internalp) {
+			printk("BINFMT_FLAT: reloc address 0x%x not in same module "
+					"(%d != %d)", (unsigned) r.reloc.offset, curid, id);
+			goto failed;
+		} else if ( ! p->lib_list[id].loaded &&
+				load_flat_shared_library(id, p) > (unsigned long) -4096) {
+			printk("BINFMT_FLAT: failed to load library %d", id);
+			goto failed;
+		}
+		/* Check versioning information (i.e. time stamps) */
+		if (p->lib_list[id].build_date && p->lib_list[curid].build_date &&
+				p->lib_list[curid].build_date < p->lib_list[id].build_date) {
+			printk("BINFMT_FLAT: library %d is younger than %d", id, curid);
+			goto failed;
+		}
+	}
+#else
+	id = 0;
+#endif
+
+	start_brk = p->lib_list[id].start_brk;
+	start_data = p->lib_list[id].start_data;
+	end_data = p->lib_list[id].end_data;
+	start_code = p->lib_list[id].start_code;
+	text_len = p->lib_list[id].text_len;
+
+        ptr = (unsigned long *) (r.reloc.offset);
+
+        if (r.reloc.offset < text_len)                     /* In text segment */
+                ptr = (unsigned long *)(r.reloc.offset + start_code);
+        else                                    /* In data segment */
+                ptr = (unsigned long *)(r.reloc.offset - text_len + start_data);
+
+
+#ifdef DEBUG_BFIN_RELOC
+	printk("reloc %d reloc.offset=%x", i, r.reloc.offset);
+	printk(" type = %x sp = %d", r.reloc.type, r.reloc.sp);
+#endif
+
+	switch (r.reloc.sp) {
+	case FLAT_BFIN_RELOC_SP_TYPE_16_BIT:
+		usptr = (unsigned short *) ptr;
+#ifdef DEBUG_BFIN_RELOC
+		printk(" sp = 16 bit *usptr = %x", get_unaligned (usptr));
+#endif
+
+		switch (r.reloc.type) {
+		  case FLAT_RELOC_TYPE_TEXT:
+			  offset = start_code;
+			  break;
+		  case FLAT_RELOC_TYPE_DATA:
+			  offset = start_data;
+			  break;
+		  case FLAT_RELOC_TYPE_BSS:
+			  offset = end_data;
+			  break;
+		  case FLAT_RELOC_TYPE_STACK:
+			  offset = current->mm->context.end_brk;
+			  break;
+		  default:
+			  printk("BINFMT_FLAT: Unknown relocation type=%x\n",
+			       r.reloc.type);
+			  break;
+		}
+
+
+		offset += get_unaligned (usptr);
+		if (r.reloc.hi_lo) {
+#ifdef DEBUG_BFIN_RELOC
+			printk(" hi ");
+#endif
+			offset >>= 16;
+		}
+		else{
+#ifdef DEBUG_BFIN_RELOC
+			printk(" lo ");
+#endif
+			offset &= 0xFFFF;
+		}
+		put_unaligned (offset, usptr);
+#ifdef DEBUG_BFIN_RELOC
+		printk(" new value %x", get_unaligned (usptr));
+#endif
+
+		i++;
+		break;
+
+	case FLAT_BFIN_RELOC_SP_TYPE_16H_BIT:
+		usptr = (unsigned short *) ptr;
+#ifdef DEBUG_BFIN_RELOC
+		printk(" sp = 16 bit *offset = %x", ntohl (rlp[i + 1]));
+#endif
+
+		switch (r.reloc.type) {
+		  case FLAT_RELOC_TYPE_TEXT:
+			  offset = start_code;
+			  break;
+		  case FLAT_RELOC_TYPE_DATA:
+			  offset = start_data;
+			  break;
+		  case FLAT_RELOC_TYPE_BSS:
+			  offset = end_data;
+			  break;
+		  case FLAT_RELOC_TYPE_STACK:
+			  offset = current->mm->context.end_brk;
+			  break;
+		  default:
+			  printk("BINFMT_FLAT: Unknown relocation type=%x\n",
+			       r.reloc.type);
+			  break;
+		}
+		if (get_unaligned (usptr) == 0) {
+			offset += ntohl (rlp[i + 1]);
+			i += 2;
+		}
+		else {
+			offset += ntohl (rlp[get_unaligned (usptr)]);
+			i++;
+		}
+		if (r.reloc.hi_lo) {
+#ifdef DEBUG_BFIN_RELOC
+			printk(" hi");
+#endif
+			offset >>= 16;
+
+		} else {
+#ifdef DEBUG_BFIN_RELOC
+			printk(" lo");
+#endif
+		}
+		put_unaligned (offset, usptr);
+#ifdef DEBUG_BFIN_RELOC
+		printk(" new value %x", get_unaligned (usptr));
+#endif
+		break;
+
+	case FLAT_BFIN_RELOC_SP_TYPE_32_BIT:
+
+#ifdef DEBUG_BFIN_RELOC
+		printk(" ptr =%x", get_unaligned ((unsigned short *)ptr));
+#endif
+		offset = get_unaligned (ptr);
+
+#ifdef CONFIG_BINFMT_SHARED_FLAT
+		/* relocation of R_byte4_data in another library.
+                   The value we have is absolute relative to the library.
+		*/
+
+		int new_id = (offset >> 24) & 0x03;	/* Find ID for this reloc */
+
+		// new_id = 0 indicates local relocation.
+		if (new_id !=0 && new_id != curid) {
+			/* this symbol is in a different library */
+			/* verify if it is loaded */
+			if(!load_library(curid, new_id, p, &r))
+				goto failed;
+			offset = offset & 0x00ffffff;
+			if(offset < p->lib_list[new_id].text_len)
+				offset +=  p->lib_list[new_id].start_code;
+			else
+				offset = offset - p->lib_list[new_id].text_len + p->lib_list[new_id].start_data;
+		}
+		else
+#endif
+		{
+			switch (r.reloc.type) {
+			case FLAT_RELOC_TYPE_TEXT:
+				offset += start_code;
+				break;
+			case FLAT_RELOC_TYPE_DATA:
+				offset += start_data;
+				break;
+			case FLAT_RELOC_TYPE_BSS:
+				offset += end_data;
+				break;
+			case FLAT_RELOC_TYPE_STACK:
+				offset = current->mm->context.end_brk;
+				break;
+			default:
+				printk
+			    		("BINFMT_FLAT: offset= %x,Unknown relocation type=%x\n",
+			     		r.reloc.offset, r.reloc.type);
+				break;
+			}
+		}
+
+		put_unaligned (offset, ptr);
+#ifdef DEBUG_BFIN_RELOC
+		printk(" new ptr =%x", get_unaligned (ptr));
+#endif
+		i++;
+		break;
+
+	default:
+		printk("BINFMT_FLAT: Unknown relocation type %x\n",
+		       r.reloc.sp);
+		break;
+	}
+#ifdef DEBUG_BFIN_RELOC
+	printk("\n");
+#endif
+	return i;
+
+#ifdef CONFIG_BINFMT_SHARED_FLAT
+failed:
+	printk(", killing %s!\n", current->comm);
+	send_sig(SIGSEGV, current, 0);
+
+	return RELOC_FAILED;
+#endif
+
+}
+
+#endif
 
 void old_reloc(unsigned long rl)
 {
@@ -378,7 +648,7 @@
 #endif
 	flat_v2_reloc_t	r;
 	unsigned long *ptr;
-	
+
 	r.value = rl;
 #if defined(CONFIG_COLDFIRE)
 	ptr = (unsigned long *) (current->mm->start_code + r.reloc.offset);
@@ -391,7 +661,7 @@
 		"(address %p, currently %x) into segment %s\n",
 		r.reloc.offset, ptr, (int)*ptr, segment[r.reloc.type]);
 #endif
-	
+
 	switch (r.reloc.type) {
 	case OLD_FLAT_RELOC_TYPE_TEXT:
 		*ptr += current->mm->start_code;
@@ -410,7 +680,7 @@
 #ifdef DEBUG
 	printk("Relocation became %x\n", (int)*ptr);
 #endif
-}		
+}
 
 /****************************************************************************/
 
@@ -459,7 +729,7 @@
 					rev, (int) FLAT_VERSION);
 		return -ENOEXEC;
 	}
-	
+
 	/* Don't allow old format executables to use shared libraries */
 	if (rev == OLD_FLAT_VERSION && id != 0) {
 		printk("BINFMT_FLAT: shared libraries are not available before rev 0x%x\n",
@@ -551,7 +821,7 @@
 		fpos = ntohl(hdr->data_start);
 #ifdef CONFIG_BINFMT_ZFLAT
 		if (flags & FLAT_FLAG_GZDATA) {
-			result = decompress_exec(bprm, fpos, (char *) datapos, 
+			result = decompress_exec(bprm, fpos, (char *) datapos,
 						 data_len + (relocs * sizeof(unsigned long)), 0);
 		} else
 #endif
@@ -666,12 +936,15 @@
 	/* Store the current module values into the global library structure */
 	libinfo->lib_list[id].start_code = start_code;
 	libinfo->lib_list[id].start_data = datapos;
+#ifdef CONFIG_BFIN
+	libinfo->lib_list[id].end_data = datapos + data_len;
+#endif
 	libinfo->lib_list[id].start_brk = datapos + data_len + bss_len;
 	libinfo->lib_list[id].text_len = text_len;
 	libinfo->lib_list[id].loaded = 1;
 	libinfo->lib_list[id].entry = (0x00ffffff & ntohl(hdr->entry)) + textpos;
 	libinfo->lib_list[id].build_date = ntohl(hdr->build_date);
-	
+
 	/*
 	 * We just load the allocations into some temporary memory to
 	 * help simplify all this mumbo jumbo
@@ -707,6 +980,15 @@
 	 * reference to be statically initialised to _stext (I've moved
 	 * __start to address 4 so that is okay).
 	 */
+#ifdef CONFIG_BFIN
+DBG_FLT("rev= %d\n", rev);
+#ifdef DEBUG_BFIN_RELOC
+	printk("start_code=%x start_data=%x end_data=%x\n",current->mm->start_code,
+	current->mm->start_data, current->mm->end_data);
+#endif
+				 for(i = 0; i < relocs;)
+					 i = calc_v5_reloc(i, reloc, libinfo, id, 1);
+#else
 	if (rev > OLD_FLAT_VERSION) {
 		for (i=0; i < relocs; i++) {
 			unsigned long addr, relval;
@@ -741,7 +1023,7 @@
 		for (i=0; i < relocs; i++)
 			old_reloc(ntohl(reloc[i]));
 	}
-	
+#endif
 	flush_icache_range(start_code, end_code);
 
 	/* zero the BSS,  BRK and stack areas */
@@ -821,11 +1103,11 @@
 	stack_len += (bprm->argc + 1) * sizeof(char *); /* the argv array */
 	stack_len += (bprm->envc + 1) * sizeof(char *); /* the envp array */
 
-	
+
 	res = load_flat_file(bprm, &libinfo, 0, &stack_len);
 	if (res > (unsigned long)-4096)
 		return res;
-	
+
 	/* Update data segment pointers for all libraries */
 	for (i=0; i<MAX_SHARED_LIBS; i++)
 		if (libinfo.lib_list[i].loaded)
@@ -848,7 +1130,7 @@
 			((char *) page_address(bprm->page[i/PAGE_SIZE]))[i % PAGE_SIZE];
 
 	sp = (unsigned long *) create_flat_tables(p, bprm);
-	
+
 	/* Fake some return addresses to ensure the call chain will
 	 * initialise library in order for us.  We are required to call
 	 * lib 1 first, then 2, ... and finally the main program (id 0).
@@ -864,14 +1146,14 @@
 		}
 	}
 #endif
-	
+
 	/* Stash our initial stack pointer into the mm structure */
 	current->mm->start_stack = (unsigned long )sp;
 
-	
+
 	DBG_FLT("start_thread(regs=0x%x, entry=0x%x, start_stack=0x%x)\n",
 		(int)regs, (int)start_addr, (int)current->mm->start_stack);
-	
+
 	start_thread(regs, start_addr, current->mm->start_stack);
 
 	if (current->ptrace & PT_PTRACED)
Index: git/linux-2.6/include/linux/flat.h
===================================================================
--- git.orig/linux-2.6/include/linux/flat.h	2005-12-15 11:37:17.000000000 +0800
+++ git/linux-2.6/include/linux/flat.h	2005-12-15 11:51:47.000000000 +0800
@@ -5,6 +5,10 @@
  *
  * This file provides the definitions and structures needed to
  * support uClinux flat-format executables.
+ * Modification History
+ *    Merged a "v5" header information that was needed to support
+ *        Analog Devices blackfin. Comments indicate the changes were
+ *        made by Faisal Akber.
  */
 
 #ifndef _LINUX_FLAT_H
@@ -14,7 +18,11 @@
 #include <asm/flat.h>
 #endif
 
+#ifdef CONFIG_BFIN
+#define	FLAT_VERSION			0x00000005L
+#else
 #define	FLAT_VERSION			0x00000004L
+#endif
 
 #ifdef CONFIG_BINFMT_SHARED_FLAT
 #define	MAX_SHARED_LIBS			(4)
@@ -45,9 +53,14 @@
 	unsigned long reloc_start;  /* Offset of relocation records from
 	                               beginning of file */
 	unsigned long reloc_count;  /* Number of relocation records */
-	unsigned long flags;       
+	unsigned long flags;
 	unsigned long build_date;   /* When the program/library was built */
+#ifdef CONFIG_BFIN
+	unsigned long filler[6];    /* Reservered, set to zero */
+#else
 	unsigned long filler[5];    /* Reservered, set to zero */
+#endif
+
 };
 
 #define FLAT_FLAG_RAM    0x0001 /* load program entirely into RAM */
@@ -56,6 +69,182 @@
 #define FLAT_FLAG_GZDATA 0x0008 /* only data/relocs are compressed (for XIP) */
 #define FLAT_FLAG_KTRACE 0x0010 /* output useful kernel trace for debugging */
 
+#ifdef CONFIG_BFIN
+/*
+ * This is to define a type called flat_reloc_t (which is a macro, of course).
+ * This type is to make the code simpler for the generic parts of the code, in
+ * both the kernel loader and the flat generators.
+ *
+ * Faisal Akber
+ */
+#if (FLAT_VERSION <= 2)
+#define flat_reloc_t flat_v2_reloc_t
+#elif (FLAT_VERSION == 4)
+#define flat_reloc_t unsigned long
+#elif (FLAT_VERSION == 5)
+#define flat_reloc_t flat_v5_reloc_t
+#else
+#error Unknown bFLT format version number.
+#endif
+
+/*
+ * Special Cases for ARM and M68K as they only support version 4 binaries.
+ */
+#if defined(CONFIG_ARM) || defined(CONFIG_M68K)
+#undef flat_reloc_t
+#define flat_reloc_t unsigned long
+#endif
+
+/*
+ * Moved this higher to accommodate the requirements for all of the relocation
+ * types.
+ *
+ * Faisal Akber
+ */
+#include <asm/byteorder.h>
+
+/*
+ * Version 5 relocation records.
+ * =============================
+ *
+ * +--+-+---+--------------------------+
+ * |  | |   |                          |
+ * +--+-+---+--------------------------+
+ * |  | |   |                          |
+ * |  | |   +--------------------------+-------------- offset
+ * |  | |   |
+ * |  | +---+----------------------------------------- sp
+ * |  | |
+ * |  +-+--------------------------------------------- hi_lo
+ * |  |
+ * +--+----------------------------------------------- type
+ *
+ * offset - This is the offset of where the relocation must take place.
+ *          The offset is from the start of the section.  To find out
+ *          which section to look at, see type.
+ * sp     - These bits are special platform specific bits.  See below for
+ *          further explanation and mapping for supported platforms.
+ * hi_lo  - For relocations where only part of the address is taken, then
+ *          this bit indicates whether it is the high part or the low part of
+ *          the address.
+ *          0 - Low part of address
+ *          1 - High part of address
+ * type   - This indicates which section the relocation is in.
+ *          00 - TEXT section
+ *          01 - DATA section
+ *          10 - BSS section
+ *
+ * MIPS sp Specification
+ * =====================
+ *
+ * +-+-+-+
+ * | | | |
+ * +-+-+-+
+ * | | | |
+ * | | +-+-------------------------------------------- carry
+ * | | |
+ * +-+-+---------------------------------------------- reloc_type
+ *
+ * carry      - This indicates whether the high part of the relcation address
+ *              requires a carry because of the low part calculations.
+ *              0 - Do not carry from low part
+ *              1 - Carry from low part
+ * reloc_type - For MIPS, there are three types of relocations to handle.
+ *              16-bit High part, 16-bit Low part, and 26-bit.  Thus this
+ *              indicates whether it is a hi/lo reloc or a 26-bit reloc.
+ *              00 - 16-bit hi/lo relocation
+ *              01 - 26-bit relocation
+ *              10 - 32-bit relocation
+ *
+ * BLACKfin sp Specification
+ * =========================
+ *
+ * 000 luimm16 and huimm16. hi_lo used for selecting.
+ * 001 pcrel24.
+ * 010 abs32.
+ *
+ * Blackfin has too many kinds of relocations to fit into 3 bits. Only those
+ * types of relocations that are required for compiled code are supported at
+ * this time. Unlike mips tools, we don't have enough support for carry. The
+ * kernel has to do ad-hoc carry calculations for huimm16 relocations. It
+ * doesn't cause any problems for compiler generated code because a compiler
+ * always generates a luimm16 type instruction followed by a huimm16
+ * instruction. - akale
+ *
+ * SPARC sp Specification
+ * ======================
+ *
+ * This architecture is not yet defined.
+ *
+ * ARM and M68K Details
+ * ====================
+ * These architectures use the version 4 bFLT format.  The version 4 format is
+ * a simple unsigned long integer (32-bits).  This record holds the relocation
+ * offset from the start of text.  The loader must check for size of offset
+ * against the size of text section for XIP to work properly.
+ *
+ *
+ * Faisal Akber
+ *
+ */
+
+typedef union
+{
+  unsigned long	value;
+  struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+    unsigned long type  : 2;
+    unsigned long hi_lo : 1;
+    unsigned long sp    : 3;
+    signed long offset  : 26;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+    signed long offset  : 26;
+    unsigned long sp    : 3;
+    unsigned long hi_lo : 1;
+    unsigned long type  : 2;
+#else
+#error "Unknown bitfield order for flat files."
+# endif
+	} reloc;
+} flat_v5_reloc_t;
+
+#define FLAT_RELOC_TYPE_TEXT 0
+#define FLAT_RELOC_TYPE_DATA 1
+#define FLAT_RELOC_TYPE_BSS 2
+#define FLAT_RELOC_TYPE_STACK 3
+#define FLAT_RELOC_PART_LO 0
+#define FLAT_RELOC_PART_HI 1
+
+#ifdef CONFIG_MIPS
+#define TARGET_MIPS
+#define FLAT_MIPS_RELOC_SP(type, carry) ((type * 2) + (carry))
+#define FLAT_MIPS_RELOC_SP_TYPE_16_BIT 0
+#define FLAT_MIPS_RELOC_SP_TYPE_26_BIT 1
+#define FLAT_MIPS_RELOC_SP_TYPE_32_BIT 2
+#define FLAT_MIPS_RELOC_SP_NO_CARRY 0
+#define FLAT_MIPS_RELOC_SP_CARRY 1
+#endif
+
+#ifdef CONFIG_BFIN
+#define TARGET_BFIN
+#define FLAT_BFIN_RELOC_SP_TYPE_16_BIT 0
+#define FLAT_BFIN_RELOC_SP_TYPE_16H_BIT 1
+#define FLAT_BFIN_RELOC_SP_TYPE_32_BIT 2
+#endif
+/*
+ * Need to add the rest of the macros for other architecture specific
+ * sp field values.
+ */
+
+#ifdef CONFIG_M68K
+#define TARGET_M68K
+#endif
+
+#ifdef CONFIG_ARM
+#define TARGET_ARM
+#endif
+
+#endif	/*CONFIG_BFIN*/
 
 #ifdef __KERNEL__ /* so systems without linux headers can compile the apps */
 /*
