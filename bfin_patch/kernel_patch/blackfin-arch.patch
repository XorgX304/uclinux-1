Index: git/linux-2.6/arch/blackfin/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/Kconfig	2005-12-21 16:10:50.000000000 +0800
@@ -0,0 +1,672 @@
+#
+# For a description of the syntax of this configuration file,
+# see Documentation/kbuild/kconfig-language.txt.
+#
+
+mainmenu "uClinux/Blackfin (w/o MMU) Kernel Configuration"
+
+config MMU
+	bool
+	default n
+
+config FPU
+	bool
+	default n
+
+config UID16
+	bool
+	default y
+
+config RWSEM_GENERIC_SPINLOCK
+	bool
+	default y
+
+config RWSEM_XCHGADD_ALGORITHM
+	bool
+	default n
+
+config BFIN
+	bool
+	default y
+
+config UCLINUX
+	bool
+	default y
+
+config FORCE_MAX_ZONEORDER
+	int
+	default "14"
+
+config GENERIC_CALIBRATE_DELAY
+	bool
+	default y
+
+source "init/Kconfig"
+
+menu "Blackfin Processor Options"
+
+comment "Processor and Board Settings"
+
+choice
+	prompt	"CPU"
+	default BF533
+
+config BF533
+	bool "BF533"
+	help
+	 BF533 Processor Support.
+
+config BF532
+	bool "BF532"
+	help
+	 BF532 Processor Support.
+
+config BF531
+	bool "BF531"
+	help
+	 BF531 Processor Support.
+
+config BF534
+	bool "BF534"
+	help
+	 BF534 Processor Support.
+
+config BF535
+	bool "BF535"
+	help
+	 Not Supported - BF535 Processor Support.
+
+config BF536
+	bool "BF536"
+	help
+	 BF536 Processor Support.
+
+config BF537
+	bool "BF537"
+	help
+	 BF537 Processor Support.
+
+config BF561
+	bool "BF561"
+	help
+	 Not Supported Yet - Work in progress - BF561 Processor Support.
+
+endchoice
+
+config BLACKFIN
+	bool
+	depends on (BF537 || BF536 || BF534 || BF561 || BF535 || BF533 || BF532 || BF531)
+	default y
+
+config BFIN_SINGLE_CORE
+	bool
+	depends on (BF537 || BF536 || BF534 || BF535 || BF533 || BF532 || BF531)
+	default y
+
+config BFIN_DUAL_CORE
+	bool
+	depends on (BF561)
+	default y
+
+choice
+	prompt	"Kernel is configured for"
+	default BFIN533_STAMP
+	help
+	  Do NOT change the board here, please use the top level configuration to ensure all
+	  all the other settings are correct
+
+config BFIN533_EZKIT
+	bool "BF533-EZKIT"
+	depends on (BF533 || BF532 || BF531)
+	help
+	 BF533-EZKIT-LITE board Support.
+
+config  BFIN533_STAMP
+	bool "BF533-STAMP"
+	depends on (BF533 || BF532 || BF531)
+	help
+	 BF533-STAMP board Support.
+
+config BFIN537_STAMP
+	bool "BF537-STAMP"
+	depends on (BF537)
+	help
+	  BF537-STAMP board Support.
+
+config BFIN533_BLUETECHNIX_CM
+	bool "Bluetechnix CM-BF533 board support"
+	depends on BF533
+	help
+	  CM-BF533 support for EVAL- and DEV-Board
+
+config BFIN561_EZKIT
+	bool "BF561-EZKIT"
+	depends on (BF561)
+	help
+	 BF561-EZKIT-LITE board Support.
+
+config GENERIC_BOARD
+	bool "Custom"
+	depends on (BF537 || BF536 || BF534 || BF561 || BF535 || BF533 || BF532 || BF531)
+	help
+	 GENERIC or Custom board Support.
+
+endchoice
+
+config MEM_GENERIC_BOARD
+	bool
+	depends on GENERIC_BOARD
+	default y
+
+config MEM_MT48LC64M4A2FB_7E
+	bool
+	depends on (BFIN533_STAMP)
+	default y
+
+config MEM_MT48LC16M16A2TG_75
+	bool
+	depends on (BFIN533_EZKIT || BFIN561_EZKIT || BFIN533_BLUETECHNIX_CM)
+	default y
+
+config MEM_MT48LC16M8A2TG_75
+	bool
+	depends on (BFIN537_STAMP)
+	default y
+
+config BFIN_SHARED_FLASH_ENET
+	bool
+	depends on (BFIN533_STAMP || BFIN533_BLUETECHNIX_CM)
+	default y
+
+source "arch/blackfin/mach-bf533/Kconfig"
+source "arch/blackfin/mach-bf561/Kconfig"
+source "arch/blackfin/mach-bf537/Kconfig"
+
+menu 	'Board specific issues'
+
+comment 'Board Setup'
+
+config CLKIN_HZ
+	int "Crystal Frequency in Hz"
+	default "11059200" if BFIN533_STAMP
+	default "27000000" if BFIN533_EZKIT
+	default "25000000" if BFIN537_STAMP
+	default "27000000" if BFIN533_BLUETECHNIX_CM
+	default "30000000" if BFIN561_EZKIT
+	help
+	  The frequency of CLKIN crystal oscillator on the board in Hz.
+
+config MEM_SIZE
+	int "SDRAM Memory Size in MBytes"
+	default  32 if BFIN533_EZKIT
+	default  32 if BFIN533_BLUETECHNIX_CM
+	default  64 if BFIN537_STAMP
+	default  64 if BFIN561_EZKIT
+	default 128 if BFIN533_STAMP
+
+config MEM_ADD_WIDTH
+	int "SDRAM Memory Address Width"
+	default  9 if BFIN533_EZKIT
+	default  9 if BFIN561_EZKIT
+	default  9 if BFIN533_BLUETECHNIX_CM
+	default 10 if BFIN537_STAMP
+	default 11 if BFIN533_STAMP
+
+config ENET_FLASH_PIN
+	int "PF port/pin used for flash and ethernet sharing"
+	depends on (BFIN533_STAMP)
+	default  1
+	help
+	  PF port/pin used for flash and ethernet sharing to allow other PF
+	  pins to be used on other platforms without having to touch common code.
+	  For example: PF0 --> 1,PF1 --> 2,PF2 --> 4, etc.
+
+comment	'LED Status Indicators'
+
+config BFIN_ALIVE_LED
+	bool "Enable Board Alive"
+	depends on ( BFIN533_STAMP || BFIN533_BLUETECHNIX_CM )
+	default n
+	help
+	  Blinks the LED you select when the kernel is running. Helps detect a hung kernel.
+
+config BFIN_ALIVE_LED_NUM
+	int "LED"
+	depends on BFIN_ALIVE_LED
+	range 1 3 if BFIN533_STAMP
+	range 1 2 if BFIN533_BLUETECHNIX_CM
+	default "3" if BFIN533_STAMP
+	default "1" if BFIN533_BLUETECHNIX_CM
+	help
+	  Select the LED (marked on the board) for you to blink.
+
+config BFIN_IDLE_LED
+	bool 'Enable System Load/Idle LED'
+	depends on ( BFIN533_STAMP || BFIN533_BLUETECHNIX_CM )
+	default n
+	help
+	  Blinks the LED you select when to determine kernel load.
+
+config BFIN_IDLE_LED_NUM
+	int "LED"
+	depends on BFIN_IDLE_LED
+	range 1 3 if BFIN533_STAMP
+	range 1 2 if BFIN533_BLUETECHNIX_CM
+	default "2" if BFIN533_STAMP
+	default "2" if BFIN533_BLUETECHNIX_CM
+	help
+	  Select the LED (marked on the board) for you to blink.
+
+#
+# Sorry - but you need to put the hex address here -
+#
+
+# Flag Data register
+config BFIN_ALIVE_LED_PORT
+	hex
+	default 0xFFC00700 if (BFIN533_STAMP)
+	default 0xFFC00700 if (BFIN533_BLUETECHNIX_CM)
+
+# Peripheral Flag Direction Register
+config BFIN_ALIVE_LED_DPORT
+        hex
+        default 0xFFC00730 if (BFIN533_STAMP)
+	default 0xFFC00730 if (BFIN533_BLUETECHNIX_CM)
+
+config BFIN_ALIVE_LED_PIN
+	hex
+	default 0x04 if (BFIN533_STAMP && ( BFIN_ALIVE_LED_NUM = 1 ))
+	default 0x08 if (BFIN533_STAMP && ( BFIN_ALIVE_LED_NUM = 2 ))
+	default 0x10 if (BFIN533_STAMP && ( BFIN_ALIVE_LED_NUM = 3 ))
+	default 0x80 if (BFIN533_BLUETECHNIX_CM && ( BFIN_ALIVE_LED_NUM = 1 ))
+	default 0xC0 if (BFIN533_BLUETECHNIX_CM && ( BFIN_ALIVE_LED_NUM = 2 ))
+
+config BFIN_IDLE_LED_PORT
+        hex
+        default 0xFFC00700 if (BFIN533_STAMP)
+	default 0xFFC00700 if (BFIN533_BLUETECHNIX_CM)
+
+# Peripheral Flag Direction Register
+config BFIN_IDLE_LED_DPORT
+        hex
+        default 0xFFC00730 if (BFIN533_STAMP)
+	default 0xFFC00730 if (BFIN533_BLUETECHNIX_CM)
+
+config BFIN_IDLE_LED_PIN
+        hex
+        default 0x04 if (BFIN533_STAMP && ( BFIN_IDLE_LED_NUM = 1 ))
+        default 0x08 if (BFIN533_STAMP && ( BFIN_IDLE_LED_NUM = 2 ))
+        default 0x10 if (BFIN533_STAMP && ( BFIN_IDLE_LED_NUM = 3 ))
+        default 0x80 if (BFIN533_BLUETECHNIX_CM && ( BFIN_IDLE_LED_NUM = 1 ))
+        default 0xC0 if (BFIN533_BLUETECHNIX_CM && ( BFIN_IDLE_LED_NUM = 2 ))
+
+comment 'Console UART Setup'
+
+choice
+        prompt "Baud Rate"
+        default BAUD_57600
+config BAUD_9600
+        bool "9600"
+config BAUD_19200
+        bool "19200"
+config BAUD_38400
+        bool "38400"
+config BAUD_57600
+        bool "57600"
+config BAUD_115200
+        bool "115200"
+endchoice
+
+choice
+	prompt "Parity"
+	default BAUD_NO_PARITY
+config  BAUD_NO_PARITY
+	bool "No Parity"
+config  BAUD_PARITY
+	bool "Parity"
+endchoice
+
+choice
+	prompt "Stop Bits"
+	default BAUD_1_STOPBIT
+config  BAUD_1_STOPBIT
+	bool "1"
+config  BAUD_2_STOPBIT
+        bool "2"
+endchoice
+
+endmenu
+
+
+choice
+	prompt	"Kernel executes from"
+	---help---
+	  Choose the memory type that the kernel will be running in.
+
+config	RAMKERNEL
+	bool "RAM"
+	help
+	  The kernel will be resident in RAM when running.
+
+config	ROMKERNEL
+	bool "ROM"
+	help
+	  The kernel will be resident in FLASH/ROM when running.
+
+endchoice
+
+source "mm/Kconfig"
+
+
+config LARGE_ALLOCS
+	bool "Allow allocating large blocks (> 1MB) of memory"
+	help
+	  Allow the slab memory allocator to keep chains for very large
+	  memory sizes - upto 32MB. You may need this if your system has
+	  a lot of RAM, and you need to able to allocate very large
+	  contiguous chunks. If unsure, say N.
+
+config IRQCHIP_DEMUX_GPIO
+	bool "Enable GPIO IRQ Demultiplexing"
+	depends on BLACKFIN
+	default n
+	help
+	  Demultiplex GPIO interrupt, enabling IRQ_PF0 through IRQ_PF15
+
+comment 'DMA Support'
+choice
+	prompt	"Select DMA driver"
+	---help---
+	  Choose DMA driver implemntation
+
+config NO_DMA
+	bool 'Disable DMA Support'
+	help
+	  Disable DMA driver
+
+config BFIN_DMA_5XX
+	bool 'Enable DMA Support'
+	depends on (BF533 || BF532 || BF531 || BF537 || BF536 || BF534 || BF561)
+	help
+	  DMA driver for BF5xx
+endchoice
+
+comment 'Cache Support'
+config	BLKFIN_CACHE
+	bool "Enable ICACHE"
+config	BLKFIN_DCACHE
+	bool "Enable DCACHE"
+config 	BLKFIN_CACHE_LOCK
+	bool "Enable Cache Locking"
+
+choice
+	prompt "Policy"
+	depends on BLKFIN_DCACHE
+	default BLKFIN_WB
+config 	BLKFIN_WB
+	bool "Write back"
+config	BLKFIN_WT
+	bool "Write through"
+endchoice
+
+config UNCACHED_1M
+	bool 'Enable 1M Uncached SDRAM region'
+	default y
+	---help---
+	  Size of the uncached SDRAM region
+
+menu	"Clock Settings"
+
+config BFIN_KERNEL_CLOCK
+	bool "Re-program Clocks while Kernel boots?"
+	default n
+	help
+	  This option decides if kernel clocks are re-programed from the bootloader
+	  settings. If the clocks are not set, the SDRAM settings are also not
+	  changed, and the Bootloader does 100% of the hardware configuration.
+
+config VCO_MULT
+	int "VCO Multiplier"
+	depends on BFIN_KERNEL_CLOCK
+	default "22" if BFIN533_EZKIT
+	default "45" if BFIN533_STAMP
+	default "20" if BFIN537_STAMP
+	default "22" if BFIN533_BLUETECHNIX_CM
+	default "20" if BFIN561_EZKIT
+
+config CCLK_DIV
+	int "Core Clock Divider"
+	depends on BFIN_KERNEL_CLOCK
+	default 1 if BFIN533_EZKIT
+	default 1 if BFIN533_STAMP
+	default 1 if BFIN537_STAMP
+	default 1 if BFIN533_BLUETECHNIX_CM
+	default 1 if BFIN561_EZKIT
+
+config SCLK_DIV
+	int "System Clock Divider"
+	depends on BFIN_KERNEL_CLOCK
+	default 5 if BFIN533_EZKIT
+	default 5 if BFIN533_STAMP
+	default 4 if BFIN537_STAMP
+	default 5 if BFIN533_BLUETECHNIX_CM
+	default 5 if BFIN561_EZKIT
+
+config CLKIN_HALF
+	bool "Half ClockIn"
+	depends on BFIN_KERNEL_CLOCK
+	default n
+
+config PLL_BYPASS
+	bool "Bypass PLL"
+	depends on BFIN_KERNEL_CLOCK
+	default n
+
+endmenu
+
+comment'Asynchonous Memory Configuration'
+
+menu'EBIU_AMBCTL Global Control'
+config C_AMCKEN
+	bool "Enable CLKOUT"
+	default y
+
+config C_CDPRIO
+	bool "DMA has priority over core for ext. accesses"
+	default n
+
+config C_B0PEN
+	depends on BF561
+	bool "Bank 0 16 bit packing enable"
+	default y
+
+config C_B1PEN
+	depends on BF561
+	bool "Bank 1 16 bit packing enable"
+	default y
+
+config C_B2PEN
+	depends on BF561
+	bool "Bank 3 16 bit packing enable"
+	default y
+
+config C_B3PEN
+	depends on BF561
+	bool "Bank 3 16 bit packing enable"
+	default n
+
+choice
+	prompt"Enable Asynchonous Memory Banks"
+	default C_AMBEN_ALL
+
+config C_AMBEN
+	bool "Disable All Banks"
+
+config C_AMBEN_B0
+	bool "Enable Bank 0"
+
+config C_AMBEN_B0_B1
+	bool "Enable Bank 0 & 1"
+
+config C_AMBEN_B0_B1_B2
+	bool "Enable Bank 0 & 1 & 2"
+
+config C_AMBEN_ALL
+	bool "Enable All Banks"
+endchoice
+endmenu
+
+menu'EBIU_AMBCTL Control'
+config BANK_0
+	hex "Bank 0"
+	default 0x7BB0
+
+config BANK_1
+	hex "Bank 1"
+	default 0x7BB0
+
+config BANK_2
+	hex "Bank 2"
+	default 0x7BB0
+
+config BANK_3
+	hex "Bank 3"
+	default 0x99B3
+endmenu
+
+endmenu
+
+#############################################################################
+menu "Bus options (PCI, PCMCIA, EISA, MCA, ISA)"
+
+config PCI
+	bool "PCI support"
+	help
+	  Support for PCI bus.
+
+source "drivers/pci/Kconfig"
+
+config HOTPLUG
+	bool "Support for hot-pluggable device"
+	  ---help---
+	  Say Y here if you want to plug devices into your computer while
+	  the system is running, and be able to use them quickly.  In many
+	  cases, the devices can likewise be unplugged at any time too.
+
+	  One well known example of this is PCMCIA- or PC-cards, credit-card
+	  size devices such as network cards, modems or hard drives which are
+	  plugged into slots found on all modern laptop computers.  Another
+	  example, used on modern desktops as well as laptops, is USB.
+
+	  Enable HOTPLUG and KMOD, and build a modular kernel.  Get agent
+	  software (at <http://linux-hotplug.sourceforge.net/>) and install it.
+	  Then your kernel will automatically call out to a user mode "policy
+	  agent" (/sbin/hotplug) to load modules and set up software needed
+	  to use devices as you hotplug them.
+
+source "drivers/pcmcia/Kconfig"
+
+source "drivers/pci/hotplug/Kconfig"
+
+endmenu
+
+menu "Executable file formats"
+
+source "fs/Kconfig.binfmt"
+
+endmenu
+
+menu "Power management options"
+config PM
+	bool "Power Management support for BF533/BF537"
+	help
+	  Support processor power management modes
+endmenu
+
+if (BF537 || BF533)
+
+menu "CPU Frequency scaling"
+
+source "drivers/cpufreq/Kconfig"
+
+config CPU_FREQ
+	bool
+	default n
+	help
+	If you want to enable this option, you should select DPMC driver from Character Devices
+endmenu
+
+endif
+
+source "net/Kconfig"
+
+source "drivers/Kconfig"
+
+source "fs/Kconfig"
+
+source "arch/blackfin/oprofile/Kconfig"
+
+menu "Kernel hacking"
+
+source "lib/Kconfig.debug"
+
+config DEBUG_INFO
+	bool "Compile the kernel with debug info"
+	help
+	  If you say Y here the resulting kernel image will include
+	  debugging info resulting in a larger kernel image.
+	  Say Y here only if you plan to debug the kernel.
+
+config DEBUG_HWERR
+	bool "Hardware error interrupt debugging"
+	help
+	  When enabled, the hardware error interrupt is never disabled, and
+	  will happen immediately when an error condition occurs.  This comes
+	  at a slight cost in code size, but is necessary if you are getting
+	  hardware error interrupts and need to know where they are coming
+	  from.
+
+config DEBUG_KERNEL_START
+	bool "Debug Kernel Startup"
+	depends on DEBUG_KERNEL
+	help
+	  Say Y here to put in an mini-execption handler before the kernel
+	  replaces the bootloader exception handler. This will stop kernels
+	  from dieing at startup with no visible error messages
+
+config DEBUG_HUNT_FOR_ZERO
+	bool "Halt on reads/writes to null Pointer"
+	depends on DEBUG_KERNEL
+	help
+	  Say Y here to crash the kernel on reads/writes to anywhere in the
+	  memory range from 0x0000 - 0x0FFF (the first 4k) of memory. This
+	  can make null pointers easier to find.
+
+config BOOTPARAM
+	bool 'Compiled-in Kernel Boot Parameter'
+
+config BOOTPARAM_STRING
+	string 'Kernel Boot Parameter'
+	default 'console=ttyS0,19200'
+	depends on BOOTPARAM
+
+config NO_KERNEL_MSG
+	bool "Suppress Kernel BUG Messages"
+	help
+	  Do not output any debug BUG messages within the kernel.
+
+config CPLB_INFO
+	bool "Display the CPLB information"
+	help
+	  Display the CPLB information.
+endmenu
+
+source "security/Kconfig"
+
+source "crypto/Kconfig"
+
+source "lib/Kconfig"
+
+
+
+
Index: git/linux-2.6/arch/blackfin/Kconfig.ide
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/Kconfig.ide	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,88 @@
+# uClinux Blackfin Target Board Selection Menu (IDE)
+
+if (BFIN)
+menu "IDE Extra configuration"
+
+config BFIN_IDE_BASE
+	hex "IDE register base address"
+	depends on IDE
+	default 0x20304020
+	help
+	  IDE registers base address
+
+config BFIN_IDE_ALT
+	hex "IDE register alternate address"
+	depends on IDE
+	default 0x2030401C
+	help
+	  IDE alternate registers address
+
+config BFIN_IDE_IRQ
+	int "IDE IRQ no"
+	depends on IDE
+	default "34" if BFIN537_STAMP
+	default "26" if BFIN533_STAMP
+	help
+	  IDE use IRQ no IRQ_PROG_INTA
+
+config BFIN_IDE_IRQ_PFX
+	int "IDE IRQ PFx no"
+	depends on IDE
+	default 55
+	help
+	  IDE IRQ use PFx
+
+choice
+	prompt	"IDE Interface Address Mapping (see help)"
+	depends on IDE
+	default BFIN_IDE_ADDRESS_MAPPING_MODE0
+
+config BFIN_IDE_ADDRESS_MAPPING_MODE0
+	bool "Linear 16-bit mapping with reg spacing"
+	help
+	  Blackfin 	HDD
+	  A1 	  -->	A0
+	  A2	  -->	A1
+	  A3	  -->	A2
+	  A4 +AMSx  -->	/CS0
+	  A5 +AMSx  -->	/CS1
+	  /ARE	  -->	/IOR
+	  /AWE	  -->	/IOW
+	  PFx	  <--	/INTRQ
+	  /RESET	  -->	/RESET
+	  D[0..15]  <->	D[0..15]
+
+	  For CF Cards in TRUE IDE MODE only
+	  VCC	  <--	/REG
+	  VCC	  <--	/WE
+	  GND	  <--	/ATA_SEL
+
+config BFIN_IDE_ADDRESS_MAPPING_MODE1
+	bool "16-bit mapping for multimode CF Interface"
+	help
+	  Blackfin 	HDD
+	  Ax 	  -->	A0
+	  A1	  -->	A1
+	  A2	  -->	A2
+	  A4 +AMSx  -->	/CS0
+	  A5 +AMSx  -->	/CS1
+	  /ARE	  -->	/IOR
+	  /AWE	  -->	/IOW
+	  PFx	  <--	/INTRQ
+	  /RESET	  -->	/RESET
+	  D[0..15]  <->	D[0..15]
+
+	  For CF Cards in TRUE IDE MODE only
+	  VCC	  <--	/REG
+	  VCC	  <--	/WE
+	  GND	  <--	/ATA_SEL
+endchoice
+
+config BFIN_IDE_ADDRESS_AX
+	int "Blackfin A[x] used as CF A0"
+	depends on BFIN_IDE_ADDRESS_MAPPING_MODE1
+	default 13
+	help
+
+endmenu
+endif
Index: git/linux-2.6/arch/blackfin/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/Makefile	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,85 @@
+#
+# arch/blackfin/Makefile
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+
+CROSS_COMPILE	:= bfin-uclinux-
+LDFLAGS_vmlinux	:= -X
+LDFLAGS_BLOB	:=--format binary -elf32-bfin
+OBJCOPYFLAGS	:=-O binary -R .note -R .comment -S
+GZFLAGS		:=-9
+CFLAGS		+=-D__linux__
+BFIN_TARGET 	= vmlinux
+
+CFLAGS_MODULE   += -mlong-calls
+KALLSYMS	+= --symbol-prefix=_
+
+comma = ,
+
+# These are the default values for independt
+PROCESSOR	:= bf5xx
+
+# setup the machine name and the machine dependent settings
+
+machine-$(CONFIG_BF533) := bf533
+machine-$(CONFIG_BF532) := bf533
+machine-$(CONFIG_BF531) := bf533
+machine-$(CONFIG_BF534) := bf537
+machine-$(CONFIG_BF536) := bf537
+machine-$(CONFIG_BF535) := bf535
+machine-$(CONFIG_BF537) := bf537
+machine-$(CONFIG_BF561) := bf561
+
+# set the environment variables and export
+MACHINE  := $(machine-y)
+
+export	MACHINE PROCESSOR GZFLAGS CFLAGS_BOOT
+
+CLEAN_FILES := include/asm-$(ARCH)/asm-offsets.h \
+	       arch/$(ARCH)/kernel/asm-offsets.s include/asm-$(ARCH)/mach include/asm-blackfin/.mach
+
+# The machine has its own head.S
+
+head-y	:= arch/$(ARCH)/mach-$(MACHINE)/head.o
+
+# add the init_task to head
+
+head-y		+= arch/$(ARCH)/kernel/init_task.o
+
+core-y		+= arch/$(ARCH)/kernel/ arch/$(ARCH)/mm/
+
+core-y		+= arch/$(ARCH)/mach-common/
+
+# must be linked after kernel/
+drivers-$(CONFIG_OPROFILE)              += arch/$(ARCH)/oprofile/
+
+
+# If we have a machine-specific directory, then include it in the build.
+ifneq ($(machine-y),)
+core-y		+= arch/$(ARCH)/mach-$(MACHINE)/
+core-y		+= arch/$(ARCH)/mach-$(MACHINE)/boards/
+endif
+
+libs-y		+= arch/$(ARCH)/lib/
+
+#	Update machine arch symlinks if something which affects
+#	them changed.  We use .arch to indicate when they were updated
+#	last, otherwise make uses the target directory mtime.
+
+include/asm-blackfin/.mach:
+	@echo '  SYMLINK include/asm-$(ARCH)/arch -> include/asm-$(ARCH)/$(INCDIR)'
+ifneq ($(KBUILD_SRC),)
+	$(Q)mkdir -p include/asm-$(ARCH)
+	$(Q)ln -fsn $(srctree)/include/asm-$(ARCH)/mach-$(MACHINE) include/asm-$(ARCH)/mach
+else
+	$(Q)ln -fsn mach-$(MACHINE) include/asm-$(ARCH)/mach
+endif
+	@touch $@
+
+archprepare: include/asm-blackfin/.mach
+archclean:
+
+
Index: git/linux-2.6/arch/blackfin/defconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/defconfig	2005-12-21 16:10:27.000000000 +0800
@@ -0,0 +1,772 @@
+#
+# Automatically generated make config: don't edit
+#
+# CONFIG_MMU is not set
+# CONFIG_FPU is not set
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_BFIN=y
+CONFIG_UCLINUX=y
+CONFIG_FORCE_MAX_ZONEORDER=14
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+# CONFIG_FUTEX is not set
+CONFIG_EPOLL=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# Block layer
+#
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# Blackfin Processor Options
+#
+
+#
+# Processor and Board Settings
+#
+CONFIG_BF533=y
+# CONFIG_BF532 is not set
+# CONFIG_BF531 is not set
+# CONFIG_BF534 is not set
+# CONFIG_BF535 is not set
+# CONFIG_BF536 is not set
+# CONFIG_BF537 is not set
+# CONFIG_BF561 is not set
+CONFIG_BLACKFIN=y
+CONFIG_BFIN_SINGLE_CORE=y
+# CONFIG_BFIN533_EZKIT is not set
+CONFIG_BFIN533_STAMP=y
+# CONFIG_BFIN537_STAMP is not set
+# CONFIG_BFIN533_BLUETECHNIX_CM is not set
+# CONFIG_BFIN561_EZKIT is not set
+# CONFIG_GENERIC_BOARD is not set
+CONFIG_MEM_MT48LC64M4A2FB_7E=y
+CONFIG_BFIN_SHARED_FLASH_ENET=y
+
+#
+# Platform
+#
+#CONFIG_EZKIT is not set
+CONFIG_STAMP=y
+CONFIG_RAMKERNEL=y
+# CONFIG_ROMKERNEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_LARGE_ALLOCS=y
+# CONFIG_IRQCHIP_DEMUX_GPIO is not set
+
+#
+# DMA Support
+#
+# CONFIG_NO_DMA is not set
+CONFIG_BFIN_DMA_5XX=y
+
+#
+# Cache Support
+#
+CONFIG_BLKFIN_CACHE=y
+CONFIG_BLKFIN_DCACHE=y
+# CONFIG_BLKFIN_CACHE_LOCK is not set
+# CONFIG_BLKFIN_WB is not set
+CONFIG_BLKFIN_WT=y
+CONFIG_UNCACHED_1M=y
+
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_RAM=y
+CONFIG_MTD_ROM=m
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+CONFIG_MTD_UCLINUX=y
+CONFIG_MTD_PLATRAM=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_SMC91X=y
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_BLACKFIN=y
+CONFIG_SERIAL_BLACKFIN_DMA=y
+# CONFIG_SERIAL_BLACKFIN_PIO is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=m
+CONFIG_SND_TIMER=m
+CONFIG_SND_PCM=m
+CONFIG_SND_SEQUENCER=m
+CONFIG_SND_SEQ_DUMMY=m
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=m
+CONFIG_SND_PCM_OSS=m
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SND_VERBOSE_PRINTK=y
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_VIRMIDI is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+# CONFIG_USB_ARCH_HAS_HCD is not set
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=m
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DETECT_SOFTLOCKUP is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_DEBUG_HWERR is not set
+# CONFIG_DEBUG_KERNEL_START is not set
+# CONFIG_DEBUG_HUNT_FOR_ZERO is not set
+# CONFIG_BOOTPARAM is not set
+# CONFIG_NO_KERNEL_MSG is not set
+CONFIG_CPLB_INFO=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+CONFIG_SECURITY=y
+# CONFIG_SECURITY_NETWORK is not set
+CONFIG_SECURITY_CAPABILITIES=y
+# CONFIG_SECURITY_SECLVL is not set
+# CONFIG_SECURITY_SELINUX is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
Index: git/linux-2.6/arch/blackfin/kernel/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/kernel/Makefile	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,9 @@
+# Makefile for the linux kernel.
+# modified for uClinux.
+#
+extra-y += init_task.o vmlinux.lds
+# Object file lists.
+obj-y:= entry.o process.o bfin_ksyms.o ptrace.o semaphore.o setup.o signal.o sys_bfin.o time.o traps.o irqchip.o dma-mapping.o
+
+obj-$(CONFIG_MODULES)		+= module.o
+obj-$(CONFIG_BFIN_DMA_5XX)	+= bfin_dma_5xx.o
Index: git/linux-2.6/arch/blackfin/kernel/asm-offsets.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/kernel/asm-offsets.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,135 @@
+/*
+ * File:         arch/blackfin/kernel/asm-offsets.c
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:  generate definitions needed by assembly language modules.
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/stddef.h>
+#include <linux/sched.h>
+#include <linux/kernel_stat.h>
+#include <linux/ptrace.h>
+#include <linux/hardirq.h>
+#include <asm/irq.h>
+#include <asm/thread_info.h>
+
+#define DEFINE(sym, val) \
+        asm volatile("\n->" #sym " %0 " #val : : "i" (val))
+
+int main(void)
+{
+	/* offsets into the task struct */
+	DEFINE(TASK_STATE, offsetof(struct task_struct, state));
+	DEFINE(TASK_FLAGS, offsetof(struct task_struct, flags));
+	DEFINE(TASK_PTRACE, offsetof(struct task_struct, ptrace));
+	DEFINE(TASK_BLOCKED, offsetof(struct task_struct, blocked));
+	DEFINE(TASK_THREAD, offsetof(struct task_struct, thread));
+	DEFINE(TASK_THREAD_INFO, offsetof(struct task_struct, thread_info));
+	DEFINE(TASK_MM, offsetof(struct task_struct, mm));
+	DEFINE(TASK_ACTIVE_MM, offsetof(struct task_struct, active_mm));
+	DEFINE(TASK_SIGPENDING, offsetof(struct task_struct, pending));
+
+	/* offsets into the irq_cpustat_t struct */
+	DEFINE(CPUSTAT_SOFTIRQ_PENDING,
+	       offsetof(irq_cpustat_t, __softirq_pending));
+
+	/* offsets into the thread struct */
+	DEFINE(THREAD_KSP, offsetof(struct thread_struct, ksp));
+	DEFINE(THREAD_USP, offsetof(struct thread_struct, usp));
+	DEFINE(THREAD_SR, offsetof(struct thread_struct, seqstat));
+	DEFINE(PT_SR, offsetof(struct thread_struct, seqstat));
+	DEFINE(THREAD_ESP0, offsetof(struct thread_struct, esp0));
+	DEFINE(THREAD_PC, offsetof(struct thread_struct, pc));
+	DEFINE(KERNEL_STACK_SIZE, THREAD_SIZE);
+
+	/* offsets into the pt_regs */
+	DEFINE(PT_ORIG_P0, offsetof(struct pt_regs, orig_p0));
+	DEFINE(PT_ORIG_PC, offsetof(struct pt_regs, orig_pc));
+	DEFINE(PT_R0, offsetof(struct pt_regs, r0));
+	DEFINE(PT_R1, offsetof(struct pt_regs, r1));
+	DEFINE(PT_R2, offsetof(struct pt_regs, r2));
+	DEFINE(PT_R3, offsetof(struct pt_regs, r3));
+	DEFINE(PT_R4, offsetof(struct pt_regs, r4));
+	DEFINE(PT_R5, offsetof(struct pt_regs, r5));
+	DEFINE(PT_R6, offsetof(struct pt_regs, r6));
+	DEFINE(PT_R7, offsetof(struct pt_regs, r7));
+
+	DEFINE(PT_P0, offsetof(struct pt_regs, p0));
+	DEFINE(PT_P1, offsetof(struct pt_regs, p1));
+	DEFINE(PT_P2, offsetof(struct pt_regs, p2));
+	DEFINE(PT_P3, offsetof(struct pt_regs, p3));
+	DEFINE(PT_P4, offsetof(struct pt_regs, p4));
+	DEFINE(PT_P5, offsetof(struct pt_regs, p5));
+
+	DEFINE(PT_FP, offsetof(struct pt_regs, fp));
+	DEFINE(PT_USP, offsetof(struct pt_regs, usp));
+	DEFINE(PT_I0, offsetof(struct pt_regs, i0));
+	DEFINE(PT_I1, offsetof(struct pt_regs, i1));
+	DEFINE(PT_I2, offsetof(struct pt_regs, i2));
+	DEFINE(PT_I3, offsetof(struct pt_regs, i3));
+	DEFINE(PT_M0, offsetof(struct pt_regs, m0));
+	DEFINE(PT_M1, offsetof(struct pt_regs, m1));
+	DEFINE(PT_M2, offsetof(struct pt_regs, m2));
+	DEFINE(PT_M3, offsetof(struct pt_regs, m3));
+	DEFINE(PT_L0, offsetof(struct pt_regs, l0));
+	DEFINE(PT_L1, offsetof(struct pt_regs, l1));
+	DEFINE(PT_L2, offsetof(struct pt_regs, l2));
+	DEFINE(PT_L3, offsetof(struct pt_regs, l3));
+	DEFINE(PT_B0, offsetof(struct pt_regs, b0));
+	DEFINE(PT_B1, offsetof(struct pt_regs, b1));
+	DEFINE(PT_B2, offsetof(struct pt_regs, b2));
+	DEFINE(PT_B3, offsetof(struct pt_regs, b3));
+	DEFINE(PT_A0X, offsetof(struct pt_regs, a0x));
+	DEFINE(PT_A0W, offsetof(struct pt_regs, a0w));
+	DEFINE(PT_A1X, offsetof(struct pt_regs, a1x));
+	DEFINE(PT_A1W, offsetof(struct pt_regs, a1w));
+	DEFINE(PT_LC0, offsetof(struct pt_regs, lc0));
+	DEFINE(PT_LC1, offsetof(struct pt_regs, lc1));
+	DEFINE(PT_LT0, offsetof(struct pt_regs, lt0));
+	DEFINE(PT_LT1, offsetof(struct pt_regs, lt1));
+	DEFINE(PT_LB0, offsetof(struct pt_regs, lb0));
+	DEFINE(PT_LB1, offsetof(struct pt_regs, lb1));
+	DEFINE(PT_ASTAT, offsetof(struct pt_regs, astat));
+	DEFINE(PT_RESERVED, offsetof(struct pt_regs, reserved));
+	DEFINE(PT_RETS, offsetof(struct pt_regs, rets));
+	DEFINE(PT_PC, offsetof(struct pt_regs, pc));
+	DEFINE(PT_RETX, offsetof(struct pt_regs, retx));
+	DEFINE(PT_RETN, offsetof(struct pt_regs, retn));
+	DEFINE(PT_RETE, offsetof(struct pt_regs, rete));
+	DEFINE(PT_SEQSTAT, offsetof(struct pt_regs, seqstat));
+	DEFINE(PT_SYSCFG, offsetof(struct pt_regs, syscfg));
+	DEFINE(PT_IPEND, offsetof(struct pt_regs, ipend));
+	DEFINE(SIZEOF_PTREGS, sizeof(struct pt_regs));
+	DEFINE(PT_EXTRA1, sizeof(struct pt_regs));	/* Needed by gdb */
+	DEFINE(PT_EXTRA2, 4 + sizeof(struct pt_regs));	/* Needed by gdb */
+	DEFINE(PT_EXTRA3, 8 + sizeof(struct pt_regs));	/* Needed by gdb */
+
+	/* signal defines */
+	DEFINE(SIGSEGV, SIGSEGV);
+	DEFINE(SIGTRAP, SIGTRAP);
+
+	return 0;
+}
Index: git/linux-2.6/arch/blackfin/kernel/bfin_dma_5xx.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/kernel/bfin_dma_5xx.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,558 @@
+/*
+ * File:         arch/blackfin/kernel/simple_dma.c
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:  This file contains the simple DMA Implementation for Blackfin
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http:    //blackfin.uclinux.org/
+ *
+ * This program is free software ;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation ;  either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY ;  without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program ;  see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/param.h>
+#include <asm/irqchip.h>
+
+#include <asm/dma.h>
+
+/* Remove unused code not exported by symbol or internally called */
+#define REMOVE_DEAD_CODE
+
+#define SSYNC __builtin_bfin_ssync()
+
+/**************************************************************************
+ * Global Variables
+***************************************************************************/
+
+static dma_channel_t dma_ch[MAX_BLACKFIN_DMA_CHANNEL];
+#if defined (CONFIG_BF561)
+static dma_register_t *base_addr[MAX_BLACKFIN_DMA_CHANNEL] = {
+	(dma_register_t *) DMA1_0_NEXT_DESC_PTR,
+	(dma_register_t *) DMA1_1_NEXT_DESC_PTR,
+	(dma_register_t *) DMA1_2_NEXT_DESC_PTR,
+	(dma_register_t *) DMA1_3_NEXT_DESC_PTR,
+	(dma_register_t *) DMA1_4_NEXT_DESC_PTR,
+	(dma_register_t *) DMA1_5_NEXT_DESC_PTR,
+	(dma_register_t *) DMA1_6_NEXT_DESC_PTR,
+	(dma_register_t *) DMA1_7_NEXT_DESC_PTR,
+	(dma_register_t *) DMA1_8_NEXT_DESC_PTR,
+	(dma_register_t *) DMA1_9_NEXT_DESC_PTR,
+	(dma_register_t *) DMA1_10_NEXT_DESC_PTR,
+	(dma_register_t *) DMA1_11_NEXT_DESC_PTR,
+	(dma_register_t *) DMA2_0_NEXT_DESC_PTR,
+	(dma_register_t *) DMA2_1_NEXT_DESC_PTR,
+	(dma_register_t *) DMA2_2_NEXT_DESC_PTR,
+	(dma_register_t *) DMA2_3_NEXT_DESC_PTR,
+	(dma_register_t *) DMA2_4_NEXT_DESC_PTR,
+	(dma_register_t *) DMA2_5_NEXT_DESC_PTR,
+	(dma_register_t *) DMA2_6_NEXT_DESC_PTR,
+	(dma_register_t *) DMA2_7_NEXT_DESC_PTR,
+	(dma_register_t *) DMA2_8_NEXT_DESC_PTR,
+	(dma_register_t *) DMA2_9_NEXT_DESC_PTR,
+	(dma_register_t *) DMA2_10_NEXT_DESC_PTR,
+	(dma_register_t *) DMA2_11_NEXT_DESC_PTR,
+	(dma_register_t *) MDMA1_D0_NEXT_DESC_PTR,
+	(dma_register_t *) MDMA1_S0_NEXT_DESC_PTR,
+	(dma_register_t *) MDMA1_D1_NEXT_DESC_PTR,
+	(dma_register_t *) MDMA1_S1_NEXT_DESC_PTR,
+	(dma_register_t *) MDMA2_D0_NEXT_DESC_PTR,
+	(dma_register_t *) MDMA2_S0_NEXT_DESC_PTR,
+	(dma_register_t *) MDMA2_D1_NEXT_DESC_PTR,
+	(dma_register_t *) MDMA2_S1_NEXT_DESC_PTR,
+	(dma_register_t *) IMDMA_D0_NEXT_DESC_PTR,
+	(dma_register_t *) IMDMA_S0_NEXT_DESC_PTR,
+	(dma_register_t *) IMDMA_D1_NEXT_DESC_PTR,
+	(dma_register_t *) IMDMA_S1_NEXT_DESC_PTR,
+};
+#else
+static dma_register_t *base_addr[MAX_BLACKFIN_DMA_CHANNEL] = {
+	(dma_register_t *) DMA0_NEXT_DESC_PTR,
+	(dma_register_t *) DMA1_NEXT_DESC_PTR,
+	(dma_register_t *) DMA2_NEXT_DESC_PTR,
+	(dma_register_t *) DMA3_NEXT_DESC_PTR,
+	(dma_register_t *) DMA4_NEXT_DESC_PTR,
+	(dma_register_t *) DMA5_NEXT_DESC_PTR,
+	(dma_register_t *) DMA6_NEXT_DESC_PTR,
+	(dma_register_t *) DMA7_NEXT_DESC_PTR,
+#if (defined(CONFIG_BF537) || defined(CONFIG_BF534) || defined(CONFIG_BF536))
+	(dma_register_t *) DMA8_NEXT_DESC_PTR,
+	(dma_register_t *) DMA9_NEXT_DESC_PTR,
+	(dma_register_t *) DMA10_NEXT_DESC_PTR,
+	(dma_register_t *) DMA11_NEXT_DESC_PTR,
+#endif
+	(dma_register_t *) MDMA_D0_NEXT_DESC_PTR,
+	(dma_register_t *) MDMA_S0_NEXT_DESC_PTR,
+	(dma_register_t *) MDMA_D1_NEXT_DESC_PTR,
+	(dma_register_t *) MDMA_S1_NEXT_DESC_PTR,
+};
+#endif
+
+/*------------------------------------------------------------------------------
+ *       Set the Buffer Clear bit in the Configuration register of specific DMA
+ *       channel. This will stop the descriptor based DMA operation.
+ *-----------------------------------------------------------------------------*/
+static void clear_dma_buffer(unsigned int channel)
+{
+	dma_ch[channel].regs->cfg |= RESTART;
+	SSYNC;
+	dma_ch[channel].regs->cfg &= ~RESTART;
+	SSYNC;
+}
+
+int __init blackfin_dma_init(void)
+{
+	int i;
+#if defined (CONFIG_BF561)
+	printk("Blackfin DMA Controller for BF561\n");
+#else
+	printk("Blackfin DMA Controller for BF533\n");
+#endif
+	for (i = 0; i < MAX_BLACKFIN_DMA_CHANNEL; i++) {
+		dma_ch[i].chan_status = DMA_CHANNEL_FREE;
+		dma_ch[i].regs = base_addr[i];
+		init_MUTEX(&(dma_ch[i].dmalock));
+	}
+
+	return 0;
+}
+
+arch_initcall(blackfin_dma_init);
+
+/*
+ *	Form the channel find the irq number for that channel.
+ */
+static int bf533_channel2irq(unsigned int channel)
+{
+	int ret_irq = -1;
+
+	switch (channel) {
+	case CH_PPI:
+		ret_irq = IRQ_PPI;
+		break;
+
+#if (defined(CONFIG_BF537) || defined(CONFIG_BF534) || defined(CONFIG_BF536))
+
+	case CH_EMAC_RX:
+		ret_irq = IRQ_MAC_RX;
+		break;
+
+	case CH_EMAC_TX:
+		ret_irq = IRQ_MAC_TX;
+		break;
+
+	case CH_UART1_RX:
+		ret_irq = IRQ_UART1_RX;
+		break;
+
+	case CH_UART1_TX:
+		ret_irq = IRQ_UART1_TX;
+		break;
+#endif
+
+	case CH_SPORT0_RX:
+		ret_irq = IRQ_SPORT0_RX;
+		break;
+
+	case CH_SPORT0_TX:
+		ret_irq = IRQ_SPORT0_TX;
+		break;
+
+	case CH_SPORT1_RX:
+		ret_irq = IRQ_SPORT1_RX;
+		break;
+
+	case CH_SPORT1_TX:
+		ret_irq = IRQ_SPORT1_TX;
+		break;
+
+	case CH_SPI:
+		ret_irq = IRQ_SPI;
+		break;
+
+	case CH_UART_RX:
+		ret_irq = IRQ_UART_RX;
+		break;
+
+	case CH_UART_TX:
+		ret_irq = IRQ_UART_TX;
+		break;
+
+	case CH_MEM_STREAM0_SRC:
+	case CH_MEM_STREAM0_DEST:
+		ret_irq = IRQ_MEM_DMA0;
+		break;
+
+	case CH_MEM_STREAM1_SRC:
+	case CH_MEM_STREAM1_DEST:
+		ret_irq = IRQ_MEM_DMA1;
+		break;
+	}
+	return ret_irq;
+}
+
+#if defined (CONFIG_BF561)
+static int bf561_channel2irq(unsigned int channel)
+{
+	int ret_irq = -1;
+
+	switch (channel) {
+	case CH_PPI0:
+		ret_irq = IRQ_PPI0;
+		break;
+	case CH_PPI1:
+		ret_irq = IRQ_PPI1;
+		break;
+	case CH_SPORT0_RX:
+		ret_irq = IRQ_SPORT0_RX;
+		break;
+	case CH_SPORT0_TX:
+		ret_irq = IRQ_SPORT0_TX;
+		break;
+	case CH_SPORT1_RX:
+		ret_irq = IRQ_SPORT1_RX;
+		break;
+	case CH_SPORT1_TX:
+		ret_irq = IRQ_SPORT1_TX;
+		break;
+	case CH_SPI:
+		ret_irq = IRQ_SPI;
+		break;
+	case CH_UART_RX:
+		ret_irq = IRQ_UART_RX;
+		break;
+	case CH_UART_TX:
+		ret_irq = IRQ_UART_TX;
+		break;
+
+	case CH_MEM_STREAM0_SRC:
+	case CH_MEM_STREAM0_DEST:
+		ret_irq = IRQ_MEM_DMA0;
+		break;
+	case CH_MEM_STREAM1_SRC:
+	case CH_MEM_STREAM1_DEST:
+		ret_irq = IRQ_MEM_DMA1;
+		break;
+	case CH_MEM_STREAM2_SRC:
+	case CH_MEM_STREAM2_DEST:
+		ret_irq = IRQ_MEM_DMA2;
+		break;
+	case CH_MEM_STREAM3_SRC:
+	case CH_MEM_STREAM3_DEST:
+		ret_irq = IRQ_MEM_DMA3;
+		break;
+
+	case CH_IMEM_STREAM0_SRC:
+	case CH_IMEM_STREAM0_DEST:
+		ret_irq = IRQ_IMEM_DMA0;
+		break;
+	case CH_IMEM_STREAM1_SRC:
+	case CH_IMEM_STREAM1_DEST:
+		ret_irq = IRQ_IMEM_DMA1;
+		break;
+	}
+	return ret_irq;
+}
+#endif
+
+#if defined (CONFIG_BF561)
+#define channel2irq(channel) bf561_channel2irq(channel)
+#else
+#define channel2irq(channel) bf533_channel2irq(channel)
+#endif
+/*------------------------------------------------------------------------------
+ *	Request the specific DMA channel from the system.
+ *-----------------------------------------------------------------------------*/
+int request_dma(unsigned int channel, char *device_id)
+{
+
+	DMA_DBG("request_dma() : BEGIN \n");
+	down(&(dma_ch[channel].dmalock));
+
+	if ((dma_ch[channel].chan_status == DMA_CHANNEL_REQUESTED)
+	    || (dma_ch[channel].chan_status == DMA_CHANNEL_ENABLED)) {
+		up(&(dma_ch[channel].dmalock));
+		DMA_DBG("DMA CHANNEL IN USE  \n");
+		return -EBUSY;
+	} else {
+		dma_ch[channel].chan_status = DMA_CHANNEL_REQUESTED;
+		DMA_DBG("DMA CHANNEL IS ALLOCATED  \n");
+	}
+
+	up(&(dma_ch[channel].dmalock));
+
+	dma_ch[channel].device_id = device_id;
+
+	/* This is to be enabled by putting a restriction -
+	   you have to request DMA , before doing any operations on
+	   descriptor/channel
+	 */
+	DMA_DBG("request_dma() : END  \n");
+	return channel;
+}
+
+int set_dma_callback(unsigned int channel, dma_interrupt_t callback, void *data)
+{
+	int ret_irq = 0;
+
+	assert(dma_ch[channel].chan_status != DMA_CHANNEL_FREE
+	       || channel < MAX_BLACKFIN_DMA_CHANNEL);
+
+	if (callback != NULL) {
+		int ret_val;
+		ret_irq = channel2irq(channel);
+
+		dma_ch[channel].data = data;
+
+		ret_val =
+		    request_irq(ret_irq, (void *)callback, SA_INTERRUPT,
+				dma_ch[channel].device_id, data);
+		if (ret_val) {
+			printk("Request irq in DMA engine failed.\n");
+			return -EPERM;
+		}
+	}
+	return 0;
+}
+
+void free_dma(unsigned int channel)
+{
+	int ret_irq = 0;
+
+	DMA_DBG("freedma() : BEGIN \n");
+
+	assert(dma_ch[channel].chan_status != DMA_CHANNEL_FREE
+	       || channel < MAX_BLACKFIN_DMA_CHANNEL);
+
+	/* Halt the DMA */
+	disable_dma(channel);
+	clear_dma_buffer(channel);
+	ret_irq = channel2irq(channel);
+	free_irq(ret_irq, dma_ch[channel].data);
+
+	/* Clear the DMA Variable in the Channel */
+	down(&(dma_ch[channel].dmalock));
+	dma_ch[channel].chan_status = DMA_CHANNEL_FREE;
+	up(&(dma_ch[channel].dmalock));
+
+	DMA_DBG("freedma() : END \n");
+}
+
+int dma_channel_active(unsigned int channel)
+{
+	if (dma_ch[channel].chan_status == DMA_CHANNEL_FREE) {
+		return 0;
+	} else {
+		return 1;
+	}
+}
+
+/*------------------------------------------------------------------------------
+*	stop the specific DMA channel.
+*-----------------------------------------------------------------------------*/
+void disable_dma(unsigned int channel)
+{
+	DMA_DBG("stop_dma() : BEGIN \n");
+
+	assert(dma_ch[channel].chan_status != DMA_CHANNEL_FREE
+	       && channel < MAX_BLACKFIN_DMA_CHANNEL);
+
+	dma_ch[channel].regs->cfg &= ~DMAEN;	/* Clean the enable bit */
+	SSYNC;
+	dma_ch[channel].chan_status = DMA_CHANNEL_REQUESTED;
+	/* Needs to be enabled Later */
+	DMA_DBG("stop_dma() : END \n");
+	return;
+}
+
+void enable_dma(unsigned int channel)
+{
+	DMA_DBG("enable_dma() : BEGIN \n");
+
+	assert(dma_ch[channel].chan_status != DMA_CHANNEL_FREE
+	       && channel < MAX_BLACKFIN_DMA_CHANNEL);
+
+	dma_ch[channel].chan_status = DMA_CHANNEL_ENABLED;
+	dma_ch[channel].regs->curr_x_count = 0;
+	dma_ch[channel].regs->curr_y_count = 0;
+
+	dma_ch[channel].regs->cfg |= DMAEN;	/* Set the enable bit */
+	SSYNC;
+	DMA_DBG("enable_dma() : END \n");
+	return;
+}
+
+/*------------------------------------------------------------------------------
+*		Set the Start Address register for the specific DMA channel
+* 		This function can be used for register based DMA,
+*		to setup the start address
+*		addr:		Starting address of the DMA Data to be transferred.
+*-----------------------------------------------------------------------------*/
+void set_dma_start_addr(unsigned int channel, unsigned long addr)
+{
+	DMA_DBG("set_dma_start_addr() : BEGIN \n");
+
+	assert(dma_ch[channel].chan_status != DMA_CHANNEL_FREE
+	       && channel < MAX_BLACKFIN_DMA_CHANNEL);
+
+	dma_ch[channel].regs->start_addr = addr;
+	SSYNC;
+	DMA_DBG("set_dma_start_addr() : END\n");
+}
+
+void set_dma_x_count(unsigned int channel, unsigned short x_count)
+{
+	assert(dma_ch[channel].chan_status != DMA_CHANNEL_FREE
+	       && channel < MAX_BLACKFIN_DMA_CHANNEL);
+
+	dma_ch[channel].regs->x_count = x_count;
+	SSYNC;
+}
+
+void set_dma_y_count(unsigned int channel, unsigned short y_count)
+{
+	assert(dma_ch[channel].chan_status != DMA_CHANNEL_FREE
+	       && channel < MAX_BLACKFIN_DMA_CHANNEL);
+
+	dma_ch[channel].regs->y_count = y_count;
+	SSYNC;
+}
+
+void set_dma_x_modify(unsigned int channel, unsigned short x_modify)
+{
+	assert(dma_ch[channel].chan_status != DMA_CHANNEL_FREE
+	       && channel < MAX_BLACKFIN_DMA_CHANNEL);
+
+	dma_ch[channel].regs->x_modify = x_modify;
+	SSYNC;
+}
+
+void set_dma_y_modify(unsigned int channel, unsigned short y_modify)
+{
+	assert(dma_ch[channel].chan_status != DMA_CHANNEL_FREE
+	       && channel < MAX_BLACKFIN_DMA_CHANNEL);
+
+	dma_ch[channel].regs->y_modify = y_modify;
+	SSYNC;
+}
+
+void set_dma_config(unsigned int channel, unsigned short config)
+{
+	assert(dma_ch[channel].chan_status != DMA_CHANNEL_FREE
+	       && channel < MAX_BLACKFIN_DMA_CHANNEL);
+
+	dma_ch[channel].regs->cfg = config;
+	SSYNC;
+}
+
+unsigned short
+set_bfin_dma_config(char direction, char flow_mode,
+		    char intr_mode, char dma_mode, char width)
+{
+	unsigned short config;
+
+	config =
+	    ((direction << 1) | (width << 2) | (dma_mode << 4) |
+	     (intr_mode << 6) | (flow_mode << 12) | RESTART);
+	return config;
+}
+
+void set_dma_sg(unsigned int channel, dmasg_t * sg, int nr_sg)
+{
+	assert(dma_ch[channel].chan_status != DMA_CHANNEL_FREE
+	       && channel < MAX_BLACKFIN_DMA_CHANNEL);
+
+	dma_ch[channel].regs->cfg |= ((nr_sg & 0x0F) << 8);
+
+	dma_ch[channel].regs->next_desc_ptr = (unsigned int)sg;
+
+	SSYNC;
+}
+
+/*------------------------------------------------------------------------------
+ *	Get the DMA status of a specific DMA channel from the system.
+ *-----------------------------------------------------------------------------*/
+unsigned short get_dma_curr_irqstat(unsigned int channel)
+{
+	assert(dma_ch[channel].chan_status != DMA_CHANNEL_FREE
+	       && channel < MAX_BLACKFIN_DMA_CHANNEL);
+
+	return dma_ch[channel].regs->irq_status;
+}
+
+/*------------------------------------------------------------------------------
+ *	Clear the DMA_DONE bit in DMA status. Stop the DMA completion interrupt.
+ *-----------------------------------------------------------------------------*/
+void clear_dma_irqstat(unsigned int channel)
+{
+	assert(dma_ch[channel].chan_status != DMA_CHANNEL_FREE
+	       && channel < MAX_BLACKFIN_DMA_CHANNEL);
+	dma_ch[channel].regs->irq_status |= 3;
+}
+
+/*------------------------------------------------------------------------------
+ *	Get current DMA xcount of a specific DMA channel from the system.
+ *-----------------------------------------------------------------------------*/
+unsigned short get_dma_curr_xcount(unsigned int channel)
+{
+	assert(dma_ch[channel].chan_status != DMA_CHANNEL_FREE
+	       && channel < MAX_BLACKFIN_DMA_CHANNEL);
+
+	return dma_ch[channel].regs->curr_x_count;
+}
+
+/*------------------------------------------------------------------------------
+ *	Get current DMA ycount of a specific DMA channel from the system.
+ *-----------------------------------------------------------------------------*/
+unsigned short get_dma_curr_ycount(unsigned int channel)
+{
+	assert(dma_ch[channel].chan_status != DMA_CHANNEL_FREE
+	       && channel < MAX_BLACKFIN_DMA_CHANNEL);
+
+	return dma_ch[channel].regs->curr_y_count;
+}
+
+EXPORT_SYMBOL(request_dma);
+EXPORT_SYMBOL(set_dma_callback);
+EXPORT_SYMBOL(enable_dma);
+EXPORT_SYMBOL(disable_dma);
+EXPORT_SYMBOL(dma_channel_active);
+EXPORT_SYMBOL(free_dma);
+
+EXPORT_SYMBOL(get_dma_curr_irqstat);
+EXPORT_SYMBOL(clear_dma_irqstat);
+EXPORT_SYMBOL(get_dma_curr_xcount);
+EXPORT_SYMBOL(get_dma_curr_ycount);
+EXPORT_SYMBOL(set_dma_start_addr);
+
+EXPORT_SYMBOL(set_dma_config);
+EXPORT_SYMBOL(set_bfin_dma_config);
+EXPORT_SYMBOL(set_dma_x_count);
+EXPORT_SYMBOL(set_dma_x_modify);
+EXPORT_SYMBOL(set_dma_y_count);
+EXPORT_SYMBOL(set_dma_y_modify);
+EXPORT_SYMBOL(set_dma_sg);
Index: git/linux-2.6/arch/blackfin/kernel/bfin_ksyms.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/kernel/bfin_ksyms.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,119 @@
+/*
+ * File:         arch/blackfin/kernel/bfin_ksyms.c
+ * Based on:     none - original work
+ * Author:
+ *
+ * Created:
+ * Description:
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/module.h>
+#include <asm/irq.h>
+#include <asm/checksum.h>
+#include <asm/cacheflush.h>
+#include <asm/uaccess.h>
+
+extern void dump_thread(struct pt_regs *, struct user *);
+
+/* platform dependent support */
+
+EXPORT_SYMBOL(__ioremap);
+EXPORT_SYMBOL(dump_thread);
+EXPORT_SYMBOL(strnlen);
+EXPORT_SYMBOL(strrchr);
+EXPORT_SYMBOL(strstr);
+EXPORT_SYMBOL(strchr);
+EXPORT_SYMBOL(strcat);
+EXPORT_SYMBOL(strlen);
+EXPORT_SYMBOL(strcmp);
+EXPORT_SYMBOL(strncmp);
+
+EXPORT_SYMBOL(ip_fast_csum);
+
+EXPORT_SYMBOL(enable_irq);
+EXPORT_SYMBOL(disable_irq);
+EXPORT_SYMBOL(kernel_thread);
+
+EXPORT_SYMBOL(__up);
+EXPORT_SYMBOL(__down);
+EXPORT_SYMBOL(__down_trylock);
+EXPORT_SYMBOL(__down_interruptible);
+
+EXPORT_SYMBOL(memory_start);
+EXPORT_SYMBOL(memory_end);
+EXPORT_SYMBOL(is_in_rom);
+
+EXPORT_SYMBOL(dump_stack);
+
+/* Networking helper routines. */
+EXPORT_SYMBOL(csum_partial_copy);
+
+/* The following are special because they're not called
+   explicitly (the C compiler generates them).  Fortunately,
+   their interface isn't gonna change any time soon now, so
+   it's OK to leave it out of version control.  */
+EXPORT_SYMBOL(memcpy);
+EXPORT_SYMBOL(memset);
+EXPORT_SYMBOL(memcmp);
+EXPORT_SYMBOL(memscan);
+EXPORT_SYMBOL(memmove);
+EXPORT_SYMBOL(memchr);
+
+EXPORT_SYMBOL(get_wchan);
+
+/*
+ * libgcc functions - functions that are used internally by the
+ * compiler...  (prototypes are not correct though, but that
+ * doesn't really matter since they're not versioned).
+ */
+extern void __ashldi3(void);
+extern void __ashrdi3(void);
+extern void __divsi3(void);
+extern void __lshrdi3(void);
+extern void __modsi3(void);
+extern void __muldi3(void);
+extern void __udivsi3(void);
+extern void __umodsi3(void);
+
+/* gcc lib functions */
+EXPORT_SYMBOL(__ashldi3);
+EXPORT_SYMBOL(__ashrdi3);
+EXPORT_SYMBOL(__divsi3);
+EXPORT_SYMBOL(__lshrdi3);
+EXPORT_SYMBOL(__modsi3);
+EXPORT_SYMBOL(__muldi3);
+EXPORT_SYMBOL(__udivsi3);
+EXPORT_SYMBOL(__umodsi3);
+
+EXPORT_SYMBOL(outsw);
+EXPORT_SYMBOL(insw);
+EXPORT_SYMBOL(irq_flags);
+EXPORT_SYMBOL(iounmap);
+EXPORT_SYMBOL(blackfin_dcache_invalidate_range);
+EXPORT_SYMBOL(blackfin_icache_dcache_flush_range);
+EXPORT_SYMBOL(blackfin_icache_flush_range);
+EXPORT_SYMBOL(blackfin_dcache_flush_range);
+EXPORT_SYMBOL(blackfin_dflush_page);
+
+EXPORT_SYMBOL(csum_partial);
Index: git/linux-2.6/arch/blackfin/kernel/dma-mapping.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/kernel/dma-mapping.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,174 @@
+/*
+ * File:         arch/blackfin/kernel/dma-mapping.c
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:  Dynamic DMA mapping support.
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/bootmem.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <asm/cacheflush.h>
+#include <asm/io.h>
+
+static spinlock_t dma_page_lock = SPIN_LOCK_UNLOCKED;
+static unsigned int *dma_page;
+static unsigned int dma_pages;
+static unsigned long dma_base;
+static unsigned long dma_size;
+static unsigned int dma_initialized = 0;
+extern unsigned long _ramend;
+extern unsigned long memory_end;
+extern unsigned long memory_mtd_end;
+
+void dma_alloc_init(unsigned long start, unsigned long end)
+{
+	dma_page = (unsigned int *)__get_free_page(GFP_KERNEL);
+	memset(dma_page, 0, PAGE_SIZE);
+	dma_base = PAGE_ALIGN(start);
+	dma_size = PAGE_ALIGN(end) - PAGE_ALIGN(start);
+	dma_pages = dma_size >> PAGE_SHIFT;
+	memset((void *)dma_base, 0, 1024 * 1024);
+	dma_initialized = 1;
+
+	printk("%s: dma_page @ 0x%p - %d pages at 0x%08lx\n", __FUNCTION__,
+	       dma_page, dma_pages, dma_base);
+}
+
+static inline unsigned int get_pages(size_t size)
+{
+	return ((size - 1) >> PAGE_SHIFT) + 1;
+}
+
+static unsigned long __alloc_dma_pages(unsigned int pages)
+{
+	unsigned long ret = 0, flags;
+	int i, count = 0;
+
+	if (dma_initialized == 0)
+		dma_alloc_init(memory_mtd_end, _ramend);
+
+	spin_lock_irqsave(&dma_page_lock, flags);
+
+	for (i = 0; i < dma_pages;) {
+		if (dma_page[i++] == 0) {
+			if (++count == pages) {
+				while (count--)
+					dma_page[--i] = 1;
+				ret = dma_base + (i << PAGE_SHIFT);
+				break;
+			}
+		} else
+			count = 0;
+	}
+	spin_unlock_irqrestore(&dma_page_lock, flags);
+	return ret;
+}
+
+static void __free_dma_pages(unsigned long addr, unsigned int pages)
+{
+	unsigned long page = (addr - dma_base) >> PAGE_SHIFT;
+	unsigned long flags;
+	int i;
+
+	if ((page + pages) > dma_pages) {
+		printk(KERN_ERR "%s: freeing outside range.\n", __FUNCTION__);
+		BUG();
+	}
+
+	spin_lock_irqsave(&dma_page_lock, flags);
+	for (i = page; i < page + pages; i++) {
+		dma_page[i] = 0;
+	}
+	spin_unlock_irqrestore(&dma_page_lock, flags);
+}
+
+void *dma_alloc_coherent(struct device *dev, size_t size,
+			 dma_addr_t * dma_handle, gfp_t gfp)
+{
+	void *ret;
+
+	ret = (void *)__alloc_dma_pages(get_pages(size));
+
+	if (ret) {
+		memset(ret, 0, size);
+		dma_handle = (dma_addr_t *) virt_to_phys(ret);
+	}
+
+	return ret;
+}
+
+void
+dma_free_coherent(struct device *dev, size_t size, void *vaddr,
+		  dma_addr_t dma_handle)
+{
+	__free_dma_pages((unsigned long)vaddr, get_pages(size));
+}
+
+/*
+  Dummy functions defined for some existing drivers
+ */
+
+dma_addr_t
+dma_map_single(struct device *dev, void *ptr, size_t size,
+	       enum dma_data_direction direction)
+{
+	if (direction == DMA_NONE)
+		BUG();
+
+	blackfin_dcache_invalidate_range((unsigned long)ptr,
+					 (unsigned long)ptr + size);
+
+	return (dma_addr_t) ptr;
+}
+
+int
+dma_map_sg(struct device *dev, struct scatterlist *sg, int nents,
+	   enum dma_data_direction direction)
+{
+	int i;
+
+	for (i = 0; i < nents; i++)
+		invalidate_dcache_range(sg_dma_address(&sg[i]),
+					sg_dma_address(&sg[i]) +
+					sg_dma_len(&sg[i]));
+
+	if (direction == DMA_NONE)
+		BUG();
+
+	return nents;
+}
+
+EXPORT_SYMBOL(dma_alloc_coherent);
+EXPORT_SYMBOL(dma_free_coherent);
+EXPORT_SYMBOL(dma_map_single);
+EXPORT_SYMBOL(dma_unmap_single);
+EXPORT_SYMBOL(dma_map_sg);
+EXPORT_SYMBOL(dma_unmap_sg);
Index: git/linux-2.6/arch/blackfin/kernel/entry.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/kernel/entry.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,129 @@
+/*
+ * File:	  arch/blackfin/kernel/entry.S
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ * Rev:	          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:	  Enter bugs at http:	//blackfin.uclinux.org/
+ *
+ * This program is free software ;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation	;  either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY ;  without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program ;  see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#include <linux/linkage.h>
+#include <asm/thread_info.h>
+#include <asm/errno.h>
+#include <asm/asm-offsets.h>
+
+.text
+
+ENTRY(reschedule)
+	r7 = sp;
+	r4.l = 0xe000;
+	r4.h = 0xffff;
+	r7 = r7 & r4;  /*thread_info*/
+	p2 = r7;
+	p2 = [p2];
+	[p2 + (TASK_THREAD + THREAD_KSP)] = sp;
+	call _schedule;
+
+ENTRY(_ret_from_fork)
+	SP += -12;
+	call _schedule_tail;
+	SP += 12;
+	r0 = [sp + PT_IPEND];
+	cc = bittst(r0,1);
+	if cc jump in_kernel;
+	RESTORE_CONTEXT
+	rti;
+in_kernel:
+	bitclr(r0,1);
+	[sp + PT_IPEND] = r0;
+	/* do a 'fake' RTI by jumping to [RETI] */
+        /* to avoid clearing supervisor mode in child */
+	RESTORE_ALL_SYS
+	p0 = reti;
+	jump (p0);
+
+ENTRY(_sys_fork)
+	r0 = -EINVAL;
+	rts;
+
+ENTRY(_sys_vfork)
+	r0 = sp;
+	r0 += 20;
+	[--sp] = rets;
+	SP += -12;
+	call _bfin_vfork;
+	SP += 12;
+	rets = [sp++];
+	rts;
+
+ENTRY(_sys_clone)
+	r0 = sp;
+	r0 += 20;
+	[--sp] = rets;
+	SP += -12;
+	call _bfin_clone;
+	SP += 12;
+	rets = [sp++];
+	rts;
+
+ENTRY(_sys_sigsuspend)
+	r0 = sp;
+	r0 += 20;
+	[--sp] = rets;
+	SP += -12;
+	call _do_sigsuspend;
+	SP += 12;
+	rets = [sp++];
+	rts;
+
+ENTRY(_sys_rt_sigsuspend)
+	r0 = sp;
+	r0 += 20;
+	[--sp] = rets;
+	SP += -12;
+	call _do_rt_sigsuspend;
+	SP += 12;
+	rets = [sp++];
+	rts;
+
+ENTRY(_sys_sigreturn)
+	r0 = sp;
+	r0 += 20;
+	[--sp] = rets;
+	SP += -12;
+	call _do_sigreturn;
+	SP += 12;
+	rets = [sp++];
+	rts;
+
+ENTRY(_sys_rt_sigreturn)
+	r0 = sp;
+	r0 += 20;
+	[--sp] = rets;
+	SP += -12;
+	call _do_rt_sigreturn;
+	SP += 12;
+	rets = [sp++];
+	rts;
Index: git/linux-2.6/arch/blackfin/kernel/init_task.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/kernel/init_task.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * File:         arch/blackfin/kernel/init_task.c
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:  This file contains the simple DMA Implementation for Blackfin
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http:    //blackfin.uclinux.org/
+ *
+ * This program is free software ;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation ;  either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY ;  without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program ;  see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/init_task.h>
+#include <linux/mqueue.h>
+
+static struct fs_struct init_fs = INIT_FS;
+static struct files_struct init_files = INIT_FILES;
+static struct signal_struct init_signals = INIT_SIGNALS(init_signals);
+static struct sighand_struct init_sighand = INIT_SIGHAND(init_sighand);
+struct mm_struct init_mm = INIT_MM(init_mm);
+
+EXPORT_SYMBOL(init_mm);
+
+/*
+ * Initial task structure.
+ *
+ * All other task structs will be allocated on slabs in fork.c
+ */
+struct task_struct init_task = INIT_TASK(init_task);
+
+EXPORT_SYMBOL(init_task);
+
+/*
+ * Initial thread structure.
+ *
+ * We need to make sure that this is 8192-byte aligned due to the
+ * way process stacks are handled. This is done by having a special
+ * "init_task" linker map entry.
+ */
+union thread_union init_thread_union
+    __attribute__ ((__section__(".data.init_task"))) = {
+INIT_THREAD_INFO(init_task)};
Index: git/linux-2.6/arch/blackfin/kernel/irqchip.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/kernel/irqchip.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,900 @@
+/*
+ * File:         arch/blackfin/kernel/irqchip.c
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:  This file contains the simple DMA Implementation for Blackfin
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http:    //blackfin.uclinux.org/
+ *
+ * This program is free software ;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation ;  either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY ;  without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program ;  see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/random.h>
+#include <linux/seq_file.h>
+#include <linux/kallsyms.h>
+#include <linux/interrupt.h>
+
+#include <asm/irqchip.h>
+
+/*#define IRQ_DEBUG*/
+#undef IRQ_DEBUG
+
+#ifdef IRQ_DEBUG
+#define IRQ_DPRINTK(x...)	printk(x)
+#else
+#define IRQ_DPRINTK(x...)	do { } while (0)
+#endif
+
+/*
+ * Maximum IRQ count.  Currently, this is arbitary. However, it should
+ * not be set too low to prevent false triggering. Conversely, if it
+ * is set too high, then you could miss a stuck IRQ.
+ *
+ * Maybe we ought to set a timer and re-enable the IRQ at a later time?
+ */
+#define MAX_IRQ_CNT	100000
+
+static volatile unsigned long irq_err_count;
+static spinlock_t irq_controller_lock = SPIN_LOCK_UNLOCKED;
+static LIST_HEAD(irq_pending);
+
+struct irqdesc irq_desc[NR_IRQS];
+
+extern int init_arch_irq(void);
+/*
+ * Dummy mask/unmask handler
+ */
+void dummy_mask_unmask_irq(unsigned int irq)
+{
+}
+
+irqreturn_t no_action(int irq, void *dev_id, struct pt_regs *regs)
+{
+	return IRQ_NONE;
+}
+
+void do_bad_IRQ(unsigned int irq, struct irqdesc *desc, struct pt_regs *regs)
+{
+	irq_err_count += 1;
+	printk(KERN_ERR "IRQ: spurious interrupt %d\n", irq);
+}
+
+static struct irqchip bad_chip = {
+	.ack = dummy_mask_unmask_irq,
+	.mask = dummy_mask_unmask_irq,
+	.unmask = dummy_mask_unmask_irq,
+};
+
+static struct irqdesc bad_irq_desc = {
+	.chip = &bad_chip,
+	.handle = do_bad_IRQ,
+	.pend = LIST_HEAD_INIT(bad_irq_desc.pend),
+	.disable_depth = 1,
+};
+
+/*
+ *	disable_irq - disable an irq and wait for completion
+ *	@irq: Interrupt to disable
+ *
+ *	Disable the selected interrupt line.  Enables and disables
+ *	are nested. We do this lazily.
+ *
+ *	This function may be called from IRQ context.
+ */
+void disable_irq(unsigned int irq)
+{
+	struct irqdesc *desc = irq_desc + irq;
+	unsigned long flags;
+	spin_lock_irqsave(&irq_controller_lock, flags);
+	if (!desc->disable_depth++)
+		desc->chip->mask(irq);
+	list_del_init(&desc->pend);
+	spin_unlock_irqrestore(&irq_controller_lock, flags);
+}
+
+EXPORT_SYMBOL(disable_irq);
+
+/*
+ *	enable_irq - enable interrupt handling on an irq
+ *	@irq: Interrupt to enable
+ *
+ *	Re-enables the processing of interrupts on this IRQ line.
+ *	Note that this may call the interrupt handler, so you may
+ *	get unexpected results if you hold IRQs disabled.
+ *
+ *	This function may be called from IRQ context.
+ */
+void enable_irq(unsigned int irq)
+{
+	struct irqdesc *desc = irq_desc + irq;
+	unsigned long flags;
+
+	spin_lock_irqsave(&irq_controller_lock, flags);
+	if (unlikely(!desc->disable_depth)) {
+		printk("enable_irq(%u) unbalanced from %p\n", irq,
+		       __builtin_return_address(0));
+	} else if (!--desc->disable_depth) {
+		desc->probing = 0;
+		desc->chip->unmask(irq);
+
+		/*
+		 * If the interrupt is waiting to be processed,
+		 * try to re-run it. We can't directly run it
+		 * from here since the caller might be in an
+		 * interrupt-protected region.
+		 */
+		if (desc->pending && list_empty(&desc->pend)) {
+			desc->pending = 0;
+			if (!desc->chip->retrigger
+			    || desc->chip->retrigger(irq))
+				list_add(&desc->pend, &irq_pending);
+		}
+	}
+	spin_unlock_irqrestore(&irq_controller_lock, flags);
+}
+
+EXPORT_SYMBOL(enable_irq);
+
+/*
+ * Enable wake on selected irq
+ */
+void enable_irq_wake(unsigned int irq)
+{
+	struct irqdesc *desc = irq_desc + irq;
+	unsigned long flags;
+
+	spin_lock_irqsave(&irq_controller_lock, flags);
+	if (desc->chip->wake)
+		desc->chip->wake(irq, 1);
+	spin_unlock_irqrestore(&irq_controller_lock, flags);
+}
+
+EXPORT_SYMBOL(enable_irq_wake);
+
+void disable_irq_wake(unsigned int irq)
+{
+	struct irqdesc *desc = irq_desc + irq;
+	unsigned long flags;
+
+	spin_lock_irqsave(&irq_controller_lock, flags);
+	if (desc->chip->wake)
+		desc->chip->wake(irq, 0);
+	spin_unlock_irqrestore(&irq_controller_lock, flags);
+}
+
+EXPORT_SYMBOL(disable_irq_wake);
+
+int show_interrupts(struct seq_file *p, void *v)
+{
+	int i = *(loff_t *) v;
+	struct irqaction *action;
+	unsigned long flags;
+
+	if (i < NR_IRQS) {
+		spin_lock_irqsave(&irq_controller_lock, flags);
+		action = irq_desc[i].action;
+		if (!action)
+			goto unlock;
+
+		seq_printf(p, "%3d: %10u ", i, kstat_irqs(i));
+		seq_printf(p, "  %s", action->name);
+		for (action = action->next; action; action = action->next)
+			seq_printf(p, ", %s", action->name);
+
+		seq_putc(p, '\n');
+	      unlock:
+		spin_unlock_irqrestore(&irq_controller_lock, flags);
+	} else if (i == NR_IRQS) {
+		seq_printf(p, "Err: %10lu\n", irq_err_count);
+	}
+	return 0;
+}
+
+/*
+ * IRQ lock detection.
+ *
+ * Hopefully, this should get us out of a few locked situations.
+ * However, it may take a while for this to happen, since we need
+ * a large number if IRQs to appear in the same jiffie with the
+ * same instruction pointer (or within 2 instructions).
+ */
+static int check_irq_lock(struct irqdesc *desc, int irq, struct pt_regs *regs)
+{
+	unsigned long instr_ptr = instruction_pointer(regs);
+
+	if (desc->lck_jif == jiffies &&
+	    desc->lck_pc >= instr_ptr && desc->lck_pc < instr_ptr + 8) {
+		desc->lck_cnt += 1;
+
+		if (desc->lck_cnt > MAX_IRQ_CNT) {
+			printk(KERN_ERR
+			       "IRQ LOCK: IRQ%d is locking the system, disabled\n",
+			       irq);
+			return 1;
+		}
+	} else {
+		desc->lck_cnt = 0;
+		desc->lck_pc = instruction_pointer(regs);
+		desc->lck_jif = jiffies;
+	}
+	return 0;
+}
+
+static void
+report_bad_irq(unsigned int irq, struct pt_regs *regs,
+	       struct irqdesc *desc, int ret)
+{
+	static int count = 100;
+	struct irqaction *action;
+
+	if (!count)
+		return;
+
+	count--;
+
+	if (ret != IRQ_HANDLED && ret != IRQ_NONE) {
+		printk(KERN_WARNING "irq%u: bogus retval mask %x\n", irq, ret);
+	} else {
+		printk(KERN_WARNING "irq%u: nobody cared\n", irq);
+	}
+	show_regs(regs);
+	dump_stack();
+	printk(KERN_ERR "handlers:");
+	action = desc->action;
+	do {
+		printk("\n" KERN_ERR "[<%p>]", action->handler);
+		print_symbol(" (%s)", (unsigned long)action->handler);
+		action = action->next;
+	}
+	while (action);
+	printk("\n");
+}
+
+static int
+__do_irq(unsigned int irq, struct irqaction *action, struct pt_regs *regs)
+{
+	unsigned int status;
+	int retval = 0;
+
+	spin_unlock(&irq_controller_lock);
+
+	if (!(action->flags & SA_INTERRUPT)) {
+		local_irq_enable();
+	}
+
+	status = 0;
+	do {
+		status |= action->flags;
+		retval |= action->handler(irq, action->dev_id, regs);
+		action = action->next;
+	}
+	while (action);
+
+	if (status & SA_SAMPLE_RANDOM)
+		add_interrupt_randomness(irq);
+
+	spin_lock_irq(&irq_controller_lock);
+
+	return retval;
+}
+
+/*
+ * This is for software-decoded IRQs. The caller is expected to
+ * handle the ack, clear, mask and unmask issues.
+ */
+void do_simple_IRQ(unsigned int irq, struct irqdesc *desc, struct pt_regs *regs)
+{
+	struct irqaction *action;
+	const int cpu = smp_processor_id();
+
+	desc->triggered = 1;
+
+	kstat_cpu(cpu).irqs[irq]++;
+
+	action = desc->action;
+	if (action) {
+		int ret = __do_irq(irq, action, regs);
+		if (ret != IRQ_HANDLED)
+			report_bad_irq(irq, regs, desc, ret);
+	}
+}
+
+/*
+ * Most edge-triggered IRQ implementations seem to take a broken
+ * approach to this.  Hence the complexity.
+ */
+void do_edge_IRQ(unsigned int irq, struct irqdesc *desc, struct pt_regs *regs)
+{
+	const int cpu = smp_processor_id();
+
+	desc->triggered = 1;
+
+	/*
+	 * If we're currently running this IRQ, or its disabled,
+	 * we shouldn't process the IRQ. Instead, turn on the
+	 * hardware masks.
+	 */
+	if (unlikely(desc->running || desc->disable_depth))
+		goto running;
+
+	/*
+	 * Acknowledge and clear the IRQ, but don't mask it.
+	 */
+	desc->chip->ack(irq);
+
+	/*
+	 * Mark the IRQ currently in progress.
+	 */
+	desc->running = 1;
+
+	kstat_cpu(cpu).irqs[irq]++;
+
+	do {
+		struct irqaction *action;
+		int ret;
+
+		action = desc->action;
+		if (!action)
+			break;
+
+		if (desc->pending && !desc->disable_depth) {
+			desc->pending = 0;
+			desc->chip->unmask(irq);
+		}
+
+		ret = __do_irq(irq, action, regs);
+		if (ret != IRQ_HANDLED)
+			report_bad_irq(irq, regs, desc, ret);
+	}
+	while (desc->pending && !desc->disable_depth);
+
+	desc->running = 0;
+
+	/*
+	 * If we were disabled or freed, shut down the handler.
+	 */
+	if (likely(desc->action && !check_irq_lock(desc, irq, regs)))
+		return;
+
+      running:
+	/*
+	 * We got another IRQ while this one was masked or
+	 * currently running. Delay it.
+	 */
+	desc->pending = 1;
+	desc->chip->mask(irq);
+	desc->chip->ack(irq);
+}
+
+/*
+ * Level-based IRQ handler. Nice and simple.
+ */
+void do_level_IRQ(unsigned int irq, struct irqdesc *desc, struct pt_regs *regs)
+{
+	struct irqaction *action;
+	const int cpu = smp_processor_id();
+
+	desc->triggered = 1;
+
+	/*
+	 * Acknowledge, clear _AND_ disable the interrupt.
+	 */
+	desc->chip->ack(irq);
+
+	if (likely(!desc->disable_depth)) {
+		kstat_cpu(cpu).irqs[irq]++;
+
+		/*
+		 * Return with this interrupt masked if no action
+		 */
+		action = desc->action;
+		if (action) {
+			int ret = __do_irq(irq, desc->action, regs);
+
+			if (ret != IRQ_HANDLED)
+				report_bad_irq(irq, regs, desc, ret);
+			if (likely(!desc->disable_depth &&
+				   !check_irq_lock(desc, irq, regs)))
+				desc->chip->unmask(irq);
+		}
+	}
+}
+
+static void do_pending_irqs(struct pt_regs *regs)
+{
+	struct list_head head, *l, *n;
+
+	do {
+		struct irqdesc *desc;
+
+		/*
+		 * First, take the pending interrupts off the list.
+		 * The act of calling the handlers may add some IRQs
+		 * back onto the list.
+		 */
+		head = irq_pending;
+		INIT_LIST_HEAD(&irq_pending);
+		head.next->prev = &head;
+		head.prev->next = &head;
+
+		/*
+		 * Now run each entry.  We must delete it from our
+		 * list before calling the handler.
+		 */
+		list_for_each_safe(l, n, &head) {
+			desc = list_entry(l, struct irqdesc, pend);
+			list_del_init(&desc->pend);
+			desc->handle(desc - irq_desc, desc, regs);
+		}
+
+		/*
+		 * The list must be empty.
+		 */
+		BUG_ON(!list_empty(&head));
+	}
+	while (!list_empty(&irq_pending));
+}
+
+extern asmlinkage void lower_to_irq14(void);
+
+/*
+ * do_IRQ handles all hardware IRQ's.  Decoded IRQs should not
+ * come via this function.  Instead, they should provide their
+ * own 'handler'
+ */
+asmlinkage void asm_do_IRQ(unsigned int irq, struct pt_regs *regs)
+{
+	struct irqdesc *desc = irq_desc + irq;
+	unsigned short pending, other_ints;
+
+	/*
+	 * Some hardware gives randomly wrong interrupts.  Rather
+	 * than crashing, do something sensible.
+	 */
+	if (irq >= NR_IRQS)
+		desc = &bad_irq_desc;
+
+	irq_enter();
+	spin_lock(&irq_controller_lock);
+	desc->handle(irq, desc, regs);
+
+	/*
+	 * Now re-run any pending interrupts.
+	 */
+	if (!list_empty(&irq_pending))
+		do_pending_irqs(regs);
+
+	spin_unlock(&irq_controller_lock);
+
+	/* If we're the only interrupt running (ignoring IRQ15 which is for
+	   syscalls), lower our priority to IRQ14 so that softirqs run at
+	   that level.  If there's another, lower-level interrupt, irq_exit
+	   will defer softirqs to that.  */
+	__builtin_bfin_csync();
+	pending = *pIPEND & ~0x8000;
+	other_ints = pending & (pending - 1);
+	if (other_ints == 0)
+		lower_to_irq14();
+	irq_exit();
+}
+
+void __set_irq_handler(unsigned int irq, irq_handler_t handle, int is_chained)
+{
+	struct irqdesc *desc;
+	unsigned long flags;
+
+	if (irq >= NR_IRQS) {
+		printk(KERN_ERR "Trying to install handler for IRQ%d\n", irq);
+		return;
+	}
+
+	if (handle == NULL)
+		handle = do_bad_IRQ;
+
+	desc = irq_desc + irq;
+
+	if (is_chained && desc->chip == &bad_chip)
+		printk(KERN_WARNING
+		       "Trying to install chained handler for IRQ%d\n", irq);
+
+	spin_lock_irqsave(&irq_controller_lock, flags);
+	if (handle == do_bad_IRQ) {
+		desc->chip->mask(irq);
+		desc->chip->ack(irq);
+		desc->disable_depth = 1;
+	}
+	desc->handle = handle;
+	if (handle != do_bad_IRQ && is_chained) {
+		desc->valid = 0;
+		desc->probe_ok = 0;
+		desc->disable_depth = 0;
+		desc->chip->unmask(irq);
+	}
+	spin_unlock_irqrestore(&irq_controller_lock, flags);
+}
+
+void set_irq_chip(unsigned int irq, struct irqchip *chip)
+{
+	struct irqdesc *desc;
+	unsigned long flags;
+
+	if (irq >= NR_IRQS) {
+		printk(KERN_ERR "Trying to install chip for IRQ%d\n", irq);
+		return;
+	}
+
+	if (chip == NULL)
+		chip = &bad_chip;
+
+	desc = irq_desc + irq;
+	spin_lock_irqsave(&irq_controller_lock, flags);
+	desc->chip = chip;
+	spin_unlock_irqrestore(&irq_controller_lock, flags);
+}
+
+int set_irq_type(unsigned int irq, unsigned int type)
+{
+	struct irqdesc *desc;
+	unsigned long flags;
+	int ret = -ENXIO;
+
+	if (irq >= NR_IRQS) {
+		printk(KERN_ERR "Trying to set irq type for IRQ%d\n", irq);
+		return -ENODEV;
+	}
+
+	desc = irq_desc + irq;
+	if (desc->chip->type) {
+		spin_lock_irqsave(&irq_controller_lock, flags);
+		ret = desc->chip->type(irq, type);
+		spin_unlock_irqrestore(&irq_controller_lock, flags);
+	}
+
+	return ret;
+}
+
+EXPORT_SYMBOL(set_irq_type);
+
+void set_irq_flags(unsigned int irq, unsigned int iflags)
+{
+	struct irqdesc *desc;
+	unsigned long flags;
+
+	if (irq >= NR_IRQS) {
+		printk(KERN_ERR "Trying to set irq flags for IRQ%d\n", irq);
+		return;
+	}
+
+	desc = irq_desc + irq;
+	spin_lock_irqsave(&irq_controller_lock, flags);
+	desc->valid = (iflags & IRQF_VALID) != 0;
+	desc->probe_ok = (iflags & IRQF_PROBE) != 0;
+	desc->noautoenable = (iflags & IRQF_NOAUTOEN) != 0;
+	spin_unlock_irqrestore(&irq_controller_lock, flags);
+}
+
+int setup_irq(unsigned int irq, struct irqaction *new)
+{
+	int shared = 0;
+	struct irqaction *old, **p;
+	unsigned long flags;
+	struct irqdesc *desc;
+
+	/*
+	 * Some drivers like serial.c use request_irq() heavily,
+	 * so we have to be careful not to interfere with a
+	 * running system.
+	 */
+	if (new->flags & SA_SAMPLE_RANDOM) {
+		/*
+		 * This function might sleep, we want to call it first,
+		 * outside of the atomic block.
+		 * Yes, this might clear the entropy pool if the wrong
+		 * driver is attempted to be loaded, without actually
+		 * installing a new handler, but is this really a problem,
+		 * only the sysadmin is able to do this.
+		 */
+		rand_initialize_irq(irq);
+	}
+
+	/*
+	 * The following block of code has to be executed atomically
+	 */
+	desc = irq_desc + irq;
+	spin_lock_irqsave(&irq_controller_lock, flags);
+	p = &desc->action;
+	if ((old = *p) != NULL) {
+		/* Can't share interrupts unless both agree to */
+		if (!(old->flags & new->flags & SA_SHIRQ)) {
+			spin_unlock_irqrestore(&irq_controller_lock, flags);
+			return -EBUSY;
+		}
+
+		/* add new interrupt at end of irq queue */
+		do {
+			p = &old->next;
+			old = *p;
+		}
+		while (old);
+		shared = 1;
+	}
+
+	*p = new;
+
+	if (!shared) {
+		desc->probing = 0;
+		desc->running = 0;
+		desc->pending = 0;
+		desc->disable_depth = 1;
+		if (!desc->noautoenable) {
+			desc->disable_depth = 0;
+			desc->chip->unmask(irq);
+		}
+	}
+
+	spin_unlock_irqrestore(&irq_controller_lock, flags);
+	return 0;
+}
+
+/**
+ *	request_irq - allocate an interrupt line
+ *	@irq: Interrupt line to allocate
+ *	@handler: Function to be called when the IRQ occurs
+ *	@irqflags: Interrupt type flags
+ *	@devname: An ascii name for the claiming device
+ *	@dev_id: A cookie passed back to the handler function
+ *
+ *	This call allocates interrupt resources and enables the
+ *	interrupt line and IRQ handling. From the point this
+ *	call is made your handler function may be invoked. Since
+ *	your handler function must clear any interrupt the board
+ *	raises, you must take care both to initialise your hardware
+ *	and to set up the interrupt handler in the right order.
+ *
+ *	Dev_id must be globally unique. Normally the address of the
+ *	device data structure is used as the cookie. Since the handler
+ *	receives this value it makes sense to use it.
+ *
+ *	If your interrupt is shared you must pass a non NULL dev_id
+ *	as this is required when freeing the interrupt.
+ *
+ *	Flags:
+ *
+ *	SA_SHIRQ		Interrupt is shared
+ *
+ *	SA_INTERRUPT		Disable local interrupts while processing
+ *
+ *	SA_SAMPLE_RANDOM	The interrupt can be used for entropy
+ *
+ */
+int
+request_irq(unsigned int irq,
+	    irqreturn_t(*handler) (int, void *, struct pt_regs *),
+	    unsigned long irq_flags, const char *devname, void *dev_id)
+{
+	unsigned long retval;
+	struct irqaction *action;
+
+	IRQ_DPRINTK
+	    ("request_irq: irq=%d handler=%p irq_flags=%#lx devname=%s devid=%p\n",
+	     irq, handler, irq_flags, devname, dev_id);
+	if (irq >= NR_IRQS || !irq_desc[irq].valid || !handler
+	    || (irq_flags & SA_SHIRQ && !dev_id))
+		return -EINVAL;
+
+	action = kmalloc(sizeof(struct irqaction), GFP_KERNEL);
+	if (!action)
+		return -ENOMEM;
+
+	action->handler = handler;
+	action->flags = irq_flags;
+	cpus_clear(action->mask);
+	action->name = devname;
+	action->next = NULL;
+	action->dev_id = dev_id;
+
+	retval = setup_irq(irq, action);
+
+	if (retval)
+		kfree(action);
+	return retval;
+}
+
+EXPORT_SYMBOL(request_irq);
+
+/*
+ *	free_irq - free an interrupt
+ *	@irq: Interrupt line to free
+ *	@dev_id: Device identity to free
+ *
+ *	Remove an interrupt handler. The handler is removed and if the
+ *	interrupt line is no longer in use by any driver it is disabled.
+ *	On a shared IRQ the caller must ensure the interrupt is disabled
+ *	on the card it drives before calling this function.
+ *
+ *	This function must not be called from interrupt context.
+ */
+void free_irq(unsigned int irq, void *dev_id)
+{
+	struct irqdesc *desc = irq_desc + irq;
+	struct irqaction *action, **p;
+	unsigned long flags;
+
+	if (irq >= NR_IRQS || !irq_desc[irq].valid) {
+		printk(KERN_ERR "Trying to free IRQ%d\n", irq);
+		dump_stack();
+		return;
+	}
+
+	spin_lock_irqsave(&irq_controller_lock, flags);
+	for (p = &desc->action; (action = *p) != NULL; p = &action->next) {
+		if (action->dev_id != dev_id)
+			continue;
+
+		/* Found it - now free it */
+		*p = action->next;
+		if (!desc->action)
+			desc->chip->mask(irq);
+		break;
+	}
+	spin_unlock_irqrestore(&irq_controller_lock, flags);
+
+	if (!action) {
+		printk(KERN_ERR "Trying to already freed IRQ%d\n", irq);
+		dump_stack();
+	} else {
+		synchronize_irq(irq);
+		kfree(action);
+	}
+}
+
+EXPORT_SYMBOL(free_irq);
+
+static DECLARE_MUTEX(probe_sem);
+
+/* Start the interrupt probing. Unlike other architectures,
+ * we don't return a mask of interrupts from probe_irq_on,
+ * but return the number of interrupts enabled for the probe.
+ * The interrupts which have been enabled for probing is
+ * instead recorded in the irq_desc structure.
+ */
+unsigned long probe_irq_on(void)
+{
+	unsigned int i, irqs = 0;
+	unsigned long delay;
+
+	down(&probe_sem);
+
+	/*
+	 * first snaffle up any unassigned but probe-able interrupts
+	 */
+	spin_lock_irq(&irq_controller_lock);
+	for (i = 0; i < NR_IRQS; i++) {
+		if (!irq_desc[i].probe_ok || irq_desc[i].action)
+			continue;
+
+		irq_desc[i].probing = 1;
+		irq_desc[i].triggered = 0;
+		if (irq_desc[i].chip->type)
+			irq_desc[i].chip->type(i, IRQT_PROBE);
+		irq_desc[i].chip->unmask(i);
+		irqs += 1;
+	}
+	spin_unlock_irq(&irq_controller_lock);
+
+	/*
+	 * wait for spurious interrupts to mask themselves out again
+	 */
+	for (delay = jiffies + HZ / 10; time_before(jiffies, delay);)
+		/* min 100ms delay */ ;
+
+	/*
+	 * now filter out any obviously spurious interrupts
+	 */
+	spin_lock_irq(&irq_controller_lock);
+	for (i = 0; i < NR_IRQS; i++) {
+		if (irq_desc[i].probing && irq_desc[i].triggered) {
+			irq_desc[i].probing = 0;
+			irqs--;
+		}
+	}
+	spin_unlock_irq(&irq_controller_lock);
+
+	return irqs;
+}
+
+EXPORT_SYMBOL(probe_irq_on);
+
+unsigned int probe_irq_mask(unsigned long irqs)
+{
+	unsigned int mask = 0, i;
+
+	spin_lock_irq(&irq_controller_lock);
+	for (i = 0; i < 16 && i < NR_IRQS; i++)
+		if (irq_desc[i].probing && irq_desc[i].triggered)
+			mask |= 1 << i;
+	spin_unlock_irq(&irq_controller_lock);
+
+	up(&probe_sem);
+
+	return mask;
+}
+
+EXPORT_SYMBOL(probe_irq_mask);
+
+/*
+ * Possible return values:
+ *  >= 0 - interrupt number
+ *    -1 - no interrupt/many interrupts
+ */
+int probe_irq_off(unsigned long irqs)
+{
+	unsigned int i;
+	int irq_found = NO_IRQ;
+
+	/*
+	 * look at the interrupts, and find exactly one
+	 * that we were probing has been triggered
+	 */
+	spin_lock_irq(&irq_controller_lock);
+	for (i = 0; i < NR_IRQS; i++) {
+		if (irq_desc[i].probing && irq_desc[i].triggered) {
+			if (irq_found != NO_IRQ) {
+				irq_found = NO_IRQ;
+				goto out;
+			}
+			irq_found = i;
+		}
+	}
+
+	if (irq_found == -1)
+		irq_found = NO_IRQ;
+      out:
+	spin_unlock_irq(&irq_controller_lock);
+
+	up(&probe_sem);
+
+	return irq_found;
+}
+
+EXPORT_SYMBOL(probe_irq_off);
+
+void __init init_irq_proc(void)
+{
+}
+
+void __init init_IRQ(void)
+{
+	struct irqdesc *desc;
+	extern void init_dma(void);
+	int irq;
+
+	for (irq = 0, desc = irq_desc; irq < NR_IRQS; irq++, desc++) {
+		*desc = bad_irq_desc;
+		INIT_LIST_HEAD(&desc->pend);
+	}
+
+	init_arch_irq();
+}
Index: git/linux-2.6/arch/blackfin/kernel/module.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/kernel/module.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,342 @@
+/*
+ * File:         arch/blackfin/kernel/module.c
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http:    //blackfin.uclinux.org/
+ *
+ * This program is free software ;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation ;  either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY ;  without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program ;  see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/moduleloader.h>
+#include <linux/elf.h>
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+
+#define DEBUGP(fmt...)
+
+/* handle arithmetic relocations.
+   See binutils/bfd/elf32-bfin.c for more details
+*/
+#define RELOC_STACK_SIZE 100
+static uint32_t reloc_stack[RELOC_STACK_SIZE];
+static unsigned int reloc_stack_tos = 0;
+
+#define is_reloc_stack_empty() ((reloc_stack_tos > 0)?0:1)
+
+static void reloc_stack_push(uint32_t value)
+{
+	reloc_stack[reloc_stack_tos++] = value;
+}
+
+static uint32_t reloc_stack_pop(void)
+{
+	return reloc_stack[--reloc_stack_tos];
+}
+
+static uint32_t reloc_stack_operate(unsigned int oper)
+{
+	uint32_t value;
+	switch (oper) {
+	case R_add:
+		{
+			value =
+			    reloc_stack[reloc_stack_tos - 2] +
+			    reloc_stack[reloc_stack_tos - 1];
+			reloc_stack_tos -= 2;
+			break;
+		}
+	case R_sub:
+		{
+			value =
+			    reloc_stack[reloc_stack_tos - 2] -
+			    reloc_stack[reloc_stack_tos - 1];
+			reloc_stack_tos -= 2;
+			break;
+		}
+	case R_mult:
+		{
+			value =
+			    reloc_stack[reloc_stack_tos -
+					2] * reloc_stack[reloc_stack_tos - 1];
+			reloc_stack_tos -= 2;
+			break;
+		}
+	case R_div:
+		{
+			value =
+			    reloc_stack[reloc_stack_tos -
+					2] / reloc_stack[reloc_stack_tos - 1];
+			reloc_stack_tos -= 2;
+			break;
+		}
+	case R_mod:
+		{
+			value =
+			    reloc_stack[reloc_stack_tos -
+					2] % reloc_stack[reloc_stack_tos - 1];
+			reloc_stack_tos -= 2;
+			break;
+		}
+	case R_lshift:
+		{
+			value =
+			    reloc_stack[reloc_stack_tos -
+					2] << reloc_stack[reloc_stack_tos - 1];
+			reloc_stack_tos -= 2;
+			break;
+		}
+	case R_rshift:
+		{
+			value =
+			    reloc_stack[reloc_stack_tos -
+					2] >> reloc_stack[reloc_stack_tos - 1];
+			reloc_stack_tos -= 2;
+			break;
+		}
+	case R_and:
+		{
+			value =
+			    reloc_stack[reloc_stack_tos -
+					2] & reloc_stack[reloc_stack_tos - 1];
+			reloc_stack_tos -= 2;
+			break;
+		}
+	case R_or:
+		{
+			value =
+			    reloc_stack[reloc_stack_tos -
+					2] | reloc_stack[reloc_stack_tos - 1];
+			reloc_stack_tos -= 2;
+			break;
+		}
+	case R_xor:
+		{
+			value =
+			    reloc_stack[reloc_stack_tos -
+					2] ^ reloc_stack[reloc_stack_tos - 1];
+			reloc_stack_tos -= 2;
+			break;
+		}
+	case R_land:
+		{
+			value = reloc_stack[reloc_stack_tos - 2]
+			    && reloc_stack[reloc_stack_tos - 1];
+			reloc_stack_tos -= 2;
+			break;
+		}
+	case R_lor:
+		{
+			value = reloc_stack[reloc_stack_tos - 2]
+			    || reloc_stack[reloc_stack_tos - 1];
+			reloc_stack_tos -= 2;
+			break;
+		}
+	case R_neg:
+		{
+			value = -reloc_stack[reloc_stack_tos - 1];
+			reloc_stack_tos--;
+			break;
+		}
+	case R_comp:
+		{
+			value = ~reloc_stack[reloc_stack_tos - 1];
+			reloc_stack_tos -= 1;
+			break;
+		}
+	default:
+		{
+			printk(KERN_WARNING "unhandled reloction\n");
+			return 0;
+		}
+	}
+
+	/* now push the new value back on stack */
+	reloc_stack_push(value);
+
+	return value;
+}
+
+void *module_alloc(unsigned long size)
+{
+	if (size == 0)
+		return NULL;
+	return vmalloc(size);
+}
+
+/* Free memory returned from module_alloc */
+void module_free(struct module *mod, void *module_region)
+{
+	vfree(module_region);
+}
+
+/* We don't need anything special. */
+int
+module_frob_arch_sections(Elf_Ehdr * hdr, Elf_Shdr * sechdrs,
+			  char *secstrings, struct module *mod)
+{
+	return 0;
+}
+
+int
+apply_relocate(Elf32_Shdr * sechdrs, const char *strtab,
+	       unsigned int symindex, unsigned int relsec, struct module *me)
+{
+	printk(KERN_ERR "module %s: .rel unsupported\n", me->name);
+	return -ENOEXEC;
+}
+
+/*************************************************************************/
+/* FUNCTION : apply_relocate_add                                         */
+/* ABSTRACT : Blackfin specific relocation handling for the loadable     */
+/*            modules. Modules are expected to be .o files.              */
+/*            Arithmetic relocations are handled.                        */
+/*            We do not expect LSETUP to be split and hence is not       */
+/*            handled.                                                   */
+/*            R_byte and R_byte2 are also not handled as the gas         */
+/*            does not generate it.                                      */
+/*************************************************************************/
+int
+apply_relocate_add(Elf32_Shdr * sechdrs, const char *strtab,
+		   unsigned int symindex, unsigned int relsec,
+		   struct module *me)
+{
+	unsigned int i;
+	Elf32_Rela *rel = (void *)sechdrs[relsec].sh_addr;
+	Elf32_Sym *sym;
+	uint32_t *location32;
+	uint16_t *location16;
+	uint32_t value;
+
+	DEBUGP("Applying relocate section %u to %u\n", relsec,
+	       sechdrs[relsec].sh_info);
+	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
+		/* This is where to make the change */
+		location16 =
+		    (uint16_t *) (sechdrs[sechdrs[relsec].sh_info].sh_addr +
+				  rel[i].r_offset);
+		location32 = (uint32_t *) location16;
+		/* This is the symbol it is referring to. Note that all
+		   undefined symbols have been resolved. */
+		sym = (Elf32_Sym *) sechdrs[symindex].sh_addr
+		    + ELF32_R_SYM(rel[i].r_info);
+		if (is_reloc_stack_empty()) {
+			value = sym->st_value;
+		} else {
+			value = reloc_stack_pop();
+		}
+		value += rel[i].r_addend;
+		DEBUGP("location is %x, value is %x type is %d \n", location32,
+		       value, ELF32_R_TYPE(rel[i].r_info));
+
+		switch (ELF32_R_TYPE(rel[i].r_info)) {
+
+		case R_pcrel24:
+		case R_pcrel24_jump_l:
+			/* Add the value, subtract its postition */
+			location16 =
+			    (uint16_t *) (sechdrs[sechdrs[relsec].sh_info].
+					  sh_addr + rel[i].r_offset - 2);
+			location32 = (uint32_t *) location16;
+			value -= (uint32_t) location32;
+			value >>= 1;
+			DEBUGP("value is %x, before %x-%x after %x-%x\n", value,
+			       *location16, *(location16 + 1),
+			       (*location16 & 0xff00) | (value >> 16 & 0x00ff),
+			       value & 0xffff);
+			*location16 =
+			    (*location16 & 0xff00) | (value >> 16 & 0x00ff);
+			*(location16 + 1) = value & 0xffff;
+			break;
+		case R_pcrel12_jump:
+		case R_pcrel12_jump_s:
+			value -= (uint32_t) location32;
+			value >>= 1;
+			*location16 = (value & 0xfff);
+			break;
+		case R_pcrel10:
+			value -= (uint32_t) location32;
+			value >>= 1;
+			*location16 = (value & 0x3ff);
+			break;
+		case R_luimm16:
+			DEBUGP("before %x after %x\n", *location16,
+			       (value & 0xffff));
+			*location16 = (value & 0xffff);
+			break;
+		case R_huimm16:
+			DEBUGP("before %x after %x\n", *location16,
+			       ((value >> 16) & 0xffff));
+			*location16 = ((value >> 16) & 0xffff);
+			break;
+		case R_rimm16:
+			*location16 = (value & 0xffff);
+			break;
+		case R_byte4_data:
+			DEBUGP("before %x after %x\n", *location32, value);
+			*location32 = value;
+			break;
+		case R_push:
+			reloc_stack_push(value);
+			break;
+		case R_const:
+			reloc_stack_push(rel[i].r_addend);
+			break;
+		case R_add:
+		case R_sub:
+		case R_mult:
+		case R_div:
+		case R_mod:
+		case R_lshift:
+		case R_rshift:
+		case R_and:
+		case R_or:
+		case R_xor:
+		case R_land:
+		case R_lor:
+		case R_neg:
+		case R_comp:
+			reloc_stack_operate(ELF32_R_TYPE(rel[i].r_info));
+			break;
+		default:
+			printk(KERN_ERR "module %s: Unknown relocation: %u\n",
+			       me->name, ELF32_R_TYPE(rel[i].r_info));
+			return -ENOEXEC;
+		}
+	}
+	return 0;
+}
+
+int
+module_finalize(const Elf_Ehdr * hdr,
+		const Elf_Shdr * sechdrs, struct module *me)
+{
+	return 0;
+}
+
+void module_arch_cleanup(struct module *mod)
+{
+}
Index: git/linux-2.6/arch/blackfin/kernel/process.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/kernel/process.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,320 @@
+/*
+ * File:         arch/blackfin/kernel/process.c
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:  This file handles the architecture-dependent parts
+ *              of process handling.
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software ;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation ;  either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY ;  without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program ;  see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/smp_lock.h>
+#include <linux/unistd.h>
+#include <linux/user.h>
+#include <linux/a.out.h>
+
+#include <asm/blackfin.h>
+#include <asm/uaccess.h>
+
+#define	LED_ON	0
+#define	LED_OFF	1
+
+inline void static leds_switch(int flag);
+asmlinkage void ret_from_fork(void);
+extern void reset(void);
+
+/*
+ * The idle loop on BFIN
+ */
+inline static void default_idle(void)
+{
+	while (!need_resched()) {
+		leds_switch(LED_OFF);
+	      __asm__("nop;\n\t \
+                         nop;\n\t \
+                         nop;\n\t \
+                         idle;\n\t": : :"cc");
+		leds_switch(LED_ON);
+	}
+}
+
+void (*idle)(void) = default_idle;
+
+/*
+ * The idle thread. There's no useful work to be
+ * done, so just try to conserve power and have a
+ * low exit latency (ie sit in a loop waiting for
+ * somebody to say that they'd like to reschedule)
+ */
+void cpu_idle(void)
+{
+	/* endless idle loop with no priority at all */
+	while (1) {
+		idle();
+		preempt_enable_no_resched();
+		schedule();
+		preempt_disable();
+	}
+}
+
+void machine_restart(char *__unused)
+{
+#if defined(CONFIG_BLKFIN_CACHE)
+	*pIMEM_CONTROL = 0x01;
+	__builtin_bfin_ssync();
+#endif
+	reset();
+	/* Dont do anything till the reset occurs */
+	while (1) {
+		__builtin_bfin_ssync();
+	}
+}
+
+void machine_halt(void)
+{
+	for (;;)
+		/* nothing */ ;
+}
+
+void machine_power_off(void)
+{
+	for (;;)
+		/* nothing */ ;
+}
+
+void show_regs(struct pt_regs *regs)
+{
+	printk(KERN_NOTICE "\n");
+	printk(KERN_NOTICE
+	       "PC: %08lu  Status: %04lu  SysStatus: %04lu  RETS: %08lu\n",
+	       regs->pc, regs->astat, regs->seqstat, regs->rets);
+	printk(KERN_NOTICE
+	       "A0.x: %08lx  A0.w: %08lx  A1.x: %08lx  A1.w: %08lx\n",
+	       regs->a0x, regs->a0w, regs->a1x, regs->a1w);
+	printk(KERN_NOTICE "P0: %08lx  P1: %08lx  P2: %08lx  P3: %08lx\n",
+	       regs->p0, regs->p1, regs->p2, regs->p3);
+	printk(KERN_NOTICE "P4: %08lx  P5: %08lx\n", regs->p4, regs->p5);
+	printk(KERN_NOTICE "R0: %08lx  R1: %08lx  R2: %08lx  R3: %08lx\n",
+	       regs->r0, regs->r1, regs->r2, regs->r3);
+	printk(KERN_NOTICE "R4: %08lx  R5: %08lx  R6: %08lx  R7: %08lx\n",
+	       regs->r4, regs->r5, regs->r6, regs->r7);
+
+	if (!(regs->ipend))
+		printk("USP: %08lx\n", rdusp());
+}
+
+/*
+ * This gets run with P1 containing the
+ * function to call, and R1 containing
+ * the "args".  Note P0 is clobbered on the way here.
+ */
+extern void kernel_thread_helper(void);
+__asm__(".section .text\n"
+	".align 4\n"
+	"_kernel_thread_helper:\n\t"
+	"\tsp += -12;\n\t"
+	"\tr0 = r1;\n\t" "\tcall (p1);\n\t" "\tcall _do_exit;\n" ".previous");
+
+/*
+ * Create a kernel thread.
+ */
+pid_t kernel_thread(int (*fn) (void *), void *arg, unsigned long flags)
+{
+	struct pt_regs regs;
+
+	memset(&regs, 0, sizeof(regs));
+
+	regs.r1 = (unsigned long)arg;
+	regs.p1 = (unsigned long)fn;
+	regs.pc = (unsigned long)kernel_thread_helper;
+	regs.orig_p0 = -1;
+	/* Set bit 2 to tell ret_from_fork we should be returning to kernel
+	   mode.  */
+	regs.ipend = 0x8002;
+	__asm__ __volatile__("%0 = syscfg;":"=da"(regs.syscfg):);
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL,
+		       NULL);
+}
+
+void flush_thread(void)
+{
+}
+
+asmlinkage int bfin_vfork(struct pt_regs *regs)
+{
+	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, rdusp(), regs, 0, NULL,
+		       NULL);
+}
+
+asmlinkage int bfin_clone(struct pt_regs *regs)
+{
+	unsigned long clone_flags;
+	unsigned long newsp;
+
+	/* syscall2 puts clone_flags in r0 and usp in r1 */
+	clone_flags = regs->r0;
+	newsp = regs->r1;
+	if (!newsp)
+		newsp = rdusp();
+	return do_fork(clone_flags, newsp, regs, 0, NULL, NULL);
+}
+
+int
+copy_thread(int nr, unsigned long clone_flags,
+	    unsigned long usp, unsigned long topstk,
+	    struct task_struct *p, struct pt_regs *regs)
+{
+	struct pt_regs *childregs;
+	unsigned long stack_offset;
+
+	stack_offset = THREAD_SIZE - sizeof(struct pt_regs);
+	childregs =
+	    (struct pt_regs *)((unsigned long)p->thread_info + stack_offset);
+
+	*childregs = *regs;
+	childregs->r0 = 0;
+
+	p->thread.usp = usp;
+	p->thread.ksp = (unsigned long)childregs;
+	p->thread.pc = (unsigned long)ret_from_fork;
+
+	return 0;
+}
+
+/*
+ * fill in the user structure for a core dump..
+ */
+void dump_thread(struct pt_regs *regs, struct user *dump)
+{
+	dump->magic = CMAGIC;
+	dump->start_code = 0;
+	dump->start_stack = rdusp() & ~(PAGE_SIZE - 1);
+	dump->u_tsize = ((unsigned long)current->mm->end_code) >> PAGE_SHIFT;
+	dump->u_dsize = ((unsigned long)(current->mm->brk +
+					 (PAGE_SIZE - 1))) >> PAGE_SHIFT;
+	dump->u_dsize -= dump->u_tsize;
+	dump->u_ssize = 0;
+
+	if (dump->start_stack < TASK_SIZE)
+		dump->u_ssize =
+		    ((unsigned long)(TASK_SIZE -
+				     dump->start_stack)) >> PAGE_SHIFT;
+
+	dump->u_ar0 = (struct user_regs_struct *)((int)&dump->regs - (int)dump);
+
+	dump->regs.r0 = regs->r0;
+	dump->regs.r1 = regs->r1;
+	dump->regs.r2 = regs->r2;
+	dump->regs.r3 = regs->r3;
+	dump->regs.r4 = regs->r4;
+	dump->regs.r5 = regs->r5;
+	dump->regs.r6 = regs->r6;
+	dump->regs.r7 = regs->r7;
+	dump->regs.p0 = regs->p0;
+	dump->regs.p1 = regs->p1;
+	dump->regs.p2 = regs->p2;
+	dump->regs.p3 = regs->p3;
+	dump->regs.p4 = regs->p4;
+	dump->regs.p5 = regs->p5;
+	dump->regs.orig_p0 = regs->orig_p0;
+	dump->regs.a0w = regs->a0w;
+	dump->regs.a1w = regs->a1w;
+	dump->regs.a0x = regs->a0x;
+	dump->regs.a1x = regs->a1x;
+	dump->regs.rets = regs->rets;
+	dump->regs.astat = regs->astat;
+	dump->regs.pc = regs->pc;
+}
+
+/*
+ * sys_execve() executes a new program.
+ */
+
+asmlinkage int sys_execve(char *name, char **argv, char **envp)
+{
+	int error;
+	char *filename;
+	struct pt_regs *regs = (struct pt_regs *)((&name) + 5);
+
+	lock_kernel();
+	filename = getname(name);
+	error = PTR_ERR(filename);
+	if (IS_ERR(filename))
+		goto out;
+	error = do_execve(filename, argv, envp, regs);
+	putname(filename);
+      out:
+	unlock_kernel();
+	return error;
+}
+
+unsigned long get_wchan(struct task_struct *p)
+{
+	unsigned long fp, pc;
+	unsigned long stack_page;
+	int count = 0;
+	if (!p || p == current || p->state == TASK_RUNNING)
+		return 0;
+
+	stack_page = (unsigned long)p;
+	fp = p->thread.usp;
+	do {
+		if (fp < stack_page + sizeof(struct thread_info) ||
+		    fp >= 8184 + stack_page)
+			return 0;
+		pc = ((unsigned long *)fp)[1];
+		if (!in_sched_functions(pc))
+			return pc;
+		fp = *(unsigned long *)fp;
+	}
+	while (count++ < 16);
+	return 0;
+}
+
+/*
+ * We are using a different LED from the one used to indicate timer interrupt.
+ */
+#if defined(CONFIG_BFIN_IDLE_LED)
+inline void static leds_switch(int flag)
+{
+	unsigned short tmp = 0;
+
+	tmp = *(volatile unsigned short *)CONFIG_BFIN_IDLE_LED_PORT;
+	__builtin_bfin_ssync();
+
+	if (flag == LED_ON)
+		tmp &= ~CONFIG_BFIN_IDLE_LED_PIN;	/* light on */
+	else
+		tmp |= CONFIG_BFIN_IDLE_LED_PIN;	/* light off */
+
+	*(volatile unsigned short *)CONFIG_BFIN_IDLE_LED_PORT = tmp;
+	__builtin_bfin_ssync();
+
+}
+#else
+inline void static leds_switch(int flag)
+{
+}
+#endif
Index: git/linux-2.6/arch/blackfin/kernel/ptrace.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/kernel/ptrace.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,652 @@
+/*
+ * File:         arch/blackfin/kernel/ptrace.c
+ * Based on:     Taken from linux/kernel/ptrace.c
+ * Author:       linux/kernel/ptrace.c is by Ross Biro 1/23/92, edited by Linus Torvalds
+ *
+ * Created:      1/23/92
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http:    //blackfin.uclinux.org/
+ *
+ * This program is free software ;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation ;  either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY ;  without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program ;  see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/errno.h>
+#include <linux/ptrace.h>
+#include <linux/user.h>
+#include <linux/config.h>
+#include <linux/signal.h>
+
+/*#define DEBUG*/
+
+#include <asm/uaccess.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/system.h>
+#include <asm/processor.h>
+#include <asm/asm-offsets.h>
+
+#define MAX_SHARED_LIBS 3
+#define TEXT_OFFSET 0
+/*
+ * does not yet catch signals sent when the child dies.
+ * in exit.c or in signal.c.
+ */
+
+/* determines which bits in the SYSCFG reg the user has access to. */
+/* 1 = access 0 = no access */
+#define SYSCFG_MASK 0x0007	/* SYSCFG reg */
+/* sets the trace bits. */
+#define TRACE_BITS 0x0001
+
+/* Find the stack offset for a register, relative to thread.esp0. */
+#define PT_REG(reg)	((long)&((struct pt_regs *)0)->reg)
+
+/*
+ * Get the address of the live pt_regs for the specified task.
+ * These are saved onto the top kernel stack when the process
+ * is not running.
+ *
+ * Note: if a user thread is execve'd from kernel space, the
+ * kernel stack will not be empty on entry to the kernel, so
+ * ptracing these tasks will fail.
+ */
+static inline struct pt_regs *get_user_regs(struct task_struct *task)
+{
+	return (struct pt_regs *)
+	    ((unsigned long)task->thread_info +
+	     (THREAD_SIZE - sizeof(struct pt_regs)));
+}
+
+/*
+ * Get all user integer registers.
+ */
+static inline int ptrace_getregs(struct task_struct *tsk, void __user * uregs)
+{
+	struct pt_regs *regs = get_user_regs(tsk);
+	return copy_to_user(uregs, regs, sizeof(struct pt_regs)) ? -EFAULT : 0;
+}
+
+/* Mapping from PT_xxx to the stack offset at which the register is
+   saved.  Notice that usp has no stack-slot and needs to be treated
+   specially (see get_reg/put_reg below). */
+
+/*
+ * Get contents of register REGNO in task TASK.
+ */
+static inline long get_reg(struct task_struct *task, int regno)
+{
+	unsigned long *addr;
+
+	struct pt_regs *regs =
+	    (struct pt_regs *)((unsigned long)task->thread_info +
+			       (THREAD_SIZE - sizeof(struct pt_regs)));
+	switch (regno) {
+	case PT_ORIG_PC:
+		return regs->orig_pc;
+	case PT_PC:
+		return regs->pc;
+	case PT_R0:
+		return regs->r0;
+	case PT_ORIG_P0:
+		return regs->orig_p0;
+	case PT_R1:
+		return regs->r1;
+	case PT_R2:
+		return regs->r2;
+	case PT_R3:
+		return regs->r3;
+	case PT_R4:
+		return regs->r4;
+	case PT_R5:
+		return regs->r5;
+	case PT_R6:
+		return regs->r6;
+	case PT_R7:
+		return regs->r7;
+	case PT_P0:
+		return regs->p0;
+	case PT_P1:
+		return regs->p1;
+	case PT_P2:
+		return regs->p2;
+	case PT_P3:
+		return regs->p3;
+	case PT_P4:
+		return regs->p4;
+	case PT_P5:
+		return regs->p5;
+	case PT_A0W:
+		return regs->a0w;
+	case PT_A1W:
+		return regs->a1w;
+	case PT_A0X:
+		return regs->a0x;
+	case PT_A1X:
+		return regs->a1x;
+	case PT_IPEND:
+		return regs->ipend;
+	case PT_SYSCFG:
+		return regs->syscfg;
+	case PT_SEQSTAT:
+		return regs->seqstat;
+		/*case PT_RETE : return task->mm->start_code + TEXT_OFFSET; */
+	case PT_RETE:
+		return regs->rete;
+	case PT_RETN:
+		return regs->retn;
+	case PT_RETX:
+		return regs->retx;
+	case PT_RETS:
+		return regs->rets;
+	case PT_RESERVED:
+		return regs->reserved;
+	case PT_ASTAT:
+		return regs->astat;
+	case PT_LB0:
+		return regs->lb0;
+	case PT_LB1:
+		return regs->lb1;
+	case PT_LT0:
+		return regs->lt0;
+	case PT_LT1:
+		return regs->lt1;
+	case PT_LC0:
+		return regs->lc0;
+	case PT_LC1:
+		return regs->lc1;
+	case PT_B0:
+		return regs->b0;
+	case PT_B1:
+		return regs->b1;
+	case PT_B2:
+		return regs->b2;
+	case PT_B3:
+		return regs->b3;
+	case PT_L0:
+		return regs->l0;
+	case PT_L1:
+		return regs->l1;
+	case PT_L2:
+		return regs->l2;
+	case PT_L3:
+		return regs->l3;
+	case PT_M0:
+		return regs->m0;
+	case PT_M1:
+		return regs->m1;
+	case PT_M2:
+		return regs->m2;
+	case PT_M3:
+		return regs->m3;
+	case PT_I0:
+		return regs->i0;
+	case PT_I1:
+		return regs->i1;
+	case PT_I2:
+		return regs->i2;
+	case PT_I3:
+		return regs->i3;
+	case PT_USP:
+		return task->thread.usp;
+	case PT_FP:
+		return regs->fp;
+		//case PT_VECTOR : return regs->pc;
+	}
+	/* slight mystery ... never seems to come here but kernel misbehaves without this code! */
+
+	printk("did not return for %d\n", regno);
+	if (regno == PT_USP) {
+		addr = &task->thread.usp;
+	} else if (regno < 208) {
+		addr = (unsigned long *)(task->thread.esp0 + regno);
+	} else {
+		printk("Request to get for unknown register\n");
+		return 0;
+	}
+	return *addr;
+
+}
+
+/*
+ * Write contents of register REGNO in task TASK.
+ */
+static inline int
+put_reg(struct task_struct *task, int regno, unsigned long data)
+{
+	struct pt_regs *regs =
+	    (struct pt_regs *)((unsigned long)task->thread_info +
+			       (THREAD_SIZE - sizeof(struct pt_regs)));
+	switch (regno) {
+	case PT_ORIG_PC:
+		regs->orig_pc = data;
+		break;
+	case PT_PC:
+		/*********************************************************************/
+		/* At this point the kernel is most likely in exception.             */
+		/* The RETX register will be used to populate the pc of the process. */
+		/*********************************************************************/
+		regs->retx = data;
+		regs->pc = data;
+		break;
+	case PT_R0:
+		regs->r0 = data;
+		break;
+	case PT_ORIG_P0:
+		regs->orig_p0 = data;
+		break;
+	case PT_R1:
+		regs->r1 = data;
+		break;
+	case PT_R2:
+		regs->r2 = data;
+		break;
+	case PT_R3:
+		regs->r3 = data;
+		break;
+	case PT_R4:
+		regs->r4 = data;
+		break;
+	case PT_R5:
+		regs->r5 = data;
+		break;
+	case PT_R6:
+		regs->r6 = data;
+		break;
+	case PT_R7:
+		regs->r7 = data;
+		break;
+	case PT_P0:
+		regs->p0 = data;
+		break;
+	case PT_P1:
+		regs->p1 = data;
+		break;
+	case PT_P2:
+		regs->p2 = data;
+		break;
+	case PT_P3:
+		regs->p3 = data;
+		break;
+	case PT_P4:
+		regs->p4 = data;
+		break;
+	case PT_P5:
+		regs->p5 = data;
+		break;
+	case PT_A0W:
+		regs->a0w = data;
+		break;
+	case PT_A1W:
+		regs->a1w = data;
+		break;
+	case PT_A0X:
+		regs->a0x = data;
+		break;
+	case PT_A1X:
+		regs->a1x = data;
+		break;
+	case PT_IPEND:
+		regs->ipend = data;
+		break;
+	case PT_SYSCFG:
+		regs->syscfg = data;
+		break;
+	case PT_SEQSTAT:
+		regs->seqstat = data;
+		break;
+	case PT_RETE:
+		regs->rete = data;
+		break;
+	case PT_RETN:
+		regs->retn = data;
+		break;
+	case PT_RETX:
+		break;		//regs->retx = data; break;
+	case PT_RETS:
+		regs->rets = data;
+		break;
+	case PT_RESERVED:
+		regs->reserved = data;
+		break;
+	case PT_ASTAT:
+		regs->astat = data;
+		break;
+	case PT_LB0:
+		regs->lb0 = data;
+		break;
+	case PT_LB1:
+		regs->lb1 = data;
+		break;
+	case PT_LT0:
+		regs->lt0 = data;
+		break;
+	case PT_LT1:
+		regs->lt1 = data;
+		break;
+	case PT_LC0:
+		regs->lc0 = data;
+		break;
+	case PT_LC1:
+		regs->lc1 = data;
+		break;
+	case PT_B0:
+		regs->b0 = data;
+		break;
+	case PT_B1:
+		regs->b1 = data;
+		break;
+	case PT_B2:
+		regs->b2 = data;
+		break;
+	case PT_B3:
+		regs->b3 = data;
+		break;
+	case PT_L0:
+		regs->l0 = data;
+		break;
+	case PT_L1:
+		regs->l1 = data;
+		break;
+	case PT_L2:
+		regs->l2 = data;
+		break;
+	case PT_L3:
+		regs->l3 = data;
+		break;
+	case PT_M0:
+		regs->m0 = data;
+		break;
+	case PT_M1:
+		regs->m1 = data;
+		break;
+	case PT_M2:
+		regs->m2 = data;
+		break;
+	case PT_M3:
+		regs->m3 = data;
+		break;
+	case PT_I0:
+		regs->i0 = data;
+		break;
+	case PT_I1:
+		regs->i1 = data;
+		break;
+	case PT_I2:
+		regs->i2 = data;
+		break;
+	case PT_I3:
+		regs->i3 = data;
+		break;
+	case PT_USP:
+		regs->usp = data;
+		task->thread.usp = data;
+		break;
+	case PT_FP:
+		regs->fp = data;
+		break;
+		//case PT_VECTOR : regs->pc = data; break;
+	}
+	return 0;
+}
+
+/*
+ * Called by kernel/ptrace.c when detaching..
+ *
+ * Make sure the single step bit is not set.
+ */
+void ptrace_disable(struct task_struct *child)
+{
+	unsigned long tmp;
+	/* make sure the single step bit is not set. */
+	tmp = get_reg(child, PT_SR) & ~(TRACE_BITS << 16);
+	put_reg(child, PT_SR, tmp);
+}
+
+long arch_ptrace(struct task_struct *child, long request, long addr, long data)
+{
+	int ret;
+	int add = 0;
+
+	switch (request) {
+		/* when I and D space are separate, these will need to be fixed. */
+	case PTRACE_PEEKDATA:
+#ifdef DEBUG
+		printk("PTRACE_PEEKDATA\n");
+#endif
+		add = MAX_SHARED_LIBS * 4;	/* space between text and data */
+		/* fall through */
+	case PTRACE_PEEKTEXT:	/* read word at location addr. */
+		{
+			unsigned long tmp = 0;
+			int copied;
+
+#ifdef DEBUG
+			printk("PEEKTEXT at addr %x + add %d %d", addr, add,
+			       sizeof(data));
+#endif
+			copied =
+			    access_process_vm(child, addr + add, &tmp,
+					      sizeof(tmp), 0);
+#ifdef DEBUG
+			printk(" bytes %x\n", data);
+#endif
+			ret = -EIO;
+			if (copied != sizeof(tmp))
+				break;
+			ret = put_user(tmp, (unsigned long *)data);
+			break;
+		}
+
+		/* read the word at location addr in the USER area. */
+	case PTRACE_PEEKUSR:
+		{
+			unsigned long tmp;
+			ret = -EIO;
+			tmp = 0;
+			if ((addr & 3) || (addr > (sizeof(struct pt_regs) + 8))) {
+				printk
+				    ("ptrace error : PEEKUSR : temporarily returning 0 - %x sizeof(pt_regs) is %lx\n",
+				     (int)addr, sizeof(struct pt_regs));
+				break;
+			}
+			if (addr == sizeof(struct pt_regs)) {
+				tmp = child->mm->start_code + TEXT_OFFSET;
+			} else if (addr == (sizeof(struct pt_regs) + 4)) {
+				// should really just be start_data but the .gdb file has data starting
+				// at an offset and gdb refuses to reduce the start value
+				tmp =
+				    child->mm->start_data -
+				    (child->mm->end_code -
+				     child->mm->start_code);
+			} else if (addr == (sizeof(struct pt_regs) + 8)) {
+				// should really just be end_data but the .gdb file has data starting
+				// at an offset and gdb refuses to reduce the start value
+				tmp =
+				    child->mm->end_data - (child->mm->end_code -
+							   child->mm->
+							   start_code);
+			} else {
+				tmp = get_reg(child, addr);
+			}
+			ret = put_user(tmp, (unsigned long *)data);
+			break;
+		}
+
+		/* when I and D space are separate, this will have to be fixed. */
+	case PTRACE_POKEDATA:
+		printk("PTRACE_PEEKDATA\n");
+		/* fall through */
+	case PTRACE_POKETEXT:	/* write the word at location addr. */
+		{
+			ret = 0;
+#ifdef DEBUG
+			printk("POKETEXT at addr %x + add %d %d bytes %x\n",
+			       addr, add, sizeof(data), data);
+#endif
+			if (access_process_vm(child, addr + add,
+					      &data, sizeof(data),
+					      1) == sizeof(data))
+				break;
+			ret = -EIO;
+			break;
+		}
+
+	case PTRACE_POKEUSR:	/* write the word at location addr in the USER area */
+		ret = -EIO;
+		if ((addr & 3) || (addr > (sizeof(struct pt_regs) + 8))) {
+			printk
+			    ("ptrace error : POKEUSR: temporarily returning 0\n");
+			break;
+		}
+
+		if (addr == PT_SYSCFG) {
+			data &= SYSCFG_MASK;
+			data |= get_reg(child, PT_SYSCFG);
+		}
+		ret = put_reg(child, addr, data);
+		break;
+
+	case PTRACE_SYSCALL:	/* continue and stop at next (return from) syscall */
+	case PTRACE_CONT:
+		{		/* restart after signal. */
+			long tmp;
+#ifdef DEBUG
+			printk("ptrace_cont\n");
+#endif
+
+			ret = -EIO;
+			if (!valid_signal(data))
+				break;
+			if (request == PTRACE_SYSCALL)
+				set_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
+			else
+				clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
+
+			child->exit_code = data;
+			/* make sure the single step bit is not set. */
+			tmp = get_reg(child, PT_SYSCFG) & ~(TRACE_BITS);
+			put_reg(child, PT_SYSCFG, tmp);
+#ifdef DEBUG
+			printk("before wake_up_process\n");
+#endif
+			wake_up_process(child);
+			ret = 0;
+			break;
+		}
+
+/*
+ * make the child exit.  Best I can do is send it a sigkill.
+ * perhaps it should be put in the status that it wants to
+ * exit.
+ */
+	case PTRACE_KILL:
+		{
+			long tmp;
+			ret = 0;
+			if (child->exit_state == EXIT_ZOMBIE)	/* already dead */
+				break;
+			child->exit_code = SIGKILL;
+			/* make sure the single step bit is not set. */
+			tmp = get_reg(child, PT_SYSCFG) & ~(TRACE_BITS);
+			put_reg(child, PT_SYSCFG, tmp);
+			wake_up_process(child);
+			break;
+		}
+
+	case PTRACE_SINGLESTEP:
+		{		/* set the trap flag. */
+			long tmp;
+#ifdef DEBUG
+			printk("single step\n");
+#endif
+			ret = -EIO;
+			if (!valid_signal(data))
+				break;
+			clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
+
+			tmp = get_reg(child, PT_SYSCFG) | (TRACE_BITS);
+			put_reg(child, PT_SYSCFG, tmp);
+
+			child->exit_code = data;
+			/* give it a chance to run. */
+			wake_up_process(child);
+			ret = 0;
+			break;
+		}
+
+	case PTRACE_DETACH:
+		{		/* detach a process that was attached. */
+			ret = ptrace_detach(child, data);
+			break;
+		}
+
+	case PTRACE_GETREGS:
+		{
+
+			/* Get all gp regs from the child. */
+			ret = ptrace_getregs(child, (void __user *)data);
+			break;
+		}
+
+	case PTRACE_SETREGS:
+		{
+
+			printk("SETREGS : **** NOT IMPLEMENTED ***\n");
+			/* Set all gp regs in the child. */
+			ret = 0;
+			break;
+		}
+
+	default:
+		printk("Ptrace :  *** Unhandled case **** %d\n", (int)request);
+		ret = -EIO;
+		break;
+	}
+
+	return ret;
+}
+
+asmlinkage void syscall_trace(void)
+{
+
+	if (!test_thread_flag(TIF_SYSCALL_TRACE))
+		return;
+
+	if (!(current->ptrace & PT_PTRACED))
+		return;
+
+	ptrace_notify(SIGTRAP);
+	/*
+	 * this isn't the same as continuing with a signal, but it will do
+	 * for normal use.  strace only continues with a signal if the
+	 * stopping signal is not SIGTRAP.  -brl
+	 */
+	if (current->exit_code) {
+		send_sig(current->exit_code, current, 1);
+		current->exit_code = 0;
+	}
+}
Index: git/linux-2.6/arch/blackfin/kernel/semaphore.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/kernel/semaphore.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,146 @@
+/*
+ * File:         arch/blackfin/kernel/semaphore.c
+ * Based on:     taken from alpha implementation
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http:    //blackfin.uclinux.org/
+ *
+ * This program is free software ;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation ;  either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY ;  without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program ;  see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/sched.h>
+#include <asm/semaphore-helper.h>
+
+/*
+ * Semaphores are implemented using a two-way counter:
+ * The "count" variable is decremented for each process
+ * that tries to sleep, while the "waking" variable is
+ * incremented when the "up()" code goes to wake up waiting
+ * processes.
+ *
+ * Notably, the inline "up()" and "down()" functions can
+ * efficiently test if they need to do any extra work (up
+ * needs to do something only if count was negative before
+ * the increment operation.
+ *
+ * waking_non_zero() (from asm/semaphore.h) must execute
+ * atomically.
+ *
+ * When __up() is called, the count was negative before
+ * incrementing it, and we need to wake up somebody.
+ *
+ * This routine adds one to the count of processes that need to
+ * wake up and exit.  ALL waiting processes actually wake up but
+ * only the one that gets to the "waking" field first will gate
+ * through and acquire the semaphore.  The others will go back
+ * to sleep.
+ *
+ * Note that these functions are only called when there is
+ * contention on the lock, and as such all this is the
+ * "non-critical" part of the whole semaphore business. The
+ * critical part is the inline stuff in <asm/semaphore.h>
+ * where we want to avoid any extra jumps and calls.
+ */
+void __up(struct semaphore *sem)
+{
+	wake_one_more(sem);
+	wake_up(&sem->wait);
+}
+
+/*
+ * Perform the "down" function.  Return zero for semaphore acquired,
+ * return negative for signalled out of the function.
+ *
+ * If called from __down, the return is ignored and the wait loop is
+ * not interruptible.  This means that a task waiting on a semaphore
+ * using "down()" cannot be killed until someone does an "up()" on
+ * the semaphore.
+ *
+ * If called from __down_interruptible, the return value gets checked
+ * upon return.  If the return value is negative then the task continues
+ * with the negative value in the return register (it can be tested by
+ * the caller).
+ *
+ * Either form may be used in conjunction with "up()".
+ *
+ */
+
+#define DOWN_HEAD(task_state)						\
+									\
+	current->state = (task_state);					\
+	add_wait_queue(&sem->wait, &wait);				\
+									\
+	/*								\
+	 * Ok, we're set up.  sem->count is known to be less than zero	\
+	 * so we must wait.						\
+	 *								\
+	 * We can let go the lock for purposes of waiting.		\
+	 * We re-acquire it after awaking so as to protect		\
+	 * all semaphore operations.					\
+	 *								\
+	 * If "up()" is called before we call waking_non_zero() then	\
+	 * we will catch it right away.  If it is called later then	\
+	 * we will have to go through a wakeup cycle to catch it.	\
+	 *								\
+	 * Multiple waiters contend for the semaphore lock to see	\
+	 * who gets to gate through and who has to wait some more.	\
+	 */								\
+	for (;;) {
+
+#define DOWN_TAIL(task_state)			\
+		current->state = (task_state);	\
+	}					\
+	current->state = TASK_RUNNING;		\
+	remove_wait_queue(&sem->wait, &wait);
+
+void __sched __down(struct semaphore *sem)
+{
+	DECLARE_WAITQUEUE(wait, current);
+
+	DOWN_HEAD(TASK_UNINTERRUPTIBLE) if (waking_non_zero(sem))
+		break;
+	schedule();
+DOWN_TAIL(TASK_UNINTERRUPTIBLE)}
+
+int __sched __down_interruptible(struct semaphore *sem)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	int ret = 0;
+
+	DOWN_HEAD(TASK_INTERRUPTIBLE)
+	    ret = waking_non_zero_interruptible(sem, current);
+	if (ret) {
+		if (ret == 1)
+			/* ret != 0 only if we get interrupted -arca */
+			ret = 0;
+		break;
+	}
+	schedule();
+	DOWN_TAIL(TASK_INTERRUPTIBLE) return ret;
+}
+
+int __down_trylock(struct semaphore *sem)
+{
+	return waking_non_zero_trylock(sem);
+}
Index: git/linux-2.6/arch/blackfin/kernel/setup.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/kernel/setup.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,814 @@
+/*
+ * File:         arch/blackfin/kernel/setup.c
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http:    //blackfin.uclinux.org/
+ *
+ * This program is free software ;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation ;  either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY ;  without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program ;  see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/delay.h>
+#include <linux/console.h>
+#include <linux/bootmem.h>
+#include <linux/seq_file.h>
+#include <linux/cpu.h>
+#include <linux/module.h>
+
+#include <asm/cacheflush.h>
+#include <asm/blackfin.h>
+
+#ifdef CONFIG_CONSOLE
+extern struct consw *conswitchp;
+#ifdef CONFIG_FRAMEBUFFER
+extern struct consw fb_con;
+#endif
+#endif
+
+unsigned long memory_start;
+unsigned long memory_end;
+unsigned long memory_mtd_end;
+unsigned long memory_mtd_start;
+unsigned long mtd_phys, mtd_size;
+
+EXPORT_SYMBOL(memory_start);
+EXPORT_SYMBOL(memory_end);
+
+char command_line[COMMAND_LINE_SIZE];
+
+void init_leds(void);
+void bf53x_cache_init(void);
+u_long get_cclk(void);
+u_long get_sclk(void);
+u_int get_dsp_rev_id(void);
+static void generate_cpl_tables(void);
+static unsigned short fill_cpl_tables(unsigned long *, unsigned,
+				      unsigned long, unsigned long,
+				      unsigned long, unsigned long);
+
+/* Blackfin cache functions */
+extern void icache_init(void);
+extern void dcache_init(void);
+extern int read_iloc(void);
+extern unsigned long ipdt_table[];
+extern unsigned long dpdt_table[];
+extern unsigned long icplb_table[];
+extern unsigned long dcplb_table[];
+
+void __init bf53x_cache_init(void)
+{
+
+#if defined(CONFIG_BLKFIN_CACHE) || defined(CONFIG_BLKFIN_DCACHE)
+	generate_cpl_tables();
+#endif
+
+#ifdef CONFIG_BLKFIN_CACHE
+	icache_init();
+	printk(KERN_INFO "Instruction Cache Enabled\n");
+#endif
+#ifdef CONFIG_BLKFIN_DCACHE
+	dcache_init();
+#if defined CONFIG_BLKFIN_WB
+	printk(KERN_INFO "Data Cache Enabled (write-back)\n");
+#elif defined CONFIG_BLKFIN_WT
+	printk(KERN_INFO "Data Cache Enabled (write-through)\n");
+#else
+	printk(KERN_INFO "Data Cache Enabled\n");
+#endif
+#endif
+}
+
+int DmaMemCpy(char *dest_addr, char *source_addr, unsigned short size);
+int DmaMemCpy16(char *dest_addr, char *source_addr, int size);
+
+extern char _stext, _etext, _sdata, _edata, _sbss, _ebss, _end;
+extern int _ramstart, _ramend;
+int id;
+extern char _stext_l1, _etext_l1, _sdata_l1, _edata_l1, _sbss_l1, _ebss_l1;
+
+void bf53x_relocate_l1_mem(void)
+{
+	extern char _l1_lma_start;
+	unsigned long l1_length;
+
+	l1_length = &_etext_l1 - &_stext_l1;
+	if (l1_length > L1_CODE_LENGTH)
+		l1_length = L1_CODE_LENGTH;
+	/* cannot complain as printk is not available as yet.
+	   But we can continue booting and complain later!
+	 */
+
+	/* Copy _stext_l1 to _etext_l1 to L1 instruction SRAM */
+	DmaMemCpy(&_stext_l1, &_l1_lma_start, l1_length);
+
+	l1_length = &_ebss_l1 - &_sdata_l1;
+	if (l1_length > L1_DATA_A_LENGTH)
+		l1_length = L1_DATA_A_LENGTH;
+
+	/* Copy _sdata_l1 to _ebss_l1 to L1 instruction SRAM */
+	DmaMemCpy(&_sdata_l1, &_l1_lma_start + (&_etext_l1 - &_stext_l1),
+		  l1_length);
+
+}
+
+/*
+ * Initial parsing of the command line.The format of memsize defination is
+ * mem=xxx,the unit of size is M.
+ */
+static __init void early_parsemem(char *cmdline_p)
+{
+	char *to = cmdline_p;
+	char **to_p = NULL;
+	unsigned int memsize;
+	for (;;) {
+		if (*to == 'm' && *(to + 1) == 'e' && *(to + 2) == 'm') {
+			memsize = simple_strtoul(to + 4, to_p, 10);
+			_ramend = memsize * 1024 * 1024;
+		}
+		if (to >= &cmdline_p[COMMAND_LINE_SIZE - 1]) {
+			break;
+		}
+		to++;
+	}
+}
+
+extern int bfin_console_init(void);
+
+void __init setup_arch(char **cmdline_p)
+{
+	int bootmap_size, id;
+	unsigned long l1_length;
+
+	bfin_console_init();	/* early console registration */
+	/* this give a chance to get printk() working before crash. */
+
+#if defined(CONFIG_CHR_DEV_FLASH) || defined(CONFIG_BLK_DEV_FLASH)
+	/* we need to initialize the Flashrom device here since we might
+	 * do things with flash early on in the boot
+	 */
+	flash_probe();
+#endif
+#if defined(CONFIG_BOOTPARAM)
+	memset(command_line, 0, sizeof(command_line));
+	strncpy(&command_line[0], CONFIG_BOOTPARAM_STRING,
+		sizeof(command_line));
+	command_line[sizeof(command_line) - 1] = 0;
+#endif
+	/* Keep a copy of command line */
+	*cmdline_p = &command_line[0];
+	memcpy(saved_command_line, command_line, COMMAND_LINE_SIZE);
+	saved_command_line[COMMAND_LINE_SIZE - 1] = 0;
+
+	early_parsemem(&command_line[0]);
+
+	memory_end = _ramend;	/* by now the stack is part of the init task */
+#if defined (CONFIG_UNCACHED_1M)
+	memory_end -= (1024 * 1024);
+#elif defined (CONFIG_UNCACHED_512K)
+	memory_end -= (512 * 1024);
+#elif defined (CONFIG_UNCACHED_256K)
+	memory_end -= (256 * 1024);
+#endif
+
+	memory_mtd_end = memory_end;
+
+#if defined(CONFIG_MTD_UCLINUX)
+/* generic memory mapped MTD driver */
+	mtd_phys = (unsigned long)&_ebss;
+	mtd_size = PAGE_ALIGN(*((unsigned long *)(mtd_phys + 8)));
+
+#if defined(CONFIG_EXT2_FS) || defined(CONFIG_EXT3_FS)
+	mtd_size = PAGE_ALIGN(*((unsigned long *)(mtd_phys + 0x404)) << 10);
+#endif
+
+	memory_end -= mtd_size;
+
+	/* Relocate MTD image to the top of memory after the uncached memory area */
+	DmaMemCpy16((char *)memory_end, &_ebss, mtd_size);
+
+	_ramstart = mtd_phys;
+
+#endif				/*defined(CONFIG_MTD_UCLINUX) && defined(CONFIG_ROOTFS_TIED_TO_KERNEL) */
+
+	memory_mtd_start = memory_end;
+	memory_start = PAGE_ALIGN(_ramstart);
+
+#if defined(CONFIG_BLKFIN_CACHE)
+/* Due to a Hardware Anomaly we need to limit the size of usable instruction memory to max 60MB */
+	if (memory_end >= 60 * 1024 * 1024)
+		memory_end = 60 * 1024 * 1024;
+#endif
+
+	init_mm.start_code = (unsigned long)&_stext;
+	init_mm.end_code = (unsigned long)&_etext;
+	init_mm.end_data = (unsigned long)&_edata;
+	init_mm.brk = (unsigned long)0;
+
+	init_leds();
+	id = get_dsp_rev_id();
+
+	printk(KERN_INFO "Blackfin support (C) 2004 Analog Devices, Inc.\n");
+	printk(KERN_INFO "ADSP-%s Rev. 0.%d\n", CPU, id);
+	if (id < SUPPORTED_DSPID)
+		printk(KERN_INFO
+		       "Warning: Unsupported Chip Revision ADSP-%s Rev. 0.%d detected \n",
+		       CPU, id);
+
+	printk(KERN_INFO "uClinux/" CPU "\n");
+
+	printk("Blackfin uClinux support by blackfin.uclinux.org \n");
+	printk("Processor Speed: %lu MHz core clock and %lu Mhz System Clock\n",
+	       get_cclk() / 1000000, get_sclk() / 1000000);
+	printk("Board Memory: %dMB\n", CONFIG_MEM_SIZE);
+
+	printk
+	    ("Memory map:\n  text = 0x%06x-0x%06x\n  data = 0x%06x-0x%06x\n  bss  = 0x%06x-0x%06x\n  rootfs = 0x%06x-0x%06x\n  stack = 0x%06x-0x%06x\n",
+	     (int)&_stext, (int)&_etext, (int)&_sdata, (int)&_edata,
+	     (int)&_sbss, (int)&_ebss, (int)memory_mtd_start,
+	     (int)memory_mtd_start + (int)mtd_size, (int)&init_thread_union,
+	     (int)(&init_thread_union) + 0x2000);
+
+	if (strlen(*cmdline_p))
+		printk("Command line: '%s'\n", *cmdline_p);
+
+#ifdef CONFIG_CONSOLE
+#ifdef CONFIG_FRAMEBUFFER
+	conswitchp = &fb_con;
+#else
+	conswitchp = 0;
+#endif
+#endif
+
+	/*
+	 * give all the memory to the bootmap allocator,  tell it to put the
+	 * boot mem_map at the start of memory
+	 */
+	bootmap_size = init_bootmem_node(NODE_DATA(0), memory_start >> PAGE_SHIFT,	/* map goes here */
+					 PAGE_OFFSET >> PAGE_SHIFT,
+					 memory_end >> PAGE_SHIFT);
+	/*
+	 * free the usable memory,  we have to make sure we do not free
+	 * the bootmem bitmap so we then reserve it after freeing it :-)
+	 */
+	free_bootmem(memory_start, memory_end - memory_start);
+
+	reserve_bootmem(memory_start, bootmap_size);
+	/*
+	 * get kmalloc into gear
+	 */
+	paging_init();
+
+	/* check the size of the l1 area */
+	l1_length = &_etext_l1 - &_stext_l1;
+	if (l1_length > L1_CODE_LENGTH)
+		panic("L1 memory overflow\n");
+
+	l1_length = &_ebss_l1 - &_sdata_l1;
+	if (l1_length > L1_DATA_A_LENGTH)
+		panic("L1 memory overflow\n");
+
+	bf53x_cache_init();
+
+	printk("Hardware Trace Enabled\n");
+	*pTBUFCTL = 0x03;
+
+}
+
+#if defined (CONFIG_BF561)
+static struct cpu cpu[2];
+#else
+static struct cpu cpu[1];
+#endif
+static int __init topology_init(void)
+{
+#if defined (CONFIG_BF561)
+	register_cpu(&cpu[0], 0, NULL);
+	register_cpu(&cpu[1], 1, NULL);
+	return 0;
+#else
+	return register_cpu(cpu, 0, NULL);
+#endif
+}
+
+subsys_initcall(topology_init);
+
+static unsigned short __init
+fill_cpl_tables(unsigned long *table, unsigned pos,
+		unsigned long start, unsigned long end,
+		unsigned long block_size, unsigned long CPLB_data)
+{
+	int i;
+
+	switch (block_size) {
+	case SIZE_4M:
+		i = 3;
+		break;
+	case SIZE_1M:
+		i = 2;
+		break;
+	case SIZE_4K:
+		i = 1;
+		break;
+	case SIZE_1K:
+	default:
+		i = 0;
+		break;
+	}
+
+	CPLB_data = (CPLB_data & ~(3 << 16)) | (i << 16);
+
+	while (start < end) {
+		table[pos++] = start;
+		table[pos++] = CPLB_data;
+		start += block_size;
+	}
+	return pos;
+}
+
+static void __init generate_cpl_tables(void)
+{
+
+	unsigned pos;
+
+#ifdef CONFIG_BLKFIN_DCACHE
+
+/* Generarte initial DCPLB table */
+	pos = 0;
+#ifdef CONFIG_DEBUG_HUNT_FOR_ZERO
+	pos =
+	    fill_cpl_tables(dcplb_table, pos, 0x0, SIZE_4K, SIZE_4K,
+			    SDRAM_OOPS);
+#endif
+	pos =
+	    fill_cpl_tables(dcplb_table, pos, ZERO, SIZE_4M, SIZE_4M,
+			    SDRAM_DKERNEL);
+#if defined (CONFIG_BF561)
+# if defined (CONFIG_BFIN561_EZKIT)
+	pos =
+	    fill_cpl_tables(dcplb_table, pos, ASYNC_BANK0_BASE,
+			    ASYNC_BANK0_BASE + 0x800000,
+			    SIZE_4M, SDRAM_EBIU);
+	pos =
+	    fill_cpl_tables(dcplb_table, pos, ASYNC_BANK3_BASE,
+			    ASYNC_BANK3_BASE + 0x400000,
+			    SIZE_4M, SDRAM_EBIU);
+# else
+#  error "Check the CPLB entries for your BF561 platform in arch/blackfin/kernel/setup.c"
+# endif
+#else
+	pos =
+	    fill_cpl_tables(dcplb_table, pos, ASYNC_BANK0_BASE,
+			    ASYNC_BANK3_BASE + ASYNC_BANK3_SIZE,
+			    SIZE_4M, SDRAM_EBIU);
+#endif
+	pos =
+	    fill_cpl_tables(dcplb_table, pos, RAM_END - SIZE_1M, RAM_END,
+			    SIZE_1M, SDRAM_DNON_CHBL);
+	pos =
+	    fill_cpl_tables(dcplb_table, pos, RAM_END - SIZE_4M,
+			    RAM_END - SIZE_1M, SIZE_1M, SDRAM_DGENERIC);
+	pos =
+	    fill_cpl_tables(dcplb_table, pos, SIZE_4M,
+			    min((SIZE_4M + (16 - pos / 2) * SIZE_4M),
+				RAM_END - SIZE_4M), SIZE_4M, SDRAM_DGENERIC);
+	while (pos < 32)
+		dcplb_table[pos++] = 0;
+
+	*(dcplb_table + pos) = -1;
+
+/* Generarte DCPLB switch table */
+	pos = 0;
+	pos =
+	    fill_cpl_tables(dpdt_table, pos, ZERO, SIZE_4M, SIZE_4M,
+			    SDRAM_DKERNEL);
+	pos =
+	    fill_cpl_tables(dpdt_table, pos, SIZE_4M, RAM_END - SIZE_4M,
+			    SIZE_4M, SDRAM_DGENERIC);
+	pos =
+	    fill_cpl_tables(dpdt_table, pos, RAM_END - SIZE_4M,
+			    RAM_END - SIZE_1M, SIZE_1M, SDRAM_DGENERIC);
+/*TODO: Make mtd none cachable in L1 */
+	pos =
+	    fill_cpl_tables(dpdt_table, pos, RAM_END - SIZE_1M, RAM_END,
+			    SIZE_1M, SDRAM_DNON_CHBL);
+#if defined (CONFIG_BF561)
+# if defined (CONFIG_BFIN561_EZKIT)
+	pos =
+	    fill_cpl_tables(dpdt_table, pos, ASYNC_BANK0_BASE,
+			    ASYNC_BANK0_BASE + 0x800000,
+			    SIZE_4M, SDRAM_EBIU);
+	pos =
+	    fill_cpl_tables(dpdt_table, pos, ASYNC_BANK3_BASE,
+			    ASYNC_BANK3_BASE + 0x400000,
+			    SIZE_4M, SDRAM_EBIU);
+# else
+#  error "Check the CPLB entries for your BF561 platform in arch/blackfin/kernel/setup.c"
+# endif
+#else
+	pos =
+	    fill_cpl_tables(dpdt_table, pos, ASYNC_BANK0_BASE,
+			    ASYNC_BANK3_BASE + ASYNC_BANK3_SIZE,
+			    SIZE_4M, SDRAM_EBIU);
+#endif
+	pos =
+	    fill_cpl_tables(dpdt_table, pos, L1_DATA_A_START,
+			    L1_DATA_B_START + L1_DATA_B_LENGTH, SIZE_4M,
+			    L1_DMEMORY);
+
+	*(dpdt_table + pos) = -1;
+#endif
+
+#ifdef CONFIG_BLKFIN_CACHE
+
+/* Generarte initial ICPLB table */
+	pos = 0;
+	pos =
+	    fill_cpl_tables(icplb_table, pos, L1_CODE_START,
+			    L1_CODE_START + SIZE_1M, SIZE_1M, L1_IMEMORY);
+	pos =
+	    fill_cpl_tables(icplb_table, pos, ZERO, SIZE_4M, SIZE_4M,
+			    SDRAM_IKERNEL);
+	pos =
+	    fill_cpl_tables(icplb_table, pos, SIZE_4M,
+			    min(SIZE_4M + (16 - pos / 2) * SIZE_4M, RAM_END),
+			    SIZE_4M, SDRAM_IGENERIC);
+	while (pos < 32)
+		icplb_table[pos++] = 0;
+
+	*(icplb_table + pos) = -1;
+
+/* Generarte ICPLB switch table */
+	pos = 0;
+
+	pos =
+	    fill_cpl_tables(ipdt_table, pos, ZERO, SIZE_4M, SIZE_4M,
+			    SDRAM_IKERNEL);
+	pos =
+	    fill_cpl_tables(ipdt_table, pos, SIZE_4M, RAM_END,
+			    SIZE_4M, SDRAM_IGENERIC);
+#if defined (CONFIG_BF561)
+# if defined (CONFIG_BFIN561_EZKIT)
+	pos =
+	    fill_cpl_tables(ipdt_table, pos, ASYNC_BANK0_BASE,
+			    ASYNC_BANK0_BASE + 0x800000,
+			    SIZE_4M, SDRAM_EBIU);
+	pos =
+	    fill_cpl_tables(ipdt_table, pos, ASYNC_BANK3_BASE,
+			    ASYNC_BANK3_BASE + 0x400000,
+			    SIZE_4M, SDRAM_EBIU);
+# else
+#  error "Check the CPLB entries for your BF561 platform in arch/blackfin/kernel/setup.c"
+# endif
+#else
+	pos =
+	    fill_cpl_tables(ipdt_table, pos, ASYNC_BANK0_BASE,
+			    ASYNC_BANK3_BASE + ASYNC_BANK3_SIZE,
+			    SIZE_4M, SDRAM_EBIU);
+#endif
+	pos =
+	    fill_cpl_tables(ipdt_table, pos, L1_CODE_START,
+			    L1_CODE_START + SIZE_1M, SIZE_1M, L1_IMEMORY);
+	*(ipdt_table + pos) = -1;
+#endif
+	return;
+}
+
+static inline u_long get_vco(void)
+{
+	u_long msel;
+	u_long vco;
+
+	msel = (*pPLL_CTL >> 9) & 0x3F;
+	if (0 == msel)
+		msel = 64;
+
+	vco = CONFIG_CLKIN_HZ;
+	vco >>= (1 & *pPLL_CTL);	/* DF bit */
+	vco = msel * vco;
+	return vco;
+}
+
+/*Get the Core clock*/
+u_long get_cclk()
+{
+	u_long csel, ssel;
+	if (*pPLL_STAT & 0x1)
+		return CONFIG_CLKIN_HZ;
+
+	ssel = *pPLL_DIV;
+	csel = ((ssel >> 4) & 0x03);
+	ssel &= 0xf;
+	if (ssel && ssel < (1 << csel))	/* SCLK > CCLK */
+		return get_vco() / ssel;
+	return get_vco() >> csel;
+}
+
+EXPORT_SYMBOL(get_cclk);
+
+/* Get the System clock */
+u_long get_sclk()
+{
+	u_long ssel;
+
+	if (*pPLL_STAT & 0x1)
+		return CONFIG_CLKIN_HZ;
+
+	ssel = (*pPLL_DIV & 0xf);
+	if (0 == ssel) {
+		printk(KERN_WARNING "Invalid System Clock\n");
+		ssel = 1;
+	}
+
+	return get_vco() / ssel;
+}
+
+/*Get the DSP Revision ID*/
+u_int get_dsp_rev_id()
+{
+	u_int id;
+	id = *pDSPID & 0xffff;
+	return id;
+}
+
+/*
+ *	Get CPU information for use by the procfs.
+ */
+extern char *bfin_board_name __attribute__ ((weak));
+static int show_cpuinfo(struct seq_file *m, void *v)
+{
+	char *cpu, *mmu, *fpu, *name;
+#ifdef CONFIG_BLKFIN_CACHE_LOCK
+	int lock;
+#endif
+
+	u_long cclk = 0, sclk = 0;
+	u_int id;
+
+	cpu = CPU;
+	mmu = "none";
+	fpu = "none";
+	if (&bfin_board_name) {
+		name = bfin_board_name;
+	} else {
+		name = "Unknown";
+	}
+
+	cclk = get_cclk();
+	sclk = get_sclk();
+	id = get_dsp_rev_id();
+
+	seq_printf(m, "CPU:\t\tADSP-%s Rev. 0.%d\n"
+		   "MMU:\t\t%s\n"
+		   "FPU:\t\t%s\n"
+		   "Core Clock:\t%9lu Hz\n"
+		   "System Clock:\t%9lu Hz\n"
+		   "BogoMips:\t%lu.%02lu\n"
+		   "Calibration:\t%lu loops\n",
+		   cpu, id, mmu, fpu,
+		   cclk,
+		   sclk,
+		   (loops_per_jiffy * HZ) / 500000,
+		   ((loops_per_jiffy * HZ) / 5000) % 100,
+		   (loops_per_jiffy * HZ));
+	seq_printf(m, "BOARD Name  :\t%s\n", name);
+	seq_printf(m, "BOARD Memory:\t%d MB\n", CONFIG_MEM_SIZE);
+	if ((*(volatile unsigned long *)IMEM_CONTROL) & (ENICPLB | IMC))
+		seq_printf(m, "I-CACHE:\tON\n");
+	else
+		seq_printf(m, "I-CACHE:\tOFF\n");
+	if ((*(volatile unsigned long *)DMEM_CONTROL) & (ENDCPLB | DMC_ENABLE))
+		seq_printf(m, "D-CACHE:\tON"
+#if defined CONFIG_BLKFIN_WB
+			   " (write-back)"
+#elif defined CONFIG_BLKFIN_WT
+			   " (write-through)"
+#endif
+			   "\n");
+	else
+		seq_printf(m, "D-CACHE:\tOFF\n");
+	seq_printf(m, "I-CACHE Size:\t%dKB\n", BLKFIN_ICACHESIZE / 1024);
+	seq_printf(m, "D-CACHE Size:\t%dKB\n", BLKFIN_DCACHESIZE / 1024);
+	seq_printf(m, "I-CACHE Setup:\t%d Sub-banks/%d Ways, %d Lines/Way\n",
+		   BLKFIN_ISUBBANKS, BLKFIN_IWAYS, BLKFIN_ILINES);
+	seq_printf(m,
+		   "D-CACHE Setup:\t%d Super-banks/%d Sub-banks/%d Ways, %d Lines/Way\n",
+		   BLKFIN_DSUPBANKS, BLKFIN_DSUBBANKS, BLKFIN_DWAYS,
+		   BLKFIN_DLINES);
+#ifdef CONFIG_BLKFIN_CACHE_LOCK
+	lock = read_iloc();
+	switch (lock) {
+	case WAY0_L:
+		seq_printf(m, "Way0 Locked-Down\n");
+		break;
+	case WAY1_L:
+		seq_printf(m, "Way1 Locked-Down\n");
+		break;
+	case WAY01_L:
+		seq_printf(m, "Way0,Way1 Locked-Down\n");
+		break;
+	case WAY2_L:
+		seq_printf(m, "Way2 Locked-Down\n");
+		break;
+	case WAY02_L:
+		seq_printf(m, "Way0,Way2 Locked-Down\n");
+		break;
+	case WAY12_L:
+		seq_printf(m, "Way1,Way2 Locked-Down\n");
+		break;
+	case WAY012_L:
+		seq_printf(m, "Way0,Way1 & Way2 Locked-Down\n");
+		break;
+	case WAY3_L:
+		seq_printf(m, "Way3 Locked-Down\n");
+		break;
+	case WAY03_L:
+		seq_printf(m, "Way0,Way3 Locked-Down\n");
+		break;
+	case WAY13_L:
+		seq_printf(m, "Way1,Way3 Locked-Down\n");
+		break;
+	case WAY013_L:
+		seq_printf(m, "Way 0,Way1,Way3 Locked-Down\n");
+		break;
+	case WAY32_L:
+		seq_printf(m, "Way3,Way2 Locked-Down\n");
+		break;
+	case WAY320_L:
+		seq_printf(m, "Way3,Way2,Way0 Locked-Down\n");
+		break;
+	case WAY321_L:
+		seq_printf(m, "Way3,Way2,Way1 Locked-Down\n");
+		break;
+	case WAYALL_L:
+		seq_printf(m, "All Ways are locked\n");
+		break;
+	default:
+		seq_printf(m, "No Ways are locked\n");
+	}
+#endif
+	return 0;
+}
+
+static void *c_start(struct seq_file *m, loff_t * pos)
+{
+	return *pos < NR_CPUS ? ((void *)0x12345678) : NULL;
+}
+
+static void *c_next(struct seq_file *m, void *v, loff_t * pos)
+{
+	++*pos;
+	return c_start(m, pos);
+}
+
+static void c_stop(struct seq_file *m, void *v)
+{
+}
+
+struct seq_operations cpuinfo_op = {
+	.start = c_start,
+	.next = c_next,
+	.stop = c_stop,
+	.show = show_cpuinfo,
+};
+
+void panic_bfin(int cplb_panic)
+{
+	printk("DCPLB_FAULT_ADDR=%p\n", *pDCPLB_FAULT_ADDR);
+	printk("ICPLB_FAULT_ADDR=%p\n", *pICPLB_FAULT_ADDR);
+	dump_stack();
+	switch (cplb_panic) {
+
+	case CPLB_NO_UNLOCKED:
+		panic("All CPLBs are locked\n");
+		break;
+	case CPLB_PROT_VIOL:
+		panic("Data Access CPLB Protection Voilation \n");
+		break;
+	case CPLB_NO_ADDR_MATCH:
+		panic("No CPLB Address Match \n");
+	}
+}
+
+/*copy from SRAM to L1RAM, DMAHandler routine*/
+int DmaMemCpy(char *dest_addr, char *source_addr, unsigned short size)
+{
+
+	if (!size)
+		return 0;
+
+	/* Setup destination start address */
+	*pMDMA_D0_START_ADDR = dest_addr;
+
+	/* Setup destination xcount */
+	*pMDMA_D0_X_COUNT = size;
+
+	/* Setup destination xmodify */
+	*pMDMA_D0_X_MODIFY = 1;
+
+	/* Setup Source start address */
+	*pMDMA_S0_START_ADDR = source_addr;
+
+	/* Setup Source xcount */
+	*pMDMA_S0_X_COUNT = size;
+
+	/* Setup Source xmodify */
+	*pMDMA_S0_X_MODIFY = 1;
+#if defined (CONFIG_BF561)
+	*pSICA_IWR1 = (1 << 21);
+#else
+	*pSIC_IWR = (1 << (IRQ_MEM_DMA0 - (IRQ_CORETMR + 1)));
+#endif
+
+	/* Set word size to 8, set to read, enable interrupt for wakeup
+	   Enable source DMA */
+
+	*pMDMA_S0_CONFIG = (DMAEN);
+	__builtin_bfin_ssync();
+
+	*pMDMA_D0_CONFIG = (WNR | DMAEN | DI_EN);
+	asm("IDLE;\n");		/* go into idle and wait for wakeup */
+
+	*pMDMA_D0_IRQ_STATUS = DMA_DONE;
+
+	*pMDMA_S0_CONFIG = 0;
+	*pMDMA_D0_CONFIG = 0;
+
+	return 0;
+}
+
+int DmaMemCpy16(char *dest_addr, char *source_addr, int size)
+{
+
+	if (!size)
+                return 0;
+	/* Setup destination start address */
+	*pMDMA_D0_START_ADDR = dest_addr;
+
+	/* Setup destination xcount */
+	*pMDMA_D0_X_COUNT = 1024 / 2;
+	*pMDMA_D0_Y_COUNT = size >> 10;	/* Divide by 1024 */
+
+	/* Setup destination xmodify */
+	*pMDMA_D0_X_MODIFY = 2;
+	*pMDMA_D0_Y_MODIFY = 2;
+
+	/* Setup Source start address */
+	*pMDMA_S0_START_ADDR = source_addr;
+
+	/* Setup Source xcount */
+	*pMDMA_S0_X_COUNT = 1024 / 2;
+	*pMDMA_S0_Y_COUNT = size >> 10;
+
+	/* Setup Source xmodify */
+	*pMDMA_S0_X_MODIFY = 2;
+	*pMDMA_S0_Y_MODIFY = 2;
+
+#if defined (CONFIG_BF561)
+	*pSICA_IWR1 = (1 << 21);
+#else
+	*pSIC_IWR = (1 << (IRQ_MEM_DMA0 - (IRQ_CORETMR + 1)));
+#endif
+
+	/* Set word size to 8, set to read, enable interrupt for wakeup
+	   Enable source DMA */
+
+	*pMDMA_S0_CONFIG = (DMAEN | DMA2D | WDSIZE_16);
+	__builtin_bfin_ssync();
+	*pMDMA_D0_CONFIG = (WNR | DMAEN | DMA2D | WDSIZE_16 | DI_EN);
+
+	asm("IDLE;\n");		/* go into idle and wait for wakeup */
+
+	*pMDMA_D0_IRQ_STATUS = DMA_DONE;
+
+	*pMDMA_S0_CONFIG = 0;
+	*pMDMA_D0_CONFIG = 0;
+
+	return 0;
+}
+
+void cmdline_init(unsigned long r0)
+{
+	if (r0)
+		strncpy(command_line, (char *)r0, COMMAND_LINE_SIZE);
+}
Index: git/linux-2.6/arch/blackfin/kernel/signal.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/kernel/signal.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,661 @@
+/*
+ * File:         arch/blackfin/kernel/signal.c
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http:    //blackfin.uclinux.org/
+ *
+ * This program is free software ;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation ;  either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY ;  without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program ;  see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * ++roman (07/09/96): implemented signal stacks (specially for tosemu on
+ * Atari :-) Current limitation: Only one sigstack can be active at one time.
+ * If a second signal with SA_ONSTACK set arrives while working on a sigstack,
+ * SA_ONSTACK is ignored. This behaviour avoids lots of trouble with nested
+ * signal handlers!
+ */
+
+#include <linux/signal.h>
+#include <linux/syscalls.h>
+#include <linux/ptrace.h>
+#include <linux/tty.h>
+#include <linux/personality.h>
+#include <linux/binfmts.h>
+
+#include <asm/uaccess.h>
+#include <asm/cacheflush.h>
+#include <asm/ucontext.h>
+
+#define _BLOCKABLE (~(sigmask(SIGKILL) | sigmask(SIGSTOP)))
+
+asmlinkage int do_signal(sigset_t * oldset, struct pt_regs *regs);
+
+struct sigframe {
+	char *pretcode;
+	int sig;
+	int code;
+	struct sigcontext *psc;
+	char retcode[8];
+	unsigned long extramask[_NSIG_WORDS - 1];
+	struct sigcontext sc;
+};
+
+struct rt_sigframe {
+	char *pretcode;
+	int sig;
+	struct siginfo *pinfo;
+	void *puc;
+	char retcode[8];
+	struct siginfo info;
+	struct ucontext uc;
+};
+
+/*
+ * Atomically swap in the new signal mask, and wait for a signal.
+ *
+ */
+asmlinkage int do_sigsuspend(struct pt_regs *regs)
+{
+	old_sigset_t mask = regs->r0;
+	sigset_t saveset;
+
+	mask &= _BLOCKABLE;
+	spin_lock_irq(&current->sighand->siglock);
+	saveset = current->blocked;
+	siginitset(&current->blocked, mask);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
+
+	regs->r0 = -EINTR;
+	while (1) {
+		current->state = TASK_INTERRUPTIBLE;
+		schedule();
+		if (do_signal(&saveset, regs))
+			return regs->r0;
+	}
+}
+
+asmlinkage int do_rt_sigsuspend(struct pt_regs *regs)
+{
+	sigset_t *unewset = (sigset_t *) regs->r0;
+	size_t sigsetsize = (size_t) regs->r1;
+	sigset_t saveset, newset;
+
+	/* XXX: Don't preclude handling different sized sigset_t's.  */
+	if (sigsetsize != sizeof(sigset_t))
+		return -EINVAL;
+
+	if (copy_from_user(&newset, unewset, sizeof(newset)))
+		return -EFAULT;
+	sigdelsetmask(&newset, ~_BLOCKABLE);
+
+	spin_lock_irq(&current->sighand->siglock);
+	saveset = current->blocked;
+	current->blocked = newset;
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
+
+	regs->r0 = -EINTR;
+	while (1) {
+		current->state = TASK_INTERRUPTIBLE;
+		schedule();
+		if (do_signal(&saveset, regs))
+			return regs->r0;
+	}
+}
+
+asmlinkage int
+sys_sigaction(int sig, const struct old_sigaction *act,
+	      struct old_sigaction *oact)
+{
+	struct k_sigaction new_ka, old_ka;
+	int ret;
+
+	if (act) {
+		old_sigset_t mask;
+		if (!access_ok(VERIFY_READ, act, sizeof(*act)) ||
+		    __get_user(new_ka.sa.sa_handler, &act->sa_handler) ||
+		    __get_user(new_ka.sa.sa_restorer, &act->sa_restorer))
+			return -EFAULT;
+		__get_user(new_ka.sa.sa_flags, &act->sa_flags);
+		__get_user(mask, &act->sa_mask);
+		siginitset(&new_ka.sa.sa_mask, mask);
+	}
+
+	ret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);
+
+	if (!ret && oact) {
+		if (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)) ||
+		    __put_user(old_ka.sa.sa_handler, &oact->sa_handler) ||
+		    __put_user(old_ka.sa.sa_restorer, &oact->sa_restorer))
+			return -EFAULT;
+		__put_user(old_ka.sa.sa_flags, &oact->sa_flags);
+		__put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask);
+	}
+
+	return ret;
+}
+
+asmlinkage int sys_sigaltstack(const stack_t * uss, stack_t * uoss)
+{
+	return do_sigaltstack(uss, uoss, rdusp());
+}
+
+/*
+ * Do a signal return; undo the signal stack.
+ *
+ * Keep the return code on the stack quadword aligned!
+ * That makes the cache flush below easier.
+ */
+static inline int
+restore_sigcontext(struct pt_regs *regs, struct sigcontext *usc, int *pr0)
+{
+	struct sigcontext context;
+	int err = 0;
+
+	/* get previous context */
+	if (copy_from_user(&context, usc, sizeof(context)))
+		goto badframe;
+	if (context.sc_pc == 0)
+		goto badframe;
+	/* restore passed registers */
+	regs->r0 = context.sc_r0;
+	regs->r1 = context.sc_r1;
+	regs->r2 = context.sc_r2;
+	regs->r3 = context.sc_r3;
+	regs->r4 = context.sc_r4;
+	regs->p0 = context.sc_p0;
+	regs->p1 = context.sc_p1;
+	regs->l0 = context.sc_l0;
+	regs->l1 = context.sc_l1;
+	regs->l2 = context.sc_l2;
+	regs->l3 = context.sc_l3;
+	regs->seqstat = context.sc_seqstat;
+	regs->pc = context.sc_pc;
+	regs->retx = context.sc_retx;
+	regs->pc = context.sc_retx;
+	regs->rets = context.sc_rets;
+	regs->orig_p0 = -1;	/* disable syscall checks */
+	wrusp(context.sc_usp);
+
+	*pr0 = context.sc_r0;
+	return err;
+
+      badframe:
+	return 1;
+}
+
+static inline int
+rt_restore_ucontext(struct pt_regs *regs, struct ucontext *uc, int *pr0)
+{
+	int temp;
+	greg_t *gregs = uc->uc_mcontext.gregs;
+	unsigned long usp;
+	int err;
+
+	err = __get_user(temp, &uc->uc_mcontext.version);
+	if (temp != MCONTEXT_VERSION)
+		goto badframe;
+	/* restore passed registers */
+	err |= __get_user(regs->r0, &gregs[0]);
+	err |= __get_user(regs->r1, &gregs[1]);
+	err |= __get_user(regs->r2, &gregs[2]);
+	err |= __get_user(regs->r3, &gregs[3]);
+	err |= __get_user(regs->r4, &gregs[4]);
+	err |= __get_user(regs->r5, &gregs[5]);
+	err |= __get_user(regs->r6, &gregs[6]);
+	err |= __get_user(regs->r7, &gregs[7]);
+	err |= __get_user(regs->p0, &gregs[8]);
+	err |= __get_user(regs->p1, &gregs[9]);
+	err |= __get_user(regs->p2, &gregs[10]);
+	err |= __get_user(regs->p3, &gregs[11]);
+	err |= __get_user(regs->p4, &gregs[12]);
+	err |= __get_user(regs->p5, &gregs[13]);
+	err |= __get_user(usp, &gregs[14]);
+	wrusp(usp);
+	err |= __get_user(regs->a0w, &gregs[15]);
+	err |= __get_user(regs->a1w, &gregs[16]);
+	err |= __get_user(regs->a0x, &gregs[17]);
+	err |= __get_user(regs->a1x, &gregs[18]);
+	err |= __get_user(regs->astat, &gregs[19]);
+	err |= __get_user(regs->rets, &gregs[20]);
+	err |= __get_user(regs->pc, &gregs[21]);
+	err |= __get_user(regs->retx, &gregs[22]);
+
+	err |= __get_user(regs->fp, &gregs[23]);
+	err |= __get_user(regs->i0, &gregs[24]);
+	err |= __get_user(regs->i1, &gregs[25]);
+	err |= __get_user(regs->i2, &gregs[26]);
+	err |= __get_user(regs->i3, &gregs[27]);
+	err |= __get_user(regs->m0, &gregs[28]);
+	err |= __get_user(regs->m1, &gregs[29]);
+	err |= __get_user(regs->m2, &gregs[30]);
+	err |= __get_user(regs->m3, &gregs[31]);
+	err |= __get_user(regs->l0, &gregs[32]);
+	err |= __get_user(regs->l1, &gregs[33]);
+	err |= __get_user(regs->l2, &gregs[34]);
+	err |= __get_user(regs->l3, &gregs[35]);
+	err |= __get_user(regs->b0, &gregs[36]);
+	err |= __get_user(regs->b1, &gregs[37]);
+	err |= __get_user(regs->b2, &gregs[38]);
+	err |= __get_user(regs->b3, &gregs[39]);
+	err |= __get_user(regs->lc0, &gregs[40]);
+	err |= __get_user(regs->lc1, &gregs[41]);
+	err |= __get_user(regs->lt0, &gregs[42]);
+	err |= __get_user(regs->lt1, &gregs[43]);
+	err |= __get_user(regs->lb0, &gregs[44]);
+	err |= __get_user(regs->lb1, &gregs[45]);
+	err |= __get_user(regs->seqstat, &gregs[46]);
+
+	regs->orig_p0 = -1;	/* disable syscall checks */
+
+	if (do_sigaltstack(&uc->uc_stack, NULL, usp) == -EFAULT)
+		goto badframe;
+
+	*pr0 = regs->r0;
+	return err;
+
+      badframe:
+	return 1;
+}
+
+asmlinkage int do_sigreturn(unsigned long __unused)
+{
+	struct pt_regs *regs = (struct pt_regs *)__unused;
+	unsigned long usp = rdusp();
+	struct sigframe *frame = (struct sigframe *)(usp);
+	sigset_t set;
+	int r0;
+
+	if (!access_ok(VERIFY_READ, frame, sizeof(*frame)))
+		goto badframe;
+	if (__get_user(set.sig[0], &frame->sc.sc_mask) ||
+	    (_NSIG_WORDS > 1 &&
+	     __copy_from_user(&set.sig[1], &frame->extramask,
+			      sizeof(frame->extramask))))
+
+		goto badframe;
+
+	sigdelsetmask(&set, ~_BLOCKABLE);
+	spin_lock_irq(&current->sighand->siglock);
+	current->blocked = set;
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
+
+	if (restore_sigcontext(regs, &frame->sc, &r0))
+		goto badframe;
+	return r0;
+
+      badframe:
+	force_sig(SIGSEGV, current);
+	return 0;
+}
+
+asmlinkage int do_rt_sigreturn(unsigned long __unused)
+{
+	struct pt_regs *regs = (struct pt_regs *)__unused;
+	unsigned long usp = rdusp();
+	struct rt_sigframe *frame = (struct rt_sigframe *)(usp);
+	sigset_t set;
+	int r0;
+
+	if (!access_ok(VERIFY_READ, frame, sizeof(*frame)))
+		goto badframe;
+	if (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))
+		goto badframe;
+
+	sigdelsetmask(&set, ~_BLOCKABLE);
+	spin_lock_irq(&current->sighand->siglock);
+	current->blocked = set;
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
+
+	if (rt_restore_ucontext(regs, &frame->uc, &r0))
+		goto badframe;
+	return r0;
+
+      badframe:
+	force_sig(SIGSEGV, current);
+	return 0;
+}
+
+static void
+setup_sigcontext(struct sigcontext *sc, struct pt_regs *regs,
+		 unsigned long mask)
+{
+	sc->sc_mask = mask;
+	sc->sc_usp = rdusp();
+	sc->sc_r0 = regs->r0;
+	sc->sc_r1 = regs->r1;
+	sc->sc_r2 = regs->r2;
+	sc->sc_r3 = regs->r3;
+	sc->sc_r4 = regs->r4;
+	sc->sc_p0 = regs->p0;
+	sc->sc_p1 = regs->p1;
+	sc->sc_l0 = regs->l0;
+	sc->sc_l1 = regs->l1;
+	sc->sc_l2 = regs->l2;
+	sc->sc_l3 = regs->l3;
+	sc->sc_seqstat = regs->seqstat;
+	sc->sc_pc = regs->pc;
+	sc->sc_rets = regs->rets;
+
+	if (regs->seqstat)
+		sc->sc_retx = regs->retx;
+	else
+		sc->sc_retx = regs->pc;
+
+}
+
+static inline int rt_setup_ucontext(struct ucontext *uc, struct pt_regs *regs)
+{
+	greg_t *gregs = uc->uc_mcontext.gregs;
+	int err = 0;
+
+	err |= __put_user(MCONTEXT_VERSION, &uc->uc_mcontext.version);
+	err |= __put_user(regs->r0, &gregs[0]);
+	err |= __put_user(regs->r1, &gregs[1]);
+	err |= __put_user(regs->r2, &gregs[2]);
+	err |= __put_user(regs->r3, &gregs[3]);
+	err |= __put_user(regs->r4, &gregs[4]);
+	err |= __put_user(regs->r5, &gregs[5]);
+	err |= __put_user(regs->r6, &gregs[6]);
+	err |= __put_user(regs->r7, &gregs[7]);
+	err |= __put_user(regs->p0, &gregs[8]);
+	err |= __put_user(regs->p1, &gregs[9]);
+	err |= __put_user(regs->p2, &gregs[10]);
+	err |= __put_user(regs->p3, &gregs[11]);
+	err |= __put_user(regs->p4, &gregs[12]);
+	err |= __put_user(regs->p5, &gregs[13]);
+	err |= __put_user(rdusp(), &gregs[14]);
+	err |= __put_user(regs->a0w, &gregs[15]);
+	err |= __put_user(regs->a1w, &gregs[16]);
+	err |= __put_user(regs->a0x, &gregs[17]);
+	err |= __put_user(regs->a1x, &gregs[18]);
+	err |= __put_user(regs->astat, &gregs[19]);
+	err |= __put_user(regs->rets, &gregs[20]);
+	err |= __put_user(regs->pc, &gregs[21]);
+	err |= __put_user(regs->retx, &gregs[22]);
+
+	err |= __put_user(regs->fp, &gregs[23]);
+	err |= __put_user(regs->i0, &gregs[24]);
+	err |= __put_user(regs->i1, &gregs[25]);
+	err |= __put_user(regs->i2, &gregs[26]);
+	err |= __put_user(regs->i3, &gregs[27]);
+	err |= __put_user(regs->m0, &gregs[28]);
+	err |= __put_user(regs->m1, &gregs[29]);
+	err |= __put_user(regs->m2, &gregs[30]);
+	err |= __put_user(regs->m3, &gregs[31]);
+	err |= __put_user(regs->l0, &gregs[32]);
+	err |= __put_user(regs->l1, &gregs[33]);
+	err |= __put_user(regs->l2, &gregs[34]);
+	err |= __put_user(regs->l3, &gregs[35]);
+	err |= __put_user(regs->b0, &gregs[36]);
+	err |= __put_user(regs->b1, &gregs[37]);
+	err |= __put_user(regs->b2, &gregs[38]);
+	err |= __put_user(regs->b3, &gregs[39]);
+	err |= __put_user(regs->lc0, &gregs[40]);
+	err |= __put_user(regs->lc1, &gregs[41]);
+	err |= __put_user(regs->lt0, &gregs[42]);
+	err |= __put_user(regs->lt1, &gregs[43]);
+	err |= __put_user(regs->lb0, &gregs[44]);
+	err |= __put_user(regs->lb1, &gregs[45]);
+	err |= __put_user(regs->seqstat, &gregs[46]);
+	return err;
+}
+
+static inline void push_cache(unsigned long vaddr, unsigned int len)
+{
+	flush_icache_range(vaddr, vaddr + len);
+}
+
+static inline void *get_sigframe(struct k_sigaction *ka, struct pt_regs *regs,
+				 size_t frame_size)
+{
+	unsigned long usp;
+
+	/* Default to using normal stack.  */
+	usp = rdusp();
+
+	/* This is the X/Open sanctioned signal stack switching.  */
+	if (ka->sa.sa_flags & SA_ONSTACK) {
+		if (!on_sig_stack(usp))
+			usp = current->sas_ss_sp + current->sas_ss_size;
+	}
+	return (void *)((usp - frame_size) & -8UL);
+}
+
+static void
+setup_frame(int sig, struct k_sigaction *ka,
+	    sigset_t * set, struct pt_regs *regs)
+{
+	struct sigframe *frame;
+	struct sigcontext context;
+	int err = 0;
+
+	frame = get_sigframe(ka, regs, sizeof(*frame));
+
+	err |= __put_user((current_thread_info()->exec_domain
+			   && current_thread_info()->exec_domain->signal_invmap
+			   && sig < 32
+			   ? current_thread_info()->exec_domain->
+			   signal_invmap[sig] : sig), &frame->sig);
+
+	err |= __put_user(&frame->sc, &frame->psc);
+
+	if (_NSIG_WORDS > 1)
+		err |= copy_to_user(frame->extramask, &set->sig[1],
+				    sizeof(frame->extramask));
+
+	setup_sigcontext(&context, regs, set->sig[0]);
+	err |= copy_to_user(&frame->sc, &context, sizeof(context));
+
+	/* Set up to return from userspace.  */
+	err |= __put_user(frame->retcode, &frame->pretcode);
+	err |= __put_user(0x28, &(frame->retcode[0]));
+	err |= __put_user(0xe1, &(frame->retcode[1]));
+	err |= __put_user(0x77, &(frame->retcode[2]));
+	err |= __put_user(0x00, &(frame->retcode[3]));
+	err |= __put_user(0xa0, &(frame->retcode[4]));
+	err |= __put_user(0x00, &(frame->retcode[5]));
+
+	if (err)
+		goto give_sigsegv;
+
+	push_cache((unsigned long)&frame->retcode, sizeof(frame->retcode));
+
+	/* Set up registers for signal handler */
+	wrusp((unsigned long)frame);
+	regs->pc = (unsigned long)ka->sa.sa_handler;
+	regs->rets = (unsigned long)(frame->retcode);
+	regs->r0 = frame->sig;
+	regs->l0 = regs->l1 = regs->l2 = regs->l3 = 0;
+
+	if (regs->seqstat)
+		regs->retx = (unsigned long)ka->sa.sa_handler;
+
+	return;
+
+      give_sigsegv:
+	if (sig == SIGSEGV)
+		ka->sa.sa_handler = SIG_DFL;
+	force_sig(SIGSEGV, current);
+	return;
+}
+
+static void
+setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t * info,
+	       sigset_t * set, struct pt_regs *regs)
+{
+	struct rt_sigframe *frame;
+	int err = 0;
+
+	frame = get_sigframe(ka, regs, sizeof(*frame));
+
+	err |= __put_user((current_thread_info()->exec_domain
+			   && current_thread_info()->exec_domain->signal_invmap
+			   && sig < 32
+			   ? current_thread_info()->exec_domain->
+			   signal_invmap[sig] : sig), &frame->sig);
+
+	err |= __put_user(&frame->info, &frame->pinfo);
+
+	err |= __put_user(&frame->info, &frame->pinfo);
+	err |= __put_user(&frame->uc, &frame->puc);
+	err |= copy_siginfo_to_user(&frame->info, info);
+
+	/* Create the ucontext.  */
+	err |= __put_user(0, &frame->uc.uc_flags);
+	err |= __put_user(0, &frame->uc.uc_link);
+	err |=
+	    __put_user((void *)current->sas_ss_sp, &frame->uc.uc_stack.ss_sp);
+	err |= __put_user(sas_ss_flags(rdusp()), &frame->uc.uc_stack.ss_flags);
+	err |= __put_user(current->sas_ss_size, &frame->uc.uc_stack.ss_size);
+	err |= rt_setup_ucontext(&frame->uc, regs);
+	err |= copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
+
+	/* Set up to return from userspace.  */
+	err |= __put_user(frame->retcode, &frame->pretcode);
+	err |= __put_user(0x28, &(frame->retcode[0]));
+	err |= __put_user(0xe1, &(frame->retcode[1]));
+	err |= __put_user(0xad, &(frame->retcode[2]));
+	err |= __put_user(0x00, &(frame->retcode[3]));
+	err |= __put_user(0xa0, &(frame->retcode[4]));
+	err |= __put_user(0x00, &(frame->retcode[5]));
+
+	if (err)
+		goto give_sigsegv;
+
+	push_cache((unsigned long)&frame->retcode, sizeof(frame->retcode));
+
+	/* Set up registers for signal handler */
+	wrusp((unsigned long)frame);
+	regs->pc = (unsigned long)ka->sa.sa_handler;
+	regs->rets = (unsigned long)(frame->retcode);
+
+	regs->r0 = frame->sig;
+	regs->r1 = (unsigned long)(&frame->info);
+	regs->r2 = (unsigned long)(&frame->uc);
+
+	if (regs->seqstat)
+		regs->retx = (unsigned long)ka->sa.sa_handler;
+
+	return;
+
+      give_sigsegv:
+	if (sig == SIGSEGV)
+		ka->sa.sa_handler = SIG_DFL;
+	force_sig(SIGSEGV, current);
+	return;
+}
+
+static inline void
+handle_restart(struct pt_regs *regs, struct k_sigaction *ka, int has_handler)
+{
+	switch (regs->r0) {
+	case -ERESTARTNOHAND:
+		if (!has_handler)
+			goto do_restart;
+		regs->r0 = -EINTR;
+		break;
+
+	case -ERESTARTSYS:
+		if (has_handler && !(ka->sa.sa_flags & SA_RESTART)) {
+			regs->r0 = -EINTR;
+			break;
+		}
+		/* fallthrough */
+	case -ERESTARTNOINTR:
+	      do_restart:
+		regs->p0 = regs->orig_p0;
+		regs->r0 = regs->orig_r0;
+		regs->pc -= 2;
+		break;
+	}
+}
+
+/*
+ * OK, we're invoking a handler
+ */
+static void
+handle_signal(int sig, struct k_sigaction *ka, siginfo_t * info,
+	      sigset_t * oldset, struct pt_regs *regs)
+{
+	/* are we from a system call? to see pt_regs->orig_p0 */
+	if (regs->orig_p0 >= 0)
+		/* If so, check system call restarting.. */
+		handle_restart(regs, ka, 1);
+
+	/* set up the stack frame */
+	if (ka->sa.sa_flags & SA_SIGINFO)
+		setup_rt_frame(sig, ka, info, oldset, regs);
+	else
+		setup_frame(sig, ka, oldset, regs);
+
+	if (ka->sa.sa_flags & SA_ONESHOT)
+		ka->sa.sa_handler = SIG_DFL;
+
+	spin_lock_irq(&current->sighand->siglock);
+	sigorsets(&current->blocked, &current->blocked, &ka->sa.sa_mask);
+	if (!(ka->sa.sa_flags & SA_NODEFER))
+		sigaddset(&current->blocked, sig);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
+}
+
+/*
+ * Note that 'init' is a special process: it doesn't get signals it doesn't
+ * want to handle. Thus you cannot kill init even with a SIGKILL even by
+ * mistake.
+ *
+ * Note that we go through the signals twice: once to check the signals
+ * that the kernel can handle, and then we build all the user-level signal
+ * handling stack-frames in one go after that.
+ */
+asmlinkage int do_signal(sigset_t * oldset, struct pt_regs *regs)
+{
+	siginfo_t info;
+	struct k_sigaction ka;
+	int signr;
+
+	current->thread.esp0 = (unsigned long)regs;
+
+	if (!oldset)
+		oldset = &current->blocked;
+
+	signr = get_signal_to_deliver(&info, &ka, regs, NULL);
+	if (signr > 0) {
+		/* Whee!  Actually deliver the signal.  */
+		handle_signal(signr, &ka, &info, oldset, regs);
+		return 1;
+	}
+
+	/* Did we come from a system call? */
+	if (regs->orig_p0 >= 0)
+		/* Restart the system call - no handlers present */
+		handle_restart(regs, NULL, 0);
+
+	return 0;
+}
Index: git/linux-2.6/arch/blackfin/kernel/sys_bfin.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/kernel/sys_bfin.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,228 @@
+/*
+ * File:         arch/blackfin/kernel/sys_bfin.c
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:  This file contains various random system calls that
+ *               have a non-standard calling sequence on the Linux/bfin
+ *               platform.
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http:    //blackfin.uclinux.org/
+ *
+ * This program is free software ;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation ;  either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY ;  without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program ;  see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/smp_lock.h>
+#include <linux/spinlock.h>
+#include <linux/sem.h>
+#include <linux/msg.h>
+#include <linux/shm.h>
+#include <linux/syscalls.h>
+#include <linux/mman.h>
+#include <linux/file.h>
+
+#include <asm/cacheflush.h>
+#include <asm/uaccess.h>
+#include <asm/ipc.h>
+
+/*
+ * sys_pipe() is the normal C calling standard for creating
+ * a pipe. It's not the way unix traditionally does this, though.
+ */
+asmlinkage int sys_pipe(unsigned long *fildes)
+{
+	int fd[2];
+	int error;
+
+	error = do_pipe(fd);
+	if (!error) {
+		if (copy_to_user(fildes, fd, 2 * sizeof(int)))
+			error = -EFAULT;
+	}
+	return error;
+}
+
+/* common code for old and new mmaps */
+static inline long
+do_mmap2(unsigned long addr, unsigned long len,
+	 unsigned long prot, unsigned long flags,
+	 unsigned long fd, unsigned long pgoff)
+{
+	int error = -EBADF;
+	struct file *file = NULL;
+
+	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
+	if (!(flags & MAP_ANONYMOUS)) {
+		file = fget(fd);
+		if (!file)
+			goto out;
+	}
+
+	down_write(&current->mm->mmap_sem);
+	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
+	up_write(&current->mm->mmap_sem);
+
+	if (file)
+		fput(file);
+      out:
+	return error;
+}
+
+asmlinkage long
+sys_mmap2(unsigned long addr, unsigned long len,
+	  unsigned long prot, unsigned long flags,
+	  unsigned long fd, unsigned long pgoff)
+{
+	return do_mmap2(addr, len, prot, flags, fd, pgoff);
+}
+
+/*
+ * Perform the select(nd, in, out, ex, tv) and mmap() system
+ * calls. Linux/bfin cloned Linux/i386, which didn't use to be able to
+ * handle more than 4 system call parameters, so these system calls
+ * used a memory block for parameter passing..
+ */
+
+struct mmap_arg_struct {
+	unsigned long addr;
+	unsigned long len;
+	unsigned long prot;
+	unsigned long flags;
+	unsigned long fd;
+	unsigned long offset;
+};
+
+asmlinkage int old_mmap(struct mmap_arg_struct *arg)
+{
+	struct mmap_arg_struct a;
+	int error = -EFAULT;
+
+	if (copy_from_user(&a, arg, sizeof(a)))
+		goto out;
+
+	error = -EINVAL;
+	if (a.offset & ~PAGE_MASK)
+		goto out;
+
+	a.flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
+
+	error =
+	    do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd,
+		     a.offset >> PAGE_SHIFT);
+      out:
+	return error;
+}
+
+struct sel_arg_struct {
+	unsigned long n;
+	fd_set *inp, *outp, *exp;
+	struct timeval *tvp;
+};
+
+asmlinkage int old_select(struct sel_arg_struct *arg)
+{
+	struct sel_arg_struct a;
+
+	if (copy_from_user(&a, arg, sizeof(a)))
+		return -EFAULT;
+	return sys_select(a.n, a.inp, a.outp, a.exp, a.tvp);
+}
+
+/*
+ * sys_ipc() is the de-multiplexer for the SysV IPC calls..
+ *
+ * This is really horribly ugly.
+ */
+asmlinkage int
+sys_ipc(uint call, int first, int second, int third, void *ptr, long fifth)
+{
+	int version;
+
+	version = call >> 16;	/* hack for backward compatibility */
+	call &= 0xffff;
+
+	if (call <= SEMCTL)
+		switch (call) {
+		case SEMOP:
+			return sys_semop(first, (struct sembuf *)ptr, second);
+		case SEMGET:
+			return sys_semget(first, second, third);
+		case SEMCTL:
+			{
+				union semun fourth;
+				if (!ptr)
+					return -EINVAL;
+				if (get_user(fourth.__pad, (void **)ptr))
+					return -EFAULT;
+				return sys_semctl(first, second, third, fourth);
+			}
+		default:
+			return -EINVAL;
+		}
+	if (call <= MSGCTL)
+		switch (call) {
+		case MSGSND:
+			return sys_msgsnd(first, (struct msgbuf *)ptr, second,
+					  third);
+		case MSGRCV:
+			switch (version) {
+			case 0:
+				{
+					struct ipc_kludge tmp;
+					if (!ptr)
+						return -EINVAL;
+					if (copy_from_user(&tmp,
+							   (struct ipc_kludge *)
+							   ptr, sizeof(tmp)))
+						return -EFAULT;
+					return sys_msgrcv(first, tmp.msgp,
+							  second, tmp.msgtyp,
+							  third);
+				}
+			default:
+				return sys_msgrcv(first,
+						  (struct msgbuf *)ptr, second,
+						  fifth, third);
+			}
+		case MSGGET:
+			return sys_msgget((key_t) first, second);
+		case MSGCTL:
+			return sys_msgctl(first, second,
+					  (struct msqid_ds *)ptr);
+		default:
+			return -EINVAL;
+		}
+	return -EINVAL;
+}
+
+/* sys_cacheflush -- flush (part of) the processor cache.  */
+asmlinkage int
+sys_cacheflush(unsigned long addr, int scope, int cache, unsigned long len)
+{
+	flush_cache_all();
+	return 0;
+}
+
+asmlinkage int sys_getpagesize(void)
+{
+	return PAGE_SIZE;
+}
Index: git/linux-2.6/arch/blackfin/kernel/time.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/kernel/time.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,343 @@
+/*
+ * File:         arch/blackfin/kernel/time.c
+ * Based on:     none - original work
+ * Author:
+ *
+ * Created:
+ * Description:  This file contains the bfin-specific time handling details.
+ *               Most of the stuff is located in the machine specific files.
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http:    //blackfin.uclinux.org/
+ *
+ * This program is free software ;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation ;  either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY ;  without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program ;  see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/profile.h>
+#include <linux/interrupt.h>
+
+#include <asm/blackfin.h>
+#include <asm/irq.h>
+#include <asm/bf5xx_rtc.h>
+
+#define	TICK_SIZE (tick_nsec / 1000)
+
+void time_sched_init(irqreturn_t (*timer_routine)
+		      (int, void *, struct pt_regs *));
+unsigned long gettimeoffset(void);
+extern unsigned long wall_jiffies;
+extern int setup_irq(unsigned int, struct irqaction *);
+inline static void do_leds(void);
+
+extern u_long get_cclk(void);
+
+#define TIME_SCALE 100
+#define CLOCKS_PER_JIFFY (get_cclk() / HZ / TIME_SCALE)
+
+#if (defined(CONFIG_BFIN_ALIVE_LED) || defined(CONFIG_BFIN_IDLE_LED))
+void __init init_leds(void)
+{
+	unsigned int tmp = 0;
+
+#if defined(CONFIG_BFIN_ALIVE_LED)
+	/* config pins as output. */
+	tmp = *(volatile unsigned short *)CONFIG_BFIN_ALIVE_LED_DPORT;
+	__builtin_bfin_ssync();
+	*(volatile unsigned short *)CONFIG_BFIN_ALIVE_LED_DPORT =
+	    tmp | CONFIG_BFIN_ALIVE_LED_PIN;
+	__builtin_bfin_ssync();
+
+	/*      First set led be off */
+	tmp = *(volatile unsigned short *)CONFIG_BFIN_ALIVE_LED_PORT;
+	__builtin_bfin_ssync();
+	*(volatile unsigned short *)CONFIG_BFIN_ALIVE_LED_PORT = tmp | CONFIG_BFIN_ALIVE_LED_PIN;	/* light off */
+	__builtin_bfin_ssync();
+#endif
+
+#if defined(CONFIG_BFIN_IDLE_LED)
+	/* config pins as output. */
+	tmp = *(volatile unsigned short *)CONFIG_BFIN_IDLE_LED_DPORT;
+	__builtin_bfin_ssync();
+	*(volatile unsigned short *)CONFIG_BFIN_IDLE_LED_DPORT =
+	    tmp | CONFIG_BFIN_IDLE_LED_PIN;
+	__builtin_bfin_ssync();
+
+	/*      First set led be off */
+	tmp = *(volatile unsigned short *)CONFIG_BFIN_IDLE_LED_PORT;
+	__builtin_bfin_ssync();
+	*(volatile unsigned short *)CONFIG_BFIN_IDLE_LED_PORT = tmp | CONFIG_BFIN_IDLE_LED_PIN;	/* light off */
+	__builtin_bfin_ssync();
+#endif
+
+}
+#else
+inline void __init init_leds(void)
+{
+}
+#endif
+
+#if defined(CONFIG_BFIN_ALIVE_LED)
+inline static void do_leds(void)
+{
+	static unsigned int count = 50;
+	static int flag = 0;
+	unsigned short tmp = 0;
+
+	if (--count == 0) {
+		count = 50;
+		flag = ~flag;
+	}
+	tmp = *(volatile unsigned short *)CONFIG_BFIN_ALIVE_LED_PORT;
+	__builtin_bfin_ssync();
+
+	if (flag)
+		tmp &= ~CONFIG_BFIN_ALIVE_LED_PIN;	/* light on */
+	else
+		tmp |= CONFIG_BFIN_ALIVE_LED_PIN;	/* light off */
+
+	*(volatile unsigned short *)CONFIG_BFIN_ALIVE_LED_PORT = tmp;
+	__builtin_bfin_ssync();
+
+}
+#else
+inline static void do_leds(void)
+{
+}
+#endif
+
+static struct irqaction bfin_timer_irq = {
+	.name = "BFIN Timer Tick",
+	.flags = SA_INTERRUPT
+};
+
+void
+time_sched_init(irqreturn_t(*timer_routine) (int, void *, struct pt_regs *))
+{
+	/* power up the timer, but don't enable it just yet */
+	*pTCNTL = 1;
+	__builtin_bfin_csync();
+
+	/*
+	 * the TSCALE prescaler counter.
+	 */
+	*pTSCALE = (TIME_SCALE - 1);
+
+	*pTCOUNT = *pTPERIOD = (CLOCKS_PER_JIFFY - 1);
+
+	/* now enable the timer */
+	__builtin_bfin_csync();
+
+	*pTCNTL = 7;
+
+	bfin_timer_irq.handler = timer_routine;
+	/* call setup_irq instead of request_irq because request_irq calls kmalloc which has not been initialized yet */
+	setup_irq(IRQ_CORETMR, &bfin_timer_irq);
+}
+
+unsigned long gettimeoffset(void)
+{
+	unsigned long offset;
+	unsigned long clocks_per_jiffy = CLOCKS_PER_JIFFY;	/* call get_cclk() only once */
+
+	offset =
+	    tick_usec * (clocks_per_jiffy - (*pTCOUNT + 1)) / clocks_per_jiffy;
+
+	/* Check if we just wrapped the counters and maybe missed a tick */
+	if ((*pILAT & (1 << IRQ_CORETMR)) && (offset < (100000 / HZ / 2)))
+		offset += (1000000 / HZ);
+
+	return offset;
+}
+
+static inline int set_rtc_mmss(unsigned long nowtime)
+{
+	return 0;
+}
+
+static inline void do_profile(struct pt_regs *regs)
+{
+/*
+ * temperary remove code to do profile, because the arch change of the profile in the kernel 2.6.12
+ */
+#if 0
+	unsigned long pc;
+
+	pc = regs->pc;
+
+	profile_hook(regs);
+
+	if (prof_buffer && current->pid) {
+		extern int _stext;
+		pc -= (unsigned long)&_stext;
+		pc >>= prof_shift;
+		if (pc < prof_len)
+			++prof_buffer[pc];
+		else
+			/*
+			 * Don't ignore out-of-bounds PC values silently,
+			 * put them into the last histogram slot, so if
+			 * present, they will show up as a sharp peak.
+			 */
+			++prof_buffer[prof_len - 1];
+	}
+#endif
+}
+
+/*
+ * timer_interrupt() needs to keep up the real-time clock,
+ * as well as call the "do_timer()" routine every clocktick
+ */
+irqreturn_t timer_interrupt(int irq, void *dummy, struct pt_regs *regs)
+{
+	/* last time the cmos clock got updated */
+	static long last_rtc_update = 0;
+
+	write_seqlock(&xtime_lock);
+
+	do_timer(regs);
+	do_leds();
+
+#ifndef CONFIG_SMP
+	update_process_times(user_mode(regs));
+#endif
+	profile_tick(CPU_PROFILING, regs);
+
+	/*
+	 * If we have an externally synchronized Linux clock, then update
+	 * CMOS clock accordingly every ~11 minutes. Set_rtc_mmss() has to be
+	 * called as close as possible to 500 ms before the new second starts.
+	 */
+
+	if (ntp_synced() &&
+	    xtime.tv_sec > last_rtc_update + 660 &&
+	    (xtime.tv_nsec / 1000) >= 500000 - ((unsigned)TICK_SIZE) / 2 &&
+	    (xtime.tv_nsec / 1000) <= 500000 + ((unsigned)TICK_SIZE) / 2) {
+		if (set_rtc_mmss(xtime.tv_sec) == 0)
+			last_rtc_update = xtime.tv_sec;
+		else
+			/* Do it again in 60s. */
+			last_rtc_update = xtime.tv_sec - 600;
+	}
+	write_sequnlock(&xtime_lock);
+	return IRQ_HANDLED;
+}
+
+void time_init(void)
+{
+#ifdef CONFIG_BFIN_HAVE_RTC
+	time_t secs_since_1970 = 0;
+
+	/* Initialize the RTC sub-system */
+	rtc_init();
+	/* Retrieve calendar time (secs since Jan 1970) */
+	rtc_get(&secs_since_1970);
+#else
+	time_t secs_since_1970 = (365 * 35 + 9) * 24 * 3600;	/* 1 Jan 2005 */
+#endif
+	/* Initialize xtime. From now on, xtime is updated with timer interrupts */
+	xtime.tv_sec = secs_since_1970;
+	xtime.tv_nsec = 0;
+
+	wall_to_monotonic.tv_sec = -xtime.tv_sec;
+
+	time_sched_init(timer_interrupt);
+}
+
+void do_gettimeofday(struct timeval *tv)
+{
+	unsigned long flags;
+	unsigned long lost, seq;
+	unsigned long usec, sec;
+
+	do {
+		seq = read_seqbegin_irqsave(&xtime_lock, flags);
+		usec = gettimeoffset();
+		lost = jiffies - wall_jiffies;
+		if (lost)
+			usec += lost * (1000000 / HZ);
+		sec = xtime.tv_sec;
+		usec += (xtime.tv_nsec / 1000);
+	}
+	while (read_seqretry_irqrestore(&xtime_lock, seq, flags));
+
+	while (usec >= 1000000) {
+		usec -= 1000000;
+		sec++;
+	}
+
+	tv->tv_sec = sec;
+	tv->tv_usec = usec;
+}
+
+EXPORT_SYMBOL(do_gettimeofday);
+
+int do_settimeofday(struct timespec *tv)
+{
+	time_t wtm_sec, sec = tv->tv_sec;
+	long wtm_nsec, nsec = tv->tv_nsec;
+
+	if ((unsigned long)tv->tv_nsec >= NSEC_PER_SEC)
+		return -EINVAL;
+
+	write_seqlock_irq(&xtime_lock);
+	/*
+	 * This is revolting. We need to set the xtime.tv_usec
+	 * correctly. However, the value in this location is
+	 * is value at the last tick.
+	 * Discover what correction gettimeofday
+	 * would have done, and then undo it!
+	 */
+	nsec -= (gettimeoffset() * 1000);
+
+	wtm_sec = wall_to_monotonic.tv_sec + (xtime.tv_sec - sec);
+	wtm_nsec = wall_to_monotonic.tv_nsec + (xtime.tv_nsec - nsec);
+
+	set_normalized_timespec(&xtime, sec, nsec);
+	set_normalized_timespec(&wall_to_monotonic, wtm_sec, wtm_nsec);
+
+	ntp_clear();
+
+	write_sequnlock_irq(&xtime_lock);
+	clock_was_set();
+
+	/*
+	 *  rtc_set() busy-waits up to a second (the next tick of the RTC)
+	 *  for completion of the write.
+	 *  We release xtime_lock before updating the RTC so as not to
+	 *  lock out the timer_interrupt() routine which also acquires
+	 *  xtime_lock.  Locking out timer_interrupt() loses ticks!
+	 */
+#ifdef CONFIG_BFIN_HAVE_RTC
+	rtc_set(sec);
+#endif
+
+	return 0;
+}
+
+/*
+ * Scheduler clock - returns current time in nanosec units.
+ */
+unsigned long long sched_clock(void)
+{
+	return (unsigned long long)jiffies *(1000000000 / HZ);
+}
+
+EXPORT_SYMBOL(do_settimeofday);
Index: git/linux-2.6/arch/blackfin/kernel/traps.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/kernel/traps.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,392 @@
+/*
+ * File:         arch/blackfin/kernel/traps.c
+ * Based on:
+ * Author:       Hamish Macdonald
+ *
+ * Created:
+ * Description:  uses S/W interrupt 15 for the system calls
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http:    //blackfin.uclinux.org/
+ *
+ * This program is free software ;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation ;  either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY ;  without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program ;  see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/traps.h>
+#include <asm/blackfin.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+
+/*
+ *  . EXCEPTION TRAPS DEBUGGING LEVELS
+ *  .
+ *  0 for normal operation without any error messages
+ *  1 for serious error messages
+ *  2 for errors but handled somwhere else
+ * >2 for various levels of hopefully increasingly useless information
+ */
+
+#define TRAPS_DEBUG 1		/* Must be defined here or in in Makefile */
+
+#if (TRAPS_DEBUG > 2 )
+#define DPRINTK3(args...) printk(args)
+#else
+#define DPRINTK3(args...)
+#endif
+
+#if TRAPS_DEBUG > 1
+#define DPRINTK2(args...) printk(args)
+#else
+#define DPRINTK2(args...)
+#endif
+
+#ifdef TRAPS_DEBUG
+#define DPRINTK(args...) printk(args)
+#else
+#define DPRINTK(args...)
+#endif
+
+/* assembler routines */
+asmlinkage void evt_system_call(void);
+asmlinkage void evt_soft_int1(void);
+asmlinkage void trap(void);
+
+extern void dump(struct pt_regs *fp, void *);
+extern void _cplb_hdr(void);
+
+/* Initiate the event table handler */
+void __init trap_init(void)
+{
+	__builtin_bfin_csync();
+	*pEVT3 = trap;
+	__builtin_bfin_csync();
+}
+
+asmlinkage void trap_c(struct pt_regs *fp);
+
+int kstack_depth_to_print = 48;
+
+#ifdef CONFIG_KALLSYMS
+#include <linux/kallsyms.h>
+int printk_address(unsigned long address)
+{
+	unsigned long offset = 0, symsize;
+	const char *symname;
+	char *modname;
+	char *delim = ":";
+	char namebuf[128];
+
+	symname =
+	    kallsyms_lookup(address, &symsize, &offset, &modname, namebuf);
+	if (!symname) {
+		if (current->mm) {
+			if ((address > current->mm->start_code) &&
+			    (address < current->mm->end_code)) {
+				return printk("<%08lx>{%s+0x%x}",
+					      address,
+					      current->comm,
+					      (int)(address -
+						    current->mm->start_code));
+			}
+		}
+		return printk("[<%08lx>]", address);
+	}
+	if (!modname)
+		modname = delim = "";
+	return printk("<%08lx>{%s%s%s%s%+ld}",
+		      address, delim, modname, delim, symname, offset);
+}
+#else
+int printk_address(unsigned long address)
+{
+	return printk("[<%08lx>]", address);
+}
+#endif
+
+/* Used by the assembly entry point to work around an anomaly.  */
+void *last_cplb_fault_retx;
+
+asmlinkage void trap_c(struct pt_regs *fp)
+{
+	int j, sig = 0;
+	siginfo_t info;
+
+	j = *pTBUFCTL;
+	*pTBUFCTL = j & 0x1D;
+
+	/* trap_c() will be called for exceptions. During exceptions
+	   processing, the pc value should be set with retx value.
+	   With this change we can cleanup some code in signal.c- TODO */
+	fp->orig_pc = fp->retx;
+
+	/* send the appropriate signal to the user program */
+	switch (fp->seqstat & 0x3f) {
+	case VEC_STEP:
+		info.si_code = TRAP_STEP;
+		sig = SIGTRAP;
+		break;
+	case VEC_EXCPT01:	/* gdb breakpoint */
+		info.si_code = TRAP_ILLTRAP;
+		sig = SIGTRAP;
+		break;
+	case VEC_EXCPT03:	/* Atomic test and set service */
+		info.si_code = SEGV_STACKFLOW;
+		sig = SIGSEGV;
+		DPRINTK(EXC_0x03);
+		break;
+	case VEC_EXCPT04:	/* Atomic test and set service */
+		panic("Exception 4");
+		goto nsig;
+	case VEC_UNDEF_I:
+		info.si_code = ILL_ILLOPC;
+		sig = SIGILL;
+		DPRINTK(EXC_0x21);
+		break;
+	case VEC_OVFLOW:
+		info.si_code = TRAP_TRACEFLOW;
+		sig = SIGTRAP;
+		DPRINTK(EXC_0x11);
+		break;
+	case VEC_ILGAL_I:
+		info.si_code = ILL_ILLPARAOP;
+		sig = SIGILL;
+		DPRINTK(EXC_0x22);
+		break;
+	case VEC_ILL_RES:
+		info.si_code = ILL_PRVOPC;
+		sig = SIGILL;
+		DPRINTK(EXC_0x2E);
+		break;
+	case VEC_MISALI_D:
+		info.si_code = BUS_ADRALN;
+		sig = SIGBUS;
+		DPRINTK(EXC_0x24);
+		DPRINTK("DCPLB_FAULT_ADDR=%p\n", *pDCPLB_FAULT_ADDR);
+		break;
+	case VEC_MISALI_I:
+		info.si_code = BUS_ADRALN;
+		sig = SIGBUS;
+		DPRINTK(EXC_0x2A);
+		DPRINTK("ICPLB_FAULT_ADDR=%p\n", *pICPLB_FAULT_ADDR);
+		break;
+	case VEC_UNCOV:
+		info.si_code = ILL_ILLEXCPT;
+		sig = SIGILL;
+		DPRINTK(EXC_0x25);
+		break;
+	case VEC_WATCH:
+		info.si_code = TRAP_WATCHPT;
+		sig = SIGTRAP;
+		DPRINTK3(EXC_0x28);
+		break;
+	case VEC_ISTRU_VL:	/* ADSP-BF535 only (MH) */
+		info.si_code = BUS_OPFETCH;
+		sig = SIGBUS;
+		break;
+	case VEC_CPLB_I_VL:
+		DPRINTK2(EXC_0x2B);
+		DPRINTK2("ICPLB_FAULT_ADDR: %p\n", *pICPLB_FAULT_ADDR);
+	case VEC_CPLB_VL:
+		info.si_code = ILL_CPLB_VI;
+		DPRINTK3(EXC_0x23);
+		DPRINTK3("DCPLB_FAULT_ADDR=%p\n", *pDCPLB_FAULT_ADDR);
+		_cplb_hdr();
+		goto nsig;
+		sig = SIGILL;
+		break;
+	case VEC_CPLB_I_M:
+		DPRINTK3(EXC_0x2C);
+		DPRINTK3("ICPLB_FAULT_ADDR=%p\n", *pICPLB_FAULT_ADDR);
+	case VEC_CPLB_M:
+		info.si_code = IlL_CPLB_MISS;
+		DPRINTK3(EXC_0x26);
+		DPRINTK3("DCPLB_FAULT_ADDR=%p\n", *pDCPLB_FAULT_ADDR);
+		/*Call the handler to replace the CPLB */
+		_cplb_hdr();
+		goto nsig;
+	case VEC_CPLB_I_MHIT:
+		info.si_code = ILL_CPLB_MULHIT;
+		sig = SIGILL;
+		DPRINTK3(EXC_0x2D);
+		DPRINTK3("ICPLB_FAULT_ADDR=%p\n", *pICPLB_FAULT_ADDR);
+		break;
+	case VEC_CPLB_MHIT:
+		info.si_code = ILL_CPLB_MULHIT;
+		sig = SIGILL;
+		DPRINTK3(EXC_0x27);
+		DPRINTK3("DCPLB_FAULT_ADDR=%p\n", *pDCPLB_FAULT_ADDR);
+		break;
+	default:
+		info.si_code = TRAP_ILLTRAP;
+		sig = SIGTRAP;
+		break;
+	}
+	info.si_signo = sig;
+	info.si_errno = 0;
+	info.si_addr = (void *)fp->pc;
+	force_sig_info(sig, &info, current);
+	if (sig != 0 && sig != SIGTRAP) {
+		dump(fp, (void *)fp->retx);
+		dump_stack();
+
+	}
+      nsig:
+	*pTBUFCTL = j;
+	return;
+}
+
+/* Typical exception handling routines	*/
+void show_stack(struct task_struct *task, unsigned long *stack)
+{
+	unsigned long *endstack, addr;
+	extern char _start, _etext;
+	int i;
+
+	if (!stack) {
+		if (task)
+			stack = (unsigned long *)task->thread.ksp;
+		else
+			stack = (unsigned long *)&stack;
+	}
+
+	addr = (unsigned long)stack;
+	endstack = (unsigned long *)PAGE_ALIGN(addr);
+
+	printk(KERN_EMERG "Stack from %08lx:", (unsigned long)stack);
+	for (i = 0; i < kstack_depth_to_print; i++) {
+		if (stack + 1 > endstack)
+			break;
+		if (i % 8 == 0)
+			printk(KERN_EMERG "\n       ");
+		printk(KERN_EMERG " %08lx", *stack++);
+	}
+
+	printk(KERN_EMERG "\nCall Trace:");
+	i = 0;
+	while (stack + 1 <= endstack) {
+		addr = *stack++;
+		/*
+		 * If the address is either in the text segment of the
+		 * kernel, or in the region which contains vmalloc'ed
+		 * memory, it *may* be the address of a calling
+		 * routine; if so, print it so that someone tracing
+		 * down the cause of the crash will be able to figure
+		 * out the call path that was taken.
+		 */
+		if (addr >= (unsigned long)&_start
+		    && addr <= (unsigned long)&_etext) {
+			if (i % 4 == 0)
+				printk(KERN_EMERG "\n       ");
+			printk(KERN_EMERG " [<%08lx>]", addr);
+			i++;
+		}
+	}
+	printk(KERN_EMERG "\n");
+}
+
+void dump_stack(void)
+{
+	unsigned long stack;
+	show_stack(current, &stack);
+}
+
+EXPORT_SYMBOL(dump_stack);
+
+void dump(struct pt_regs *fp, void *retaddr)
+{
+	int i;
+
+	printk("\nCURRENT PROCESS:\n\n");
+	printk("COMM=%s PID=%d\n", current->comm, current->pid);
+	if (current->mm) {
+		printk("TEXT=%08x-%08x DATA=%08x-%08x BSS=%08x-%08x\n",
+		       (int)current->mm->start_code,
+		       (int)current->mm->end_code,
+		       (int)current->mm->start_data,
+		       (int)current->mm->end_data,
+		       (int)current->mm->end_data, (int)current->mm->brk);
+		printk("USER-STACK=%08x\n\n", (int)current->mm->start_stack);
+	}
+	printk("return address: %08lx; contents of [PC-16...PC+8[:\n",
+	       (long)retaddr);
+	for (i = -16; i < 8; i++) {
+		unsigned short x;
+		get_user(x, (unsigned short *)retaddr + i);
+		if (i == -8)
+			printk("\n");
+		if (i == 0)
+			printk("X\n");
+		printk("%04x ", x);
+	}
+	printk("\n\n");
+
+	printk("RETE:  %08lx  RETN: %08lx  RETX: %08lx  RETS: %08lx\n",
+	       fp->rete, fp->retn, fp->retx, fp->rets);
+	printk("IPEND: %04lx  SYSCFG: %04lx\n", fp->ipend, fp->syscfg);
+	printk("SEQSTAT: %08lx    SP: %08lx\n", (long)fp->seqstat, (long)fp);
+	printk("R0: %08lx    R1: %08lx    R2: %08lx    R3: %08lx\n",
+	       fp->r0, fp->r1, fp->r2, fp->r3);
+	printk("R4: %08lx    R5: %08lx    R6: %08lx    R7: %08lx\n",
+	       fp->r4, fp->r5, fp->r6, fp->r7);
+	printk("P0: %08lx    P1: %08lx    P2: %08lx    P3: %08lx\n",
+	       fp->p0, fp->p1, fp->p2, fp->p3);
+	printk("P4: %08lx    P5: %08lx    FP: %08lx\n", fp->p4, fp->p5, fp->fp);
+	printk("A0.w: %08lx    A0.x: %08lx    A1.w: %08lx    A1.x: %08lx\n",
+	       fp->a0w, fp->a0x, fp->a1w, fp->a1x);
+
+	printk("LB0: %08lx  LT0: %08lx  LC0: %08lx\n", fp->lb0, fp->lt0,
+	       fp->lc0);
+	printk("LB1: %08lx  LT1: %08lx  LC1: %08lx\n", fp->lb1, fp->lt1,
+	       fp->lc1);
+	printk("B0: %08lx  L0: %08lx  M0: %08lx  I0: %08lx\n", fp->b0, fp->l0,
+	       fp->m0, fp->i0);
+	printk("B1: %08lx  L1: %08lx  M1: %08lx  I1: %08lx\n", fp->b1, fp->l1,
+	       fp->m1, fp->i1);
+	printk("B2: %08lx  L2: %08lx  M2: %08lx  I2: %08lx\n", fp->b2, fp->l2,
+	       fp->m2, fp->i2);
+	printk("B3: %08lx  L3: %08lx  M3: %08lx  I3: %08lx\n", fp->b3, fp->l3,
+	       fp->m3, fp->i3);
+
+	printk("\nUSP: %08lx   ASTAT: %08lx\n", rdusp(), fp->astat);
+
+	printk("\n\n");
+	if (*pTBUFSTAT) {
+		printk(KERN_EMERG "Hardware Trace:\n");
+		for (i = 0; (*pTBUFSTAT) & 0x1f; i++) {
+			printk(KERN_EMERG "%2i Target : ", i);
+			printk_address((unsigned long)*pTBUF);
+			printk(KERN_EMERG "\n   Source : ");
+			printk_address((unsigned long)*pTBUF);
+			printk(KERN_EMERG "\n");
+		}
+	}
+}
+
+asmlinkage int sys_bfin_spinlock(int *spinlock)
+{
+	int ret = 0;
+	local_irq_disable();
+	if (*spinlock)
+		ret = 1;
+	*spinlock = 1;
+	local_irq_enable();
+	return ret;
+}
Index: git/linux-2.6/arch/blackfin/kernel/vmlinux.lds.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/kernel/vmlinux.lds.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,194 @@
+/*
+ * File:	 arch/blackfin/kernel/vmlinux.lds.S
+ * Based on:	 none - original work
+ * Author:
+ *
+ * Created:	 Tue Sep 21 2004
+ * Description:	 Master linker script for blackfin architecture
+ *
+ * Rev:	         $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:	 Enter bugs at http:	//blackfin.uclinux.org/
+ *
+ * This program is free software ;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation	;  either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY ;  without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program ;  see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#define VMLINUX_SYMBOL(_sym_) _##_sym_
+
+#include <asm-generic/vmlinux.lds.h>
+#include <linux/config.h>
+#include <asm/mem_map.h>
+
+
+OUTPUT_FORMAT("elf32-bfin")
+ENTRY(__start)
+_jiffies = _jiffies_64;
+MEMORY
+	{
+	ram		: ORIGIN = RAM_START,       LENGTH = RAM_LENGTH
+	l1_data_a	: ORIGIN = L1_DATA_A_START, LENGTH = L1_DATA_A_LENGTH
+	l1_data_b	: ORIGIN = L1_DATA_B_START, LENGTH = L1_DATA_B_LENGTH
+	l1_code		: ORIGIN = L1_CODE_START,   LENGTH = L1_CODE_LENGTH
+	l1_scratch	: ORIGIN = L1_SCRATCH_START,LENGTH = L1_SCRATCH_LENGTH
+	}
+
+SECTIONS
+{
+	. = RAM_START ;
+
+	.text  : {
+		 __stext = .;
+		*(.text)
+		SCHED_TEXT
+		*(.text.lock)
+		. = ALIGN(16);
+		  ___start___ex_table = .;
+		*(__ex_table)
+		 ___stop___ex_table = .;
+
+		  *($code)
+        	  *(.rodata)
+        	  *(.rodata.*)
+		  *(__vermagic)		/* Kernel version magic */
+        	  *(.rodata1)
+	          *(.fixup)
+
+		/* Kernel symbol table: Normal symbols */
+		. = ALIGN(4);
+		___start___ksymtab = .;
+		*(__ksymtab)
+		___stop___ksymtab = .;
+
+		/* Kernel symbol table: GPL-only symbols */
+		___start___ksymtab_gpl = .;
+		*(__ksymtab_gpl)
+		___stop___ksymtab_gpl = .;
+
+		/* Kernel symbol table: Normal symbols */
+		___start___kcrctab = .;
+		*(__kcrctab)
+		___stop___kcrctab = .;
+
+		/* Kernel symbol table: GPL-only symbols */
+		___start___kcrctab_gpl = .;
+		*(__kcrctab_gpl)
+		___stop___kcrctab_gpl = .;
+
+		/* Kernel symbol table: strings */
+		*(__ksymtab_strings)
+
+		 . = ALIGN(4) ;
+	  	__etext = . ;
+	} > ram
+
+	.init :
+	{
+		. = ALIGN(4096);
+		___init_begin = .;
+		__sinittext = .;
+		*(.init.text)
+		__einittext = .;
+		*(.init.data)
+		. = ALIGN(16);
+		___setup_start = .;
+		*(.init.setup)
+		___setup_end = .;
+		___start___param = .;
+		*(__param)
+		___stop___param = .;
+		___initcall_start = .;
+		*(.initcall1.init)
+		*(.initcall2.init)
+		*(.initcall3.init)
+		*(.initcall4.init)
+		*(.initcall5.init)
+		*(.initcall6.init)
+		*(.initcall7.init)
+		___initcall_end = .;
+		___con_initcall_start = .;
+		*(.con_initcall.init)
+		___con_initcall_end = .;
+		___security_initcall_start = .;
+		*(.security_initcall.init)
+		___security_initcall_end = .;
+		. = ALIGN(4);
+		___initramfs_start = .;
+		*(.init.ramfs)
+		___initramfs_end = .;
+		. = ALIGN(4);
+		___init_end = .;
+	} > ram
+
+	 __l1_lma_start = .;
+	.text_l1 L1_CODE_START :
+		AT ( __l1_lma_start )
+	{
+		. = ALIGN(4) ;
+		 __stext_l1 = . ;
+		*(.text.l1)
+
+		. = ALIGN(4) ;
+		 __etext_l1 = . ;
+	}
+
+	.data_l1 L1_DATA_A_START :
+		AT ( __l1_lma_start + SIZEOF(.text_l1) )
+	{
+		. = ALIGN(4) ;
+		 __sdata_l1 = . ;
+		*(.data.l1)
+		 __edata_l1 = . ;
+
+		. = ALIGN(4) ;
+		 __sbss_l1 = . ;
+		*(.bss.l1)
+
+		. = ALIGN(4) ;
+		 __ebss_l1 = . ;
+	}
+
+	. = __l1_lma_start + SIZEOF(.text_l1) + SIZEOF(.data_l1) ;
+	.data (__l1_lma_start + SIZEOF(.text_l1) + SIZEOF(.data_l1)) :	AT ( __l1_lma_start + SIZEOF(.text_l1) + SIZEOF(.data_l1) )
+	{
+		 __sdata = . ;
+		. = ALIGN(0x2000) ;
+		*(.data.init_task)
+		*(.data)
+		__edata = . ;
+	} > ram
+
+	/DISCARD/ : {			/* Exit code and data*/
+		*(.exit.text)
+		*(.exit.data)
+		*(.exitcall.exit)
+	} > ram
+
+
+	.bss : AT ( __l1_lma_start + SIZEOF(.text_l1) + SIZEOF(.data_l1) + SIZEOF(.data) )
+	{
+		. = ALIGN(4) ;
+		 __sbss = . ;
+		*(.bss)
+		*(COMMON)
+		. = ALIGN(4) ;
+		 __ebss = . 	;
+		 __end = .	;
+ 		__bss_end = . ;
+    	} > ram
+}
Index: git/linux-2.6/arch/blackfin/lib/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/lib/Makefile	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,8 @@
+#
+# Makefile for blackfin specific library files..
+#
+
+lib-y	:= ashldi3.o ashrdi3.o lshrdi3.o \
+	   muldi3.o divsi3.o udivsi3.o modsi3.o umodsi3.o \
+	   checksum.o memcpy.o memset.o memcmp.o memchr.o memmove.o \
+	   ins.o outs.o
Index: git/linux-2.6/arch/blackfin/lib/ashldi3.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/lib/ashldi3.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,55 @@
+/*
+ * File:         arch/blackfin/lib/ashldi3.c
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "gcclib.h"
+
+DItype __ashldi3(DItype u, word_type b)
+{
+	DIunion w;
+	word_type bm;
+	DIunion uu;
+
+	if (b == 0)
+		return u;
+
+	uu.ll = u;
+
+	bm = (sizeof(SItype) * BITS_PER_UNIT) - b;
+	if (bm <= 0) {
+		w.s.low = 0;
+		w.s.high = (USItype) uu.s.low << -bm;
+	} else {
+		USItype carries = (USItype) uu.s.low >> bm;
+		w.s.low = (USItype) uu.s.low << b;
+		w.s.high = ((USItype) uu.s.high << b) | carries;
+	}
+
+	return w.ll;
+}
Index: git/linux-2.6/arch/blackfin/lib/ashrdi3.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/lib/ashrdi3.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,57 @@
+/*
+ * File:         arch/blackfin/lib/ashrdi3.c
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "gcclib.h"
+
+DItype __ashrdi3(DItype u, word_type b)
+{
+	DIunion w;
+	word_type bm;
+	DIunion uu;
+
+	if (b == 0)
+		return u;
+
+	uu.ll = u;
+
+	bm = (sizeof(SItype) * BITS_PER_UNIT) - b;
+	if (bm <= 0) {
+		/* w.s.high = 1..1 or 0..0 */
+		w.s.high = uu.s.high >> (sizeof(SItype) * BITS_PER_UNIT - 1);
+		w.s.low = uu.s.high >> -bm;
+	} else {
+		USItype carries = (USItype) uu.s.high << bm;
+		w.s.high = uu.s.high >> b;
+		w.s.low = ((USItype) uu.s.low >> b) | carries;
+	}
+
+	return w.ll;
+}
Index: git/linux-2.6/arch/blackfin/lib/checksum.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/lib/checksum.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,135 @@
+/*
+ * File:         arch/blackfin/lib/checksum.c
+ * Based on:     none - original work
+ * Author:
+ * Created:
+ * Description:  An implementation of the TCP/IP protocol suite for the LINUX
+ *               operating system.  INET is implemented using the  BSD Socket
+ *               interface as the means of communication with the user level.
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include <net/checksum.h>
+#include <asm/checksum.h>
+
+static unsigned short do_csum(const unsigned char *buff, int len)
+{
+
+	register unsigned long sum = 0;
+	int swappem = 0;
+
+	if (1 & (unsigned long)buff) {
+		sum = *buff << 8;
+		buff++;
+		len--;
+		++swappem;
+	}
+
+	while (len > 1) {
+		sum += *(unsigned short *)buff;
+		buff += 2;
+		len -= 2;
+	}
+
+	if (len > 0)
+		sum += *buff;
+
+	/*  Fold 32-bit sum to 16 bits */
+	while (sum >> 16)
+		sum = (sum & 0xffff) + (sum >> 16);
+
+	if (swappem)
+		sum = ((sum & 0xff00) >> 8) + ((sum & 0x00ff) << 8);
+
+	return sum;
+
+}
+
+/*
+ *	This is a version of ip_compute_csum() optimized for IP headers,
+ *	which always checksum on 4 octet boundaries.
+ */
+unsigned short ip_fast_csum(unsigned char *iph, unsigned int ihl)
+{
+	return ~do_csum(iph, ihl * 4);
+}
+
+/*
+ * computes the checksum of a memory block at buff, length len,
+ * and adds in "sum" (32-bit)
+ *
+ * returns a 32-bit number suitable for feeding into itself
+ * or csum_tcpudp_magic
+ *
+ * this function must be called with even lengths, except
+ * for the last fragment, which may be odd
+ *
+ * it's best to have buff aligned on a 32-bit boundary
+ */
+unsigned int csum_partial(const unsigned char *buff, int len, unsigned int sum)
+{
+
+	/* printk(KERN_INFO "csum_partial(%p, %i, %i)", buff, len, sum); */
+
+	sum += do_csum(buff, len);
+
+	sum = (sum & 0xffff) + (sum >> 16);
+
+	/* printk(" = %04x\n", sum); */
+
+	return sum;
+}
+
+/*
+ * this routine is used for miscellaneous IP-like checksums, mainly
+ * in icmp.c
+ */
+unsigned short ip_compute_csum(const unsigned char *buff, int len)
+{
+	return ~do_csum(buff, len);
+}
+
+/*
+ * copy from fs while checksumming, otherwise like csum_partial
+ */
+
+unsigned int
+csum_partial_copy_from_user(const unsigned char *src, unsigned char *dst,
+			    int len, int sum, int *csum_err)
+{
+	if (csum_err)
+		*csum_err = 0;
+	memcpy(dst, src, len);
+	return csum_partial(dst, len, sum);
+}
+
+/*
+ * copy from ds while checksumming, otherwise like csum_partial
+ */
+
+unsigned int csum_partial_copy(const unsigned char *src, unsigned char *dst,
+			       int len, int sum)
+{
+	memcpy(dst, src, len);
+	return csum_partial(dst, len, sum);
+}
Index: git/linux-2.6/arch/blackfin/lib/divsi3.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/lib/divsi3.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,156 @@
+/*
+ * File:         arch/blackfin/lib/divsi3.S
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:   16 / 32 bit signed division .
+ *                 Special cases :
+ *                      1)  If(numerator == 0)
+ *                             return 0
+ *                      2)  If(denominator ==0)
+ *                             return positive max = 0x7fffffff
+ *                      3)  If(numerator == denominator)
+ *                             return 1
+ *                      4)  If(denominator ==1)
+ *                             return numerator
+ *                      5)  If(denominator == -1)
+ *                             return -numerator
+ *
+ *		Operand         : R0 - Numerator   (i)
+ *              		  R1 - Denominator (i)
+ *                 		  R0 - Quotient    (o)
+ *			  	  Registers Used : R2-R7,P0-P2
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+.global   ___divsi3;
+
+.align 8;
+___divsi3 :
+/*
+ * Attempt to use divide primitives first; these will handle
+ *  most cases, and they're quick - avoids stalls incurred by
+ *  testing for identities.
+ */
+	R2.H = 0x8000;
+	R2 >>>= 16;                     /* R2 now 0xFFFF8000 */
+	R3 = R0 | R1;                   /* If either dividend or */
+	R2 = R3 & R2;                   /* divisor have bits in */
+	CC = R2;                        /* top half or low half's sign */
+	IF CC JUMP IDENTS;             /* bit, skip builtins. */
+	DIVS(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	R0 = R0.L (X);
+	RTS;
+
+	/* Can't use the primitives. Test common identities.
+	 * If the identity is true, return the value in R2.
+	 */
+
+IDENTS:
+	CC = R0 == 0;                   /* NR==0 => 0 */
+	IF CC JUMP ZERO_RETURN;
+
+	R2.L = -1;                      /* DR==0 => 0x7FFFFFFF */
+	R2.H = 0x7FFF;
+	CC = R1 == 0;
+	IF CC JUMP IDENT_RETURN;
+
+	R2 = 1 (Z);                     /* NR==DR => 1 */
+	CC = R0 == R1;
+	IF CC JUMP IDENT_RETURN;
+
+	R2 = R0;                        /* DR==1 => NR */
+	CC = R1 == 1;
+	IF CC JUMP IDENT_RETURN;
+
+	R2 = -R0;                       /* DR==-1 => -NR */
+	CC = R1 == -1;
+	IF CC JUMP IDENT_RETURN;
+
+	/* Identities haven't helped either.
+	 * Perform the full division process.
+	 */
+
+	P0 = R0;                        /* Copy R0,R1 */
+	P1 = R1;
+	R0 = ABS R0;                    /* Absolute of R0,R1 */
+	CC = V;
+	[--SP] = (R7:4);                /* Push registers R4-R7 */
+	R7 = CC;
+
+	R1 = ABS R1;
+	R3 = 0 ;                        /* Clear msw partial remainder */
+	R2 = R0<< 1;                    /* R2 lsw of dividend  */
+	R4 = R0^R1;                     /* Get sign */
+	R5 = R4 >> 31;                  /* Shift sign to LSB */
+
+	R2 = R2|R5;                     /* Shift quotient bit */
+	P2 = 31;                        /* Set loop counter   */
+	R4 = R3^R1;                     /* Get new quotient bit */
+
+	LSETUP ( LST,LEND )  LC0 = P2;     /* Setup loop */
+LST:    R5 = R2 >> 31;                  /* record copy of carry from R2 */
+	R2 = R2 << 1;                   /* Shift 64 bit dividend up by 1 bit */
+	R3 = R3 << 1;
+	R3 = R3|R5;                     /* and add carry */
+	CC = R4 < 0;                    /* Check quotient(AQ) */
+	R5 = -R1;                       /* we might be subtracting divisor (AQ==0) */
+	IF CC R5 = R1;                  /* or we might be adding divisor  (AQ==1)*/
+	R3 = R3 + R5;                   /* do add or subtract, as indicated by AQ */
+	R4 = R3^R1;                     /* Generate next quotient bit */
+	R5 = R4 >> 31;
+	BITCLR(R2,0);                   /* Assume AQ==1, shift in zero */
+	BITTGL(R5,0);                   /* tweak AQ to be what we want to shift in */
+LEND:   R2 = R2 + R5;                   /* and then set shifted-in value to tweaked AQ. */
+
+	R2 = R2 + R7;
+	R0 = P0;
+	R1 = P1;
+	R3 = R0^R1;
+	CC = R3<0;                      /* Check sign of R0 and R1 */
+	(R7:4)= [SP++];                 /* Pop registers R4-R7 */
+	R0 = -R2;                       /* If negative, return -R2 */
+	IF !CC R0 = R2;                 /* If positive, return R2 */
+	RTS;
+
+IDENT_RETURN:
+	R0 = R2;                        /* Return an identity value */
+ZERO_RETURN:
+	RTS;                            /* ...including zero */
Index: git/linux-2.6/arch/blackfin/lib/gcclib.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/lib/gcclib.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,48 @@
+/*
+ * File:         arch/blackfin/lib/gcclib.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#define BITS_PER_UNIT  8
+#define SI_TYPE_SIZE (sizeof (SItype) * BITS_PER_UNIT)
+
+typedef unsigned int UQItype __attribute__ ((mode(QI)));
+typedef int SItype __attribute__ ((mode(SI)));
+typedef unsigned int USItype __attribute__ ((mode(SI)));
+typedef int DItype __attribute__ ((mode(DI)));
+typedef int word_type __attribute__ ((mode(__word__)));
+typedef unsigned int UDItype __attribute__ ((mode(DI)));
+
+struct DIstruct {
+	SItype low, high;
+};
+
+typedef union {
+	struct DIstruct s;
+	DItype ll;
+} DIunion;
Index: git/linux-2.6/arch/blackfin/lib/ins.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/lib/ins.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,72 @@
+/*
+ * File:	ins.S
+ * Description:	Implementation of ins{bwl} for BlackFin processors using zero overhead loops.
+ * Rev:		$Id$
+ * Created:	Tue Mar 22 15:27:24 CEST 2005
+ * Author:	Bas Vermeulen
+ * Email:	bas@buyways.nl
+ *
+ * Copyright (C) 2005 Bas Vermeulen, BuyWays BV <bas@buyways.nl>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTIBILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/linkage.h>
+	.align 2;
+
+ENTRY(_insl)
+	P0 = R0;	/* P0 = port */
+	P1 = R1;	/* P1 = address */
+	P2 = R2;	/* P2 = count */
+	cli R2;
+	NOP;
+	NOP;
+
+	LSETUP( long_loop_s, long_loop_e) LC0 = P2;
+long_loop_s: R0 = [P0];
+long_loop_e: [P1++] = R0;
+
+    sti R2;
+	RTS;
+
+ENTRY(_insw)
+	P0 = R0;	/* P0 = port */
+	P1 = R1;	/* P1 = address */
+	P2 = R2;	/* P2 = count */
+	cli R2;
+	NOP;
+	NOP;
+
+	LSETUP( word_loop_s, word_loop_e) LC0 = P2;
+word_loop_s: R0 = W[P0];
+word_loop_e: W[P1++] = R0;
+
+	sti R2;
+	RTS;
+
+ENTRY(_insb)
+	P0 = R0;	/* P0 = port */
+	P1 = R1;	/* P1 = address */
+	P2 = R2;	/* P2 = count */
+	cli R2;
+	NOP;
+	NOP;
+
+	LSETUP( byte_loop_s, byte_loop_e) LC0 = P2;
+byte_loop_s: R0 = B[P0];
+byte_loop_e: B[P1++] = R0;
+	sti R2;
+	RTS;
Index: git/linux-2.6/arch/blackfin/lib/lshrdi3.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/lib/lshrdi3.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,70 @@
+/*
+ * File:         arch/blackfin/lib/lshrdi3.c
+ * Based on:
+ * Author:
+ *
+ * Created:      T
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#define BITS_PER_UNIT 8
+
+typedef int SItype __attribute__ ((mode(SI)));
+typedef unsigned int USItype __attribute__ ((mode(SI)));
+typedef int DItype __attribute__ ((mode(DI)));
+typedef int word_type __attribute__ ((mode(__word__)));
+
+struct DIstruct {
+	SItype high, low;
+};
+
+typedef union {
+	struct DIstruct s;
+	DItype ll;
+} DIunion;
+
+DItype __lshrdi3(DItype u, word_type b)
+{
+	DIunion w;
+	word_type bm;
+	DIunion uu;
+
+	if (b == 0)
+		return u;
+
+	uu.ll = u;
+
+	bm = (sizeof(SItype) * BITS_PER_UNIT) - b;
+	if (bm <= 0) {
+		w.s.high = 0;
+		w.s.low = (USItype) uu.s.high >> -bm;
+	} else {
+		USItype carries = (USItype) uu.s.high << bm;
+		w.s.high = (USItype) uu.s.high >> b;
+		w.s.low = ((USItype) uu.s.low >> b) | carries;
+	}
+
+	return w.ll;
+}
Index: git/linux-2.6/arch/blackfin/lib/memchr.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/lib/memchr.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,64 @@
+/*
+ * File:         arch/blackfin/lib/memchr.S
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:     Roy Huang <royhuang@blackfin.uclinux.org>
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/linkage.h>
+	.align 2;
+
+	   /*
+	   * C Library function MEMCHR
+	   * R0 = address
+	   * R1 = sought byte
+	   * R2 = count
+	   * Returns pointer to located character.
+	   */
+
+ENTRY(_memchr)
+	     P0 = R0 ;             /* P0 = address */
+	     P2 = R2 ;             /* P2 = count */
+	     R1 = R1.B(Z);
+	     CC = R2 == 0;
+	     IF CC JUMP failed;
+
+bytes:       LSETUP (byte_loop_s , byte_loop_e) LC0=P2;
+
+byte_loop_s:
+	     R3 = B[P0++](Z);
+	     CC = R3 == R1;
+	     IF CC JUMP found;
+	     NOP;
+byte_loop_e:
+
+failed:      R0=0;
+	     RTS;
+
+found:       R0 = P0;
+	     R0 += -1;
+	     RTS;
Index: git/linux-2.6/arch/blackfin/lib/memcmp.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/lib/memcmp.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,110 @@
+/*
+ * File:         arch/blackfin/lib/memcmp.S
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+.text
+.global _memcmp;
+	.align 2;
+/*
+ * C Library function MEMCMP
+ * R0 = First Address
+ * R1 = Second Address
+ * R2 = count
+ * Favours word aligned data.
+ */
+_memcmp:
+	I1 = P3;
+	P0 = R0;			/* P0 = s1 address */
+	P3 = R1;			/* P3 = s2 Address  */
+	P2 = R2 ;			/* P2 = count */
+	CC = R2 <= 7(IU);
+	IF CC JUMP  too_small;
+	I0 = R1;			/* s2 */
+	R1 = R1 | R0;		/* OR addresses together */
+	R1 <<= 30;		/* check bottom two bits */
+	CC =  AZ;			/* AZ set if zero. */
+	IF !CC JUMP  bytes ;	/* Jump if addrs not aligned. */
+
+	P1 = P2 >> 2;		/* count = n/4 */
+	R3 =  3;
+	R2 = R2 & R3;		/* remainder */
+	P2 = R2;			/* set remainder */
+
+	LSETUP (quad_loop_s , quad_loop_e) LC0=P1;
+quad_loop_s:
+	NOP;
+	R0 = [P0++];
+	R1 = [I0++];
+	CC = R0 == R1;
+	IF !CC JUMP quad_different;
+quad_loop_e:
+	NOP;
+
+	P3 = I0;			/* s2 */
+too_small:
+	CC = P2 == 0;		/* Check zero count*/
+	IF CC JUMP finished;	/* very unlikely*/
+
+bytes:
+	LSETUP (byte_loop_s , byte_loop_e) LC0=P2;
+byte_loop_s:
+	R1 = B[P3++](Z);	/* *s2 */
+	R0 = B[P0++](Z);	/* *s1 */
+	CC = R0 == R1;
+	IF !CC JUMP different;
+byte_loop_e:
+	NOP;
+
+different:
+	R0 = R0 - R1;
+	P3 = I1;
+	RTS;
+
+quad_different:
+/* We've read two quads which don't match.
+ * Can't just compare them, because we're
+ * a little-endian machine, so the MSBs of
+ * the regs occur at later addresses in the
+ * string.
+ * Arrange to re-read those two quads again,
+ * byte-by-byte.
+ */
+	P0 += -4;		/* back up to the start of the */
+	P3 = I0;		/* quads, and increase the*/
+	P2 += 4;		/* remainder count*/
+	P3 += -4;
+	JUMP bytes;
+
+finished:
+	R0 = 0;
+	P3 = I1;
+	RTS;
+
+._memcmp.end:
Index: git/linux-2.6/arch/blackfin/lib/memcpy.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/lib/memcpy.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,127 @@
+/*
+ * File:         arch/blackfin/lib/memcpy.S
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:  internal version of memcpy(), issued by the compiler
+ * 		 to copy blocks of data around.
+ *		 This is really memmove() - it has to be able to deal with
+ * 		 possible overlaps, because that ambiguity is when the compiler
+ * 		 gives up and calls a function. We have our own, internal version
+ *		 so that we get something we trust, even if the user has redefined
+ * 		 the normal symbol.
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/linkage.h>
+
+	.align 2;
+ENTRY(_memcpy)
+	CC = R2 <=  0;	/* length not positive?*/
+	P0 = R0 ;	/* dst*/
+	P1 = R1 ;	/* src*/
+	P2 = R2 ;	/* length */
+	IF CC JUMP  ._P1L2147483647;	/* Nothing to do */
+
+	/* check for overlapping data */
+	CC = R1 < R0;	/* src < dst */
+	IF !CC JUMP .no_overlap;
+	R3 = R1 + R2;
+	CC = R0 < R3;	/* and dst < src+len */
+	IF CC JUMP .has_overlap;
+
+.no_overlap:
+	/* Check for aligned data.*/
+
+	R3 = R1 | R0;
+	R0 = 0x3;
+	R3 = R3 & R0;
+	CC = R3;	/* low bits set on either address? */
+	IF CC JUMP .not_aligned;
+
+	/* Both addresses are word-aligned, so we can copy
+	at least part of the data using word copies.*/
+	P2 = P2 >> 2;
+	CC = P2 <= 2;
+	IF !CC JUMP .more_than_seven;
+	/* less than eight bytes... */
+	P2 = R2;
+	LSETUP(.three_start, .three_end) LC0=P2;
+	R0 = R1;	/* setup src address for return */
+.three_start:
+	R3 = B[P1++] (X);
+.three_end:
+	B[P0++] = R3;
+
+	RTS;
+
+.more_than_seven:
+	/* There's at least eight bytes to copy. */
+	P2 += -1;	/* because we unroll one iteration */
+	LSETUP(.word_loop, .word_loop) LC0=P2;
+	R0 = R1;
+	I1 = P1;
+	R3 = [I1++];
+.word_loop:
+	MNOP || [P0++] = R3 || R3 = [I1++];
+
+	[P0++] = R3;
+	/* Any remaining bytes to copy? */
+	R3 = 0x3;
+	R3 = R2 & R3;
+	CC = R3 == 0;
+	P1 = I1;	/* in case there's something left, */
+	IF !CC JUMP .bytes_left;
+	RTS;
+.bytes_left:	P2 = R3;
+.not_aligned:
+	/* From here, we're copying byte-by-byte. */
+	LSETUP (.byte_start , .byte_end) LC0=P2;
+	R0 = R1;	/* Save src address for return */
+.byte_start:
+	R1 = B[P1++] (X);
+.byte_end:
+	B[P0++] = R1;
+
+._P1L2147483647:
+	RTS;
+
+.has_overlap:
+/* Need to reverse the copying, because the
+ * dst would clobber the src.
+ * Don't bother to work out alignment for
+ * the reverse case.
+ */
+	R0 = R1;	/* save src for later. */
+	P0 = P0 + P2;
+	P0 += -1;
+	P1 = P1 + P2;
+	P1 += -1;
+	LSETUP(.over_start, .over_end) LC0=P2;
+.over_start:
+	R1 = B[P1--] (X);
+.over_end:
+	B[P0--] = R1;
+
+	RTS;
Index: git/linux-2.6/arch/blackfin/lib/memmove.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/lib/memmove.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,101 @@
+/*
+ * File:         arch/blackfin/lib/memmove.S
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include <linux/linkage.h>
+	   .align 2;
+
+/*
+ * C Library function MEMMOVE
+ * R0 = To Address ( leave unchanged to form result)
+ * R1 = From Address
+ * R2 = count
+ * Data may overlap
+ */
+
+ENTRY(_memmove)
+		I1 = P3;
+		P0 = R0;              /* P0 = To address */
+		P3 = R1;              /* P3 = From Address */
+		P2 = R2 ;             /* P2 = count */
+		CC = P2 == 0;           /* Check zero count*/
+		IF CC JUMP finished;    /* very unlikely */
+
+		CC = R1 < R0 (IU);	/* From < To */
+		IF !CC JUMP no_overlap;
+		R3 = R1 + R2;
+		CC = R0 <= R3 (IU);	/* (From+len) >= To */
+		IF CC JUMP overlap;
+no_overlap:
+		R3 = 11;
+		CC = R2 <= R3;
+		IF CC JUMP  bytes;
+		R3 = R1 | R0;         /* OR addresses together */
+		R3 <<= 30;            /* check bottom two bits */
+		CC =  AZ;             /* AZ set if zero.*/
+		IF !CC JUMP  bytes ;  /* Jump if addrs not aligned.*/
+
+		I0 = P3;
+		P1 = P2 >> 2;         /* count = n/4 */
+		P1 += -1;
+		R3 =  3;
+		R2 = R2 & R3;         /* remainder */
+		P2 = R2;              /* set remainder */
+		R1 = [I0++];
+
+		LSETUP (quad_loop , quad_loop) LC0=P1;
+quad_loop:	MNOP || [P0++] = R1 || R1 = [I0++];
+		[P0++] = R1;
+
+		CC = P2 == 0;         /* any remaining bytes? */
+		P3 = I0;		  /* Ammend P3 to updated ptr. */
+		IF !CC JUMP bytes;
+		P3 = I1;
+		RTS;
+
+bytes:		LSETUP (byte2_s , byte2_e) LC0=P2;
+byte2_s:	R1 = B[P3++](Z);
+byte2_e:	B[P0++] = R1;
+
+finished:	P3 = I1;
+		RTS;
+
+overlap:
+		P2 += -1;
+		P0 = P0 + P2;
+		P3 = P3 + P2;
+		R1 = B[P3--] (Z);
+		CC = P2 == 0;
+		IF CC JUMP no_loop;
+		LSETUP (ol_s, ol_e) LC0 = P2;
+ol_s:		B[P0--] = R1;
+ol_e:		R1 = B[P3--] (Z);
+no_loop:	B[P0] = R1;
+		P3 = I1;
+		RTS;
Index: git/linux-2.6/arch/blackfin/lib/memset.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/lib/memset.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,102 @@
+/*
+ * File:         arch/blackfin/lib/memset.S
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+	.global _memset;
+	.type _memset,STT_FUNC;
+	.align 2;
+
+/*
+ * C Library function MEMSET
+ * R0 = address ( leave unchanged to form result)
+ * R1 = filler byte
+ * R2 = count
+ * Favours word aligned data.
+ */
+
+_memset:
+	P0 = R0 ;              /* P0 = address */
+	P2 = R2 ;              /* P2 = count   */
+	R3 = R0 + R2;          /* end          */
+	CC = R2 <= 7(IU);
+	IF CC JUMP  too_small;
+	R1 = R1.B (Z);         /* R1 = fill char */
+	R2 =  3;
+	R2 = R0 & R2;          /* addr bottom two bits */
+	CC =  R2 == 0;             /* AZ set if zero.	*/
+	IF !CC JUMP  force_align ;  /* Jump if addr not aligned. */
+
+aligned:
+	P1 = P2 >> 2;          /* count = n/4        */
+	R2 = R1 <<  8;         /* create quad filler */
+	R2.L = R2.L + R1.L(NS);
+	R2.H = R2.L + R1.H(NS);
+	P2 = R3;
+
+	LSETUP (quad_loop , quad_loop) LC0=P1;
+quad_loop:
+	[P0++] = R2;
+
+	CC = P0 == P2;
+	IF !CC JUMP bytes_left;
+	RTS;
+
+bytes_left:
+	R2 = R3;                /* end point */
+	R3 = P0;                /* current position */
+	R2 = R2 - R3;           /* bytes left */
+	P2 = R2;
+
+too_small:
+	CC = P2 == 0;           /* Check zero count */
+	IF CC JUMP finished;    /* Unusual */
+
+bytes:
+	LSETUP (byte_loop , byte_loop) LC0=P2;
+byte_loop:
+	B[P0++] = R1;
+
+finished:
+	RTS;
+
+force_align:
+	CC = BITTST (R0, 0);  /* odd byte */
+	R0 = 4;
+	R0 = R0 - R2;
+	P1 = R0;
+	R0 = P0;		    /* Recover return address */
+	IF !CC JUMP skip1;
+	B[P0++] = R1;
+skip1:
+	CC = R2 <= 2;          /* 2 bytes */
+	P2 -= P1;              /* reduce count */
+	IF !CC JUMP aligned;
+	B[P0++] = R1;
+	B[P0++] = R1;
+	JUMP aligned;
Index: git/linux-2.6/arch/blackfin/lib/modsi3.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/lib/modsi3.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,74 @@
+/*
+ * File:         arch/blackfin/lib/modsi3.S
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:  This program computes 32 bit signed remainder. It calls div32 function
+ *  		 for quotient estimation.
+ *
+ *		 Registers used :
+ *		 Numerator/ Denominator in  R0, R1
+ *		  R0  -  returns remainder.
+ *		  R2-R7
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+.global ___modsi3;
+.type ___modsi3, STT_FUNC;
+.extern ___divsi3;
+.type ___divsi3, STT_FUNC;
+___modsi3:
+
+	CC=R0==0;
+	IF CC JUMP RETURN_R0;		/* Return 0, if numerator  == 0 */
+	CC=R1==0;
+	IF CC JUMP RETURN_ZERO;		/* Return 0, if denominator == 0 */
+	CC=R0==R1;
+	IF CC JUMP RETURN_ZERO;		/* Return 0, if numerator == denominator */
+	CC = R1 == 1;
+	IF CC JUMP RETURN_ZERO;		/* Return 0, if denominator ==  1 */
+	CC = R1 == -1;
+	IF CC JUMP RETURN_ZERO;		/* Return 0, if denominator == -1 */
+
+	/* Valid input. Use __divsi3() to compute the quotient, and then
+	   derive the remainder from that. */
+
+	[--SP] = (R7:6);		/* Push  R7 and R6 */
+	[--SP] = RETS;			/* and return address */
+	R7 = R0;			/* Copy of R0 */
+	R6 = R1;			/* Save for later */
+	SP += -12;			/* Should always provide this space */
+	CALL ___divsi3;			/* Compute signed quotient using ___divsi3()*/
+	SP += 12;
+	R0 *= R6;			/* Quotient * divisor */
+	R0 = R7 - R0;			/* Dividend - ( quotient *divisor) */
+	RETS = [SP++];			/* Get back return address */
+	(R7:6) = [SP++];		/* Pop registers R7 and R4 */
+	RTS;				/* Store remainder    */
+
+RETURN_ZERO:
+	R0 = 0;
+RETURN_R0:
+	RTS;
Index: git/linux-2.6/arch/blackfin/lib/muldi3.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/lib/muldi3.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,96 @@
+/*
+ * File:         arch/blackfin/lib/muldi3.c
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef SI_TYPE_SIZE
+#define SI_TYPE_SIZE 32
+#endif
+#define __ll_b (1L << (SI_TYPE_SIZE / 2))
+#define __ll_lowpart(t) ((usitype) (t) % __ll_b)
+#define __ll_highpart(t) ((usitype) (t) / __ll_b)
+#define BITS_PER_UNIT 8
+
+#if !defined (umul_ppmm)
+#define umul_ppmm(w1, w0, u, v)						\
+  do {									\
+    usitype __x0, __x1, __x2, __x3;					\
+    usitype __ul, __vl, __uh, __vh;					\
+									\
+    __ul = __ll_lowpart (u);						\
+    __uh = __ll_highpart (u);						\
+    __vl = __ll_lowpart (v);						\
+    __vh = __ll_highpart (v);						\
+									\
+    __x0 = (usitype) __ul * __vl;					\
+    __x1 = (usitype) __ul * __vh;					\
+    __x2 = (usitype) __uh * __vl;					\
+    __x3 = (usitype) __uh * __vh;					\
+									\
+    __x1 += __ll_highpart (__x0);/* this can't give carry */		\
+    __x1 += __x2;		/* but this indeed can */		\
+    if (__x1 < __x2)		/* did we get it? */			\
+      __x3 += __ll_b;		/* yes, add it in the proper pos. */	\
+									\
+    (w1) = __x3 + __ll_highpart (__x1);					\
+    (w0) = __ll_lowpart (__x1) * __ll_b + __ll_lowpart (__x0);		\
+  } while (0)
+#endif
+
+#if !defined (__umulsidi3)
+#define __umulsidi3(u, v) 						\
+  ({diunion __w;                                                        \
+       umul_ppmm (__w.s.high, __w.s.low, u, v);                         \
+           __w.ll; })
+#endif
+
+typedef unsigned int usitype __attribute__ ((mode(SI)));
+typedef int sitype __attribute__ ((mode(SI)));
+typedef int ditype __attribute__ ((mode(DI)));
+typedef int word_type __attribute__ ((mode(__word__)));
+
+struct distruct {
+	sitype low, high;
+};
+typedef union {
+	struct distruct s;
+	ditype ll;
+} diunion;
+
+ditype __muldi3(ditype u, ditype v)
+{
+	diunion w;
+	diunion uu, vv;
+
+	uu.ll = u, vv.ll = v;
+	w.ll = __umulsidi3(uu.s.low, vv.s.low);
+	w.s.high += ((usitype) uu.s.low * (usitype) vv.s.high
+		     + (usitype) uu.s.high * (usitype) vv.s.low);
+
+	return w.ll;
+}
Index: git/linux-2.6/arch/blackfin/lib/outs.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/lib/outs.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,58 @@
+/*
+ * File:	arch/blackfin/lib/outs.S
+ * Description:	Implementation of outs{bwl} for BlackFin processors using zero overhead loops.
+ * Rev:		$Id$
+ * Created:	Tue Mar 22 15:27:24 CEST 2005
+ * Author:	Bas Vermeulen
+ * Email:	bas@buyways.nl
+ *
+ * Copyright (C) 2005 Bas Vermeulen, BuyWays BV <bas@buyways.nl>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTIBILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/linkage.h>
+	.align 2;
+
+ENTRY(_outsl)
+	P0 = R0;	/* P0 = port */
+	P1 = R1;	/* P1 = address */
+	P2 = R2;	/* P2 = count */
+
+	LSETUP( long_loop_s, long_loop_e) LC0 = P2;
+long_loop_s: R0 = [P1++];
+long_loop_e: [P0] = R0;
+	RTS;
+
+ENTRY(_outsw)
+	P0 = R0;	/* P0 = port */
+	P1 = R1;	/* P1 = address */
+	P2 = R2;	/* P2 = count */
+
+	LSETUP( word_loop_s, word_loop_e) LC0 = P2;
+word_loop_s: R0 = W[P1++];
+word_loop_e: W[P0] = R0;
+	RTS;
+
+ENTRY(_outsb)
+	P0 = R0;	/* P0 = port */
+	P1 = R1;	/* P1 = address */
+	P2 = R2;	/* P2 = count */
+
+	LSETUP( byte_loop_s, byte_loop_e) LC0 = P2;
+byte_loop_s: R0 = B[P1++];
+byte_loop_e: B[P0] = R0;
+	RTS;
Index: git/linux-2.6/arch/blackfin/lib/udivsi3.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/lib/udivsi3.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,156 @@
+/*
+ * File:         arch/blackfin/lib/udivsi3.S
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+	.text
+	.globl	___udivsi3
+___udivsi3:
+
+	/* Attempt to use divide primitive first; these will handle
+	most cases, and they're quick - avoids stalls incurred by
+	testing for identities. */
+
+	R2.H = 0x8000;
+	R2 >>>= 16;                     /* R2 now 0xFFFF8000 */
+	R3 = R0 | R1;                   /* If either dividend or */
+	R2 = R3 & R2;                   /* divisor have bits in */
+	CC = R2;                        /* top half or low half's sign */
+	IF CC JUMP IDENTS;              /* bit, skip builtins. */
+
+	/* Can use the builtins. */
+
+	AQ = CC;                        /* Clear AQ (CC==0) */
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	DIVQ(R0, R1);
+	R0 = R0.L (Z);
+	RTS;
+
+IDENTS:
+       /* Test for common identities. Value to be returned is
+	  placed in R2. */
+	CC = R0 == 0;                   /* NR==0 => 0 */
+	IF CC JUMP RETURN_R0;
+	R2 = -1 (X);                    /* DR==0 => 0xFFFFFFFF */
+	CC = R1 == 0;
+	IF CC JUMP RETURN_IDENT;
+	R2 = -R2;                       /* R2 now 1 */
+	CC = R0 == R1;                  /* NR==DR => 1 */
+	IF CC JUMP RETURN_IDENT;
+	R2 = R0;
+	CC = R1 == 1;                   /* DR==1 => NR */
+	IF CC JUMP RETURN_IDENT;
+	R2 = 0 (Z);
+	CC = R0 < R1 (IU);
+	IF CC JUMP RETURN_IDENT;        /* NR < DR => 0 */
+
+       /* Idents don't match. Go for the full operation. */
+
+	[--SP] = (R7:4);                /* Push registers R4-R7 */
+	[--SP] = P3;                    /* Push P3 */
+	P1 = R0;
+	P2 = R1;
+					/* If either R0 or R1 have sign set, */
+					/* divide them by two, and note it's */
+					/* been done. */
+	R6 = 2;                         /* assume we'll shift two */
+	R7 = 1;
+	R3 = 0;
+	R5 = R1 >> 1;
+	R4 = R0 >> 1;
+	CC = R1 < 0;
+	IF !CC R6 = R7;                 /* R1 doesn't, so at most 1 shifted */
+	IF !CC R5 = R1;                 /* and use original value. */
+	CC = R0 < 0;
+	IF CC R3 = R6;                  /* Number of values divided */
+	IF CC R0 = R4;                  /* Shifted R0 */
+	R1 = R5;                        /* Possibly-shifted R1 */
+	P0 = R3;                        /* 0, 1 (NR/=2) or 2 (NR/=2, DR/=2) */
+
+	R2 = R0;                        /* Copy dividend  */
+	R3 = 0;                         /* Clear partial remainder */
+	P3 = 32;                        /* Set loop counter */
+	R4 = 0;                         /* Initialise quotient bit */
+
+	LSETUP( ULST, ULEND ) LC0 = P3;   /* Set loop counter */
+ULST:
+	R6 = R2 >> 31;                  /* R6 = sign bit of R2, for carry */
+	R2 <<= 1;                   	/* Shift 64 bit dividend up by 1 bit */
+	R3 <<= 1;
+	R3 = R3 | R6;                   /* Include any carry */
+	CC = R4 < 0;                    /* Check quotient(AQ) */
+	R5 = -R1;                       /* If AQ==0, we'll sub divisor */
+	IF CC R5 = R1;                  /* and if AQ==1, we'll add it. */
+	R3= R3 + R5;                    /* Add/sub divsor to partial remainder */
+	R4 = R3^R1;                     /* Generate next quotient bit */
+	BITCLR(R2,0);                   /* Assume AQ==1, so "shift in" 0 */
+	R5 = R4 >> 31;                  /* Get AQ */
+	BITTGL(R5, 0);                  /* Invert it, to get what we'll shift */
+ULEND:
+	R2 = R2 + R5;                   /* and "shift" it in. */
+
+	CC = P0 == 0;                   /* Check how many inputs we shifted */
+	IF CC JUMP NO_MULT;             /* if none... */
+	R2 <<= 0x1;
+	R6 = R2;
+	CC = P0 == 1;
+	IF CC R2 = R6;                  /* if 1, Q = Q*2 */
+	IF !CC R1 = P2;                 /* if 2, restore stored divisor */
+
+	R3 = R2;                        /* Copy of R2 */
+	R3 *= R1;                       /* Q * divisor */
+	R4 = P1;                        /* Get stored dividend(R0)  */
+	R5 = R4 - R3;                   /* Z = (dividend - Q * divisor) */
+	CC = R1<= R5 (IU);              /* Check if divisor <= Z? */
+	R6 = CC;                        /* if yes, R6 = 1 */
+	R2 = R2 + R6;                   /* if yes, add one to quotient(Q) */
+NO_MULT:
+	P3 = [SP++];                    /* Pop register P3 */
+	( R7:4) = [SP++];               /* Pop registers R4-R7 */
+	R0 = R2;                        /* Store quotient */
+	RTS;
+
+RETURN_IDENT:
+	R0 = R2;
+RETURN_R0:
+	RTS;
Index: git/linux-2.6/arch/blackfin/lib/umodsi3.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/lib/umodsi3.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,62 @@
+/*
+ * File:         arch/blackfin/lib/umodsi3.S
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:  libgcc1 routines for Blackfin 5xx
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+	.text
+	.extern ___udivsi3;
+	.globl	___umodsi3
+___umodsi3:
+
+	CC=R0==0;
+	IF CC JUMP RETURN_R0;		/* Return 0, if NR == 0 */
+	CC= R1==0;
+	IF CC JUMP RETURN_ZERO_VAL;	/* Return 0, if DR == 0 */
+	CC=R0==R1;
+	IF CC JUMP RETURN_ZERO_VAL;	/* Return 0, if NR == DR */
+	CC = R1 == 1;
+	IF CC JUMP RETURN_ZERO_VAL;	/* Return 0, if  DR == 1 */
+	CC = R0<R1 (IU);
+	IF CC JUMP RETURN_R0;		/* Return dividend (R0),IF NR<DR */
+
+	[--SP] = (R7:6);		/* Push registers and */
+	[--SP] = RETS;			/* Return address */
+	R7 = R0;			/* Copy of R0 */
+	R6 = R1;
+	SP += -12;			/* Should always provide this space */
+	CALL ___udivsi3;		/* Compute unsigned quotient using ___udiv32()*/
+	SP += 12;
+	R0 *= R6;			/* Quotient * divisor */
+	R0 = R7 - R0;			/* Dividend - ( quotient *divisor) */
+	RETS = [SP++];			/* Pop return address */
+	( R7:6) = [SP++];		/* And registers */
+	RTS;				/* Return remainder */
+RETURN_ZERO_VAL:
+	R0 = 0;
+RETURN_R0:
+	RTS;
Index: git/linux-2.6/arch/blackfin/mach-bf533/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf533/Kconfig	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,103 @@
+if (BF533 || BF532 || BF531)
+
+menu "BF533/2/1 Specific Configuration"
+
+comment	'Interrupt Priority Assignment'
+menu	'Priority'
+
+config	UART_ERROR
+	int "UART ERROR"
+	default 7
+config  SPORT0_ERROR
+	int "SPORT0 ERROR"
+	default 7
+config  SPI_ERROR
+	int "SPI ERROR"
+	default 7
+config  SPORT1_ERROR
+	int "SPORT1 ERROR"
+	default 7
+config  PPI_ERROR
+	int "PPI ERROR"
+	default 7
+config  DMA_ERROR
+	int "DMA ERROR"
+	default 7
+config  PLLWAKE_ERROR
+	int "PLL WAKEUP ERROR"
+	default 7
+
+config  RTC_ERROR
+	int "RTC ERROR"
+	default 8
+config  DMA0_PPI
+	int "DMA0 PPI"
+	default 8
+
+config  DMA1_SPORT0RX
+	int "DMA1 (SPORT0 RX)"
+	default 9
+config  DMA2_SPORT0TX
+	int "DMA2 (SPORT0 TX)"
+	default 9
+config  DMA3_SPORT1RX
+	int "DMA3 (SPORT1 RX)"
+	default 9
+config  DMA4_SPORT1TX
+	int "DMA4 (SPORT1 TX)"
+	default 9
+
+
+config  DMA5_SPI
+	int "DMA5 (SPI)"
+	default 10
+config  DMA6_UARTRX
+	int "DMA6 (UART0 RX)"
+	default 10
+config  DMA7_UARTTX
+	int "DMA7 (UART0 TX)"
+	default 10
+
+config 	TIMER0
+	int "TIMER0"
+	default 11
+config 	TIMER1
+	int "TIMER1"
+	default 11
+config 	TIMER2
+	int "TIMER2"
+	default 11
+
+config	PFA
+	int "PF Interrupt A"
+	default 12
+config	PFB
+	int "PF Interrupt B"
+	default 12
+
+config	MEMDMA0
+	int "MEMORY DMA0"
+	default 13
+config	MEMDMA1
+	int "MEMORY DMA1"
+	default 13
+config	WDTIMER
+	int "WATCH DOG TIMER"
+	default 13
+
+	help
+	  ------------------------- GENERAL HELP -------------------------
+	  Enter the priority numbers between 7-13 ONLY. Others are Reserved.
+ 	  This applies to all the above.It is not recommended to assign the
+	  highest priority no 7 to UART or any other device.
+
+endmenu
+
+config BFIN_HAVE_RTC
+	bool "Enable built-in RTC"
+	depends on (BF533 || BF532 || BF531)
+	default y
+
+endmenu
+
+endif
Index: git/linux-2.6/arch/blackfin/mach-bf533/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf533/Makefile	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,8 @@
+#
+# Makefile for mach-bf533.
+#
+extra-y += head.o
+# Object file lists.
+obj-y:= ints-priority.o
+obj-$(CONFIG_CPU_FREQ_BF533) += cpu.o
+obj-$(CONFIG_PM) +=pm.o
Index: git/linux-2.6/arch/blackfin/mach-bf533/boards/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf533/boards/Makefile	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,10 @@
+#
+# Makefile for mach-bf533/boards.
+#
+
+# Object file lists.
+
+obj-$(CONFIG_BFIN533_STAMP) += stamp.o
+obj-$(CONFIG_BFIN533_EZKIT) += ezkit.o
+obj-$(CONFIG_GENERIC_BOARD) += generic_board.o
+obj-$(CONFIG_CM_BF533)      += cm_bf533.o
Index: git/linux-2.6/arch/blackfin/mach-bf533/boards/cm_bf533.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf533/boards/cm_bf533.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,77 @@
+ /*
+  * File:        arch/blackfin/mach-bf533/boards/cm_bf533.c
+  * Based on:   arch/blackfin/mach-bf533/boards/ezkit.c
+  * Author:      Aidan Williams <aidan@nicta.com.au>
+  *                Copright 2005
+  * Created:     2005
+  * Description: Board description file
+  *
+  * Rev:         $Id$
+  *
+  * Modified:
+  *
+  * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.
+  * If not, write to the Free Software Foundation,
+  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+  */
+
+#include <linux/device.h>
+#include <asm/irq.h>
+
+/*
+ *  USB-LAN EzExtender board
+ *  Driver needs to know address, irq and flag pin.
+ */
+static struct resource smc91x_resources[] = {
+	[0] = {
+	       .start = 0x20200300,
+	       .end = 0x20200300 + 16,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_PROG_INTB,
+	       .end = IRQ_PROG_INTB,
+	       .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	       },
+	[2] = {
+	       /*
+	        *  denotes the flag pin and is used directly if
+	        *  CONFIG_IRQCHIP_DEMUX_GPIO is defined.
+	        */
+	       .start = IRQ_PF8,
+	       .end = IRQ_PF8,
+	       .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	       },
+};
+static struct platform_device smc91x_device = {
+	.name = "smc91x",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(smc91x_resources),
+	.resource = smc91x_resources,
+};
+
+static struct platform_device *cm_bf533_devices[] __initdata = {
+	&smc91x_device,
+};
+
+static int __init cm_bf533_init(void)
+{
+	printk("%s(): registering device resources\n", __FUNCTION__);
+	return platform_add_devices(cm_bf533_devices,
+				    ARRAY_SIZE(cm_bf533_devices));
+}
+
+arch_initcall(cm_bf533_init);
Index: git/linux-2.6/arch/blackfin/mach-bf533/boards/ezkit.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf533/boards/ezkit.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,84 @@
+/*
+ * File:        arch/blackfin/mach-bf533/ezkit.c
+ * Based on:    Orginal Work
+ * Author:      Aidan Williams <aidan@nicta.com.au>
+ *               Copyright 2005 National ICT Australia (NICTA)
+ * Attribution: Thanks to Jamey Hicks
+ * Created:     2005
+ * Description:
+ *
+ * Rev:         $Id$
+ *
+ * Modified:    Robin Getz <rgetz@blackfin.uclinux.org> - Named the boards
+ *                Copyright 2005 Analog Devices
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/device.h>
+#include <asm/irq.h>
+
+/*
+ * Name the Board for the /proc/cpuinfo
+ */
+char *bfin_board_name = "ADDS-BF533-EZKIT";
+
+/*
+ *  USB-LAN EzExtender board
+ *  Driver needs to know address, irq and flag pin.
+ */
+static struct resource smc91x_resources[] = {
+	[0] = {
+	       .start = 0x20310300,
+	       .end = 0x20310300 + 16,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_PROG_INTB,
+	       .end = IRQ_PROG_INTB,
+	       .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	       },
+	[2] = {
+	       /*
+	        *  denotes the flag pin and is used directly if
+	        *  CONFIG_IRQCHIP_DEMUX_GPIO is defined.
+	        */
+	       .start = IRQ_PF9,
+	       .end = IRQ_PF9,
+	       .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	       },
+};
+static struct platform_device smc91x_device = {
+	.name = "smc91x",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(smc91x_resources),
+	.resource = smc91x_resources,
+};
+
+static struct platform_device *ezkit_devices[] __initdata = {
+	&smc91x_device,
+};
+
+static int __init ezkit_init(void)
+{
+	printk("%s(): registering device resources\n", __FUNCTION__);
+	return platform_add_devices(ezkit_devices, ARRAY_SIZE(ezkit_devices));
+}
+
+arch_initcall(ezkit_init);
Index: git/linux-2.6/arch/blackfin/mach-bf533/boards/generic_board.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf533/boards/generic_board.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,78 @@
+/*
+ * File:         arch/blackfin/mach-bf533/generic_board.c
+ * Based on:     arch/blackfin/mach-bf533/ezkit.c
+ * Author:       Aidan Williams <aidan@nicta.com.au>
+ *                 Copyright 2005 National ICT Australia (NICTA)
+ * Created:      2005
+ *
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/device.h>
+#include <asm/irq.h>
+
+/*
+ *  Driver needs to know address, irq and flag pin.
+ */
+static struct resource smc91x_resources[] = {
+	[0] = {
+	       .start = 0x20300300,
+	       .end = 0x20300300 + 16,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_PROG_INTB,
+	       .end = IRQ_PROG_INTB,
+	       .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	       },
+	[2] = {
+	       /*
+	        *  denotes the flag pin and is used directly if
+	        *  CONFIG_IRQCHIP_DEMUX_GPIO is defined.
+	        */
+	       .start = IRQ_PF7,
+	       .end = IRQ_PF7,
+	       .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	       },
+};
+static struct platform_device smc91x_device = {
+	.name = "smc91x",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(smc91x_resources),
+	.resource = smc91x_resources,
+};
+
+static struct platform_device *generic_board_devices[] __initdata = {
+	&smc91x_device,
+};
+
+static int __init generic_board_init(void)
+{
+	printk("%s(): registering device resources\n", __FUNCTION__);
+	return platform_add_devices(generic_board_devices,
+				    ARRAY_SIZE(generic_board_devices));
+}
+
+arch_initcall(generic_board_init);
Index: git/linux-2.6/arch/blackfin/mach-bf533/boards/stamp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf533/boards/stamp.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,82 @@
+/*
+ * File:        arch/blackfin/mach-bf533/stamp.c
+ * Based on:    arch/blackfin/mach-bf533/ezkit.c
+ * Author:      Aidan Williams <aidan@nicta.com.au>
+ *                Copyright 2005 National ICT Australia (NICTA)
+ * Created:     2005
+ * Description: Board Info File for the BF533-STAMP
+ *
+ * Rev:         $Id$
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <asm/irq.h>
+
+/*
+ * Name the Board for the /proc/cpuinfo
+ */
+char *bfin_board_name = "ADDS-BF533-STAMP";
+
+/*
+ *  Driver needs to know address, irq and flag pin.
+ */
+static struct resource smc91x_resources[] = {
+	[0] = {
+	       .start = 0x20300300,
+	       .end = 0x20300300 + 16,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_PROG_INTB,
+	       .end = IRQ_PROG_INTB,
+	       .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	       },
+	[2] = {
+	       /*
+	        *  denotes the flag pin and is used directly if
+	        *  CONFIG_IRQCHIP_DEMUX_GPIO is defined.
+	        */
+	       .start = IRQ_PF7,
+	       .end = IRQ_PF7,
+	       .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	       },
+};
+static struct platform_device smc91x_device = {
+	.name = "smc91x",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(smc91x_resources),
+	.resource = smc91x_resources,
+};
+
+static struct platform_device *stamp_devices[] __initdata = {
+	&smc91x_device,
+};
+
+static int __init stamp_init(void)
+{
+	printk("%s(): registering device resources\n", __FUNCTION__);
+	return platform_add_devices(stamp_devices, ARRAY_SIZE(stamp_devices));
+}
+
+arch_initcall(stamp_init);
Index: git/linux-2.6/arch/blackfin/mach-bf533/cpu.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf533/cpu.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,171 @@
+/*
+ * File:         arch/blackfin/mach-bf533/cpu.c
+ * Based on:
+ * Author:	michael.kang@analog.com
+ *              COPYRIGHT 2005 Analog Devices Inc.
+ * Created:
+ * Description: clock scaling for the bf533
+ *
+ * Rev: $Id$
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/cpufreq.h>
+#include <asm/dpmc.h>
+#include <linux/fs.h>
+
+#undef BF533_CPU_DEBUG
+
+//CONFIG_CLKIN_HZ=11059200
+#define VCO5 (CONFIG_CLKIN_HZ*45)	/*497664000 */
+#define VCO4 (CONFIG_CLKIN_HZ*36)	/*398131200 */
+#define VCO3 (CONFIG_CLKIN_HZ*27)	/*298598400 */
+#define VCO2 (CONFIG_CLKIN_HZ*18)	/*199065600 */
+#define VCO1 (CONFIG_CLKIN_HZ*9)	/*99532800 */
+#define VCO(x) VCO##x
+
+#define FREQ(x) {VCO(x),VCO(x)/4},{VCO(x),VCO(x)/2},{VCO(x),VCO(x)}
+/* frequency */
+static struct cpufreq_frequency_table bf533_freq_table[] = {
+	FREQ(1),
+	FREQ(3),
+	{VCO4, VCO4 / 2}, {VCO4, VCO4},
+	FREQ(5),
+	{0, CPUFREQ_TABLE_END},
+};
+
+extern struct file_operations dpmc_fops;
+
+/*
+ * dpmc_fops->ioctl()
+ * static int dpmc_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+ */
+
+extern unsigned long get_cclk();
+static int bf533_getfreq(unsigned int cpu)
+{
+	unsigned long cclk_mhz, vco_mhz;
+
+	/*The driver only support single cpu */
+	if (cpu == 0)
+		dpmc_fops.ioctl(NULL, NULL, IOCTL_GET_CORECLOCK, &cclk_mhz);
+	else
+		cclk_mhz = -1;
+	return cclk_mhz;
+}
+ /**/
+    static int bf533_target(struct cpufreq_policy *policy,
+			    unsigned int target_freq, unsigned int relation)
+{
+	unsigned long cclk_mhz;
+	unsigned long vco_mhz;
+	unsigned long flags;
+	unsigned int index, vco_index;
+	int i;
+
+	struct cpufreq_freqs freqs;
+	if (cpufreq_frequency_table_target
+	    (policy, bf533_freq_table, target_freq, relation, &index))
+		return -EINVAL;
+	cclk_mhz = bf533_freq_table[index].frequency;
+	vco_mhz = bf533_freq_table[index].index;
+
+	dpmc_fops.ioctl(NULL, NULL, IOCTL_CHANGE_FREQUENCY, &vco_mhz);
+	freqs.old = bf533_getfreq(0);
+	freqs.new = cclk_mhz;
+	freqs.cpu = 0;
+
+#if defined(BF533_CPU_DEBUG)
+	printk
+	    ("cclk begin change to cclk %d,vco=%d,index=%d,target=%d,oldfreq=%d\n",
+	     cclk_mhz, vco_mhz, index, target_freq, freqs.old);
+#endif
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+	local_irq_save(flags);
+	dpmc_fops.ioctl(NULL, NULL, IOCTL_SET_CCLK, &cclk_mhz);
+	local_irq_restore(flags);
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+
+	vco_mhz = get_vco();
+	cclk_mhz = get_cclk();
+	return 0;
+}
+
+/* make sure that only the "userspace" governor is run -- anything else wouldn't make sense on
+ * this platform, anyway.
+ */
+static int bf533_verify_speed(struct cpufreq_policy *policy)
+{
+	return cpufreq_frequency_table_verify(policy, &bf533_freq_table);
+}
+
+static int __init __bf533_cpu_init(struct cpufreq_policy *policy)
+{
+	int result;
+
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+
+	policy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;
+	/*Now ,only support one cpu */
+	policy->cur = bf533_getfreq(0);
+	cpufreq_frequency_table_get_attr(bf533_freq_table, policy->cpu);
+	return cpufreq_frequency_table_cpuinfo(policy, bf533_freq_table);
+}
+
+static struct freq_attr *bf533_freq_attr[] = {
+	&cpufreq_freq_attr_scaling_available_freqs,
+	NULL,
+};
+
+static struct cpufreq_driver bf533_driver = {
+	.verify = bf533_verify_speed,
+	.target = bf533_target,
+	.get = bf533_getfreq,
+	.init = __bf533_cpu_init,
+	.name = "bf533",
+	.owner = THIS_MODULE,
+	.attr = bf533_freq_attr,
+};
+
+static int __init bf533_cpu_init(void)
+{
+	//MISC_MAJOR, DPMC_MINOR
+	return (cpufreq_register_driver(&bf533_driver));
+}
+
+static void __exit bf533_cpu_exit(void)
+{
+	cpufreq_unregister_driver(&bf533_driver);
+}
+
+MODULE_AUTHOR("Mickael Kang");
+MODULE_DESCRIPTION("cpufreq driver for BF533 CPU");
+MODULE_LICENSE("GPL");
+
+module_init(bf533_cpu_init);
+module_exit(bf533_cpu_exit);
Index: git/linux-2.6/arch/blackfin/mach-bf533/head.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf533/head.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,751 @@
+ /*
+ * File:        arch/blackfin/mach-bf533/head.S
+ * Based on:
+ * Author:      Jeff Dionne <jeff@uclinux.org>
+ *              COPYRIGHT 1998 D. Jeff Dionne
+ * Created:     1998
+ * Description: bf533 startup file
+ *
+ * Rev:         $Id$
+ *
+ * Modified:    LG Soft India
+ *                Copyright 2004-2005 ANALOG DEVICES
+ *
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/linkage.h>
+#include <asm/blackfin.h>
+#if CONFIG_BFIN_KERNEL_CLOCK
+#include <asm/mach/mem_init.h>
+#endif
+#if CONFIG_DEBUG_KERNEL_START
+#include <asm/mach-common/def_LPBlackfin.h>
+#endif
+
+.global __rambase
+.global __ramstart
+.global __ramend
+.extern __ebss
+.extern _bf53x_relocate_l1_mem
+
+#define INITIAL_STACK	0xFFB01000
+
+.text
+
+ENTRY(__start)
+ENTRY(__stext)
+/*  R0: argument of command line string, passed from uboot, save it */
+	R7 = R0;
+	/* Set the SYSCFG register */
+	R0 = 0x36;
+	SYSCFG = R0; 		/*Enable Cycle Counter and Nesting Of Interrupts(3rd Bit)*/
+	R0 = 0;
+
+/*Clear Out All the data and pointer  Registers*/
+	R1 = R0;
+	R2 = R0;
+	R3 = R0;
+	R4 = R0;
+	R5 = R0;
+	R6 = R0;
+
+	P0 = R0;
+	P1 = R0;
+	P2 = R0;
+	P3 = R0;
+	P4 = R0;
+	P5 = R0;
+
+	LC0 = r0;
+	LC1 = r0;
+	L0 = r0;
+	L1 = r0;
+	L2 = r0;
+	L3 = r0;
+
+/*Clear Out All the DAG Registers*/
+	B0 = r0;
+	B1 = r0;
+	B2 = r0;
+	B3 = r0;
+
+	I0 = r0;
+	I1 = r0;
+	I2 = r0;
+	I3 = r0;
+
+	M0 = r0;
+	M1 = r0;
+	M2 = r0;
+	M3 = r0;
+
+#if CONFIG_DEBUG_KERNEL_START
+
+/*
+ * Set up a temporary Event Vector Table, so if something bad happens before
+ * the kernel is fully started, it doesn't vector off into the bootloaders
+ * table
+ */
+	P0.l = lo(EVT2);
+	P0.h = hi(EVT2);
+	P1.l = lo(EVT15);
+	P1.h = hi(EVT15);
+	P2.l = debug_kernel_start_trap;
+	P2.h = debug_kernel_start_trap;
+
+	RTS = P2;
+	RTI = P2;
+	RTX = P2;
+	RTN = P2;
+	RTE = P2;
+
+fill_temp_vector_table:
+	[P0++] = P2;	/* Core Event Vector Table */
+	CC = P0 == P1;
+	if !CC JUMP fill_temp_vector_table
+	P0 = r0;
+	P1 = r0;
+	P2 = r0;
+
+#endif
+
+/* Turn off the icache */
+	p0.l = (IMEM_CONTROL & 0xFFFF);
+	p0.h = (IMEM_CONTROL >> 16);
+	R1 = [p0];
+	R0 = ~ENICPLB;
+	R0 = R0 & R1;
+
+	/* Anamoly 05000125 */
+	CLI R2;
+	SSYNC;
+	[p0] = R0;
+	SSYNC;
+	STI R2;
+
+    /* Turn off the dcache */
+    p0.l = (DMEM_CONTROL & 0xFFFF);
+    p0.h = (DMEM_CONTROL >> 16);
+    R1 = [p0];
+    R0 = ~ENDCPLB;
+    R0 = R0 & R1;
+
+    /* Anamoly 05000125 */
+    CLI R2;
+    SSYNC;
+    [p0] = R0;
+    SSYNC;
+    STI R2;
+
+/*Initialise UART*/
+	p0.h = hi(UART_LCR);
+	p0.l = lo(UART_LCR);
+	r0 = 0x0(Z);
+	w[p0] = r0.L;	/* To enable DLL writes */
+	ssync;
+
+	p0.h = hi(UART_DLL);
+	p0.l = lo(UART_DLL);
+	r0 = 0x0(Z);
+	w[p0] = r0.L;
+	ssync;
+
+	p0.h = hi(UART_DLH);
+	p0.l = lo(UART_DLH);
+	r0 = 0x00(Z);
+	w[p0] = r0.L;
+	ssync;
+
+	p0.h = hi(UART_GCTL);
+	p0.l = lo(UART_GCTL);
+	r0 = 0x0(Z);
+	w[p0] = r0.L;	/* To enable UART clock */
+	ssync;
+
+	/* Initialize stack pointer */
+	sp.l = lo(INITIAL_STACK);
+        sp.h = hi(INITIAL_STACK);
+        fp = sp;
+        usp = sp;
+
+	/*Put The Code for PLL Programming and SDRAM Programming in L1 ISRAM*/
+	call _bf53x_relocate_l1_mem;
+#if CONFIG_BFIN_KERNEL_CLOCK
+	call start_dma_code;
+#endif
+
+	/* Code for initializing Async memory banks */
+
+        p2.h = hi(EBIU_AMBCTL1);
+        p2.l = lo(EBIU_AMBCTL1);
+        r0.h = hi(AMBCTL1VAL);
+        r0.l = lo(AMBCTL1VAL);
+        [p2] = r0;
+        ssync;
+
+        p2.h = hi(EBIU_AMBCTL0);
+        p2.l = lo(EBIU_AMBCTL0);
+        r0.h = hi(AMBCTL0VAL);
+        r0.l = lo(AMBCTL0VAL);
+        [p2] = r0;
+        ssync;
+
+        p2.h = hi(EBIU_AMGCTL);
+        p2.l = lo(EBIU_AMGCTL);
+        r0 = AMGCTLVAL;
+        w[p2] = r0;
+        ssync;
+
+	/* This section keeps the processor in supervisor mode
+         * during kernel boot.  Switches to user mode at end of boot.
+	 * See page 3-9 of Hardware Reference manual for documentation.
+	 */
+
+	/* EVT15 = _real_start */
+
+	p0.l = lo(EVT15);
+	p0.h = hi(EVT15);
+	p1.l = _real_start;
+	p1.h = _real_start;
+	[p0] = p1;
+	csync;
+
+	p0.l = lo(IMASK);
+	p0.h = hi(IMASK);
+	p1.l = IMASK_IVG15;
+	p1.h = 0x0;
+	[p0] = p1;
+	csync;
+
+	raise 15;
+	p0.l = WAIT_HERE;
+	p0.h = WAIT_HERE;
+	reti = p0;
+	rti;
+
+WAIT_HERE:
+	jump WAIT_HERE;
+
+ENTRY(_real_start)
+	[ -- sp ] = reti;
+	p0.l = lo(WDOG_CTL);
+	p0.h = hi(WDOG_CTL);
+	r0 = 0xAD6(z);
+	w[p0] = r0;	/* watchdog off for now */
+	ssync;
+
+	/* Code update for BSS size == 0
+	 * Zero out the bss region.
+	 */
+
+	p1.l = __sbss;
+	p1.h = __sbss;
+	p2.l = __ebss;
+	p2.h = __ebss;
+	r0 = 0;
+	p2 -= p1;
+	lsetup (_clear_bss, _clear_bss ) lc0 = p2;
+_clear_bss:
+	B[p1++] = r0;
+
+	/* In case there is a NULL pointer reference
+	 * Zero out region before stext
+	 */
+
+	p1.l = 0x0;
+	p1.h = 0x0;
+	r0.l = __stext;
+	r0.h = __stext;
+	r0 = r0 >> 1;
+	p2 = r0;
+	r0 = 0;
+	lsetup (_clear_zero, _clear_zero ) lc0 = p2;
+_clear_zero:
+	W[p1++] = r0;
+
+/* pass the uboot arguments to the global value command line */
+	R0 = R7;
+	call _cmdline_init;
+
+	p1.l = __rambase;
+	p1.h = __rambase;
+	r0.l = __sdata;
+	r0.h = __sdata;
+	[p1] = r0;
+
+	p1.l = __ramstart;
+	p1.h = __ramstart;
+	p3.l = __ebss;
+	p3.h = __ebss;
+
+	r1 = p3;
+	[p1] = r1;
+
+	r0.l = lo(RAM_END);
+	r0.h = hi(RAM_END);
+	p1.l = __ramend;
+	p1.h = __ramend;
+	[p1] = r0;
+
+	/*
+	 *  load the current thread pointer and stack
+	 */
+	r1.l = _init_thread_union;
+	r1.h = _init_thread_union;
+
+	r2.l = 0x2000;
+	r2.h = 0x0000;
+	r1 = r1 + r2;
+	sp = r1;
+	usp = sp;
+	fp = sp;
+	call _start_kernel;
+_exit:
+	jump.s	_exit;
+
+.section .text.l1
+ENTRY(start_dma_code)
+#if CONFIG_BFIN_KERNEL_CLOCK
+	p0.h = hi(SIC_IWR);
+	p0.l = lo(SIC_IWR);
+	r0.l = 0x1;
+	[p0] = r0;
+	SSYNC;
+
+	/*
+         *  Set PLL_CTL
+         *   - [14:09] = MSEL[5:0] : CLKIN / VCO multiplication factors
+         *   - [8]     = BYPASS    : BYPASS the PLL, run CLKIN into CCLK/SCLK
+         *   - [7]     = output delay (add 200ps of delay to mem signals)
+         *   - [6]     = input delay (add 200ps of input delay to mem signals)
+         *   - [5]     = PDWN      : 1=All Clocks off
+         *   - [3]     = STOPCK    : 1=Core Clock off
+         *   - [1]     = PLL_OFF   : 1=Disable Power to PLL
+         *   - [0]     = DF        : 1=Pass CLKIN/2 to PLL / 0=Pass CLKIN to PLL
+         *   all other bits set to zero
+         */
+
+	p0.h = hi(PLL_LOCKCNT);
+	p0.l = lo(PLL_LOCKCNT);
+	r0 = 0x300(Z);
+	w[p0] = r0.l;
+	ssync;
+
+        P2.H = hi(EBIU_SDGCTL);
+        P2.L = lo(EBIU_SDGCTL);
+        R0 = [P2];
+        BITSET (R0, 24);
+        [P2] = R0;
+        SSYNC;
+
+        r0 = CONFIG_VCO_MULT & 63; /* Load the VCO multiplier         */
+        r0 = r0 << 9;                   /* Shift it over,                  */
+        r1 = CLKIN_HALF;        /* Do we need to divide CLKIN by 2?*/
+        r0 = r1 | r0;
+        r1 = PLL_BYPASS;         /* Bypass the PLL?                 */
+        r1 = r1 << 8;                   /* Shift it over                   */
+        r0 = r1 | r0;                   /* add them all together           */
+
+        p0.h = hi(PLL_CTL);
+        p0.l = lo(PLL_CTL);      /* Load the address                */
+        cli r2;                         /* Disable interrupts              */
+	ssync;
+        w[p0] = r0.l;                     /* Set the value                   */
+        idle;                           /* Wait for the PLL to stablize    */
+        sti r2;                         /* Enable interrupts               */
+
+check_again:
+	p0.h = hi(PLL_STAT);
+	p0.l = lo(PLL_STAT);
+	R0 = W[P0](Z);
+	CC = BITTST(R0,5);
+	if ! CC jump check_again;
+
+	/* Configure SCLK & CCLK Dividers */
+       	r0 = (CONFIG_CCLK_ACT_DIV | CONFIG_SCLK_DIV);
+        p0.h = hi(PLL_DIV);
+        p0.l = lo(PLL_DIV);
+        w[p0] = r0.l;
+        ssync;
+
+	p0.l = lo(EBIU_SDRRC);
+        p0.h = hi(EBIU_SDRRC);
+        r0 = mem_SDRRC;
+        w[p0] = r0.l;
+        ssync;
+
+        p0.l = (EBIU_SDBCTL & 0xFFFF);
+        p0.h = (EBIU_SDBCTL >> 16);     /* SDRAM Memory Bank Control Register */
+        r0 = mem_SDBCTL;
+        w[p0] = r0.l;
+        ssync;
+
+	P2.H = hi(EBIU_SDGCTL);
+        P2.L = lo(EBIU_SDGCTL);
+        R0 = [P2];
+        BITCLR (R0, 24);
+	p0.h = hi(EBIU_SDSTAT);
+	p0.l = lo(EBIU_SDSTAT);
+	r2.l = w[p0];
+	cc = bittst(r2,3);
+	if !cc jump skip;
+    NOP;
+	BITSET (R0, 23);
+skip:
+	[P2] = R0;
+        SSYNC;
+
+        R0.L = lo(mem_SDGCTL);
+        R0.H = hi(mem_SDGCTL);
+	R1 = [p2];
+	R1 = R1 | R0;
+	[P2] = R1;
+        SSYNC;
+
+	RTS;
+#endif /* CONFIG_BFIN_KERNEL_CLOCK */
+
+ENTRY(_reset)
+	/* No more interrupts to be handled*/
+	CLI R6;
+	SSYNC;
+
+#if defined(CONFIG_BFIN_SHARED_FLASH_ENET)
+	p0.h = hi(FIO_INEN);
+	p0.l = lo(FIO_INEN);
+	r0.l = ~(PF1 | PF0);
+	w[p0] = r0.l;
+
+	p0.h = hi(FIO_DIR);
+	p0.l = lo(FIO_DIR);
+	r0.l = (PF1 | PF0);
+	w[p0] = r0.l;
+
+	p0.h = hi(FIO_FLAG_C);
+	p0.l = lo(FIO_FLAG_C);
+	r0.l = (PF1 | PF0);
+	w[p0] = r0.l;
+#endif
+
+	/* Clear the bits 13-15 in SWRST if they werent cleared */
+	p0.h = hi(SWRST);
+	p0.l = lo(SWRST);
+	csync;
+	r0.l = w[p0];
+
+	/* Clear the IMASK register */
+	p0.h = hi(IMASK);
+	p0.l = lo(IMASK);
+	r0 = 0x0;
+	[p0] = r0;
+
+	/* Clear the ILAT register */
+	p0.h = hi(ILAT);
+	p0.l = lo(ILAT);
+	r0 = [p0];
+	[p0] = r0;
+	SSYNC;
+
+	/* Disable the WDOG TIMER */
+	p0.h = hi(WDOG_CTL);
+	p0.l = lo(WDOG_CTL);
+	r0.l = 0xAD6;
+	w[p0] = r0.l;
+	SSYNC;
+
+	/* Clear the sticky bit incase it is already set */
+	p0.h = hi(WDOG_CTL);
+	p0.l = lo(WDOG_CTL);
+	r0.l = 0x8AD6;
+	w[p0] = r0.l;
+	SSYNC;
+
+	/* Program the count value */
+	R0.l = 0x100;
+	R0.h = 0x0;
+	P0.h = hi(WDOG_CNT);
+	P0.l = lo(WDOG_CNT);
+	[P0] = R0;
+	SSYNC;
+
+	/* Program WDOG_STAT if necessary */
+	P0.h = hi(WDOG_CTL);
+	P0.l = lo(WDOG_CTL);
+	R0 = W[P0](Z);
+	CC = BITTST(R0,1);
+	if !CC JUMP WRITESTAT;
+	CC = BITTST(R0,2);
+	if !CC JUMP WRITESTAT;
+	JUMP SKIP_WRITE;
+
+WRITESTAT:
+	/* When watch dog timer is enabled, a write to STAT will load the contents of CNT to STAT */
+	R0 = 0x0000(z);
+	P0.h = hi(WDOG_STAT);
+	P0.l = lo(WDOG_STAT)
+	[P0] = R0;
+	SSYNC;
+
+SKIP_WRITE:
+	/* Enable the reset event */
+	P0.h = hi(WDOG_CTL);
+        P0.l = lo(WDOG_CTL);
+        R0 = W[P0](Z);
+        BITCLR(R0,1);
+        BITCLR(R0,2);
+        W[P0] = R0.L;
+        SSYNC;
+        NOP;
+
+	/* Enable the wdog counter */
+        R0 = W[P0](Z);
+        BITCLR(R0,4);
+        W[P0] = R0.L;
+        SSYNC;
+
+	IDLE;
+
+	RTS;
+
+#if CONFIG_DEBUG_KERNEL_START
+debug_kernel_start_trap:
+	/* Set up a temp stack in L1 - SDRAM might not be working  */
+	P0.L = lo(L1_DATA_A_START + 0x100);
+	P0.H = hi(L1_DATA_A_START + 0x100);
+	SP = P0;
+
+	/* Make sure the Clocks are the way I think they should be */
+        r0 = CONFIG_VCO_MULT & 63;      /* Load the VCO multiplier         */
+        r0 = r0 << 9;                   /* Shift it over,                  */
+        r1 = CLKIN_HALF;                /* Do we need to divide CLKIN by 2?*/
+        r0 = r1 | r0;
+        r1 = PLL_BYPASS;                /* Bypass the PLL?                 */
+        r1 = r1 << 8;                   /* Shift it over                   */
+        r0 = r1 | r0;                   /* add them all together           */
+
+        p0.h = hi(PLL_CTL);
+        p0.l = lo(PLL_CTL);      /* Load the address                */
+        cli r2;                         /* Disable interrupts              */
+        ssync;
+        w[p0] = r0.l;                     /* Set the value                   */
+        idle;                           /* Wait for the PLL to stablize    */
+        sti r2;                         /* Enable interrupts               */
+
+check_again1:
+        p0.h = hi(PLL_STAT);
+        p0.l = lo(PLL_STAT);
+        R0 = W[P0](Z);
+        CC = BITTST(R0,5);
+        if ! CC jump check_again1;
+
+        /* Configure SCLK & CCLK Dividers */
+        r0 = (CONFIG_CCLK_ACT_DIV | CONFIG_SCLK_DIV);
+        p0.h = hi(PLL_DIV);
+        p0.l = lo(PLL_DIV);
+        w[p0] = r0.l;
+        ssync;
+
+        /* Make sure UART is enabled - you can never be sure */
+
+/*
+ *      Setup for console. Argument comes from the menuconfig
+ */
+
+#ifdef CONFIG_BAUD_9600
+#define CONSOLE_BAUD_RATE       9600
+#elif CONFIG_BAUD_19200
+#define CONSOLE_BAUD_RATE       19200
+#elif CONFIG_BAUD_38400
+#define CONSOLE_BAUD_RATE       38400
+#elif CONFIG_BAUD_57600
+#define CONSOLE_BAUD_RATE       57600
+#elif CONFIG_BAUD_115200
+#define CONSOLE_BAUD_RATE       115200
+#endif
+
+        p0.h = hi(UART_GCTL);
+        p0.l = lo(UART_GCTL);
+        r0 = 0x00(Z);
+        w[p0] = r0.L;   /* To Turn off UART clocks */
+        ssync;
+
+        p0.h = hi(UART_LCR);
+        p0.l = lo(UART_LCR);
+        r0 = 0x83(Z);
+        w[p0] = r0.L;   /* To enable DLL writes */
+        ssync;
+
+	R1 = (((CONFIG_CLKIN_HZ * CONFIG_VCO_MULT) / CONFIG_SCLK_DIV) / ( CONSOLE_BAUD_RATE * 16 ) );
+
+        p0.h = hi(UART_DLL);
+        p0.l = lo(UART_DLL);
+	r0 = 0xFF(Z);
+        r0 = R1 & R0;
+        w[p0] = r0.L;
+        ssync;
+
+        p0.h = hi(UART_DLH);
+        p0.l = lo(UART_DLH);
+        r1 >>= 8 ;
+        w[p0] = r1.L;
+        ssync;
+
+        p0.h = hi(UART_GCTL);
+        p0.l = lo(UART_GCTL);
+        r0 = 0x0(Z);
+        w[p0] = r0.L;   /* To enable UART clock */
+        ssync;
+
+        p0.h = hi(UART_LCR);
+        p0.l = lo(UART_LCR);
+        r0 = 0x03(Z);
+        w[p0] = r0.L;   /* To Turn on UART */
+        ssync;
+
+        p0.h = hi(UART_GCTL);
+        p0.l = lo(UART_GCTL);
+        r0 = 0x01(Z);
+        w[p0] = r0.L;   /* To Turn on UART Clocks */
+        ssync;
+
+        P0.h = hi(UART_THR);
+        P0.l = lo(UART_THR);
+        P1.h = hi(UART_LSR);
+        P1.l = lo(UART_LSR);
+
+	R0.L = 'K';
+	call wait_char;
+        R0.L='e';
+        call wait_char;
+        R0.L='r';
+        call wait_char;
+        R0.L='n'
+        call wait_char;
+        R0.L='e'
+        call wait_char;
+        R0.L='l';
+        call wait_char;
+        R0.L=' ';
+        call wait_char;
+        R0.L='c';
+        call wait_char;
+        R0.L='r';
+        call wait_char;
+        R0.L='a';
+        call wait_char;
+        R0.L='s';
+        call wait_char;
+        R0.L='h';
+        call wait_char;
+        R0.L='\r';
+        call wait_char;
+        R0.L='\n';
+        call wait_char;
+
+        R0.L='S';
+        call wait_char;
+        R0.L='E';
+        call wait_char;
+        R0.L='Q'
+        call wait_char;
+        R0.L='S'
+        call wait_char;
+        R0.L='T';
+        call wait_char;
+        R0.L='A';
+        call wait_char;
+        R0.L='T';
+        call wait_char;
+        R0.L='=';
+        call wait_char;
+	R2 = SEQSTAT;
+	call dump_reg;
+
+        R0.L=' ';
+        call wait_char;
+        R0.L='R';
+        call wait_char;
+        R0.L='E'
+        call wait_char;
+        R0.L='T'
+        call wait_char;
+        R0.L='X';
+        call wait_char;
+        R0.L='=';
+        call wait_char;
+        R2 = RETX;
+        call dump_reg;
+
+        R0.L='\r';
+        call wait_char;
+        R0.L='\n';
+        call wait_char;
+
+debug_kernel_start_trap_done:
+        JUMP    debug_kernel_start_trap_done;
+dump_reg:
+        R3 = 32;
+        R4 = 0x0F;
+	R5 = ':';  /* one past 9 */
+
+dump_reg2:
+        R0 = R2;
+        R3 += -4;
+        R0 >>>= R3;
+        R0 = R0 & R4;
+        R0 += 0x30;
+	CC = R0 <= R5;
+	if CC JUMP dump_reg1;
+	R0 += 7;
+
+dump_reg1:
+        R1.l = W[P1];
+        CC = BITTST(R1, 5);
+        if !CC JUMP dump_reg1;
+        W[P0] = r0;
+
+        CC = R3 == 0;
+        if !CC JUMP dump_reg2
+	RTS;
+
+wait_char:
+        R1.l = W[P1];
+        CC = BITTST(R1, 5);
+        if !CC JUMP wait_char;
+        W[P0] = r0;
+	RTS;
+
+#endif  /* CONFIG_DEBUG_KERNEL_START  */
+
+.data
+
+/*
+ *      Set up the usable of RAM stuff. Size of RAM is determined then
+ *      an initial stack set up at the end.
+ */
+
+.align 4
+__rambase:
+.long   0
+__ramstart:
+.long   0
+__ramend:
+.long   0
Index: git/linux-2.6/arch/blackfin/mach-bf533/ints-priority.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf533/ints-priority.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,69 @@
+ /*
+  * File:        arch/blackfin/mach-bf533/ints-priority.c
+  * Based on:
+  * Author:      Michael Hennerich
+  *              COPYRIGHT 2005 Analog Devices
+  * Created:     ?
+  * Description: Set up the interupt priorities
+  *
+  * Rev:          $Id$
+  *
+  * Modified:
+  *
+  *
+  * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.
+  * If not, write to the Free Software Foundation,
+  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+  */
+
+#include <linux/module.h>
+#include <asm/blackfin.h>
+#include <asm/irq.h>
+
+void program_IAR(void);
+/*Program the IAR registers*/
+
+void program_IAR(void)
+{
+	/* Program the IAR0 Register with the configured priority */
+	*pSIC_IAR0 = ((CONFIG_PLLWAKE_ERROR - 7) << PLLWAKE_ERROR_POS) |
+	    ((CONFIG_DMA_ERROR - 7) << DMA_ERROR_POS) |
+	    ((CONFIG_PPI_ERROR - 7) << PPI_ERROR_POS) |
+	    ((CONFIG_SPORT0_ERROR - 7) << SPORT0_ERROR_POS) |
+	    ((CONFIG_SPI_ERROR - 7) << SPI_ERROR_POS) |
+	    ((CONFIG_SPORT1_ERROR - 7) << SPORT1_ERROR_POS) |
+	    ((CONFIG_UART_ERROR - 7) << UART_ERROR_POS) |
+	    ((CONFIG_RTC_ERROR - 7) << RTC_ERROR_POS);
+
+	*pSIC_IAR1 = ((CONFIG_DMA0_PPI - 7) << DMA0_PPI_POS) |
+	    ((CONFIG_DMA1_SPORT0RX - 7) << DMA1_SPORT0RX_POS) |
+	    ((CONFIG_DMA2_SPORT0TX - 7) << DMA2_SPORT0TX_POS) |
+	    ((CONFIG_DMA3_SPORT1RX - 7) << DMA3_SPORT1RX_POS) |
+	    ((CONFIG_DMA4_SPORT1TX - 7) << DMA4_SPORT1TX_POS) |
+	    ((CONFIG_DMA5_SPI - 7) << DMA5_SPI_POS) |
+	    ((CONFIG_DMA6_UARTRX - 7) << DMA6_UARTRX_POS) |
+	    ((CONFIG_DMA7_UARTTX - 7) << DMA7_UARTTX_POS);
+
+	*pSIC_IAR2 = ((CONFIG_TIMER0 - 7) << TIMER0_POS) |
+	    ((CONFIG_TIMER1 - 7) << TIMER1_POS) |
+	    ((CONFIG_TIMER2 - 7) << TIMER2_POS) |
+	    ((CONFIG_PFA - 7) << PFA_POS) |
+	    ((CONFIG_PFB - 7) << PFB_POS) |
+	    ((CONFIG_MEMDMA0 - 7) << MEMDMA0_POS) |
+	    ((CONFIG_MEMDMA1 - 7) << MEMDMA1_POS) |
+	    ((CONFIG_WDTIMER - 7) << WDTIMER_POS);
+	__builtin_bfin_ssync();
+};				/*End of program_IAR */
Index: git/linux-2.6/arch/blackfin/mach-bf533/pm.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf533/pm.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,158 @@
+/*
+ * File:        arch/blackfin/mach-bf533/pm.c
+ * Based on:    arm/mach-omap/pm.c
+ * Author:      Cliff Brake <cbrake@accelent.com>
+ *              Copyright (c) 2001
+ * Created:     2001
+ * Description: Power management for the bf533
+ *
+ * Rev:         $Id$
+ *
+ * Modified:    Nicolas Pitre - PXA250 support
+ *                Copyright (c) 2002 Monta Vista Software, Inc.
+ *              David Singleton - OMAP1510
+ *                Copyright (c) 2002 Monta Vista Software, Inc.
+ *              Dirk Behme <dirk.behme@de.bosch.com> - OMAP1510/1610
+ *                Copyright 2004
+ *              Michael.Kang@analog.com - Blackfin support
+ * Maintained:  Michael.Kang@analog.com
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/pm.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/pm.h>
+
+#include <asm/io.h>
+
+/*
+ * Let's power down on idle, but only if we are really
+ * idle, because once we start down the path of
+ * going idle we continue to do idle even if we get
+ * a clock tick interrupt . .
+ */
+void bf533_pm_idle(void)
+{
+}
+
+/*
+ * when we call pm_suspend, that code  enters into idle state and sdram enter self-refresh mode
+ *  to save more energy.When there is any interrupt,the core will resume
+ */
+void bf533_pm_suspend(void)
+{
+	/*sdram enter self-refresh mode*/
+	 *pEBIU_SDGCTL = (*pEBIU_SDGCTL |SRFS);
+        __builtin_bfin_ssync();
+	/*any interrupt can cause CPU exit idle state*/
+        *pSIC_IWR = 0x00ffffff;
+        __builtin_bfin_ssync();
+        __asm__ (
+        "CLI R2;\n\t"
+        "SSYNC;\n\t"
+        "IDLE;\n\t"
+        "STI R2;\n\t"
+        );
+        /*sdram exit self-refresh mode*/
+        *pEBIU_SDGCTL = (*pEBIU_SDGCTL |SRFS);
+        __builtin_bfin_ssync();
+
+}
+
+/*
+ *	bf533_pm_prepare - Do preliminary suspend work.
+ *	@state:		suspend state we're entering.
+ *
+ */
+
+static int bf533_pm_prepare(suspend_state_t state)
+{
+	int error = 0;
+
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+		break;
+	case PM_SUSPEND_MEM:
+		return -ENOTSUPP;
+
+	case PM_SUSPEND_DISK:
+		return -ENOTSUPP;
+
+	default:
+		return -EINVAL;
+	}
+
+	return error;
+}
+
+/*
+ *	bf533_pm_enter - Actually enter a sleep state.
+ *	@state:		State we're entering.
+ *
+ */
+
+static int bf533_pm_enter(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+		return -ENOTSUPP;
+
+	case PM_SUSPEND_MEM:
+		bf533_pm_suspend();
+		break;
+
+	case PM_SUSPEND_DISK:
+		return -ENOTSUPP;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
+ *	bf533_pm_finish - Finish up suspend sequence.
+ *	@state:		State we're coming out of.
+ *
+ *	This is called after we wake back up (or if entering the sleep state
+ *	failed).
+ */
+
+static int bf533_pm_finish(suspend_state_t state)
+{
+	return 0;
+}
+
+struct pm_ops bf533_pm_ops = {
+	.pm_disk_mode = PM_DISK_FIRMWARE,
+	.prepare = bf533_pm_prepare,
+	.enter = bf533_pm_enter,
+	.finish = bf533_pm_finish,
+};
+
+static int __init bf533_pm_init(void)
+{
+
+	pm_set_ops(&bf533_pm_ops);
+	return 0;
+}
+
+__initcall(bf533_pm_init);
Index: git/linux-2.6/arch/blackfin/mach-bf537/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf537/Kconfig	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,139 @@
+if (BF537 || BF534 || BF536)
+
+menu "BF537 Specific Configuration"
+
+comment 'PORT F/G Selection'
+choice
+	prompt	"Select BF537/6/4 default GPIO PFx PORTx"
+	---help---
+	  Quick Hack for BF537/6/4 default GPIO PFx PORTF
+
+config BF537_PORT_F
+	bool 'Select BF537/6/4 default GPIO PFx PORTF'
+	depends on (BF537 || BF536 || BF534)
+	help
+	  Quick Hack for BF537/6/4 default GPIO PFx PORTF
+
+config BF537_PORT_G
+	bool 'Select BF537/6/4 default GPIO PFx PORTG'
+	depends on (BF537 || BF536 || BF534)
+	help
+	  Quick Hack for BF537/6/4 default GPIO PFx PORTG
+endchoice
+
+comment	'Interrupt Priority Assignment'
+menu	'Priority'
+
+config	IRQ_PLL_WAKEUP
+	int "IRQ_PLL_WAKEUP"
+    default 7
+config	IRQ_DMA_ERROR
+    int "IRQ_DMA_ERROR Generic"
+    default 7
+config	IRQ_ERROR
+    int "IRQ_ERROR: CAN MAC SPORT0 SPORT1 SPI UART0 UART1"
+    default 7
+config	IRQ_RTC
+    int "IRQ_RTC"
+    default 8
+config	IRQ_PPI
+    int "IRQ_PPI"
+    default 8
+config	IRQ_SPORT0_RX
+    int "IRQ_SPORT0_RX"
+    default 9
+config	IRQ_SPORT0_TX
+    int "IRQ_SPORT0_TX"
+    default 9
+config	IRQ_SPORT1_RX
+    int "IRQ_SPORT1_RX"
+    default 9
+config	IRQ_SPORT1_TX
+    int "IRQ_SPORT1_TX"
+    default 9
+config	IRQ_TWI
+    int "IRQ_TWI"
+    default 10
+config	IRQ_SPI
+    int "IRQ_SPI"
+    default 10
+config	IRQ_UART0_RX
+    int "IRQ_UART0_RX"
+    default 10
+config	IRQ_UART0_TX
+    int "IRQ_UART0_TX"
+    default 10
+config	IRQ_UART1_RX
+    int "IRQ_UART1_RX"
+    default 10
+config	IRQ_UART1_TX
+    int "IRQ_UART1_TX"
+    default 10
+config	IRQ_CAN_RX
+    int "IRQ_CAN_RX"
+    default 11
+config	IRQ_CAN_TX
+    int "IRQ_CAN_TX"
+    default 11
+config	IRQ_MAC_RX
+    int "IRQ_MAC_RX"
+    default 11
+config	IRQ_MAC_TX
+    int "IRQ_MAC_TX"
+    default 11
+config	IRQ_TMR0
+    int "IRQ_TMR0"
+    default 12
+config	IRQ_TMR1
+    int "IRQ_TMR1"
+    default 12
+config	IRQ_TMR2
+    int "IRQ_TMR2"
+    default 12
+config	IRQ_TMR3
+    int "IRQ_TMR3"
+    default 12
+config	IRQ_TMR4
+    int "IRQ_TMR4"
+    default 12
+config	IRQ_TMR5
+    int "IRQ_TMR5"
+    default 12
+config	IRQ_TMR6
+    int "IRQ_TMR6"
+    default 12
+config	IRQ_TMR7
+    int "IRQ_TMR7"
+    default 12
+config	IRQ_PROG_INTA
+    int "IRQ_PROG_INTA"
+    default 12
+config	IRQ_PROG_INTB
+    int "IRQ_PROG_INTB"
+    default 12
+config	IRQ_MEM_DMA0
+    int "IRQ_MEM_DMA0"
+    default 13
+config	IRQ_MEM_DMA1
+    int "IRQ_MEM_DMA1"
+    default 13
+config	IRQ_WATCH
+    int "IRQ_WATCH"
+    default 13
+
+	help
+	  ------------------------- GENERAL HELP -------------------------
+	  Enter the priority numbers between 7-13 ONLY. Others are Reserved.
+ 	  This applies to all the above.It is not recommended to assign the
+	  highest priority no 7 to UART or any other device.
+
+endmenu
+
+endmenu
+
+config BFIN_HAVE_RTC
+	bool "Enable built-in RTC"
+	depends on (BF537 || BF536 || BF534)
+	default y
+
+endif
Index: git/linux-2.6/arch/blackfin/mach-bf537/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf537/Makefile	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,8 @@
+#
+# Makefile for mach-bf537.
+#
+extra-y += head.o
+# Object file lists.
+obj-y:= ints-priority.o
+obj-$(CONFIG_CPU_FREQ) += cpu.o
+obj-$(CONFIG_PM) +=pm.o
Index: git/linux-2.6/arch/blackfin/mach-bf537/boards/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf537/boards/Makefile	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,8 @@
+#
+# Makefile for mach-bf533/boards.
+#
+
+# Object file lists.
+
+obj-$(CONFIG_BFIN537_STAMP) += stamp.o
+obj-$(CONFIG_GENERIC_BOARD) += generic_board.o
Index: git/linux-2.6/arch/blackfin/mach-bf537/boards/ezkit.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf537/boards/ezkit.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,83 @@
+/*
+ * File:         arch/blackfin/mach-bf537/ezkit.c
+ * Based on:     arch/blackfin/mach-bf533/ezkit.c
+ * Author:       Aidan Williams <aidan@nicta.com.au>
+ *                 Copyright 2005 National ICT Australia (NICTA)
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/device.h>
+#include <asm/irq.h>
+
+/*
+ *  USB-LAN EzExtender board
+ *  Driver needs to know address, irq and flag pin.
+ */
+static struct resource smc91x_resources[] = {
+	[0] = {
+	       .start = 0x20310300,
+	       .end = 0x20310300 + 16,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_PROG_INTB,
+	       .end = IRQ_PROG_INTB,
+	       .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	       },
+	[2] = {
+	       /*
+	        *  denotes the flag pin and is used directly if
+	        *  CONFIG_IRQCHIP_DEMUX_GPIO is defined.
+	        */
+	       .start = IRQ_PF10,
+	       .end = IRQ_PF10,
+	       .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	       },
+};
+static struct platform_device smc91x_device = {
+	.name = "smc91x",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(smc91x_resources),
+	.resource = smc91x_resources,
+};
+
+static struct platform_device bfin_mac_device = {
+	.name = "bfin_mac",
+};
+
+static struct platform_device *ezkit_devices[] __initdata = {
+	&smc91x_device,
+	&bfin_mac_device,
+};
+
+static int __init ezkit_init(void)
+{
+	printk("%s(): registering device resources\n", __FUNCTION__);
+	return platform_add_devices(ezkit_devices, ARRAY_SIZE(ezkit_devices));
+}
+
+arch_initcall(ezkit_init);
Index: git/linux-2.6/arch/blackfin/mach-bf537/boards/generic_board.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf537/boards/generic_board.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,77 @@
+/*
+ * File:         arch/blackfin/mach-bf537/generic_board.c
+ * Based on:    arch/blackfin/mach-bf533/ezkit.c
+ * Author:      Aidan Williams <aidan@nicta.com.au>
+ *                Copyright 2005 National ICT Australia (NICTA)
+ * Created:
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/device.h>
+#include <asm/irq.h>
+
+/*
+ *  Driver needs to know address, irq and flag pin.
+ */
+static struct resource smc91x_resources[] = {
+	[0] = {
+	       .start = 0x20300300,
+	       .end = 0x20300300 + 16,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_PROG_INTB,
+	       .end = IRQ_PROG_INTB,
+	       .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	       },
+	[2] = {
+	       /*
+	        *  denotes the flag pin and is used directly if
+	        *  CONFIG_IRQCHIP_DEMUX_GPIO is defined.
+	        */
+	       .start = IRQ_PF7,
+	       .end = IRQ_PF7,
+	       .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	       },
+};
+static struct platform_device smc91x_device = {
+	.name = "smc91x",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(smc91x_resources),
+	.resource = smc91x_resources,
+};
+
+static struct platform_device *generic_board_devices[] __initdata = {
+	&smc91x_device,
+};
+
+static int __init generic_board_init(void)
+{
+	printk("%s(): registering device resources\n", __FUNCTION__);
+	return platform_add_devices(generic_board_devices,
+				    ARRAY_SIZE(generic_board_devices));
+}
+
+arch_initcall(generic_board_init);
Index: git/linux-2.6/arch/blackfin/mach-bf537/boards/stamp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf537/boards/stamp.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,82 @@
+/*
+ * File:        arch/blackfin/mach-bf537/stamp.c
+ * Based on:    archi/blacfkin/mach-bf533/ezkit.c
+ * Author:      Aidan Williams <aidan@nicta.com.au>
+ *                Copyright 2005 National ICT Australia (NICTA)
+ * Created:
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <asm/irq.h>
+
+/*
+ *  Driver needs to know address, irq and flag pin.
+ */
+static struct resource smc91x_resources[] = {
+	[0] = {
+	       .start = 0x20300300,
+	       .end = 0x20300300 + 16,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_PROG_INTB,
+	       .end = IRQ_PROG_INTB,
+	       .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	       },
+	[2] = {
+	       /*
+	        *  denotes the flag pin and is used directly if
+	        *  CONFIG_IRQCHIP_DEMUX_GPIO is defined.
+	        */
+	       .start = IRQ_PF7,
+	       .end = IRQ_PF7,
+	       .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	       },
+};
+static struct platform_device smc91x_device = {
+	.name = "smc91x",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(smc91x_resources),
+	.resource = smc91x_resources,
+};
+
+static struct platform_device bfin_mac_device = {
+	.name = "bfin_mac",
+};
+
+static struct platform_device *stamp_devices[] __initdata = {
+	&smc91x_device,
+	&bfin_mac_device,
+};
+
+static int __init stamp_init(void)
+{
+	printk("%s(): registering device resources\n", __FUNCTION__);
+	return platform_add_devices(stamp_devices, ARRAY_SIZE(stamp_devices));
+}
+
+arch_initcall(stamp_init);
Index: git/linux-2.6/arch/blackfin/mach-bf537/cpu.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf537/cpu.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,171 @@
+/*
+ * File:         arch/blackfin/mach-bf537/cpu.c
+ * Based on:
+ * Author:	michael.kang@analog.com
+ *              COPYRIGHT 2005 Analog Devices Inc.
+ * Created:
+ * Description: clock scaling for the bf537
+ *
+ * Rev: $Id$
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/cpufreq.h>
+#include <asm/dpmc.h>
+#include <linux/fs.h>
+
+#undef BF533_CPU_DEBUG
+
+//CONFIG_CLKIN_HZ=11059200
+#define VCO5 (CONFIG_CLKIN_HZ*45)	/*497664000 */
+#define VCO4 (CONFIG_CLKIN_HZ*36)	/*398131200 */
+#define VCO3 (CONFIG_CLKIN_HZ*27)	/*298598400 */
+#define VCO2 (CONFIG_CLKIN_HZ*18)	/*199065600 */
+#define VCO1 (CONFIG_CLKIN_HZ*9)	/*99532800 */
+#define VCO(x) VCO##x
+
+#define FREQ(x) {VCO(x),VCO(x)/4},{VCO(x),VCO(x)/2},{VCO(x),VCO(x)}
+/* frequency */
+static struct cpufreq_frequency_table bf537_freq_table[] = {
+	FREQ(1),
+	FREQ(3),
+	{VCO4, VCO4 / 2}, {VCO4, VCO4},
+	FREQ(5),
+	{0, CPUFREQ_TABLE_END},
+};
+
+extern struct file_operations dpmc_fops;
+
+/*
+ * dpmc_fops->ioctl()
+ * static int dpmc_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+ */
+
+extern unsigned long get_cclk();
+static int bf537_getfreq(unsigned int cpu)
+{
+	unsigned long cclk_mhz, vco_mhz;
+
+	/*The driver only support single cpu */
+	if (cpu == 0)
+		dpmc_fops.ioctl(NULL, NULL, IOCTL_GET_CORECLOCK, &cclk_mhz);
+	else
+		cclk_mhz = -1;
+	return cclk_mhz;
+}
+ /**/
+    static int bf537_target(struct cpufreq_policy *policy,
+			    unsigned int target_freq, unsigned int relation)
+{
+	unsigned long cclk_mhz;
+	unsigned long vco_mhz;
+	unsigned long flags;
+	unsigned int index, vco_index;
+	int i;
+
+	struct cpufreq_freqs freqs;
+	if (cpufreq_frequency_table_target
+	    (policy, bf537_freq_table, target_freq, relation, &index))
+		return -EINVAL;
+	cclk_mhz = bf537_freq_table[index].frequency;
+	vco_mhz = bf537_freq_table[index].index;
+
+	dpmc_fops.ioctl(NULL, NULL, IOCTL_CHANGE_FREQUENCY, &vco_mhz);
+	freqs.old = bf537_getfreq(0);
+	freqs.new = cclk_mhz;
+	freqs.cpu = 0;
+
+#if defined(BF533_CPU_DEBUG)
+	printk
+	    ("cclk begin change to cclk %d,vco=%d,index=%d,target=%d,oldfreq=%d\n",
+	     cclk_mhz, vco_mhz, index, target_freq, freqs.old);
+#endif
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+	local_irq_save(flags);
+	dpmc_fops.ioctl(NULL, NULL, IOCTL_SET_CCLK, &cclk_mhz);
+	local_irq_restore(flags);
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+
+	vco_mhz = get_vco();
+	cclk_mhz = get_cclk();
+	return 0;
+}
+
+/* make sure that only the "userspace" governor is run -- anything else wouldn't make sense on
+ * this platform, anyway.
+ */
+static int bf537_verify_speed(struct cpufreq_policy *policy)
+{
+	return cpufreq_frequency_table_verify(policy, &bf537_freq_table);
+}
+
+static int __init __bf537_cpu_init(struct cpufreq_policy *policy)
+{
+	int result;
+
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+
+	policy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;
+	/*Now ,only support one cpu */
+	policy->cur = bf537_getfreq(0);
+	cpufreq_frequency_table_get_attr(bf537_freq_table, policy->cpu);
+	return cpufreq_frequency_table_cpuinfo(policy, bf537_freq_table);
+}
+
+static struct freq_attr *bf537_freq_attr[] = {
+	&cpufreq_freq_attr_scaling_available_freqs,
+	NULL,
+};
+
+static struct cpufreq_driver bf537_driver = {
+	.verify = bf537_verify_speed,
+	.target = bf537_target,
+	.get = bf537_getfreq,
+	.init = __bf537_cpu_init,
+	.name = "bf537",
+	.owner = THIS_MODULE,
+	.attr = bf537_freq_attr,
+};
+
+static int __init bf537_cpu_init(void)
+{
+	//MISC_MAJOR, DPMC_MINOR
+	return (cpufreq_register_driver(&bf537_driver));
+}
+
+static void __exit bf537_cpu_exit(void)
+{
+	cpufreq_unregister_driver(&bf537_driver);
+}
+
+MODULE_AUTHOR("Mickael Kang");
+MODULE_DESCRIPTION("cpufreq driver for BF537 CPU");
+MODULE_LICENSE("GPL");
+
+module_init(bf537_cpu_init);
+module_exit(bf537_cpu_exit);
Index: git/linux-2.6/arch/blackfin/mach-bf537/head.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf537/head.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,530 @@
+/*
+ * File:         arch/blackfin/mach-bf537/head.S
+ * Based on:     arch/blackfin/mach-bf533/head.S
+ * Author:      Jeff Dionne <jeff@uclinux.org>
+ *                COPYRIGHT 1998 D. Jeff Dionne
+ * Created:     1998
+ * Description: Startup code for Blackfin BF537
+ *
+ * Rev:         $Id$
+ *
+ * Modified:    LG Soft India
+ *                Copyright 2004-2005 ANALOG DEVICES
+ *              Michael Hennerich - BF537 Support
+ *                Copyright 2005 ANALOG DEVICES
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#include <linux/linkage.h>
+#include <asm/blackfin.h>
+#if CONFIG_BFIN_KERNEL_CLOCK
+#include <asm/mach/mem_init.h>
+#endif
+
+.global __rambase
+.global __ramstart
+.global __ramend
+.extern __ebss
+.extern _bf53x_relocate_l1_mem
+
+#define INITIAL_STACK   0xFFB01000
+
+.text
+
+ENTRY(__start)
+ENTRY(__stext)
+/*  R0: argument of command line string, passed from uboot, save it */
+	R7 = R0;
+	/* Set the SYSCFG register */
+	R0 = 0x36;
+	SYSCFG = R0; 		/*Enable Cycle Counter and Nesting Of Interrupts(3rd Bit)*/
+	R0 = 0;
+
+/*Clear Out All the data and pointer  Registers*/
+	R1 = R0;
+	R2 = R0;
+	R3 = R0;
+	R4 = R0;
+	R5 = R0;
+	R6 = R0;
+
+	P0 = R0;
+	P1 = R0;
+	P2 = R0;
+	P3 = R0;
+	P4 = R0;
+	P5 = R0;
+
+	LC0 = r0;
+	LC1 = r0;
+	L0 = r0;
+	L1 = r0;
+	L2 = r0;
+	L3 = r0;
+
+/*Clear Out All the DAG Registers*/
+	B0 = r0;
+	B1 = r0;
+	B2 = r0;
+	B3 = r0;
+
+	I0 = r0;
+	I1 = r0;
+	I2 = r0;
+	I3 = r0;
+
+	M0 = r0;
+	M1 = r0;
+	M2 = r0;
+	M3 = r0;
+
+	/* Turn off the icache */
+	p0.l = (IMEM_CONTROL & 0xFFFF);
+	p0.h = (IMEM_CONTROL >> 16);
+	R1 = [p0];
+	R0 = ~ENICPLB;
+	R0 = R0 & R1;
+
+	/* Anamoly 05000125 */
+	CLI R2;
+	SSYNC;
+	[p0] = R0;
+	SSYNC;
+	STI R2;
+
+    /* Turn off the dcache */
+    p0.l = (DMEM_CONTROL & 0xFFFF);
+    p0.h = (DMEM_CONTROL >> 16);
+    R1 = [p0];
+    R0 = ~ENDCPLB;
+    R0 = R0 & R1;
+
+    /* Anamoly 05000125 */
+    CLI R2;
+    SSYNC;
+    [p0] = R0;
+    SSYNC;
+    STI R2;
+
+/* Initialise General-Purpose I/O Modules on BF537 */
+/* Rev 0.0 Anomaly 05000212 - PORTx_FER, PORT_MUX Registers Do Not accept "writes" correctly: */
+	p0.h = hi(PORT_MUX);
+	p0.l = lo(PORT_MUX);
+	R0.L = W[P0]; //Read
+	SSYNC;
+	R0 = (PGDE_UART | PFTE_UART)(Z);
+	W[P0] = R0.L; //Write
+	SSYNC;
+	W[P0] = R0.L; /* Enable both UARTS */
+	SSYNC;
+
+	p0.h = hi(PORTF_FER);
+	p0.l = lo(PORTF_FER);
+	R0.L = W[P0]; //Read
+	SSYNC;
+	R0 = 0x000F(Z);
+	W[P0] = R0.L; //Write
+	SSYNC;
+	W[P0] = R0.L; /* Enable peripheral function of PORTF for UART0 and UART1 */
+	SSYNC;
+
+	p0.h = hi(EMAC_SYSTAT);
+	p0.l = lo(EMAC_SYSTAT);
+	R0.h = 0xFFFF; /* Clear EMAC Interrupt Status bits */
+	R0.l = 0xFFFF;
+	[P0] = R0;
+	SSYNC;
+
+/*Initialise UART*/
+	p0.h = hi(UART_LCR);
+	p0.l = lo(UART_LCR);
+	r0 = 0x0(Z);
+	w[p0] = r0.L;	/* To enable DLL writes */
+	ssync;
+
+	p0.h = hi(UART_DLL);
+	p0.l = lo(UART_DLL);
+	r0 = 0x00(Z);
+	w[p0] = r0.L;
+	ssync;
+
+	p0.h = hi(UART_DLH);
+	p0.l = lo(UART_DLH);
+	r0 = 0x00(Z);
+	w[p0] = r0.L;
+	ssync;
+
+	p0.h = hi(UART_GCTL);
+	p0.l = lo(UART_GCTL);
+	r0 = 0x0(Z);
+	w[p0] = r0.L;	/* To enable UART clock */
+	ssync;
+
+        /* Initialize stack pointer */
+        sp.l = lo(INITIAL_STACK);
+        sp.h = hi(INITIAL_STACK);
+        fp = sp;
+        usp = sp;
+
+	/*Put The Code for PLL Programming and SDRAM Programming in L1 ISRAM*/
+	call _bf53x_relocate_l1_mem;
+#if CONFIG_BFIN_KERNEL_CLOCK
+	call start_dma_code;
+#endif
+	/* Code for initializing Async memory banks */
+
+        p2.h = hi(EBIU_AMBCTL1);
+        p2.l = lo(EBIU_AMBCTL1);
+        r0.h = hi(AMBCTL1VAL);
+        r0.l = lo(AMBCTL1VAL);
+        [p2] = r0;
+        ssync;
+
+        p2.h = hi(EBIU_AMBCTL0);
+        p2.l = lo(EBIU_AMBCTL0);
+        r0.h = hi(AMBCTL0VAL);
+        r0.l = lo(AMBCTL0VAL);
+        [p2] = r0;
+        ssync;
+
+        p2.h = hi(EBIU_AMGCTL);
+        p2.l = lo(EBIU_AMGCTL);
+        r0 = AMGCTLVAL;
+        w[p2] = r0;
+        ssync;
+        call _real_start;
+
+	/* This section keeps the processor in supervisor mode
+         * during kernel boot.  Switches to user mode at end of boot.
+	 * See page 3-9 of Hardware Reference manual for documentation.
+	 */
+
+	/* EVT15 = _real_start */
+
+	p0.l = lo(EVT15);
+	p0.h = hi(EVT15);
+	p1.l = _real_start;
+	p1.h = _real_start;
+	[p0] = p1;
+	csync;
+
+	p0.l = lo(IMASK);
+	p0.h = hi(IMASK);
+	p1.l = IMASK_IVG15;
+	p1.h = 0x0;
+	[p0] = p1;
+	csync;
+
+	raise 15;
+	p0.l = WAIT_HERE;
+	p0.h = WAIT_HERE;
+	reti = p0;
+	rti;
+
+WAIT_HERE:
+	jump WAIT_HERE;
+
+ENTRY(_real_start)
+	[ -- sp ] = reti;
+	p0.l = lo(WDOG_CTL);
+	p0.h = hi(WDOG_CTL);
+	r0 = 0xAD6(z);
+	w[p0] = r0;	/* watchdog off for now */
+	ssync;
+
+	/* Code update for BSS size == 0
+	 * Zero out the bss region.
+	 */
+
+	p1.l = __sbss;
+	p1.h = __sbss;
+	p2.l = __ebss;
+	p2.h = __ebss;
+	r0 = 0;
+	p2 -= p1;
+	lsetup (_clear_bss, _clear_bss ) lc0 = p2;
+_clear_bss:
+	B[p1++] = r0;
+
+	/* In case there is a NULL pointer reference
+	 * Zero out region before stext
+	 */
+
+	p1.l = 0x0;
+	p1.h = 0x0;
+	r0.l = __stext;
+	r0.h = __stext;
+	r0 = r0 >> 1;
+	p2 = r0;
+	r0 = 0;
+	lsetup (_clear_zero, _clear_zero ) lc0 = p2;
+_clear_zero:
+	W[p1++] = r0;
+
+/* pass the uboot arguments to the global value command line */
+	R0 = R7;
+	call _cmdline_init;
+
+	p1.l = __rambase;
+	p1.h = __rambase;
+	r0.l = __sdata;
+	r0.h = __sdata;
+	[p1] = r0;
+
+	p1.l = __ramstart;
+	p1.h = __ramstart;
+	p3.l = __ebss;
+	p3.h = __ebss;
+
+	r1 = p3;
+	[p1] = r1;
+
+	r0.l = lo(RAM_END);
+	r0.h = hi(RAM_END);
+	p1.l = __ramend;
+	p1.h = __ramend;
+	[p1] = r0;
+
+	/*
+	 *  load the current thread pointer and stack
+	 */
+	r1.l = _init_thread_union;
+	r1.h = _init_thread_union;
+
+	r2.l = 0x2000;
+	r2.h = 0x0000;
+	r1 = r1 + r2;
+	sp = r1;
+	usp = sp;
+	fp = sp;
+	call _start_kernel;
+_exit:
+	jump.s	_exit;
+
+.section .text.l1
+ENTRY(start_dma_code)
+
+	/* Enable PHY CLK buffer output */
+        p0.h = hi(VR_CTL);
+        p0.l = lo(VR_CTL);
+        r0.l = w[p0];
+        bitset(r0, 14);
+        w[p0] = r0.l;
+        ssync;
+
+#if CONFIG_BFIN_KERNEL_CLOCK
+	p0.h = hi(SIC_IWR);
+	p0.l = lo(SIC_IWR);
+	r0.l = 0x1;
+	[p0] = r0;
+	SSYNC;
+
+	/*
+         *  Set PLL_CTL
+         *   - [14:09] = MSEL[5:0] : CLKIN / VCO multiplication factors
+         *   - [8]     = BYPASS    : BYPASS the PLL, run CLKIN into CCLK/SCLK
+         *   - [7]     = output delay (add 200ps of delay to mem signals)
+         *   - [6]     = input delay (add 200ps of input delay to mem signals)
+         *   - [5]     = PDWN      : 1=All Clocks off
+         *   - [3]     = STOPCK    : 1=Core Clock off
+         *   - [1]     = PLL_OFF   : 1=Disable Power to PLL
+         *   - [0]     = DF        : 1=Pass CLKIN/2 to PLL / 0=Pass CLKIN to PLL
+         *   all other bits set to zero
+         */
+
+	p0.h = hi(PLL_LOCKCNT);
+	p0.l = lo(PLL_LOCKCNT);
+	r0 = 0x300(Z);
+	w[p0] = r0.l;
+	ssync;
+
+        P2.H = hi(EBIU_SDGCTL);
+        P2.L = lo(EBIU_SDGCTL);
+        R0 = [P2];
+        BITSET (R0, 24);
+        [P2] = R0;
+        SSYNC;
+
+        r0 = CONFIG_VCO_MULT & 63; /* Load the VCO multiplier         */
+        r0 = r0 << 9;                   /* Shift it over,                  */
+        r1 = CLKIN_HALF;        /* Do we need to divide CLKIN by 2?*/
+        r0 = r1 | r0;
+        r1 = PLL_BYPASS;         /* Bypass the PLL?                 */
+        r1 = r1 << 8;                   /* Shift it over                   */
+        r0 = r1 | r0;                   /* add them all together           */
+
+        p0.h = hi(PLL_CTL);
+        p0.l = lo(PLL_CTL);      /* Load the address                */
+        cli r2;                         /* Disable interrupts              */
+	ssync;
+        w[p0] = r0.l;                     /* Set the value                   */
+        idle;                           /* Wait for the PLL to stablize    */
+        sti r2;                         /* Enable interrupts               */
+
+check_again:
+	p0.h = hi(PLL_STAT);
+	p0.l = lo(PLL_STAT);
+	R0 = W[P0](Z);
+	CC = BITTST(R0,5);
+	if ! CC jump check_again;
+
+	/* Configure SCLK & CCLK Dividers */
+       	r0 = (CONFIG_CCLK_ACT_DIV | CONFIG_SCLK_DIV);
+        p0.h = hi(PLL_DIV);
+        p0.l = lo(PLL_DIV);
+        w[p0] = r0.l;
+        ssync;
+
+	p0.l = lo(EBIU_SDRRC);
+        p0.h = hi(EBIU_SDRRC);
+        r0 = mem_SDRRC;
+        w[p0] = r0.l;
+        ssync;
+
+        p0.l = (EBIU_SDBCTL & 0xFFFF);
+        p0.h = (EBIU_SDBCTL >> 16);     /* SDRAM Memory Bank Control Register */
+        r0 = mem_SDBCTL;
+        w[p0] = r0.l;
+        ssync;
+
+	P2.H = hi(EBIU_SDGCTL);
+        P2.L = lo(EBIU_SDGCTL);
+        R0 = [P2];
+        BITCLR (R0, 24);
+	p0.h = hi(EBIU_SDSTAT);
+	p0.l = lo(EBIU_SDSTAT);
+	r2.l = w[p0];
+	cc = bittst(r2,3);
+	if !cc jump skip;
+    NOP;
+	BITSET (R0, 23);
+skip:
+	[P2] = R0;
+        SSYNC;
+
+        R0.L = lo(mem_SDGCTL);
+        R0.H = hi(mem_SDGCTL);
+	R1 = [p2];
+	R1 = R1 | R0;
+	[P2] = R1;
+        SSYNC;
+
+	RTS;
+#endif /* CONFIG_BFIN_KERNEL_CLOCK */
+
+ENTRY(_reset)
+	/* No more interrupts to be handled*/
+	CLI R6;
+	SSYNC;
+
+	/* Clear the bits 13-15 in SWRST if they werent cleared */
+	p0.h = hi(SWRST);
+	p0.l = lo(SWRST);
+	csync;
+	r0.l = w[p0];
+
+	/* Clear the IMASK register */
+	p0.h = hi(IMASK);
+	p0.l = lo(IMASK);
+	r0 = 0x0;
+	[p0] = r0;
+
+	/* Clear the ILAT register */
+	p0.h = hi(ILAT);
+	p0.l = lo(ILAT);
+	r0 = [p0];
+	[p0] = r0;
+	SSYNC;
+
+	/* Disable the WDOG TIMER */
+	p0.h = hi(WDOG_CTL);
+	p0.l = lo(WDOG_CTL);
+	r0.l = 0xAD6;
+	w[p0] = r0.l;
+	SSYNC;
+
+	/* Clear the sticky bit incase it is already set */
+	p0.h = hi(WDOG_CTL);
+	p0.l = lo(WDOG_CTL);
+	r0.l = 0x8AD6;
+	w[p0] = r0.l;
+	SSYNC;
+
+	/* Program the count value */
+	R0.l = 0x100;
+	R0.h = 0x0;
+	P0.h = hi(WDOG_CNT);
+	P0.l = lo(WDOG_CNT);
+	[P0] = R0;
+	SSYNC;
+
+	/* Program WDOG_STAT if necessary */
+	P0.h = hi(WDOG_CTL);
+	P0.l = lo(WDOG_CTL);
+	R0 = W[P0](Z);
+	CC = BITTST(R0,1);
+	if !CC JUMP WRITESTAT;
+	CC = BITTST(R0,2);
+	if !CC JUMP WRITESTAT;
+	JUMP SKIP_WRITE;
+
+WRITESTAT:
+	/* When watch dog timer is enabled, a write to STAT will load the contents of CNT to STAT */
+	R0 = 0x0000(z);
+	P0.h = hi(WDOG_STAT);
+	P0.l = lo(WDOG_STAT)
+	[P0] = R0;
+	SSYNC;
+
+SKIP_WRITE:
+	/* Enable the reset event */
+	P0.h = hi(WDOG_CTL);
+        P0.l = lo(WDOG_CTL);
+        R0 = W[P0](Z);
+        BITCLR(R0,1);
+        BITCLR(R0,2);
+        W[P0] = R0.L;
+        SSYNC;
+        NOP;
+
+	/* Enable the wdog counter */
+        R0 = W[P0](Z);
+        BITCLR(R0,4);
+        W[P0] = R0.L;
+        SSYNC;
+
+	IDLE;
+
+	RTS;
+
+.data
+
+/*
+ *      Set up the usable of RAM stuff. Size of RAM is determined then
+ *      an initial stack set up at the end.
+ */
+
+.align 4
+__rambase:
+.long   0
+__ramstart:
+.long   0
+__ramend:
+.long   0
Index: git/linux-2.6/arch/blackfin/mach-bf537/ints-priority.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf537/ints-priority.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,80 @@
+/*
+ * File:         arch/blackfin/mach-bf537/ints-priority.c
+ * Based on:     arch/blackfin/mach-bf533/ints-priority.c
+ * Author:       Michael Hennerich
+ *               COPYRIGHT 2005 Analog Devices
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:         $Id$
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/module.h>
+#include <asm/blackfin.h>
+#include <asm/irq.h>
+
+void program_IAR(void);
+/*Program the IAR registers*/
+
+void program_IAR()
+{
+	/* Program the IAR0 Register with the configured priority */
+	*pSIC_IAR0 = ((CONFIG_IRQ_PLL_WAKEUP - 7) << IRQ_PLL_WAKEUP_POS) |
+	    ((CONFIG_IRQ_DMA_ERROR - 7) << IRQ_DMA_ERROR_POS) |
+	    ((CONFIG_IRQ_ERROR - 7) << IRQ_ERROR_POS) |
+	    ((CONFIG_IRQ_RTC - 7) << IRQ_RTC_POS) |
+	    ((CONFIG_IRQ_PPI - 7) << IRQ_PPI_POS) |
+	    ((CONFIG_IRQ_SPORT0_RX - 7) << IRQ_SPORT0_RX_POS) |
+	    ((CONFIG_IRQ_SPORT0_TX - 7) << IRQ_SPORT0_TX_POS) |
+	    ((CONFIG_IRQ_SPORT1_RX - 7) << IRQ_SPORT1_RX_POS);
+
+	*pSIC_IAR1 = ((CONFIG_IRQ_SPORT1_TX - 7) << IRQ_SPORT1_TX_POS) |
+	    ((CONFIG_IRQ_TWI - 7) << IRQ_TWI_POS) |
+	    ((CONFIG_IRQ_SPI - 7) << IRQ_SPI_POS) |
+	    ((CONFIG_IRQ_UART0_RX - 7) << IRQ_UART0_RX_POS) |
+	    ((CONFIG_IRQ_UART0_TX - 7) << IRQ_UART0_TX_POS) |
+	    ((CONFIG_IRQ_UART1_RX - 7) << IRQ_UART1_RX_POS) |
+	    ((CONFIG_IRQ_UART1_TX - 7) << IRQ_UART1_TX_POS) |
+	    ((CONFIG_IRQ_CAN_RX - 7) << IRQ_CAN_RX_POS);
+
+	*pSIC_IAR2 = ((CONFIG_IRQ_CAN_TX - 7) << IRQ_CAN_TX_POS) |
+	    ((CONFIG_IRQ_MAC_RX - 7) << IRQ_MAC_RX_POS) |
+	    ((CONFIG_IRQ_MAC_TX - 7) << IRQ_MAC_TX_POS) |
+	    ((CONFIG_IRQ_TMR0 - 7) << IRQ_TMR0_POS) |
+	    ((CONFIG_IRQ_TMR1 - 7) << IRQ_TMR1_POS) |
+	    ((CONFIG_IRQ_TMR2 - 7) << IRQ_TMR2_POS) |
+	    ((CONFIG_IRQ_TMR3 - 7) << IRQ_TMR3_POS) |
+	    ((CONFIG_IRQ_TMR4 - 7) << IRQ_TMR4_POS);
+
+	*pSIC_IAR3 = ((CONFIG_IRQ_TMR5 - 7) << IRQ_TMR5_POS) |
+	    ((CONFIG_IRQ_TMR6 - 7) << IRQ_TMR6_POS) |
+	    ((CONFIG_IRQ_TMR7 - 7) << IRQ_TMR7_POS) |
+	    ((CONFIG_IRQ_PROG_INTA - 7) << IRQ_PROG_INTA_POS) |
+	    ((CONFIG_IRQ_PROG_INTB - 7) << IRQ_PROG_INTB_POS) |
+	    ((CONFIG_IRQ_MEM_DMA0 - 7) << IRQ_MEM_DMA0_POS) |
+	    ((CONFIG_IRQ_MEM_DMA1 - 7) << IRQ_MEM_DMA1_POS) |
+	    ((CONFIG_IRQ_WATCH - 7) << IRQ_WATCH_POS);
+	__builtin_bfin_ssync();
+
+}				/*End of program_IAR */
Index: git/linux-2.6/arch/blackfin/mach-bf537/pm.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf537/pm.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,157 @@
+/*
+ * File:        arch/blackfin/mach-bf537/pm.c
+ * Based on:    arm/mach-omap/pm.c
+ * Author:      Cliff Brake <cbrake@accelent.com>
+ *              Copyright (c) 2001
+ * Created:     2001
+ * Description: Power management for the bf537
+ *
+ * Rev:         $Id$
+ *
+ * Modified:    Nicolas Pitre - PXA250 support
+ *                Copyright (c) 2002 Monta Vista Software, Inc.
+ *              David Singleton - OMAP1510
+ *                Copyright (c) 2002 Monta Vista Software, Inc.
+ *              Dirk Behme <dirk.behme@de.bosch.com> - OMAP1510/1610
+ *                Copyright 2004
+ *              Michael.Kang@analog.com - Blackfin support
+ * Maintained:  Michael.Kang@analog.com
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/pm.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+
+#include <asm/io.h>
+
+/*
+ * Let's power down on idle, but only if we are really
+ * idle, because once we start down the path of
+ * going idle we continue to do idle even if we get
+ * a clock tick interrupt . .
+ */
+void bf537_pm_idle(void)
+{
+}
+
+/*
+ * when we call pm_suspend, that code  enters into idle state and sdram enter self-refresh mode
+ *  to save more energy.When there is any interrupt,the core will resume
+ */
+void bf537_pm_suspend(void)
+{
+	/*sdram enter self-refresh mode*/
+	 *pEBIU_SDGCTL = (*pEBIU_SDGCTL |SRFS);
+        __builtin_bfin_ssync();
+	/*any interrupt can cause CPU exit idle state*/
+        *pSIC_IWR = 0x00ffffff;
+        __builtin_bfin_ssync();
+        __asm__ (
+        "CLI R2;\n\t"
+        "SSYNC;\n\t"
+        "IDLE;\n\t"
+        "STI R2;\n\t"
+        );
+        /*sdram exit self-refresh mode*/
+        *pEBIU_SDGCTL = (*pEBIU_SDGCTL |SRFS);
+        __builtin_bfin_ssync();
+
+}
+
+/*
+ *	bf537_pm_prepare - Do preliminary suspend work.
+ *	@state:		suspend state we're entering.
+ *
+ */
+
+static int bf537_pm_prepare(suspend_state_t state)
+{
+	int error = 0;
+
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+		break;
+	case PM_SUSPEND_MEM:
+		return -ENOTSUPP;
+
+	case PM_SUSPEND_DISK:
+		return -ENOTSUPP;
+
+	default:
+		return -EINVAL;
+	}
+
+	return error;
+}
+
+/*
+ *	bf537_pm_enter - Actually enter a sleep state.
+ *	@state:		State we're entering.
+ *
+ */
+
+static int bf537_pm_enter(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+		return -ENOTSUPP;
+
+	case PM_SUSPEND_MEM:
+		bf537_pm_suspend();
+		break;
+
+	case PM_SUSPEND_DISK:
+		return -ENOTSUPP;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
+ *	bf537_pm_finish - Finish up suspend sequence.
+ *	@state:		State we're coming out of.
+ *
+ *	This is called after we wake back up (or if entering the sleep state
+ *	failed).
+ */
+
+static int bf537_pm_finish(suspend_state_t state)
+{
+	return 0;
+}
+
+struct pm_ops bf537_pm_ops = {
+	.pm_disk_mode = PM_DISK_FIRMWARE,
+	.prepare = bf537_pm_prepare,
+	.enter = bf537_pm_enter,
+	.finish = bf537_pm_finish,
+};
+
+static int __init bf537_pm_init(void)
+{
+
+	pm_set_ops(&bf537_pm_ops);
+	return 0;
+}
+
+__initcall(bf537_pm_init);
Index: git/linux-2.6/arch/blackfin/mach-bf561/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf561/Kconfig	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,224 @@
+if BF561
+
+menu "BF561 Specific Configuration"
+
+comment	'Core B Support'
+
+menu	'Core B Support'
+
+config	BF561_COREB
+	bool "Enable Core B support    "
+	default y
+
+config	BF561_COREB_RESET
+	bool "Enable Core B reset support"
+	default n
+	help
+	  This requires code in the application that is loaded
+	  into Core B. In order to reset, the application needs
+	  to install an interrupt handler for Supplemental
+	  Interrupt 0, that sets RETI to 0xff600000 and writes
+	  bit 11 of SICB_SYSCR when bit 5 of SICA_SYSCR is 0.
+	  This causes Core B to stall when Supplemental Interrupt
+	  0 is set, and will reset PC to 0xff600000 when
+	  COREB_SRAM_INIT is cleared.
+
+endmenu
+
+comment	'Interrupt Priority Assignment'
+
+menu	'Priority'
+
+config  IRQ_PLL_WAKEUP
+	int "PLL Wakeup Interrupt      "
+	default 7
+config  IRQ_DMA1_ERROR
+	int "DMA1 Error (generic)      "
+	default 7
+config  IRQ_DMA2_ERROR
+	int "DMA2 Error (generic)      "
+	default 7
+config  IRQ_IMDMA_ERROR
+	int "IMDMA Error (generic)     "
+	default 7
+config  IRQ_PPI0_ERROR
+	int "PPI0 Error Interrupt      "
+	default 7
+config  IRQ_PPI1_ERROR
+	int "PPI1 Error Interrupt      "
+	default 7
+config  IRQ_SPORT0_ERROR
+	int "SPORT0 Error Interrupt    "
+	default 7
+config  IRQ_SPORT1_ERROR
+	int "SPORT1 Error Interrupt    "
+	default 7
+config  IRQ_SPI_ERROR
+	int "SPI Error Interrupt       "
+	default 7
+config  IRQ_UART_ERROR
+	int "UART Error Interrupt      "
+	default 7
+config  IRQ_RESERVED_ERROR
+	int "Reserved Interrupt	       "
+	default 7
+config  IRQ_DMA1_0
+	int "DMA1 0  Interrupt(PPI1)   "
+	default 8
+config  IRQ_DMA1_1
+	int "DMA1 1  Interrupt(PPI2)   "
+	default 8
+config  IRQ_DMA1_2
+	int "DMA1 2  Interrupt	       "
+	default 8
+config  IRQ_DMA1_3
+	int "DMA1 3  Interrupt	       "
+	default 8
+config  IRQ_DMA1_4
+	int "DMA1 4  Interrupt	       "
+	default 8
+config  IRQ_DMA1_5
+	int "DMA1 5  Interrupt	       "
+	default 8
+config  IRQ_DMA1_6
+	int "DMA1 6  Interrupt	       "
+	default 8
+config  IRQ_DMA1_7
+	int "DMA1 7  Interrupt	       "
+	default 8
+config  IRQ_DMA1_8
+	int "DMA1 8  Interrupt	       "
+	default 8
+config  IRQ_DMA1_9
+	int "DMA1 9  Interrupt	       "
+	default 8
+config  IRQ_DMA1_10
+	int "DMA1 10 Interrupt	       "
+	default 8
+config  IRQ_DMA1_11
+	int "DMA1 11 Interrupt	       "
+	default 8
+config  IRQ_DMA2_0
+	int "DMA2 0  (SPORT0 RX)       "
+	default 9
+config  IRQ_DMA2_1
+	int "DMA2 1  (SPORT0 TX)       "
+	default 9
+config  IRQ_DMA2_2
+	int "DMA2 2  (SPORT1 RX)       "
+	default 9
+config  IRQ_DMA2_3
+	int "DMA2 3  (SPORT2 TX)       "
+	default 9
+config  IRQ_DMA2_4
+	int "DMA2 4  (SPI)	       "
+	default 9
+config  IRQ_DMA2_5
+	int "DMA2 5  (UART RX)	       "
+	default 9
+config  IRQ_DMA2_6
+	int "DMA2 6  (UART TX)	       "
+	default 9
+config  IRQ_DMA2_7
+	int "DMA2 7  Interrupt	       "
+	default 9
+config  IRQ_DMA2_8
+	int "DMA2 8  Interrupt	       "
+	default 9
+config  IRQ_DMA2_9
+	int "DMA2 9  Interrupt	       "
+	default 9
+config  IRQ_DMA2_10
+	int "DMA2 10 Interrupt	       "
+	default 9
+config  IRQ_DMA2_11
+	int "DMA2 11 Interrupt	       "
+	default 9
+config  IRQ_TIMER0
+	int "TIMER 0  Interrupt	       "
+	default 10
+config  IRQ_TIMER1
+	int "TIMER 1  Interrupt	       "
+	default 10
+config  IRQ_TIMER2
+	int "TIMER 2  Interrupt	       "
+	default 10
+config  IRQ_TIMER3
+	int "TIMER 3  Interrupt	       "
+	default 10
+config  IRQ_TIMER4
+	int "TIMER 4  Interrupt	       "
+	default 10
+config  IRQ_TIMER5
+	int "TIMER 5  Interrupt	       "
+	default 10
+config  IRQ_TIMER6
+	int "TIMER 6  Interrupt	       "
+	default 10
+config  IRQ_TIMER7
+	int "TIMER 7  Interrupt	       "
+	default 10
+config  IRQ_TIMER8
+	int "TIMER 8  Interrupt	       "
+	default 10
+config  IRQ_TIMER9
+	int "TIMER 9  Interrupt	       "
+	default 10
+config  IRQ_TIMER10
+	int "TIMER 10 Interrupt	       "
+	default 10
+config  IRQ_TIMER11
+	int "TIMER 11 Interrupt	       "
+	default 10
+config  IRQ_PROG0_INTA
+	int "Programmable Flags0 A (8) "
+	default 11
+config  IRQ_PROG0_INTB
+	int "Programmable Flags0 B (8) "
+	default 11
+config  IRQ_PROG1_INTA
+	int "Programmable Flags1 A (8) "
+	default 11
+config  IRQ_PROG1_INTB
+	int "Programmable Flags1 B (8) "
+	default 11
+config  IRQ_PROG2_INTA
+	int "Programmable Flags2 A (8) "
+	default 11
+config  IRQ_PROG2_INTB
+	int "Programmable Flags2 B (8) "
+	default 11
+config  IRQ_DMA1_WRRD0
+	int "MDMA1 0 write/read INT    "
+	default 8
+config  IRQ_DMA1_WRRD1
+	int "MDMA1 1 write/read INT    "
+	default 8
+config  IRQ_DMA2_WRRD0
+	int "MDMA2 0 write/read INT    "
+	default 9
+config  IRQ_DMA2_WRRD1
+	int "MDMA2 1 write/read INT    "
+	default 9
+config  IRQ_IMDMA_WRRD0
+	int "IMDMA 0 write/read INT    "
+	default 12
+config  IRQ_IMDMA_WRRD1
+	int "IMDMA 1 write/read INT    "
+	default 12
+config  IRQ_WDTIMER
+	int "Watch Dog Timer	       "
+	default 13
+
+	help
+	------------------------- GENERAL HELP -------------------------
+
+	Enter the priority numbers between 7-13 ONLY. Others are Reserved.
+ 	This applies to all the above.It is not recommended to assign the
+	highest priority no 7 to UART or any other device.
+
+endmenu
+
+endmenu
+
+endif #
Index: git/linux-2.6/arch/blackfin/mach-bf561/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf561/Makefile	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,7 @@
+#
+# Makefile for mach-bf561.
+#
+extra-y += head.o
+# Object file lists.
+obj-y:= ints-priority.o
+obj-$(CONFIG_BF561_COREB) += coreb.o
Index: git/linux-2.6/arch/blackfin/mach-bf561/boards/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf561/boards/Makefile	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,8 @@
+#
+# Makefile for mach-bf533/boards.
+#
+
+# Object file lists.
+
+obj-$(CONFIG_BFIN561_EZKIT) += ezkit.o
+obj-$(CONFIG_GENERIC_BOARD) += generic_board.o
Index: git/linux-2.6/arch/blackfin/mach-bf561/boards/ezkit.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf561/boards/ezkit.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,78 @@
+ /*
+  * File:         arch/blackfin/mach-bf561/ezkit.c
+  * Based on:
+  * Author:
+  *
+  * Created:
+  * Description:
+  *
+  * Rev:         $Id$
+  *
+  * Modified:
+  *
+  *
+  * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.
+  * If not, write to the Free Software Foundation,
+  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+  */
+
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <asm/irq.h>
+
+/*
+ *  USB-LAN EzExtender board
+ *  Driver needs to know address, irq and flag pin.
+ */
+static struct resource smc91x_resources[] = {
+	[0] = {
+	       .start = 0x2C010300,
+	       .end = 0x2C010300 + 16,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_PROG0_INTB,
+	       .end = IRQ_PROG0_INTB,
+	       .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	       },
+	[2] = {
+	       /*
+	        *  denotes the flag pin and is used directly if
+	        *  CONFIG_IRQCHIP_DEMUX_GPIO is defined.
+	        */
+	       .start = IRQ_PF9,
+	       .end = IRQ_PF9,
+	       .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	       },
+};
+static struct platform_device smc91x_device = {
+	.name = "smc91x",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(smc91x_resources),
+	.resource = smc91x_resources,
+};
+
+static struct platform_device *ezkit_devices[] __initdata = {
+	&smc91x_device,
+};
+
+static int __init ezkit_init(void)
+{
+	printk("%s(): registering device resources\n", __FUNCTION__);
+	return platform_add_devices(ezkit_devices, ARRAY_SIZE(ezkit_devices));
+}
+
+arch_initcall(ezkit_init);
Index: git/linux-2.6/arch/blackfin/mach-bf561/boards/generic_board.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf561/boards/generic_board.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,77 @@
+ /*
+  * File:         arch/blackfin/mach-bf561/generic_board.c
+  * Based on:     arch/blackfin/mach-bf533/ezkit.c
+  * Author:       Aidan Williams <aidan@nicta.com.au>
+  *                 Copyright 2005 National ICT Australia (NICTA)
+  * Created:
+  * Description:
+  *
+  * Rev:         $Id$
+  *
+  * Modified:
+  *
+  *
+  * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.
+  * If not, write to the Free Software Foundation,
+  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+  */
+
+#include <linux/device.h>
+#include <asm/irq.h>
+
+/*
+ *  Driver needs to know address, irq and flag pin.
+ */
+static struct resource smc91x_resources[] = {
+	[0] = {
+	       .start = 0x2C010300,
+	       .end = 0x2C010300 + 16,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_PROG_INTB,
+	       .end = IRQ_PROG_INTB,
+	       .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	       },
+	[2] = {
+	       /*
+	        *  denotes the flag pin and is used directly if
+	        *  CONFIG_IRQCHIP_DEMUX_GPIO is defined.
+	        */
+	       .start = IRQ_PF9,
+	       .end = IRQ_PF9,
+	       .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+	       },
+};
+static struct platform_device smc91x_device = {
+	.name = "smc91x",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(smc91x_resources),
+	.resource = smc91x_resources,
+};
+
+static struct platform_device *generic_board_devices[] __initdata = {
+	&smc91x_device,
+};
+
+static int __init generic_board_init(void)
+{
+	printk("%s(): registering device resources\n", __FUNCTION__);
+	return platform_add_devices(generic_board_devices,
+				    ARRAY_SIZE(generic_board_devices));
+}
+
+arch_initcall(generic_board_init);
Index: git/linux-2.6/arch/blackfin/mach-bf561/coreb.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf561/coreb.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,377 @@
+#include <linux/config.h>
+#include <linux/mm.h>
+#include <linux/miscdevice.h>
+#include <linux/ioport.h>
+#include <linux/proc_fs.h>
+#include <linux/module.h>
+#include <asm/dma.h>
+#include <asm/uaccess.h>
+
+#define MODULE_VER		"v0.1"
+
+static spinlock_t coreb_lock = SPIN_LOCK_UNLOCKED;
+static wait_queue_head_t coreb_dma_wait;
+
+#define COREB_IS_OPEN		0x00000001
+#define COREB_IS_RUNNING	0x00000010
+
+#define CMD_COREB_INDEX		1
+#define CMD_COREB_START		2
+#define CMD_COREB_STOP		3
+#define CMD_COREB_RESET		4
+
+static unsigned long coreb_status = 0;
+static unsigned long coreb_base = 0xff600000;
+static unsigned long coreb_size = 0x4000;
+
+static loff_t coreb_lseek(struct file *file, loff_t offset, int origin);
+static ssize_t coreb_read(struct file *file, char *buf, size_t count,
+			  loff_t * ppos);
+static ssize_t coreb_write(struct file *file, const char *buf, size_t count,
+			   loff_t * ppos);
+static int coreb_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		       unsigned long arg);
+static int coreb_open(struct inode *inode, struct file *file);
+static int coreb_release(struct inode *inode, struct file *file);
+
+static irqreturn_t coreb_dma_interrupt(int irq, void *dev_id,
+				       struct pt_regs *regs)
+{
+	clear_dma_irqstat(CH_MEM_STREAM2_DEST);
+	wake_up(&coreb_dma_wait);
+	return IRQ_HANDLED;
+}
+
+static ssize_t coreb_write(struct file *file, const char *buf, size_t count,
+			   loff_t * ppos)
+{
+	unsigned long p = *ppos;
+	ssize_t wrote = 0;
+
+	if (p + count > coreb_size)
+		return -EFAULT;
+
+	while (count > 0) {
+		int len = count;
+
+		if (len > PAGE_SIZE)
+			len = PAGE_SIZE;
+
+		/* Source Channel */
+		set_dma_start_addr(CH_MEM_STREAM2_SRC, (unsigned long)buf);
+		set_dma_x_count(CH_MEM_STREAM2_SRC, len);
+		set_dma_x_modify(CH_MEM_STREAM2_SRC, sizeof(char));
+		set_dma_config(CH_MEM_STREAM2_SRC, RESTART);
+		/* Destination Channel */
+		set_dma_start_addr(CH_MEM_STREAM2_DEST, coreb_base + p);
+		set_dma_x_count(CH_MEM_STREAM2_DEST, len);
+		set_dma_x_modify(CH_MEM_STREAM2_DEST, sizeof(char));
+		set_dma_config(CH_MEM_STREAM2_DEST, WNR | RESTART | DI_EN);
+
+		enable_dma(CH_MEM_STREAM2_SRC);
+		enable_dma(CH_MEM_STREAM2_DEST);
+
+		interruptible_sleep_on(&coreb_dma_wait);
+
+		disable_dma(CH_MEM_STREAM2_SRC);
+		disable_dma(CH_MEM_STREAM2_DEST);
+
+		count -= len;
+		wrote += len;
+		buf += len;
+		p += len;
+	}
+	*ppos = p;
+	return wrote;
+}
+
+static ssize_t coreb_read(struct file *file, char *buf, size_t count,
+			  loff_t * ppos)
+{
+	unsigned long p = *ppos;
+	ssize_t read = 0;
+
+	if ((p + count) > coreb_size)
+		return -EFAULT;
+
+	while (count > 0) {
+		int len = count;
+		if (len > PAGE_SIZE)
+			len = PAGE_SIZE;
+
+		/* Source Channel */
+		set_dma_start_addr(CH_MEM_STREAM2_SRC, coreb_base + p);
+		set_dma_x_count(CH_MEM_STREAM2_SRC, len);
+		set_dma_x_modify(CH_MEM_STREAM2_SRC, sizeof(char));
+		set_dma_config(CH_MEM_STREAM2_SRC, RESTART);
+		/* Destination Channel */
+		set_dma_start_addr(CH_MEM_STREAM2_DEST, (unsigned long)buf);
+		set_dma_x_count(CH_MEM_STREAM2_DEST, len);
+		set_dma_x_modify(CH_MEM_STREAM2_DEST, sizeof(char));
+		set_dma_config(CH_MEM_STREAM2_DEST, WNR | RESTART | DI_EN);
+
+		enable_dma(CH_MEM_STREAM2_SRC);
+		enable_dma(CH_MEM_STREAM2_DEST);
+
+		interruptible_sleep_on(&coreb_dma_wait);
+
+		disable_dma(CH_MEM_STREAM2_SRC);
+		disable_dma(CH_MEM_STREAM2_DEST);
+
+		count -= len;
+		read += len;
+		buf += len;
+		p += len;
+	}
+
+	return read;
+}
+
+static loff_t coreb_lseek(struct file *file, loff_t offset, int origin)
+{
+	loff_t ret;
+
+	down(&file->f_dentry->d_inode->i_sem);
+
+	switch (origin) {
+	case 0 /* SEEK_SET */ :
+		if (offset < coreb_size) {
+			file->f_pos = offset;
+			ret = file->f_pos;
+		} else
+			ret = -EINVAL;
+		break;
+	case 1 /* SEEK_CUR */ :
+		if ((offset + file->f_pos) < coreb_size) {
+			file->f_pos += offset;
+			ret = file->f_pos;
+		} else
+			ret = -EINVAL;
+	default:
+		ret = -EINVAL;
+	}
+	up(&file->f_dentry->d_inode->i_sem);
+	return ret;
+}
+
+static int coreb_open(struct inode *inode, struct file *file)
+{
+	spin_lock_irq(&coreb_lock);
+
+	if (coreb_status & COREB_IS_OPEN)
+		goto out_busy;
+
+	coreb_status |= COREB_IS_OPEN;
+
+	spin_unlock_irq(&coreb_lock);
+	return 0;
+
+      out_busy:
+	spin_unlock_irq(&coreb_lock);
+	return -EBUSY;
+}
+
+static int coreb_release(struct inode *inode, struct file *file)
+{
+	spin_lock_irq(&coreb_lock);
+	coreb_status &= ~COREB_IS_OPEN;
+	spin_unlock_irq(&coreb_lock);
+	return 0;
+}
+
+static int coreb_ioctl(struct inode *inode, struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+	int coreb_index = 0;
+
+	spin_lock_irq(&coreb_lock);
+
+	switch (cmd) {
+	case CMD_COREB_INDEX:
+		if (copy_from_user(&coreb_index, (int *)arg, sizeof(int))) {
+			retval - -EFAULT;
+			break;
+		}
+		switch (coreb_index) {
+		case 0:
+			coreb_base = 0xff600000;
+			coreb_size = 0x4000;
+			break;
+		case 1:
+			coreb_base = 0xff610000;
+			coreb_size = 0x4000;
+			break;
+		case 2:
+			coreb_base = 0xff500000;
+			coreb_size = 0x8000;
+			break;
+		case 3:
+			coreb_base = 0xff400000;
+			coreb_size = 0x8000;
+			break;
+		default:
+			retval = -EINVAL;
+			break;
+		}
+		down(&file->f_dentry->d_inode->i_sem);
+		file->f_pos = 0;
+		up(&file->f_dentry->d_inode->i_sem);
+		break;
+	case CMD_COREB_START:
+		if (coreb_status & COREB_IS_RUNNING) {
+			retval = -EBUSY;
+			break;
+		}
+		printk(KERN_INFO "Starting Core B\n");
+		coreb_status |= COREB_IS_RUNNING;
+		*pSICA_SYSCR &= ~0x0020;
+		__builtin_bfin_ssync();
+		break;
+#if defined(CONFIG_BF561_COREB_RESET)
+	case CMD_COREB_STOP:
+		printk(KERN_INFO "Stopping Core B\n");
+		*pSICA_SYSCR |= 0x0020;
+		*pSICB_SYSCR |= 0x0080;
+		coreb_status &= ~COREB_IS_RUNNING;
+		break;
+	case CMD_COREB_RESET:
+		printk(KERN_INFO "Resetting Core B\n");
+		*pSICB_SYSCR |= 0x0080;
+		break;
+#endif
+	}
+
+	spin_unlock_irq(&coreb_lock);
+
+	return retval;
+}
+
+static struct file_operations coreb_fops = {
+      owner:THIS_MODULE,
+      llseek:coreb_lseek,
+      read:coreb_read,
+      write:coreb_write,
+      ioctl:coreb_ioctl,
+      open:coreb_open,
+      release:coreb_release
+};
+
+static struct miscdevice coreb_dev = {
+	COREB_MINOR,
+	"coreb",
+	&coreb_fops
+};
+
+static int coreb_read_status(char *page, char **start, off_t off, int count,
+			     int *eof, void *data)
+{
+	int len = 0;
+
+	if (off)
+		return 0;
+
+	len += sprintf(page,
+		       "Base Address:\t0x%08x\n"
+		       "Core B is %s\n"
+		       "SICA_SYSCR:\t%04x\n"
+		       "SICB_SYSCR:\t%04x\n"
+		       "\n"
+		       "IRQ Status:\tCore A\t\tCore B\n"
+		       "ISR0:\t\t%08lx\t\t%08lx\n"
+		       "ISR1:\t\t%08lx\t\t%08lx\n"
+		       "IMASK0:\t\t%08lx\t\t%08lx\n"
+		       "IMASK1:\t\t%08lx\t\t%08lx\n",
+		       coreb_base,
+		       coreb_status & COREB_IS_RUNNING ? "running" : "stalled",
+		       *pSICA_SYSCR, *pSICB_SYSCR,
+		       *pSICA_ISR0, *pSICB_ISR0,
+		       *pSICA_ISR1, *pSICB_ISR0,
+		       *pSICA_IMASK0, *pSICB_IMASK0,
+		       *pSICA_IMASK1, *pSICB_IMASK1);
+	return len;
+}
+
+static struct proc_dir_entry *coreb_proc_entry = NULL;
+
+int __init bf561_coreb_init(void)
+{
+	struct proc_dir_entry *proc_entry;
+	init_waitqueue_head(&coreb_dma_wait);
+
+	/* Request the core memory regions for Core B */
+	if (request_mem_region(0xff600000, 0x4000,
+			       "Core B - Instruction SRAM") == NULL)
+		goto exit;
+
+	if (request_mem_region(0xFF610000, 0x4000,
+			       "Core B - Instruction SRAM") == NULL)
+		goto release_instruction_a_sram;
+
+	if (request_mem_region(0xFF500000, 0x8000,
+			       "Core B - Data Bank B SRAM") == NULL)
+		goto release_instruction_b_sram;
+
+	if (request_mem_region(0xff400000, 0x8000,
+			       "Core B - Data Bank A SRAM") == NULL)
+		goto release_data_b_sram;
+
+	if (request_dma(CH_MEM_STREAM2_DEST, "Core B - DMA Destination") < 0)
+		goto release_data_a_sram;
+
+	if (request_dma(CH_MEM_STREAM2_SRC, "Core B - DMA Source") < 0)
+		goto release_dma_dest;
+
+	set_dma_callback(CH_MEM_STREAM2_DEST, coreb_dma_interrupt, NULL);
+
+	misc_register(&coreb_dev);
+
+	printk(KERN_INFO "Core B: Initializing /proc\n");
+	coreb_proc_entry = create_proc_entry("coreb", 0, NULL);
+	if (coreb_proc_entry) {
+		coreb_proc_entry->owner = THIS_MODULE;
+		coreb_proc_entry->read_proc = coreb_read_status;
+	} else {
+		printk(KERN_ERR "Core B: Unable to register /proc/coreb\n");
+		goto release_dma_src;
+	}
+	printk(KERN_INFO "BF561 Core B driver %s initialized.\n", MODULE_VER);
+	return 0;
+
+      release_dma_src:
+	free_dma(CH_MEM_STREAM2_SRC);
+      release_dma_dest:
+	free_dma(CH_MEM_STREAM2_DEST);
+      release_data_a_sram:
+	release_mem_region(0xff400000, 0x8000);
+      release_data_b_sram:
+	release_mem_region(0xff500000, 0x8000);
+      release_instruction_b_sram:
+	release_mem_region(0xff610000, 0x4000);
+      release_instruction_a_sram:
+	release_mem_region(0xff600000, 0x4000);
+      exit:
+	return -ENOMEM;
+}
+
+void __exit bf561_coreb_exit(void)
+{
+	remove_proc_entry("coreb/status", coreb_proc_entry);
+	remove_proc_entry("coreb", NULL);
+
+	misc_deregister(&coreb_dev);
+
+	release_mem_region(0xff610000, 0x4000);
+	release_mem_region(0xff600000, 0x4000);
+	release_mem_region(0xff500000, 0x8000);
+	release_mem_region(0xff400000, 0x8000);
+
+	free_dma(CH_MEM_STREAM2_DEST);
+	free_dma(CH_MEM_STREAM2_SRC);
+}
+
+module_init(bf561_coreb_init);
+module_exit(bf561_coreb_exit);
+
+MODULE_AUTHOR("Bas Vermeulen <bvermeul@blackstar.xs4all.nl>");
+MODULE_DESCRIPTION("BF561 Core B Support");
Index: git/linux-2.6/arch/blackfin/mach-bf561/head.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf561/head.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,506 @@
+ /*
+ * File:         arch/blackfin/mach-bf533/head.S
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description: bf533 startup file
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/linkage.h>
+#include <asm/blackfin.h>
+#if CONFIG_BFIN_KERNEL_CLOCK
+#include <asm/mach/mem_init.h>
+#endif
+
+.global __rambase
+.global __ramstart
+.global __ramend
+.extern __ebss
+.extern _bf53x_relocate_l1_mem
+
+#define INITIAL_STACK	0xFFB01000
+
+.text
+
+ENTRY(__start)
+ENTRY(__stext)
+/*  R0: argument of command line string, passed from uboot, save it */
+	R7 = R0;
+	/* Set the SYSCFG register */
+	R0 = 0x36;
+	SYSCFG = R0; 		/*Enable Cycle Counter and Nesting Of Interrupts(3rd Bit)*/
+	R0 = 0;
+
+/*Clear Out All the data and pointer  Registers*/
+	R1 = R0;
+	R2 = R0;
+	R3 = R0;
+	R4 = R0;
+	R5 = R0;
+	R6 = R0;
+
+	P0 = R0;
+	P1 = R0;
+	P2 = R0;
+	P3 = R0;
+	P4 = R0;
+	P5 = R0;
+
+	LC0 = r0;
+	LC1 = r0;
+	L0 = r0;
+	L1 = r0;
+	L2 = r0;
+	L3 = r0;
+
+/*Clear Out All the DAG Registers*/
+	B0 = r0;
+	B1 = r0;
+	B2 = r0;
+	B3 = r0;
+
+	I0 = r0;
+	I1 = r0;
+	I2 = r0;
+	I3 = r0;
+
+	M0 = r0;
+	M1 = r0;
+	M2 = r0;
+	M3 = r0;
+
+/* Turn off the icache */
+	p0.l = (IMEM_CONTROL & 0xFFFF);
+	p0.h = (IMEM_CONTROL >> 16);
+	R1 = [p0];
+	R0 = ~ENICPLB;
+	R0 = R0 & R1;
+
+	/* Anamoly 05000125 */
+	CLI R2;
+	SSYNC;
+	[p0] = R0;
+	SSYNC;
+	STI R2;
+
+    /* Turn off the dcache */
+    p0.l = (DMEM_CONTROL & 0xFFFF);
+    p0.h = (DMEM_CONTROL >> 16);
+    R1 = [p0];
+    R0 = ~ENDCPLB;
+    R0 = R0 & R1;
+
+    /* Anamoly 05000125 */
+    CLI R2;
+    SSYNC;
+    [p0] = R0;
+    SSYNC;
+    STI R2;
+
+/*Initialise UART*/
+	p0.h = hi(UART_LCR);
+	p0.l = lo(UART_LCR);
+	r0 = 0x0(Z);
+	w[p0] = r0.L;	/* To enable DLL writes */
+	ssync;
+
+	p0.h = hi(UART_DLL);
+	p0.l = lo(UART_DLL);
+	r0 = 0x0(Z);
+	w[p0] = r0.L;
+	ssync;
+
+	p0.h = hi(UART_DLH);
+	p0.l = lo(UART_DLH);
+	r0 = 0x00(Z);
+	w[p0] = r0.L;
+	ssync;
+
+	p0.h = hi(UART_GCTL);
+	p0.l = lo(UART_GCTL);
+	r0 = 0x0(Z);
+	w[p0] = r0.L;	/* To enable UART clock */
+	ssync;
+
+	/* Initialize stack pointer */
+	sp.l = lo(INITIAL_STACK);
+        sp.h = hi(INITIAL_STACK);
+        fp = sp;
+        usp = sp;
+
+	/*Put The Code for PLL Programming and SDRAM Programming in L1 ISRAM*/
+	call _bf53x_relocate_l1_mem;
+#if CONFIG_BFIN_KERNEL_CLOCK
+	call start_dma_code;
+#endif
+
+	/* Code for initializing Async memory banks */
+
+        p2.h = hi(EBIU_AMBCTL1);
+        p2.l = lo(EBIU_AMBCTL1);
+        r0.h = hi(AMBCTL1VAL);
+        r0.l = lo(AMBCTL1VAL);
+        [p2] = r0;
+        ssync;
+
+        p2.h = hi(EBIU_AMBCTL0);
+        p2.l = lo(EBIU_AMBCTL0);
+        r0.h = hi(AMBCTL0VAL);
+        r0.l = lo(AMBCTL0VAL);
+        [p2] = r0;
+        ssync;
+
+        p2.h = hi(EBIU_AMGCTL);
+        p2.l = lo(EBIU_AMGCTL);
+        r0 = AMGCTLVAL;
+        w[p2] = r0;
+        ssync;
+
+	/* This section keeps the processor in supervisor mode
+         * during kernel boot.  Switches to user mode at end of boot.
+	 * See page 3-9 of Hardware Reference manual for documentation.
+	 */
+
+	/* EVT15 = _real_start */
+
+	p0.l = lo(EVT15);
+	p0.h = hi(EVT15);
+	p1.l = _real_start;
+	p1.h = _real_start;
+	[p0] = p1;
+	csync;
+
+	p0.l = lo(IMASK);
+	p0.h = hi(IMASK);
+	p1.l = IMASK_IVG15;
+	p1.h = 0x0;
+	[p0] = p1;
+	csync;
+
+	raise 15;
+	p0.l = WAIT_HERE;
+	p0.h = WAIT_HERE;
+	reti = p0;
+	rti;
+
+WAIT_HERE:
+	jump WAIT_HERE;
+
+ENTRY(_real_start)
+	[ -- sp ] = reti;
+	p0.l = lo(WDOGA_CTL);
+	p0.h = hi(WDOGA_CTL);
+	r0 = 0xAD6(z);
+	w[p0] = r0;	/* watchdog off for now */
+	ssync;
+
+	/* Code update for BSS size == 0
+	 * Zero out the bss region.
+	 */
+
+	p1.l = __sbss;
+	p1.h = __sbss;
+	p2.l = __ebss;
+	p2.h = __ebss;
+	r0 = 0;
+	p2 -= p1;
+	lsetup (_clear_bss, _clear_bss ) lc0 = p2;
+_clear_bss:
+	B[p1++] = r0;
+
+	/* In case there is a NULL pointer reference
+	 * Zero out region before stext
+	 */
+
+	p1.l = 0x0;
+	p1.h = 0x0;
+	r0.l = __stext;
+	r0.h = __stext;
+	r0 = r0 >> 1;
+	p2 = r0;
+	r0 = 0;
+	lsetup (_clear_zero, _clear_zero ) lc0 = p2;
+_clear_zero:
+	W[p1++] = r0;
+
+/* pass the uboot arguments to the global value command line */
+	R0 = R7;
+	call _cmdline_init;
+
+	p1.l = __rambase;
+	p1.h = __rambase;
+	r0.l = __sdata;
+	r0.h = __sdata;
+	[p1] = r0;
+
+	p1.l = __ramstart;
+	p1.h = __ramstart;
+	p3.l = __ebss;
+	p3.h = __ebss;
+
+	r1 = p3;
+	[p1] = r1;
+
+	r0.l = lo(RAM_END);
+	r0.h = hi(RAM_END);
+	p1.l = __ramend;
+	p1.h = __ramend;
+	[p1] = r0;
+
+	/*
+	 *  load the current thread pointer and stack
+	 */
+	r1.l = _init_thread_union;
+	r1.h = _init_thread_union;
+
+	r2.l = 0x2000;
+	r2.h = 0x0000;
+	r1 = r1 + r2;
+	sp = r1;
+	usp = sp;
+	fp = sp;
+	call _start_kernel;
+_exit:
+	jump.s	_exit;
+
+.section .text.l1
+ENTRY(start_dma_code)
+#if CONFIG_BFIN_KERNEL_CLOCK
+	p0.h = hi(SICA_IWR0);
+	p0.l = lo(SICA_IWR0);
+	r0.l = 0x1;
+	[p0] = r0;
+	SSYNC;
+
+	/*
+         *  Set PLL_CTL
+         *   - [14:09] = MSEL[5:0] : CLKIN / VCO multiplication factors
+         *   - [8]     = BYPASS    : BYPASS the PLL, run CLKIN into CCLK/SCLK
+         *   - [7]     = output delay (add 200ps of delay to mem signals)
+         *   - [6]     = input delay (add 200ps of input delay to mem signals)
+         *   - [5]     = PDWN      : 1=All Clocks off
+         *   - [3]     = STOPCK    : 1=Core Clock off
+         *   - [1]     = PLL_OFF   : 1=Disable Power to PLL
+         *   - [0]     = DF        : 1=Pass CLKIN/2 to PLL / 0=Pass CLKIN to PLL
+         *   all other bits set to zero
+         */
+
+	p0.h = hi(PLL_LOCKCNT);
+	p0.l = lo(PLL_LOCKCNT);
+	r0 = 0x300(Z);
+	w[p0] = r0.l;
+	ssync;
+
+        P2.H = hi(EBIU_SDGCTL);
+        P2.L = lo(EBIU_SDGCTL);
+        R0 = [P2];
+        BITSET (R0, 24);
+        [P2] = R0;
+        SSYNC;
+
+        r0 = CONFIG_VCO_MULT & 63; /* Load the VCO multiplier         */
+        r0 = r0 << 9;                   /* Shift it over,                  */
+        r1 = CLKIN_HALF;        /* Do we need to divide CLKIN by 2?*/
+        r0 = r1 | r0;
+        r1 = PLL_BYPASS;         /* Bypass the PLL?                 */
+        r1 = r1 << 8;                   /* Shift it over                   */
+        r0 = r1 | r0;                   /* add them all together           */
+
+        p0.h = hi(PLL_CTL);
+        p0.l = lo(PLL_CTL);      /* Load the address                */
+        cli r2;                         /* Disable interrupts              */
+	ssync;
+        w[p0] = r0.l;                     /* Set the value                   */
+        idle;                           /* Wait for the PLL to stablize    */
+        sti r2;                         /* Enable interrupts               */
+
+check_again:
+	p0.h = hi(PLL_STAT);
+	p0.l = lo(PLL_STAT);
+	R0 = W[P0](Z);
+	CC = BITTST(R0,5);
+	if ! CC jump check_again;
+
+	/* Configure SCLK & CCLK Dividers */
+       	r0 = (CONFIG_CCLK_ACT_DIV | CONFIG_SCLK_DIV);
+        p0.h = hi(PLL_DIV);
+        p0.l = lo(PLL_DIV);
+        w[p0] = r0.l;
+        ssync;
+
+	p0.l = lo(EBIU_SDRRC);
+        p0.h = hi(EBIU_SDRRC);
+        r0 = mem_SDRRC;
+        w[p0] = r0.l;
+        ssync;
+
+        p0.l = (EBIU_SDBCTL & 0xFFFF);
+        p0.h = (EBIU_SDBCTL >> 16);     /* SDRAM Memory Bank Control Register */
+        r0 = mem_SDBCTL;
+        w[p0] = r0.l;
+        ssync;
+
+	P2.H = hi(EBIU_SDGCTL);
+        P2.L = lo(EBIU_SDGCTL);
+        R0 = [P2];
+        BITCLR (R0, 24);
+	p0.h = hi(EBIU_SDSTAT);
+	p0.l = lo(EBIU_SDSTAT);
+	r2.l = w[p0];
+	cc = bittst(r2,3);
+	if !cc jump skip;
+    NOP;
+	BITSET (R0, 23);
+skip:
+	[P2] = R0;
+        SSYNC;
+
+        R0.L = lo(mem_SDGCTL);
+        R0.H = hi(mem_SDGCTL);
+	R1 = [p2];
+	R1 = R1 | R0;
+	[P2] = R1;
+        SSYNC;
+
+	RTS;
+#endif /* CONFIG_BFIN_KERNEL_CLOCK */
+
+ENTRY(_reset)
+	/* No more interrupts to be handled*/
+	CLI R6;
+	SSYNC;
+
+#if defined(CONFIG_BFIN_SHARED_FLASH_ENET)
+	p0.h = hi(FIO_INEN);
+	p0.l = lo(FIO_INEN);
+	r0.l = ~(PF1 | PF0);
+	w[p0] = r0.l;
+
+	p0.h = hi(FIO_DIR);
+	p0.l = lo(FIO_DIR);
+	r0.l = (PF1 | PF0);
+	w[p0] = r0.l;
+
+	p0.h = hi(FIO_FLAG_C);
+	p0.l = lo(FIO_FLAG_C);
+	r0.l = (PF1 | PF0);
+	w[p0] = r0.l;
+#endif
+
+	/* Clear the bits 13-15 in SWRST if they werent cleared */
+	p0.h = hi(SICA_SWRST);
+	p0.l = lo(SICA_SWRST);
+	csync;
+	r0.l = w[p0];
+
+	/* Clear the IMASK register */
+	p0.h = hi(IMASK);
+	p0.l = lo(IMASK);
+	r0 = 0x0;
+	[p0] = r0;
+
+	/* Clear the ILAT register */
+	p0.h = hi(ILAT);
+	p0.l = lo(ILAT);
+	r0 = [p0];
+	[p0] = r0;
+	SSYNC;
+
+	/* Disable the WDOG TIMER */
+	p0.h = hi(WDOGA_CTL);
+	p0.l = lo(WDOGA_CTL);
+	r0.l = 0xAD6;
+	w[p0] = r0.l;
+	SSYNC;
+
+	/* Clear the sticky bit incase it is already set */
+	p0.h = hi(WDOGA_CTL);
+	p0.l = lo(WDOGA_CTL);
+	r0.l = 0x8AD6;
+	w[p0] = r0.l;
+	SSYNC;
+
+	/* Program the count value */
+	R0.l = 0x100;
+	R0.h = 0x0;
+	P0.h = hi(WDOGA_CNT);
+	P0.l = lo(WDOGA_CNT);
+	[P0] = R0;
+	SSYNC;
+
+	/* Program WDOG_STAT if necessary */
+	P0.h = hi(WDOGA_CTL);
+	P0.l = lo(WDOGA_CTL);
+	R0 = W[P0](Z);
+	CC = BITTST(R0,1);
+	if !CC JUMP WRITESTAT;
+	CC = BITTST(R0,2);
+	if !CC JUMP WRITESTAT;
+	JUMP SKIP_WRITE;
+
+WRITESTAT:
+	/* When watch dog timer is enabled, a write to STAT will load the contents of CNT to STAT */
+	R0 = 0x0000(z);
+	P0.h = hi(WDOGA_STAT);
+	P0.l = lo(WDOGA_STAT)
+	[P0] = R0;
+	SSYNC;
+
+SKIP_WRITE:
+	/* Enable the reset event */
+	P0.h = hi(WDOGA_CTL);
+        P0.l = lo(WDOGA_CTL);
+        R0 = W[P0](Z);
+        BITCLR(R0,1);
+        BITCLR(R0,2);
+        W[P0] = R0.L;
+        SSYNC;
+        NOP;
+
+	/* Enable the wdog counter */
+        R0 = W[P0](Z);
+        BITCLR(R0,4);
+        W[P0] = R0.L;
+        SSYNC;
+
+	IDLE;
+
+	RTS;
+
+.data
+
+/*
+ *      Set up the usable of RAM stuff. Size of RAM is determined then
+ *      an initial stack set up at the end.
+ */
+
+.align 4
+__rambase:
+.long   0
+__ramstart:
+.long   0
+__ramend:
+.long   0
Index: git/linux-2.6/arch/blackfin/mach-bf561/ints-priority.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-bf561/ints-priority.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,114 @@
+/*
+ * File:         arch/blackfin/mach-bf537/ints-priority.c
+ * Based on:     arch/blackfin/mach-bf533/ints-priority.c
+ * Author:       Michael Hennerich
+ *               COPYRIGHT 2005 Analog Devices
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:         $Id$
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/module.h>
+#include <asm/blackfin.h>
+#include <asm/irq.h>
+
+void program_IAR(void);
+/*Program the IAR registers*/
+
+void program_IAR()
+{
+	/* Program the IAR0 Register with the configured priority */
+	*pSICA_IAR0 = ((CONFIG_IRQ_PLL_WAKEUP - 7) << IRQ_PLL_WAKEUP_POS) |
+	    ((CONFIG_IRQ_DMA1_ERROR - 7) << IRQ_DMA1_ERROR_POS) |
+	    ((CONFIG_IRQ_DMA2_ERROR - 7) << IRQ_DMA2_ERROR_POS) |
+	    ((CONFIG_IRQ_IMDMA_ERROR - 7) << IRQ_IMDMA_ERROR_POS) |
+	    ((CONFIG_IRQ_PPI0_ERROR - 7) << IRQ_PPI0_ERROR_POS) |
+	    ((CONFIG_IRQ_PPI1_ERROR - 7) << IRQ_PPI1_ERROR_POS) |
+	    ((CONFIG_IRQ_SPORT0_ERROR - 7) << IRQ_SPORT0_ERROR_POS) |
+	    ((CONFIG_IRQ_SPORT1_ERROR - 7) << IRQ_SPORT1_ERROR_POS);
+
+	*pSICA_IAR1 = ((CONFIG_IRQ_SPI_ERROR - 7) << IRQ_SPI_ERROR_POS) |
+	    ((CONFIG_IRQ_UART_ERROR - 7) << IRQ_UART_ERROR_POS) |
+	    ((CONFIG_IRQ_RESERVED_ERROR - 7) << IRQ_RESERVED_ERROR_POS) |
+	    ((CONFIG_IRQ_DMA1_0 - 7) << IRQ_DMA1_0_POS) |
+	    ((CONFIG_IRQ_DMA1_1 - 7) << IRQ_DMA1_1_POS) |
+	    ((CONFIG_IRQ_DMA1_2 - 7) << IRQ_DMA1_2_POS) |
+	    ((CONFIG_IRQ_DMA1_3 - 7) << IRQ_DMA1_3_POS) |
+	    ((CONFIG_IRQ_DMA1_4 - 7) << IRQ_DMA1_4_POS);
+
+	*pSICA_IAR2 = ((CONFIG_IRQ_DMA1_5 - 7) << IRQ_DMA1_5_POS) |
+	    ((CONFIG_IRQ_DMA1_6 - 7) << IRQ_DMA1_6_POS) |
+	    ((CONFIG_IRQ_DMA1_7 - 7) << IRQ_DMA1_7_POS) |
+	    ((CONFIG_IRQ_DMA1_8 - 7) << IRQ_DMA1_8_POS) |
+	    ((CONFIG_IRQ_DMA1_9 - 7) << IRQ_DMA1_9_POS) |
+	    ((CONFIG_IRQ_DMA1_10 - 7) << IRQ_DMA1_10_POS) |
+	    ((CONFIG_IRQ_DMA1_11 - 7) << IRQ_DMA1_11_POS) |
+	    ((CONFIG_IRQ_DMA2_0 - 7) << IRQ_DMA2_0_POS);
+
+	*pSICA_IAR3 = ((CONFIG_IRQ_DMA2_1 - 7) << IRQ_DMA2_1_POS) |
+	    ((CONFIG_IRQ_DMA2_2 - 7) << IRQ_DMA2_2_POS) |
+	    ((CONFIG_IRQ_DMA2_3 - 7) << IRQ_DMA2_3_POS) |
+	    ((CONFIG_IRQ_DMA2_4 - 7) << IRQ_DMA2_4_POS) |
+	    ((CONFIG_IRQ_DMA2_5 - 7) << IRQ_DMA2_5_POS) |
+	    ((CONFIG_IRQ_DMA2_6 - 7) << IRQ_DMA2_6_POS) |
+	    ((CONFIG_IRQ_DMA2_7 - 7) << IRQ_DMA2_7_POS) |
+	    ((CONFIG_IRQ_DMA2_8 - 7) << IRQ_DMA2_8_POS);
+
+	*pSICA_IAR4 = ((CONFIG_IRQ_DMA2_9 - 7) << IRQ_DMA2_9_POS) |
+	    ((CONFIG_IRQ_DMA2_10 - 7) << IRQ_DMA2_10_POS) |
+	    ((CONFIG_IRQ_DMA2_11 - 7) << IRQ_DMA2_11_POS) |
+	    ((CONFIG_IRQ_TIMER0 - 7) << IRQ_TIMER0_POS) |
+	    ((CONFIG_IRQ_TIMER1 - 7) << IRQ_TIMER1_POS) |
+	    ((CONFIG_IRQ_TIMER2 - 7) << IRQ_TIMER2_POS) |
+	    ((CONFIG_IRQ_TIMER3 - 7) << IRQ_TIMER3_POS) |
+	    ((CONFIG_IRQ_TIMER4 - 7) << IRQ_TIMER4_POS);
+
+	*pSICA_IAR5 = ((CONFIG_IRQ_TIMER5 - 7) << IRQ_TIMER5_POS) |
+	    ((CONFIG_IRQ_TIMER6 - 7) << IRQ_TIMER6_POS) |
+	    ((CONFIG_IRQ_TIMER7 - 7) << IRQ_TIMER7_POS) |
+	    ((CONFIG_IRQ_TIMER8 - 7) << IRQ_TIMER8_POS) |
+	    ((CONFIG_IRQ_TIMER9 - 7) << IRQ_TIMER9_POS) |
+	    ((CONFIG_IRQ_TIMER10 - 7) << IRQ_TIMER10_POS) |
+	    ((CONFIG_IRQ_TIMER11 - 7) << IRQ_TIMER11_POS) |
+	    ((CONFIG_IRQ_PROG0_INTA - 7) << IRQ_PROG0_INTA_POS);
+
+	*pSICA_IAR6 = ((CONFIG_IRQ_PROG0_INTB - 7) << IRQ_PROG0_INTB_POS) |
+	    ((CONFIG_IRQ_PROG1_INTA - 7) << IRQ_PROG1_INTA_POS) |
+	    ((CONFIG_IRQ_PROG1_INTB - 7) << IRQ_PROG1_INTB_POS) |
+	    ((CONFIG_IRQ_PROG2_INTA - 7) << IRQ_PROG2_INTA_POS) |
+	    ((CONFIG_IRQ_PROG2_INTB - 7) << IRQ_PROG2_INTB_POS) |
+	    ((CONFIG_IRQ_DMA1_WRRD0 - 7) << IRQ_DMA1_WRRD0_POS) |
+	    ((CONFIG_IRQ_DMA1_WRRD1 - 7) << IRQ_DMA1_WRRD1_POS) |
+	    ((CONFIG_IRQ_DMA2_WRRD0 - 7) << IRQ_DMA2_WRRD0_POS);
+
+	*pSICA_IAR7 = ((CONFIG_IRQ_DMA2_WRRD1 - 7) << IRQ_DMA2_WRRD1_POS) |
+	    ((CONFIG_IRQ_IMDMA_WRRD0 - 7) << IRQ_IMDMA_WRRD0_POS) |
+	    ((CONFIG_IRQ_IMDMA_WRRD1 - 7) << IRQ_IMDMA_WRRD1_POS) |
+	    ((CONFIG_IRQ_WDTIMER - 7) << IRQ_WDTIMER_POS) |
+	    (0 << IRQ_RESERVED_1_POS) | (0 << IRQ_RESERVED_2_POS) |
+	    (0 << IRQ_SUPPLE_0_POS) | (0 << IRQ_SUPPLE_1_POS);
+	__builtin_bfin_ssync();
+
+}				/*End of program_IAR */
Index: git/linux-2.6/arch/blackfin/mach-common/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-common/Makefile	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,16 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+obj-y		+= cache.o cacheinit.o cplbhdlr.o cplbmgr.o entry.o \
+			flush.o interrupt.o lock.o dpmc.o irqpanic.o
+
+# Object files - Kernel configuration dependend features
+obj-$(CONFIG_CPLB_INFO)		+= cplbinfo.o
+
+# Object files - Machine dependend
+obj-$(CONFIG_BFIN_HAVE_RTC)     += bf5xx_rtc.o
+obj-$(CONFIG_BFIN_SINGLE_CORE)	+= ints-priority-sc.o
+obj-$(CONFIG_BFIN_DUAL_CORE)	+= ints-priority-dc.o
+
Index: git/linux-2.6/arch/blackfin/mach-common/bf5xx_rtc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-common/bf5xx_rtc.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,140 @@
+ /*
+  * File:        arch/blackfin/mach-common/bf5xx_rtc.c
+  * Based on:
+  * Author:      unknown
+  *              COPYRIGHT 2005 Analog Devices
+  * Created:     ?
+  * Description: real time clock support
+  *
+  * Rev:          $Id$
+  *
+  * Modified:
+  *
+  *
+  * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.
+  * If not, write to the Free Software Foundation,
+  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+  */
+
+#include <asm/blackfin.h>
+#include <asm/bf5xx_rtc.h>
+
+#define MIN_TO_SECS(_x_) (60 * _x_)
+#define HRS_TO_SECS(_x_) (60 * 60 * _x_)
+#define DAYS_TO_SECS(_x_) (24 * 60 * 60 * _x_)
+
+#define NUM_SECS_IN_DAY (24 * 3600)
+#define NUM_SECS_IN_HOUR (3600)
+#define NUM_SECS_IN_MIN (60)
+
+/* Shift values for RTC_STAT register */
+#define DAY_BITS_OFF    17
+#define HOUR_BITS_OFF   12
+#define MIN_BITS_OFF    6
+#define SEC_BITS_OFF    0
+
+static void wait_for_complete(void);
+
+/* Initialize the RTC. Enable pre-scaler to scale RTC clock to 1Hz. */
+int rtc_init()
+{
+	*(volatile unsigned short *)RTC_PREN = 0x1;
+	wait_for_complete();
+	return 0;
+}
+
+/* Set the time. time_in_secs is the number of seconds since Jan 1970 */
+int rtc_set(time_t time_in_secs)
+{
+	unsigned long n_days_1970 = 0;
+	unsigned long n_secs_rem = 0;
+	unsigned long n_hrs = 0;
+	unsigned long n_mins = 0;
+	unsigned long n_secs = 0;
+
+	/* Compute no. of days since 1970 */
+	n_days_1970 = (unsigned long)(time_in_secs / (NUM_SECS_IN_DAY));
+
+	/* From the remining secs, compute the hrs(0-23), mins(0-59)
+	 * and secs(0-59)
+	 */
+	n_secs_rem = (unsigned long)(time_in_secs % (NUM_SECS_IN_DAY));
+	n_hrs = n_secs_rem / (NUM_SECS_IN_HOUR);
+	n_secs_rem = n_secs_rem % (NUM_SECS_IN_HOUR);
+	n_mins = n_secs_rem / (NUM_SECS_IN_MIN);
+	n_secs = n_secs_rem % (NUM_SECS_IN_MIN);
+
+	/* Store the new time in the RTC_STAT register */
+	*(volatile unsigned long *)RTC_STAT =
+	    ((n_days_1970 << DAY_BITS_OFF) | (n_hrs << HOUR_BITS_OFF) |
+	     (n_mins << MIN_BITS_OFF) | (n_secs << SEC_BITS_OFF));
+
+	wait_for_complete();
+	return 0;
+}
+
+/* Read the time from the RTC_STAT.
+ * time_in_seconds is seconds since Jan 1970
+ */
+int rtc_get(time_t * time_in_seconds)
+{
+	unsigned long cur_rtc_stat = 0;
+	int tm_sec = 0, tm_min = 0, tm_hour = 0, tm_day = 0;
+
+	if (time_in_seconds == NULL) {
+		return -1;
+	}
+
+	/* Read the RTC_STAT register */
+	cur_rtc_stat = *(volatile unsigned long *)RTC_STAT;
+
+	/* Get the secs (0-59), mins (0-59), hrs (0-23) and the days
+	 * since Jan 1970
+	 */
+	tm_sec = (cur_rtc_stat >> SEC_BITS_OFF) & 0x3f;
+	tm_min = (cur_rtc_stat >> MIN_BITS_OFF) & 0x3f;
+	tm_hour = (cur_rtc_stat >> HOUR_BITS_OFF) & 0x1f;
+	tm_day = (cur_rtc_stat >> DAY_BITS_OFF) & 0x7fff;
+
+	/* Calculate the total number of seconds since Jan 1970 */
+	*(time_in_seconds) = (tm_sec) +
+	    MIN_TO_SECS(tm_min) + HRS_TO_SECS(tm_hour) + DAYS_TO_SECS(tm_day);
+
+	/* a time_t greater than "7FFF FFFF" would be treated as negative
+	 * manywhere,so we just reset it.
+	 * This will happen in following situations:
+	 *   1. No battery for RTC. The random time value will be reset to 0.
+	 *   2. On a system with battery, user sets time value to be greater
+	 *   than 7FFF FFFF.
+	 *   3. Many many years passed after user sets it!
+	 */
+	if ((unsigned long)(*(time_in_seconds)) >= 0x7FFFFFFF) {
+		*(volatile unsigned long *)RTC_STAT = 0;
+		*(time_in_seconds) = 0;
+		wait_for_complete();
+	}
+
+	return 0;
+}
+
+/* Wait for the previous write to a RTC register to complete */
+static void wait_for_complete(void)
+{
+	while (!(*(volatile unsigned short *)RTC_ISTAT & 0x8000)) {
+		/*printk(""); */
+	}
+	*(volatile unsigned short *)RTC_ISTAT = 0x8000;
+}
Index: git/linux-2.6/arch/blackfin/mach-common/cache.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-common/cache.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,255 @@
+ /*
+ * File:        arch/blackfin/mach-common/cache.S
+ * Based on:
+ * Author:      LG Soft India
+ *              COPYRIGHT 2005 Analog Devices
+ * Created:     ?
+ * Description: cache control support
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/linkage.h>
+#include <asm/cplb.h>
+#include <asm/entry.h>
+#include <asm/blackfin.h>
+#include <asm/cache.h>
+
+.text
+ .align 2
+ENTRY(_cache_invalidate)
+
+	/********************************************
+	 * Icache or DcacheA or DcacheB Invalidation
+	 * or any combination thereof
+	 * R0 has bits
+	 * CPLB_ENABLE_ICACHE_P,CPLB_ENABLE_DCACHE_P,CPLB_ENABLE_DCACHE2_P
+	 * set as required
+	 ********************************************/
+	[--SP] = R7;
+
+	R7 = R0;
+	CC = BITTST(R7,CPLB_ENABLE_ICACHE_P);
+	IF !CC JUMP no_icache;
+	[--SP] = RETS;
+	CALL _icache_invalidate;
+	RETS = [SP++];
+no_icache:
+	CC = BITTST(R7,CPLB_ENABLE_DCACHE_P);
+	IF !CC JUMP no_dcache_a;
+	R0 = 0;         /* specifies bank A */
+	[--SP] = RETS;
+	CALL _dcache_invalidate;
+	RETS = [SP++];
+no_dcache_a:
+	CC = BITTST(R7,CPLB_ENABLE_DCACHE2_P);
+	IF !CC JUMP no_dcache_b;
+	R0 = 0;
+	BITSET(R0, 23);		/* specifies bank B */
+	[--SP] = RETS;
+	CALL  _dcache_invalidate;
+	RETS = [SP++];
+no_dcache_b:
+	R7 = [SP++];
+	RTS;
+
+/* Invalidate the Entire Instruction cache by
+ * disabling IMC bit
+ */
+ENTRY(_icache_invalidate)
+ENTRY(_invalidate_entire_icache)
+	[--SP] = ( R7:5);
+
+	P0.L = (IMEM_CONTROL & 0xFFFF);
+	P0.H = (IMEM_CONTROL >> 16);
+	R7 = [P0];
+
+	/* Clear the IMC bit , All valid bits in the instruction
+	 * cache are set to the invalid state
+	 */
+	BITCLR(R7,IMC_P);
+	CLI R6;
+	SSYNC;		/* SSYNC required before invalidating cache. */
+	.align 8;
+	[P0] = R7;
+	SSYNC;
+	STI R6;
+
+	/* Configures the instruction cache agian */
+	R6 = (IMC | ENICPLB);
+	R7 = R7 | R6;
+
+	CLI R6;
+	SSYNC;		/* SSYNC required before writing to IMEM_CONTROL. */
+	.align 8;
+	[P0] = R7;
+	SSYNC;
+	STI R6;
+
+	( R7:5) = [SP++];
+	RTS;
+
+/*
+ * blackfin_cache_flush_range(start, end)
+ * Invalidate all cache lines assocoiated with this
+ * area of memory.
+ *
+ * start:	Start address
+ * end:		End address
+ */
+ENTRY(_blackfin_icache_flush_range)
+	R2 = -L1_CACHE_BYTES;
+	R2 = R0 & R2;
+	P0 = R2;
+	P1 = R1;
+	CSYNC;
+	IFLUSH [P0];
+1:
+	IFLUSH [P0++];
+	CC = P0 < P1 (iu);
+	IF CC JUMP 1b (bp);
+	IFLUSH [P0];
+	SSYNC;
+	RTS;
+
+/*
+ * blackfin_icache_dcache_flush_range(start, end)
+ * FLUSH all cache lines assocoiated with this
+ * area of memory.
+ *
+ * start:	Start address
+ * end:		End address
+ */
+
+ENTRY(_blackfin_icache_dcache_flush_range)
+	R2 = -L1_CACHE_BYTES;
+	R2 = R0 & R2;
+	P0 = R2;
+	P1 = R1;
+	CSYNC;
+	IFLUSH [P0];
+1:
+	FLUSH [P0];
+	IFLUSH [P0++];
+	CC = P0 < P1 (iu);
+	IF CC JUMP 1b (bp);
+	IFLUSH [P0];
+	FLUSH [P0];
+	SSYNC;
+	RTS;
+
+/* Throw away all D-cached data in specified region without any obligation to
+ * write them back. However, we must clean the D-cached entries around the
+ * boundaries of the start and/or end address is not cache aligned.
+ *
+ * Start: start address,
+ * end  : end address.
+ */
+
+ENTRY(_blackfin_dcache_invalidate_range)
+	R2 = -L1_CACHE_BYTES;
+	R2 = R0 & R2;
+	P0 = R2;
+	P1 = R1;
+	CSYNC;
+	FLUSHINV[P0];
+1:
+	FLUSHINV[P0++];
+	CC = P0 < P1 (iu);
+	IF CC JUMP 1b (bp);
+
+	/* If the data crosses a cache line, then we'll be pointing to
+	 * the last cache line, but won't have flushed/invalidated it yet,
+	 * so do one more.
+	 */
+	FLUSHINV[P0];
+	SSYNC;
+	RTS;
+
+/* Invalidate the Entire Data cache by
+ * clearing DMC[1:0] bits
+ */
+ENTRY(_invalidate_entire_dcache)
+ENTRY(_dcache_invalidate)
+	[--SP] = ( R7:6);
+
+	P0.L = (DMEM_CONTROL & 0xFFFF);
+	P0.H = (DMEM_CONTROL >> 16);
+	R7 = [P0];
+
+	/* Clear the DMC[1:0] bits, All valid bits in the data
+	 * cache are set to the invalid state
+	 */
+	BITCLR(R7,DMC0_P);
+	BITCLR(R7,DMC1_P);
+	CLI R6;
+	SSYNC;		/* SSYNC required before writing to DMEM_CONTROL. */
+	.align 8;
+	[P0] = R7;
+	SSYNC;
+	STI R6;
+
+	/* Configures the data cache again */
+
+	R6 = (ACACHE_BCACHE | ENDCPLB | PORT_PREF0);
+	R7 = R7 | R6;
+
+	CLI R6;
+	SSYNC;		/* SSYNC required before writing to DMEM_CONTROL. */
+	.align 8;
+	[P0] = R7;
+	SSYNC;
+	STI R6;
+
+	( R7:6) = [SP++];
+	RTS;
+
+ENTRY(_blackfin_dcache_flush_range)
+	R2 = -L1_CACHE_BYTES;
+	R2 = R0 & R2;
+	P0 = R2;
+	P1 = R1;
+	CSYNC;
+	FLUSH[P0];
+1:
+	FLUSH[P0++];
+	CC = P0 < P1 (iu);
+	IF CC JUMP 1b (bp);
+
+	/* If the data crosses a cache line, then we'll be pointing to
+	 * the last cache line, but won't have flushed it yet, so do
+	 * one more.
+	 */
+	FLUSH[P0];
+	SSYNC;
+	RTS;
+
+ENTRY(_blackfin_dflush_page)
+	P1 = 1 << (PAGE_SHIFT - L1_CACHE_SHIFT);
+	P0 = R0;
+	CSYNC;
+	FLUSH[P0];
+	LSETUP (fl1, fl1) LC0 = P1;
+fl1:	FLUSH [P0++];
+	SSYNC;
+	RTS;
Index: git/linux-2.6/arch/blackfin/mach-common/cacheinit.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-common/cacheinit.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,140 @@
+ /*
+ * File:        arch/blackfin/mach-common/cacheinit.S
+ * Based on:
+ * Author:      LG Soft India
+ *              COPYRIGHT 2005 Analog Devices
+ * Created:     ?
+ * Description: cache initialization
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* This function sets up the data and instruction cache. The
+ * tables like icplb table, dcplb table and Page Descriptor table
+ * are defined in cplbtab.h. You can configure those tables for
+ * your suitable requirements
+ */
+
+#include <linux/linkage.h>
+#include <asm/blackfin.h>
+#include <asm/cplbtab.h>
+
+.text
+
+#if defined (CONFIG_BLKFIN_CACHE)
+ENTRY(_icache_init)
+
+	/* Initialize Instruction CPLBS */
+
+	I0.L = (ICPLB_ADDR0 & 0xFFFF);
+	I0.H = (ICPLB_ADDR0 >> 16);
+
+	I1.L = (ICPLB_DATA0 & 0xFFFF);
+	I1.H = (ICPLB_DATA0 >> 16);
+
+	I2.L = _icplb_table;
+	I2.H = _icplb_table;
+
+	r1 = -1;	/* end point comparison */
+	r3 = 15;	/* max counter */
+
+/* read entries from table */
+
+read_iaddr:
+	R0 = [I2++];
+	CC = R0 == R1;
+	IF CC JUMP idone;
+	[I0++] = R0;
+
+read_idata:
+	R2 = [I2++];
+	[I1++] = R2;
+	R3 = R3 + R1;
+	CC = R3 == R1;
+	IF !CC JUMP read_iaddr;
+
+idone:
+	/* Enable Instruction Cache */
+	P0.l = (IMEM_CONTROL & 0xFFFF);
+	P0.h = (IMEM_CONTROL >> 16);
+	R1 = [P0];
+	R0 = (IMC | ENICPLB);
+	R0 = R0 | R1;
+
+	/*Anamoly 05000125 */
+	CLI R2;
+	SSYNC;		/* SSYNC required before writing to IMEM_CONTROL. */
+	.align 8;
+	[P0] = R0;
+	SSYNC;
+	STI R2;
+	RTS;
+#endif
+
+#if defined (CONFIG_BLKFIN_DCACHE)
+ENTRY(_dcache_init)
+
+	/* Initialize Data CPLBS */
+
+	I0.L = (DCPLB_ADDR0 & 0xFFFF);
+	I0.H = (DCPLB_ADDR0 >> 16);
+
+	I1.L = (DCPLB_DATA0 & 0xFFFF);
+	I1.H = (DCPLB_DATA0 >> 16);
+
+	I2.L = _dcplb_table;
+	I2.H = _dcplb_table;
+
+	R1 = -1;	/* end point comparison */
+	R3 = 15;	/* max counter */
+
+	/* read entries from table */
+read_daddr:
+	R0 = [I2++];
+	cc = R0 == R1;
+	IF CC JUMP ddone;
+	[I0++] = R0;
+
+read_ddata:
+	R2 = [I2++];
+	[I1++] = R2;
+	R3 = R3 + R1;
+	CC = R3 == R1;
+	IF !CC JUMP read_daddr;
+ddone:
+	P0.L = (DMEM_CONTROL & 0xFFFF);
+	P0.H = (DMEM_CONTROL >> 16);
+	R1 = [P0];
+
+	R0 = DMEM_CNTR;
+
+	R0 = R0 | R1;
+	/*Anamoly 05000125 */
+	CLI R2;
+	SSYNC;		/* SSYNC required before writing to DMEM_CONTROL. */
+	.align 8;
+	[P0] = R0;
+	SSYNC;
+	STI R2;
+	RTS;
+#endif
Index: git/linux-2.6/arch/blackfin/mach-common/cplbhdlr.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-common/cplbhdlr.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,196 @@
+ /*
+ * File:        arch/blackfin/mach-common/cplbhdlr.S
+ * Based on:
+ * Author:      LG Soft India
+ *              COPYRIGHT 2005 Analog Devices
+ * Created:     ?
+ * Description: CPLB exception handler
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/linkage.h>
+#include <asm/cplb.h>
+#include <asm/entry.h>
+
+
+.text
+
+.globl __cplb_hdr;
+.type __cplb_hdr, STT_FUNC;
+.extern _cplb_mgr;
+.type _cplb_mgr, STT_FUNC;
+.extern __unknown_exception_occurred;
+.type __unknown_exception_occurred, STT_FUNC;
+.extern __cplb_miss_all_locked;
+.type __cplb_miss_all_locked, STT_FUNC;
+.extern __cplb_miss_without_replacement;
+.type __cplb_miss_without_replacement, STT_FUNC;
+.extern __cplb_protection_violation;
+.type __cplb_protection_violation, STT_FUNC;
+.extern _panic_pv;
+
+.align 2;
+
+ENTRY(__cplb_hdr)
+	SSYNC;
+	[--SP] = ASTAT;
+	[--SP] = SEQSTAT;
+	[--SP] = I0;
+	[--SP] = I1;
+	[--SP] = I2;
+	[--SP] = I3;
+	R2 = SEQSTAT;
+
+	/*Mask the contents of SEQSTAT and leave only EXCAUSE in R2*/
+	R2 <<= 26;
+	R2 >>= 26;
+
+	R1 = 0x23; /* Data access CPLB protection violation */
+	CC = R2 == R1;
+	IF !CC JUMP not_data_write;
+	R0 = 2;		/* is a write to data space*/
+	JUMP is_icplb_miss;
+
+not_data_write:
+	R1 = 0x2C; /* CPLB miss on an instruction fetch */
+	CC = R2 == R1;
+	R0 = 0;		/* is_data_miss == False*/
+	IF CC JUMP is_icplb_miss;
+
+	R1 = 0x26;
+	CC = R2 == R1;
+	IF !CC JUMP unknown;
+
+	R0 = 1;		/* is_data_miss == True*/
+
+is_icplb_miss:
+
+#if ( defined (CONFIG_BLKFIN_CACHE) || defined (CONFIG_BLKFIN_DCACHE))
+#if ( defined (CONFIG_BLKFIN_CACHE) && !defined (CONFIG_BLKFIN_DCACHE))
+	R1 = CPLB_ENABLE_ICACHE;
+#endif
+#if ( !defined (CONFIG_BLKFIN_CACHE) && defined (CONFIG_BLKFIN_DCACHE))
+	R1 = CPLB_ENABLE_DCACHE;
+#endif
+#if ( defined (CONFIG_BLKFIN_CACHE) && defined (CONFIG_BLKFIN_DCACHE))
+	R1 = CPLB_ENABLE_DCACHE | CPLB_ENABLE_ICACHE;
+#endif
+#else
+	R1 = 0;
+#endif
+
+	[--SP] = RETS;
+	CALL _cplb_mgr;
+	RETS = [SP++];
+	CC = R0 == 0;
+	IF !CC JUMP not_replaced;
+	I3 = [SP++];
+	I2 = [SP++];
+	I1 = [SP++];
+	I0 = [SP++];
+	SEQSTAT = [SP++];
+	ASTAT = [SP++];
+	RTS;
+
+unknown:
+	[--SP] = RETS;
+	CALL __unknown_exception_occurred;
+	RETS = [SP++];
+	JUMP unknown;
+not_replaced:
+	CC = R0 == CPLB_NO_UNLOCKED;
+	IF !CC JUMP next_check;
+	[--SP] = RETS;
+	CALL __cplb_miss_all_locked;
+	RETS = [SP++];
+next_check:
+	CC = R0 == CPLB_NO_ADDR_MATCH;
+	IF !CC JUMP next_check2;
+	[--SP] = RETS;
+	CALL __cplb_miss_without_replacement;
+	RETS = [SP++];
+	JUMP not_replaced;
+next_check2:
+	CC = R0 == CPLB_PROT_VIOL;
+	IF !CC JUMP strange_return_from_cplb_mgr;
+	[--SP] = RETS;
+	CALL __cplb_protection_violation;
+	RETS = [SP++];
+	JUMP not_replaced;
+strange_return_from_cplb_mgr:
+	IDLE;
+	CSYNC;
+	JUMP strange_return_from_cplb_mgr;
+
+/************************************
+ * Diagnostic exception handlers
+ */
+
+__cplb_miss_all_locked:
+	sp += -12;
+	R0 = CPLB_NO_UNLOCKED;
+	call _panic_bfin;
+	SP += 12;
+	RTS;
+
+__cplb_miss_without_replacement:
+	sp += -12;
+	R0 = CPLB_NO_ADDR_MATCH;
+	call _panic_bfin;
+	SP += 12;
+	RTS;
+
+__cplb_protection_violation:
+	sp += -12;
+	R0 = CPLB_PROT_VIOL;
+	call _panic_bfin;
+	SP += 12;
+	RTS;
+
+__unknown_exception_occurred:
+
+	/* This function is invoked by the default exception
+	 * handler, if it does not recognise the kind of
+	 * exception that has occurred. In other words, the
+	 * default handler only handles some of the system's
+	 * exception types, and it does not expect any others
+	 * to occur. If your application is going to be using
+	 * other kinds of exceptions, you must replace the
+	 * default handler with your own, that handles all the
+	 * exceptions you will use.
+	 *
+	 * Since there's nothing we can do, we just loop here
+	 * at what we hope is a suitably informative label.
+	 */
+
+	IDLE;
+do_not_know_what_to_do:
+	NOP;
+	CSYNC;
+	JUMP __unknown_exception_occurred;
+
+	RTS;
+.__unknown_exception_occurred.end:
+.global __unknown_exception_occurred;
+.type __unknown_exception_occurred, STT_FUNC;
Index: git/linux-2.6/arch/blackfin/mach-common/cplbinfo.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-common/cplbinfo.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,218 @@
+ /*
+  * File:        arch/blackfin/mach-common/cplbinfo.c
+  * Based on:
+  * Author:      Sonic Zhang <sonic.zhang@analog.com>
+  *              COPYRIGHT 2005 Analog Devices
+  * Created:     Jan. 2005
+  * Description: Display CPLB status
+  *
+  * Rev:
+  *
+  * Modified:
+  *
+  *
+  * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.
+  * If not, write to the Free Software Foundation,
+  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+  */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+
+#include <asm/current.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+
+#include <asm/cplb.h>
+#include <asm/blackfin.h>
+
+#define CPLB_I 1
+#define CPLB_D 2
+
+#define SYNC_SYS    __builtin_bfin_ssync()
+#define SYNC_CORE   __builtin_bfin_csync()
+
+#define CPLB_BIT_PAGESIZE 0x30000
+
+static int page_size_table[4] = {
+	0x00000400,		/* 1K */
+	0x00001000,		/* 4K */
+	0x00100000,		/* 1M */
+	0x00400000		/* 4M */
+};
+
+static char page_size_string_table[][4] = { "1K", "4K", "1M", "4M" };
+
+extern unsigned long dpdt_table[];
+extern unsigned long ipdt_table[];
+
+extern unsigned long ipdt_swapcount_table[];
+extern unsigned long dpdt_swapcount_table[];
+
+static int cplb_find_entry(unsigned long *cplb_addr,
+			   unsigned long *cplb_data, unsigned long addr)
+{
+	int ii;
+
+	for (ii = 0; ii < 16; ii++)
+		if (addr >= cplb_addr[ii] && addr < cplb_addr[ii] +
+		    page_size_table[(cplb_data[ii] & CPLB_BIT_PAGESIZE) >> 16])
+			return ii;
+
+	return -1;
+}
+
+static char *cplb_print_entry(char *buf, int type)
+{
+	unsigned long *p_addr = dpdt_table;
+	unsigned long *p_data = dpdt_table + 1;
+	unsigned long *p_icount = dpdt_swapcount_table;
+	unsigned long *p_ocount = dpdt_swapcount_table + 1;
+	unsigned long *cplb_addr = (unsigned long *)DCPLB_ADDR0;
+	unsigned long *cplb_data = (unsigned long *)DCPLB_DATA0;
+	int entry, used_cplb = 0;
+
+	if (type == CPLB_I) {
+		buf += sprintf(buf, "Instrction CPLB entry:\n");
+		p_addr = ipdt_table;
+		p_data = ipdt_table + 1;
+		p_icount = ipdt_swapcount_table;
+		p_ocount = ipdt_swapcount_table + 1;
+		cplb_addr = (unsigned long *)ICPLB_ADDR0;
+		cplb_data = (unsigned long *)ICPLB_DATA0;
+	} else
+		buf += sprintf(buf, "Data CPLB entry:\n");
+
+	buf += sprintf(buf, "Address\t\tData\tSize\tValid\tLocked\tSwapin\
+\tiCount\toCount\n");
+
+	while (*p_addr != 0xffffffff) {
+		entry = cplb_find_entry(cplb_addr, cplb_data, *p_addr);
+		if (entry >= 0 && *p_data == cplb_data[entry])
+			used_cplb |= 1 << entry;
+
+		buf +=
+		    sprintf(buf,
+			    "0x%08lx\t0x%05lx\t%s\t%c\t%c\t%2d\t%ld\t%ld\n",
+			    *p_addr, *p_data,
+			    page_size_string_table[(*p_data & 0x30000) >> 16],
+			    (*p_data & CPLB_VALID) ? 'Y' : 'N',
+			    (*p_data & CPLB_LOCK) ? 'Y' : 'N', entry, *p_icount,
+			    *p_ocount);
+
+		p_addr += 2;
+		p_data += 2;
+		p_icount += 2;
+		p_ocount += 2;
+	}
+
+	if (used_cplb != 0xffff) {
+		buf += sprintf(buf, "Unused/mismatched CPLBs:\n");
+
+		for (entry = 0; entry < 16; entry++)
+			if (0 == ((1 << entry) & used_cplb)) {
+				int flags = cplb_data[entry];
+				buf +=
+				    sprintf(buf,
+					    "%2d: 0x%08lx\t0x%05x\t%s\t%c\t%c\n",
+					    entry, cplb_addr[entry], flags,
+					    page_size_string_table[(flags &
+								    0x30000) >>
+								   16],
+					    (flags & CPLB_VALID) ? 'Y' : 'N',
+					    (flags & CPLB_LOCK) ? 'Y' : 'N');
+			}
+	}
+
+	buf += sprintf(buf, "\n");
+
+	return buf;
+}
+
+static int cplbinfo_proc_output(char *buf)
+{
+	char *p;
+
+	p = buf;
+
+	p += sprintf(p,
+		     "------------------ CPLB Information ------------------\n\n");
+
+	if (*pIMEM_CONTROL & ENICPLB)
+		p = cplb_print_entry(p, CPLB_I);
+	else
+		p += sprintf(p, "Instruction CPLB is disabled.\n\n");
+
+	if (*pDMEM_CONTROL & ENDCPLB)
+		p = cplb_print_entry(p, CPLB_D);
+	else
+		p += sprintf(p, "Data CPLB is disabled.\n");
+
+	return p - buf;
+}
+
+static int cplbinfo_read_proc(char *page, char **start, off_t off,
+			      int count, int *eof, void *data)
+{
+	int len;
+
+	len = cplbinfo_proc_output(page);
+	if (len <= off + count)
+		*eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len > count)
+		len = count;
+	if (len < 0)
+		len = 0;
+	return len;
+}
+
+static int cplbinfo_write_proc(struct file *file, const char *buffer,
+			       unsigned long count, void *data)
+{
+	printk("Reset the CPLB swap in/out counts.\n");
+	memset(ipdt_swapcount_table, 0, 100 * sizeof(unsigned long));
+	memset(dpdt_swapcount_table, 0, 120 * sizeof(unsigned long));
+
+	return count;
+}
+
+static int __init cplbinfo_init(void)
+{
+	struct proc_dir_entry *entry;
+
+	if ((entry = create_proc_entry("cplbinfo", 0, NULL)) == NULL) {
+		return -ENOMEM;
+	}
+
+	entry->read_proc = cplbinfo_read_proc;
+	entry->write_proc = cplbinfo_write_proc;
+	entry->data = NULL;
+
+	return 0;
+}
+
+static void __exit cplbinfo_exit(void)
+{
+	remove_proc_entry("cplbinfo", NULL);
+}
+
+module_init(cplbinfo_init);
+module_exit(cplbinfo_exit);
Index: git/linux-2.6/arch/blackfin/mach-common/cplbmgr.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-common/cplbmgr.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,623 @@
+ /*
+ * File:        arch/blackfin/mach-common/cplbmgtr.S
+ * Based on:
+ * Author:      LG Soft India
+ *              COPYRIGHT 2005 Analog Devices
+ * Created:     ?
+ * Description: CPLB replacement routine for CPLB mismatch
+ *
+ * Rev:
+ *
+ * Modified:    LG Soft India
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* Usage: int _cplb_mgr(is_data_miss,int enable_cache)
+ * is_data_miss==2 => Mark as Dirty, write to the clean data page
+ * is_data_miss==1 => Replace a data CPLB.
+ * is_data_miss==0 => Replace an instruction CPLB.
+ *
+ * Returns:
+ * CPLB_RELOADED	=> Successfully updated CPLB table.
+ * CPLB_NO_UNLOCKED	=> All CPLBs are locked, so cannot be evicted.
+ *			   This indicates that the CPLBs in the configuration
+ *			   tablei are badly configured, as this should never
+ *			   occur.
+ * CPLB_NO_ADDR_MATCH	=> The address being accessed, that triggered the
+ *			   exception, is not covered by any of the CPLBs in
+ *			   the configuration table. The application is
+ *			   presumably misbehaving.
+ * CPLB_PROT_VIOL	=> The address being accessed, that triggered the
+ *			   exception, was not a first-write to a clean Write
+ *			   Back Data page, and so presumably is a genuine
+ *			   violation of the page's protection attributes.
+ *			   The application is misbehaving.
+ */
+
+#include <linux/linkage.h>
+#include <asm/blackfin.h>
+#include <asm/cplb.h>
+
+.text
+
+.align 2;
+ENTRY(_cplb_mgr)
+
+	[--SP]=( R7:4,P5:3 );
+
+	CC = R0 == 2;
+	IF CC JUMP dcplb_write;
+
+	CC = R0 == 0;
+	IF !CC JUMP dcplb_miss_compare;
+
+	/* ICPLB Miss Exception. We need to choose one of the
+	* currently-installed CPLBs, and replace it with one
+	* from the configuration table.
+ 	*/
+
+	P4.L = (ICPLB_FAULT_ADDR & 0xFFFF);
+	P4.H = (ICPLB_FAULT_ADDR >> 16);
+
+	P1 = 16;
+	P5.L = _page_size_table;
+	P5.H = _page_size_table;
+
+	P0.L = (ICPLB_DATA0 & 0xFFFF);
+	P0.H = (ICPLB_DATA0 >> 16);
+	R4 = [P4];		/* Get faulting address*/
+	R6 = 64;		/* Advance past the fault address, which*/
+	R6 = R6 + R4;		/* we'll use if we find a match*/
+	R3 = ((16 << 8) | 2);	/* Extract mask, bits 16 and 17.*/
+
+	R5 = 0;
+isearch:
+
+	R1 = [P0-0x100];	/* Address for this CPLB */
+
+	R0 = [P0++];		/* Info for this CPLB*/
+	CC = BITTST(R0,0);	/* Is the CPLB valid?*/
+	IF !CC JUMP nomatch;	/* Skip it, if not.*/
+	CC = R4 < R1(IU);	/* If fault address less than page start*/
+	IF CC JUMP nomatch;	/* then skip this one.*/
+	R2 = EXTRACT(R0,R3.L) (Z);	/* Get page size*/
+	P1 = R2;
+	P1 = P5 + (P1<<2);	/* index into page-size table*/
+	R2 = [P1];		/* Get the page size*/
+	R1 = R1 + R2;		/* and add to page start, to get page end*/
+	CC = R4 < R1(IU);	/* and see whether fault addr is in page.*/
+	IF !CC R4 = R6;		/* If so, advance the address and finish loop.*/
+	IF !CC JUMP isearch_done;
+nomatch:
+	/* Go around again*/
+	R5 += 1;
+	CC = BITTST(R5, 4);	/* i.e CC = R5 >= 16*/
+	IF !CC JUMP isearch;
+
+isearch_done:
+	I0 = R4;		/* Fault address we'll search for*/
+
+	/* set up pointers */
+	P0.L = (ICPLB_DATA0 & 0xFFFF);
+	P0.H = (ICPLB_DATA0 >> 16);
+
+	/* The replacement procedure for ICPLBs */
+
+	P4.L = (IMEM_CONTROL & 0xFFFF);
+	P4.H = (IMEM_CONTROL >> 16);
+
+	/* disable cplbs */
+	R5 = [P4];		/* Control Register*/
+	BITCLR(R5,ENICPLB_P);
+	CLI R1;
+	SSYNC;		/* SSYNC required before writing to IMEM_CONTROL. */
+	.align 8;
+	[P4] = R5;
+	SSYNC;
+	STI R1;
+
+	R1 = -1;		/* end point comparison */
+	R3 = 16;		/* counter */
+
+	/* Search through CPLBs for first non-locked entry */
+	/* Overwrite it by moving everyone else up by 1 */
+icheck_lock:
+	R0 = [P0++];
+	R3 = R3 + R1;
+	CC = R3 == R1;
+	IF CC JUMP all_locked;
+	CC = BITTST(R0, 0);		/* an invalid entry is good */
+	IF !CC JUMP ifound_victim;
+	CC = BITTST(R0,1);		/* but a locked entry isn't */
+	IF CC JUMP icheck_lock;
+
+ifound_victim:
+#ifdef CONFIG_CPLB_INFO
+	R7 = [P0 - 0x104];
+	P2.L = _ipdt_table;
+	P2.H = _ipdt_table;
+	P3.L = _ipdt_swapcount_table;
+	P3.H = _ipdt_swapcount_table;
+	P3 += -4;
+icount:
+	R2 = [P2];	/* address from config table */
+	P2 += 8;
+	P3 += 8;
+	CC = R2==-1;
+	IF CC JUMP icount_done;
+	CC = R7==R2;
+	IF !CC JUMP icount;
+	R7 = [P3];
+	R7 += 1;
+	[P3] = R7;
+	CSYNC;
+icount_done:
+#endif
+	LC0=R3;
+	LSETUP(is_move,ie_move) LC0;
+is_move:
+	R0 = [P0];
+	[P0 - 4] = R0;
+	R0 = [P0 - 0x100];
+	[P0-0x104] = R0;
+ie_move:P0+=4;
+
+	/* We've made space in the ICPLB table, so that ICPLB15
+	 * is now free to be overwritten. Next, we have to determine
+	 * which CPLB we need to install, from the configuration
+	 * table. This is a matter of getting the start-of-page
+	 * addresses and page-lengths from the config table, and
+	 * determining whether the fault address falls within that
+	 * range.
+ 	 */
+
+	P2.L = _ipdt_table;
+	P2.H = _ipdt_table;
+#ifdef	CONFIG_CPLB_INFO
+	P3.L = _ipdt_swapcount_table;
+	P3.H = _ipdt_swapcount_table;
+	P3 += -8;
+#endif
+	P0.L = _page_size_table;
+	P0.H = _page_size_table;
+
+	/* Retrieve our fault address (which may have been advanced
+	 * because the faulting instruction crossed a page boundary).
+	 */
+
+	R0 = I0;
+
+	/* An extraction pattern, to get the page-size bits from
+	 * the CPLB data entry. Bits 16-17, so two bits at posn 16.
+	 */
+
+	R1 = ((16<<8)|2);
+inext:	R4 = [P2++];	/* address from config table */
+	R2 = [P2++];	/* data from config table */
+#ifdef	CONFIG_CPLB_INFO
+	P3 += 8;
+#endif
+
+	CC = R4 == -1;	/* End of config table*/
+	IF CC JUMP no_page_in_table;
+
+	/* See if failed address > start address */
+	CC = R4 <= R0(IU);
+ 	IF !CC JUMP inext;
+
+	/* extract page size (17:16)*/
+	R3 = EXTRACT(R2, R1.L) (Z);
+
+	/* add page size to addr to get range */
+
+	P5 = R3;
+	P5 = P0 + (P5 << 2);	/* scaled, for int access*/
+	R3 = [P5];
+	R3 = R3 + R4;
+
+	/* See if failed address < (start address + page size) */
+	CC = R0 < R3(IU);
+	IF !CC JUMP inext;
+
+	/* We've found a CPLB in the config table that covers
+	 * the faulting address, so install this CPLB into the
+	 * last entry of the table.
+	 */
+
+	P1.L = (ICPLB_DATA15 & 0xFFFF);		/*ICPLB_DATA15*/
+	P1.H = (ICPLB_DATA15 >> 16);
+	[P1] = R2;
+	[P1-0x100] = R4;
+#ifdef	CONFIG_CPLB_INFO
+	R3 = [P3];
+	R3 += 1;
+	[P3] = R3;
+#endif
+
+	/* P4 points to IMEM_CONTROL, and R5 contains its old
+	 * value, after we disabled ICPLBS. Re-enable them.
+	 */
+
+	BITSET(R5,ENICPLB_P);
+	CLI R2;
+	SSYNC;		/* SSYNC required before writing to IMEM_CONTROL. */
+	.align 8;
+	[P4] = R5;
+	SSYNC;
+	STI R2;
+
+	( R7:4,P5:3 ) = [SP++];
+	R0 = CPLB_RELOADED;
+	RTS;
+
+/* FAILED CASES*/
+no_page_in_table:
+        ( R7:4,P5:3 ) = [SP++];
+        R0 = CPLB_NO_ADDR_MATCH;
+        RTS;
+all_locked:
+        ( R7:4,P5:3 ) = [SP++];
+        R0 = CPLB_NO_UNLOCKED;
+        RTS;
+prot_violation:
+        ( R7:4,P5:3 ) = [SP++];
+        R0 = CPLB_PROT_VIOL;
+        RTS;
+
+dcplb_write:
+
+	/* if a DCPLB is marked as write-back (CPLB_WT==0), and
+	 * it is clean (CPLB_DIRTY==0), then a write to the
+	 * CPLB's page triggers a protection violation. We have to
+	 * mark the CPLB as dirty, to indicate that there are
+	 * pending writes associated with the CPLB.
+	 */
+
+	P4.L = (DCPLB_STATUS & 0xFFFF);
+	P4.H = (DCPLB_STATUS >> 16);
+	P3.L = (DCPLB_DATA0 & 0xFFFF);
+	P3.H = (DCPLB_DATA0 >> 16);
+	R5 = [P4];
+
+	/* A protection violation can be caused by more than just writes
+	 * to a clean WB page, so we have to ensure that:
+	 * - It's a write
+	 * - to a clean WB page
+	 * - and is allowed in the mode the access occurred.
+	 */
+
+	CC = BITTST(R5, 16);	/* ensure it was a write*/
+	IF !CC JUMP prot_violation;
+
+	/* to check the rest, we have to retrieve the DCPLB.*/
+
+	/* The low half of DCPLB_STATUS is a bit mask*/
+
+	R2 = R5.L (Z);	/* indicating which CPLB triggered the event.*/
+	R3 = 30;	/* so we can use this to determine the offset*/
+	R2.L = SIGNBITS R2;
+	R2 = R2.L (Z);	/* into the DCPLB table.*/
+	R3 = R3 - R2;
+	P4 = R3;
+	P3 = P3 + (P4<<2);
+	R3 = [P3];	/* Retrieve the CPLB*/
+
+	/* Now we can check whether it's a clean WB page*/
+
+	CC = BITTST(R3, 14);	/* 0==WB, 1==WT*/
+	IF CC JUMP prot_violation;
+	CC = BITTST(R3, 7);	/* 0 == clean, 1 == dirty*/
+	IF CC JUMP prot_violation;
+
+	/* Check whether the write is allowed in the mode that was active.*/
+
+	R2 = 1<<3;		/* checking write in user mode*/
+	CC = BITTST(R5, 17);	/* 0==was user, 1==was super*/
+	R5 = CC;
+	R2 <<= R5;		/* if was super, check write in super mode*/
+	R2 = R3 & R2;
+	CC = R2 == 0;
+	IF CC JUMP prot_violation;
+
+	/* It's a genuine write-to-clean-page.*/
+
+	BITSET(R3, 7);		/* mark as dirty*/
+	[P3] = R3;		/* and write back.*/
+	NOP;
+	CSYNC;
+	( R7:4,P5:3 ) = [SP++];
+	R0 = CPLB_RELOADED;
+	RTS;
+
+dcplb_miss_compare:
+
+	/* Data CPLB Miss event. We need to choose a CPLB to
+	 * evict, and then locate a new CPLB to install from the
+	 * config table, that covers the faulting address.
+	 */
+
+	P1.L = (DCPLB_DATA15 & 0xFFFF);
+	P1.H = (DCPLB_DATA15 >> 16);
+
+	P4.L = (DCPLB_FAULT_ADDR & 0xFFFF);
+	P4.H = (DCPLB_FAULT_ADDR >> 16);
+	R4 = [P4];
+	I0 = R4;
+
+	/* The replacement procedure for DCPLBs*/
+
+	R6 = R1;	/* Save for later*/
+
+	/* Turn off CPLBs while we work.*/
+	P4.L = (DMEM_CONTROL & 0xFFFF);
+	P4.H = (DMEM_CONTROL >> 16);
+	R5 = [P4];
+	BITCLR(R5,ENDCPLB_P);
+	CLI R0;
+	SSYNC;		/* SSYNC required before writing to DMEM_CONTROL. */
+	.align 8;
+	[P4] = R5;
+	SSYNC;
+	STI R0;
+
+	/* Start looking for a CPLB to evict. Our order of preference
+	 * is: invalid CPLBs, clean CPLBs, dirty CPLBs. Locked CPLBs
+	 * are no good.
+	 */
+
+	I1.L = (DCPLB_DATA0 & 0xFFFF);
+	I1.H = (DCPLB_DATA0 >> 16);
+	P1 = 3;
+	P2 = 16;
+	I2.L = _dcplb_preference;
+	I2.H = _dcplb_preference;
+	LSETUP(sdsearch1, edsearch1) LC0 = P1;
+sdsearch1:
+	R0 = [I2++];		/* Get the bits we're interested in*/
+	P0 = I1;		/* Go back to start of table*/
+	LSETUP (sdsearch2, edsearch2) LC1 = P2;
+sdsearch2:
+	R1 = [P0++];		/* Fetch each installed CPLB in turn*/
+	R2 = R1 & R0;		/* and test for interesting bits.*/
+	CC = R2 == 0;		/* If none are set, it'll do.*/
+	IF !CC JUMP skip_stack_check;
+
+	R2 = [P0 - 0x104]; 	/* R2 - PageStart */
+	P3.L = _page_size_table; /* retrive end address */
+	P3.H = _page_size_table; /* retrive end address */
+	R3 = 0x1002;		/* 16th - position, 2 bits -length */
+	nop;			/*Anamoly 05000209*/
+	R7 = EXTRACT(R1,R3.l);
+	R7 = R7 << 2;		/* Page size index offset */
+	P5 = R7;
+	P3 = P3 + P5;
+	R7 = [P3];		/* page size in bytes */
+
+	R7 = R2 + R7;		/* R7 - PageEnd */
+	R4 = SP; 		/* Test SP is in range */
+
+	CC = R7 < R4;		/* if PageEnd < SP */
+	IF CC JUMP dfound_victim;
+	R3 = 0x284;		/* stack length from start of trap till
+				 * the point.
+				 * 20 stack locations for future modifications
+				 */
+	R4 = R4 + R3;
+	CC = R4 < R2;		/* if SP + stacklen < PageStart */
+	IF CC JUMP dfound_victim;
+skip_stack_check:
+
+edsearch2: NOP;
+edsearch1: NOP;
+
+	/* If we got here, we didn't find a DCPLB we considered
+	 * replacable, which means all of them were locked.
+	 */
+
+	JUMP all_locked;
+dfound_victim:
+
+#ifdef CONFIG_CPLB_INFO
+	R7 = [P0 - 0x104];
+	P2.L = _dpdt_table;
+	P2.H = _dpdt_table;
+	P3.L = _dpdt_swapcount_table;
+	P3.H = _dpdt_swapcount_table;
+	P3 += -4;
+dicount:
+	R2 = [P2];
+	P2 += 8;
+	P3 += 8;
+	CC = R2==-1;
+	IF CC JUMP dicount_done;
+	CC = R7==R2;
+	IF !CC JUMP dicount;
+	R7 = [P3];
+	R7 += 1;
+	[P3] = R7;
+dicount_done:
+#endif
+
+	/* Clean down the hardware loops*/
+	R2 = 0;
+	LC1 = R2;
+	LC0 = R2;
+
+	/* There's a suitable victim in [P0-4] (because we've
+	 * advanced already). If it's a valid dirty write-back
+	 * CPLB, we need to flush the pending writes first.
+	 */
+
+	CC = BITTST(R1, 0);	/* Is it valid?*/
+	IF !CC JUMP Ddoverwrite;/* nope.*/
+	CC = BITTST(R1, 7);	/* Is it dirty?*/
+	IF !CC JUMP Ddoverwrite (BP);	/* Nope.*/
+	CC = BITTST(R1, 14);	/* Is it Write-Through?*/
+	IF CC JUMP Ddoverwrite;	/* Yep*/
+
+	/* This is a dirty page, so we need to flush all writes
+	 * that are pending on the page.
+	 */
+
+	/* Retrieve the page start address*/
+    R0 = [P0 - 0x104];
+	[--sp] = rets;
+	[--sp] = p0;
+	CALL _dcplb_flush;	/* R0==CPLB addr, R1==CPLB data*/
+	p0 = [sp++];
+	rets = [sp++];
+Ddoverwrite:
+
+	/* [P0-4] is a suitable victim CPLB, so we want to
+	 * overwrite it by moving all the following CPLBs
+	 * one space closer to the start.
+	 */
+
+	R1.L = (DCPLB_DATA16 & 0xFFFF);		/*DCPLB_DATA15+4*/
+	R1.H = (DCPLB_DATA16 >> 16);
+	R0 = P0;
+
+	/* If the victim happens to be in DCPLB15,
+	 * we don't need to move anything.
+	 */
+
+	CC = R1 == R0;
+	IF CC JUMP de_moved;
+	R1 = R1 - R0;
+	R1 >>= 2;
+	P1 = R1;
+	LSETUP(ds_move, de_move) LC0=P1;
+ds_move:
+	 R0 = [P0++];	/* move data */
+	[P0 - 8] = R0;
+	R0 = [P0-0x104]	/* move address */
+de_move: [P0-0x108] = R0;
+
+	/* We've now made space in DCPLB15 for the new CPLB to be
+	 * installed. The next stage is to locate a CPLB in the
+	 * config table that covers the faulting address.
+	 */
+
+de_moved:NOP;
+	R0 = I0;		/* Our faulting address */
+
+	P2.L = _dpdt_table;
+	P2.H = _dpdt_table;
+#ifdef	CONFIG_CPLB_INFO
+	P3.L = _dpdt_swapcount_table;
+	P3.H = _dpdt_swapcount_table;
+	P3 += -8;
+#endif
+
+	P1.L = _page_size_table;
+	P1.H = _page_size_table;
+
+	/* An extraction pattern, to retrieve bits 17:16.*/
+
+	R1 = (16<<8)|2;
+dnext:	R4 = [P2++];	/* address */
+	R2 = [P2++];	/* data */
+#ifdef	CONFIG_CPLB_INFO
+	P3 += 8;
+#endif
+
+	CC = R4 == -1;
+	IF CC JUMP no_page_in_table;
+
+	/* See if failed address > start address */
+	CC = R4 <= R0(IU);
+ 	IF !CC JUMP dnext;
+
+	/* extract page size (17:16)*/
+	R3 = EXTRACT(R2, R1.L) (Z);
+
+	/* add page size to addr to get range */
+
+	P5 = R3;
+	P5 = P1 + (P5 << 2);
+	R3 = [P5];
+	R3 = R3 + R4;
+
+	/* See if failed address < (start address + page size) */
+	CC = R0 < R3(IU);
+	IF !CC JUMP dnext;
+
+	/* We've found the CPLB that should be installed, so
+	 * write it into CPLB15, masking off any caching bits
+	 * if necessary.
+	 */
+
+	P1.L = (DCPLB_DATA15 & 0xFFFF);
+	P1.H = (DCPLB_DATA15 >> 16);
+
+	/* If the DCPLB has cache bits set, but caching hasn't
+	 * been enabled, then we want to mask off the cache-in-L1
+	 * bit before installing. Moreover, if caching is off, we
+	 * also want to ensure that the DCPLB has WT mode set, rather
+	 * than WB, since WB pages still trigger first-write exceptions
+	 * even when not caching is off, and the page isn't marked as
+	 * cachable. Finally, we could mark the page as clean, not dirty,
+	 * but we choose to leave that decision to the user; if the user
+	 * chooses to have a CPLB pre-defined as dirty, then they always
+	 * pay the cost of flushing during eviction, but don't pay the
+	 * cost of first-write exceptions to mark the page as dirty.
+	 */
+
+#ifdef CONFIG_BLKFIN_WT
+	BITSET(R6, 14);		/* Set WT*/
+#endif
+
+	[P1] = R2;
+	[P1-0x100] = R4;
+#ifdef	CONFIG_CPLB_INFO
+	R3 = [P3];
+	R3 += 1;
+	[P3] = R3;
+#endif
+
+	/* We've installed the CPLB, so re-enable CPLBs. P4
+	 * points to DMEM_CONTROL, and R5 is the value we
+	 * last wrote to it, when we were disabling CPLBs.
+	 */
+
+	BITSET(R5,ENDCPLB_P);
+	CLI R2;
+	.align 8;
+	[P4] = R5;
+	SSYNC;
+	STI R2;
+
+	( R7:4,P5:3 ) = [SP++];
+	R0 = CPLB_RELOADED;
+	RTS;
+
+.data
+.align 4;
+_page_size_table:
+.byte4	0x00000400;	/* 1K */
+.byte4	0x00001000;	/* 4K */
+.byte4	0x00100000;	/* 1M */
+.byte4	0x00400000;	/* 4M */
+
+.align 4;
+_dcplb_preference:
+.byte4	0x00000001;	/* valid bit */
+.byte4	0x00000082;	/* dirty+lock bits */
+.byte4	0x00000002;	/* lock bit */
Index: git/linux-2.6/arch/blackfin/mach-common/dpmc.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-common/dpmc.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,334 @@
+ /*
+ * File:        arch/blackfin/mach-common/dpmc.S
+ * Based on:
+ * Author:      LG Soft India
+ *              COPYRIGHT 2005 Analog Devices
+ * Created:     ?
+ * Description: Watchdog Timer APIs
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <asm/blackfin.h>
+#include <asm/mach/irq.h>
+
+#define ASSEMBLY
+
+.text
+
+.global _unmask_wdog_wakeup_evt
+_unmask_wdog_wakeup_evt:
+	[--SP] = ( R7:0, P5:0 );
+#if defined (CONFIG_BF561)
+	P0.H = hi(SICA_IWR1);
+	P0.L = lo(SICA_IWR1);
+#else
+	P0.h = (SIC_IWR >> 16);
+	P0.l = (SIC_IWR & 0xFFFF);
+#endif
+	R7 = [P0];
+#if defined (CONFIG_BF561)
+	BITSET(R7, 27);
+#else
+	BITSET(R7,(IRQ_WATCH - IVG7));
+#endif
+	[P0] = R7;
+	SSYNC;
+
+	( R7:0, P5:0 ) = [SP++];
+	RTS;
+
+WRITE_TO_STAT:
+	/* When watch dog timer is enabled, a write to STAT will load the
+	 * contents of CNT to STAT
+	 */
+	R7 = 0x0000(z);
+#if defined(CONFIG_BF561)
+	P0.h = (WDOGA_STAT >> 16);
+	P0.l = (WDOGA_STAT & 0xFFFF);
+#else
+	P0.h = (WDOG_STAT >> 16);
+	P0.l = (WDOG_STAT & 0xFFFF);
+#endif
+	[P0] = R7;
+	SSYNC;
+	JUMP SKIP_WRITE_TO_STAT;
+
+.global _program_wdog_timer
+_program_wdog_timer:
+	[--SP] = ( R7:0, P5:0 );
+#if defined(CONFIG_BF561)
+	P0.h = (WDOGA_CNT >> 16);
+	P0.l = (WDOGA_CNT & 0xFFFF);
+#else
+	P0.h = (WDOG_CNT >> 16);
+	P0.l = (WDOG_CNT & 0xFFFF);
+#endif
+	[P0] = R0;
+	SSYNC;
+
+#if defined(CONFIG_BF561)
+	P0.h = (WDOGA_CTL >> 16);
+	P0.l = (WDOGA_CTL & 0xFFFF);
+#else
+	P0.h = (WDOG_CTL >> 16);
+	P0.l = (WDOG_CTL & 0xFFFF);
+#endif
+	R7 = W[P0](Z);
+	CC = BITTST(R7,1);
+	if !CC JUMP WRITE_TO_STAT;
+	CC = BITTST(R7,2);
+	if !CC JUMP WRITE_TO_STAT;
+
+SKIP_WRITE_TO_STAT:
+#if defined(CONFIG_BF561)
+	P0.h = (WDOGA_CTL >> 16);
+        P0.l = (WDOGA_CTL & 0xFFFF);
+#else
+	P0.h = (WDOG_CTL >> 16);
+        P0.l = (WDOG_CTL & 0xFFFF);
+#endif
+        R7 = W[P0](Z);
+        BITCLR(R7,1);	/* Enable GP event */
+        BITSET(R7,2);
+        W[P0] = R7.L;
+        SSYNC;
+        NOP;
+
+        R7 = W[P0](Z);
+        BITCLR(R7,4);	/* Enable the wdog counter */
+        W[P0] = R7.L;
+        SSYNC;
+
+	( R7:0, P5:0 ) = [SP++];
+	RTS;
+
+.global _clear_wdog_wakeup_evt
+_clear_wdog_wakeup_evt:
+	[--SP] = ( R7:0, P5:0 );
+
+#if defined(CONFIG_BF561)
+	P0.h = (WDOGA_CTL >> 16);
+	P0.l = (WDOGA_CTL & 0xFFFF);
+#else
+	P0.h = (WDOG_CTL >> 16);
+	P0.l = (WDOG_CTL & 0xFFFF);
+#endif
+	R7 = 0x0AD6(Z);
+	W[P0] = R7.L;
+	SSYNC;
+
+	R7 = W[P0](Z);
+	BITSET(R7,15);
+	W[P0] = R7.L;
+	SSYNC;
+
+	R7 = W[P0](Z);
+	BITSET(R7,1);
+	BITSET(R7,2);
+	W[P0] = R7.L;
+	SSYNC;
+
+	( R7:0, P5:0 ) = [SP++];
+	RTS;
+
+.global _disable_wdog_timer
+_disable_wdog_timer:
+	[--SP] = ( R7:0, P5:0 );
+#if defined(CONFIG_BF561)
+	P0.h = (WDOGA_CTL >> 16);
+	P0.l = (WDOGA_CTL & 0xFFFF);
+#else
+	P0.h = (WDOG_CTL >> 16);
+	P0.l = (WDOG_CTL & 0xFFFF);
+#endif
+	R7 = 0xAD6(Z);
+	W[P0] = R7.L;
+	SSYNC;
+	( R7:0, P5:0 ) = [SP++];
+	RTS;
+
+#if !defined(CONFIG_BF561)
+.global _sleep_mode
+_sleep_mode:
+	[--SP] = ( R7:0, P5:0 );
+
+        P0.H = hi(SIC_IWR);
+        P0.L = lo(SIC_IWR);
+	R0 = IWR_ENABLE(IRQ_RTC - IVG7)(Z);
+        [P0] = R0;
+        SSYNC;
+
+        P0.H = hi(RTC_ISTAT);
+        P0.L = lo(RTC_ISTAT);
+	/* Clear all the interrupts,bits sticky */
+        R0 = (SWEF|AEF|SEF|MEF|HEF|DEF|DAEF|WCOM)(Z);
+        w[P0] = R0.L;
+        SSYNC;
+
+	P0.H = hi(PLL_CTL);
+        P0.L = lo(PLL_CTL);
+        R1 = W[P0](z);
+        BITSET (R1, 3);
+	W[P0] = R1.L;
+
+        CLI R2;
+        SSYNC;
+        IDLE;
+        STI R2;
+
+CHECK_AGAIN1:
+	P1.H = hi(PLL_STAT);
+	P1.L = lo(PLL_STAT);
+	R5 = W[P1] (Z);
+	CC = BITTST(R5,5);
+	IF !CC JUMP CHECK_AGAIN1;
+
+	P0.H = hi(PLL_CTL);
+	P0.L = lo(PLL_CTL);
+	R7 = w[p0](z);
+	BITCLR (R7, 3);
+	BITCLR (R7, 5);
+	w[p0] = R7.L;
+	IDLE;
+
+        ( R7:0, P5:0 ) = [SP++];
+        RTS;
+
+.global _deep_sleep
+_deep_sleep:
+	[--SP] = ( R7:0, P5:0 );
+
+	/*  set the sdram to self refresh mode */
+        P2.H = hi(EBIU_SDGCTL);
+        P2.L = lo(EBIU_SDGCTL);
+        R2 = [P2];
+        R3.H = hi(SRFS);
+        R3.L = lo(SRFS);
+        R2 = R2|R3;
+        [P2] = R2;
+        ssync;
+
+
+        P0.H = hi(SIC_IWR);
+        P0.L = lo(SIC_IWR);
+	R0 = IWR_ENABLE(IRQ_RTC - IVG7)(Z);
+        [P0] = R0;
+        SSYNC;
+
+        P0.H = hi(RTC_ISTAT);
+        P0.L = lo(RTC_ISTAT);
+	/* Clear all the interrupts,bits sticky */
+        R0 = (SWEF|AEF|SEF|MEF|HEF|DEF|DAEF|WCOM)(Z);
+        w[P0] = R0;
+        SSYNC;
+
+        P0.H = hi(PLL_CTL);
+        P0.L = lo(PLL_CTL);
+        R1 = W[P0](z);
+        BITSET (R1, 5);
+       	W[P0] = R1.L;
+
+        CLI R2;
+        SSYNC;
+        IDLE;
+        STI R2;
+
+	/*  set the sdram out of self refresh mode */
+        P2.H = hi(EBIU_SDGCTL);
+        P2.L = lo(EBIU_SDGCTL);
+        R2 = [P2];
+        R3.H = hi(SRFS);
+        R3.L = lo(SRFS);
+        R3 = ~R3;
+        R2 = R2&R3;
+        [P2] = R2;
+        ssync;
+
+
+CHECK_AGAIN2:
+	P1.H = hi(PLL_STAT);
+	P1.L = lo(PLL_STAT);
+	R5 = W[P1] (Z);
+	CC = BITTST(R5,5);
+	IF !CC JUMP CHECK_AGAIN2;
+
+	P0.H = hi(PLL_CTL);
+	P0.L = lo(PLL_CTL);
+	R7 = w[p0](z);
+	BITCLR (R7, 3);
+	BITCLR (R7, 5);
+	w[p0] = R7;
+	IDLE;
+
+        ( R7:0, P5:0 ) = [SP++];
+        RTS;
+
+.global _hibernate_mode
+_hibernate_mode:
+	[--SP] = ( R7:0, P5:0 );
+ 	P0.H = hi(SIC_IWR);
+        P0.L = lo(SIC_IWR);
+	R0 = IWR_ENABLE(IRQ_RTC - IVG7)(Z);
+        [P0] = R0;
+        SSYNC;
+
+        P0.H = hi(RTC_ISTAT);
+        P0.L = lo(RTC_ISTAT);
+	/* Clear all the interrupts,bits sticky */
+        R0 = (SWEF|AEF|SEF|MEF|HEF|DEF|DAEF|WCOM)(Z);
+        w[P0] = R0;
+        SSYNC;
+
+	P0.H = hi(VR_CTL);
+        P0.L = lo(VR_CTL);
+        R1 = W[P0](z);
+        BITSET (R1, 8);
+	BITCLR (R1, 0);
+	BITCLR (R1, 1);
+	W[P0] = R1.L;
+	SSYNC;
+
+        CLI R2;
+        IDLE;
+
+	/* Actually, adding anything may not be necessary...SDRAM contents
+	 * are lost
+	 */
+
+	STI R2;
+
+	P0.H = hi(VR_CTL);
+        P0.L = lo(VR_CTL);
+        R1 = W[P0](z);
+        BITCLR (R1, 8);
+        BITSET (R1, 0);
+        BITSET (R1, 1);
+        W[P0] = R1.L;
+        SSYNC;
+
+	IDLE;
+
+        ( R7:0, P5:0 ) = [SP++];
+        RTS;
+#endif
Index: git/linux-2.6/arch/blackfin/mach-common/entry.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-common/entry.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,982 @@
+ /*
+ * File:        arch/blackfin/mach-common/entry.S
+ * Based on:
+ * Author:      Linus Torvalds
+ *              COPYRIGHT 2005 Analog Devices
+ * Created:     ?
+ * Description: contains the system-call and fault low-level handling routines.
+ * This also contains the timer-interrupt handler, as well as all interrupts
+ * and faults that can result in a task-switch.
+ *
+ * Rev:
+ *
+ * Modified:     LG Soft India
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * 25-Dec-2004 - LG Soft India
+ * 	1. Fix in return_from_int, to make sure any pending
+ *	system call in ILAT for this process to get
+ *	executed, otherwise in case context switch happens,
+ *	system call of first process (i.e in ILAT) will be
+ *	carried forward to the switched process.
+ *	2. Removed Constant references for the following
+ *		a.  IPEND
+ *		b.  EXCAUSE mask
+ *		c.  PAGE Mask
+ */
+
+/*
+ * NOTE: This code handles signal-recognition, which happens every time
+ * after a timer-interrupt and after each system call.
+ */
+
+
+#include <linux/linkage.h>
+#include <asm/blackfin.h>
+#include <asm/unistd.h>
+#include <asm/errno.h>
+#include <asm/thread_info.h>  /* TIF_NEED_RESCHED */
+#include <asm/asm-offsets.h>
+
+.data
+ALIGN
+extable:
+	.long ex_syscall;	/* 0 */
+	.long ex_soft_bp
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_spinlock
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c		/* 8 */
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_single_step	/* 16 - STEP */
+	.long ex_trap_c		/* 17 - OVFLOW */
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c		/* 24 */
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c		/* 32 */
+	.long ex_trap_c		/* 33 - UNDEF_I */
+	.long ex_trap_c		/* 34 - ILGAL_I */
+	.long ex_dcplb		/* 35 - CPLB_VL */
+	.long ex_trap_c		/* 36 - MISALI_D */
+	.long ex_trap_c		/* 37 - UNCOV */
+	.long ex_dcplb		/* 38 - CPLB_M */
+	.long ex_trap_c		/* 39 - CPLB_MHIT */
+	.long ex_trap_c		/* 40 - WATCH */
+	.long ex_trap_c		/* 41 - ISTRU_VL */
+	.long ex_trap_c		/* 42 - MISALI_I */
+	.long ex_icplb		/* 43 - CPLB_I_VL */
+	.long ex_icplb		/* 44 - CPLB_I_M */
+	.long ex_trap_c		/* 45 - CPLB_I_MHIT */
+	.long ex_trap_c		/* 46 - ILL_RES */
+	.long ex_trap_c
+	.long ex_trap_c		/* 48 */
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c		/* 56 */
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+	.long ex_trap_c
+.text
+
+/* Slightly simplified and streamlined entry point for CPLB misses.
+ * This one does not lower the level to IRQ5, and thus can be used to
+ * patch up CPLB misses on the kernel stack.
+ */
+ENTRY(ex_dcplb)
+	/*
+	 * Work around an anomaly: if we see a new DCPLB fault, return
+	 * without doing anything.  Then, if we get the same fault again,
+	 * handle it.
+ 	 */
+	p5.l = _last_cplb_fault_retx;
+	p5.h = _last_cplb_fault_retx;
+	r7 = [p5];
+	r6 = retx;
+	[p5] = r6;
+	cc = r6 == r7;
+	if !cc jump exception_do_nothing;
+	/* fall through */
+
+ENTRY(ex_icplb)
+	(R7:6,P5:4) = [sp++];
+	ASTAT = [sp++];
+	SAVE_ALL_SYS
+	call __cplb_hdr;
+	RESTORE_ALL_SYS
+	SP = RETN;
+	rtx;
+
+ENTRY(ex_spinlock)
+	/* Transform this into a syscall - twiddle the syscall vector.  */
+	p5.l = lo(EVT15);
+	p5.h = hi(EVT15);
+	r7.l = spinlock_bh;
+	r7.h = spinlock_bh;
+	[p5] = r7;
+	csync;
+	/* Fall through.  */
+
+ENTRY(ex_syscall)
+	(R7:6,P5:4) = [sp++];
+	ASTAT = [sp++];
+	raise 15;		/* invoked by TRAP #0, for sys call */
+	sp = retn;
+	rtx
+
+ENTRY(spinlock_bh)
+	SAVE_ALL_SYS
+	/* To end up here, vector 15 was changed - so we have to change it
+	 * back.
+	 */
+	p0.l = lo(EVT15);
+	p0.h = hi(EVT15);
+	p1.l = _evt_system_call;
+	p1.h = _evt_system_call;
+	[p0] = p1;
+	csync;
+	r0 = [sp + PT_R0];
+	sp += -12;
+	call _sys_bfin_spinlock;
+	sp += 12;
+	[SP + PT_R0] = R0;
+	RESTORE_ALL_SYS
+	rti;
+
+ENTRY(ex_soft_bp)
+	r7 = retx;
+	r7 += -2;
+	retx = r7;
+	jump.s ex_trap_c;
+
+ENTRY(ex_single_step)
+	r7 = syscfg;
+	bitclr (r7, 0);
+	syscfg = R7;
+	/* 1. Check if in interrupt handler.
+	 * 2. If not, call ex_trap_c.
+	 */
+	p5.l = lo(IPEND);
+	p5.h = hi(IPEND);
+	csync;
+	r7 = [p5];
+	r6 = 0x8 (Z);
+	cc = r7 == r6;
+	if !cc jump exception_do_nothing;
+	r7 = retx;
+	r6 = reti;
+	cc = r7 == r6;
+	if !cc jump ex_trap_c;
+exception_do_nothing:
+	(R7:6,P5:4) = [sp++];
+	ASTAT = [sp++];
+	sp = retn;
+	rtx;
+
+ENTRY(ex_trap_c)
+	/* Call C code (trap_c) to handle the exception, which most
+	 * likely involves sending a signal to the current process.
+	 * To avoid double faults, lower our priority to IRQ5 first.
+	 */
+	P5.h = exception_to_level5;
+	P5.l = exception_to_level5;
+	p4.l = lo(EVT5);
+	p4.h = hi(EVT5);
+	[p4] = p5;
+	csync;
+
+	/* Disable all interrupts, but make sure level 5 is enabled so
+	   we can switch to that level.  Save the old mask.  */
+	cli r6;
+	p4.l = excpt_saved_imask;
+	p4.h = excpt_saved_imask;
+	[p4] = r6;
+	r6 = 0x3f;
+	sti r6;
+
+	(R7:6,P5:4) = [sp++];
+	ASTAT = [sp++];
+	SP = RETN;
+	raise 5;
+	rtx;
+
+ENTRY(exception_to_level5)
+	SAVE_ALL_SYS
+
+	/* Restore interrupt mask.  We haven't pushed RETI, so this
+	   doesn't enable interrupts until we return from this handler.  */
+	p4.l = excpt_saved_imask;
+	p4.h = excpt_saved_imask;
+	r6 = [p4];
+	sti r6;
+
+	/* Restore the hardware error vector.  */
+	P5.h = _evt_ivhw;
+	P5.l = _evt_ivhw;
+	p4.l = lo(EVT5);
+	p4.h = hi(EVT5);
+	[p4] = p5;
+	csync;
+
+        p2.l = lo(IPEND);
+        p2.h = hi(IPEND);
+	csync;
+        r0 = [p2];              /* Read current IPEND */
+        [sp + PT_IPEND] = r0;   /* Store IPEND */
+
+	r0 = sp; 	/* stack frame pt_regs pointer argument ==> r0 */
+	SP += -12;
+	call _trap_c;
+	SP += 12;
+	call ret_from_exception;
+	RESTORE_ALL_SYS
+	rti;
+
+ENTRY(_trap) /* Exception: 4th entry into system event table(supervisor mode)*/
+	/* Since the kernel stack can be anywhere, it's not guaranteed to be
+	 * covered by a CPLB.  Switch to an exception stack; use RETN as a
+	 * scratch register (for want of a better option).
+	 */
+	retn = sp;
+	sp.l = exception_stack_top;
+	sp.h = exception_stack_top;
+	/* Try to deal with syscalls quickly.  */
+	[--sp] = ASTAT;
+	[--sp] = (R7:6, P5:4);
+	r7 = SEQSTAT;		/* reason code is in bit 5:0 */
+	r6.l = lo(SEQSTAT_EXCAUSE);
+	r6.h = hi(SEQSTAT_EXCAUSE);
+	r7 = r7 & r6;
+	p5.h = extable;
+	p5.l = extable;
+	p4 = r7;
+	p5 = p5 + (p4 << 2);
+	p4 = [p5];
+	jump (p4);
+
+badsys:
+	r7 = -ENOSYS; 		/* signextending enough */
+	[sp + PT_R0] = r7;	/* return value from system call */
+	rti;
+
+ENTRY(_execve)
+	link SIZEOF_PTREGS;
+	p0 = sp;
+	r3 = SIZEOF_PTREGS / 4;
+	r4 = 0(x);
+0:
+	[p0++] = r4;
+	r3 += -1;
+	cc = r3 == 0;
+	if !cc jump 0b (bp);
+
+	p0 = sp;
+	sp += -16;
+	[sp + 12] = p0;
+	call _do_execve;
+	SP += 16;
+	cc = r0 == 0;
+	if ! cc jump 1f;
+	/* Success.  Copy our temporary pt_regs to the top of the kernel
+	 * stack and do a normal exception return.
+	 */
+	r1 = sp;
+	r0 = (-KERNEL_STACK_SIZE) (x);
+	r1 = r1 & r0;
+	p2 = r1;
+	p3 = [p2];
+	r0 = KERNEL_STACK_SIZE - 4 (z);
+	p1 = r0;
+	p1 = p1 + p2;
+
+	p0 = fp;
+	r4 = [p0--];
+	r3 = SIZEOF_PTREGS / 4;
+0:
+	r4 = [p0--];
+	[p1--] = r4;
+	r3 += -1;
+	cc = r3 == 0;
+	if ! cc jump 0b (bp);
+
+	r0 = (KERNEL_STACK_SIZE - SIZEOF_PTREGS) (z);
+	p1 = r0;
+	p1 = p1 + p2;
+	sp = p1;
+	r0 = syscfg;
+	[SP + PT_SYSCFG] = r0;
+	[p3 + (TASK_THREAD + THREAD_KSP)] = sp;
+
+	RESTORE_CONTEXT;
+	rti;
+1:
+	unlink;
+	rts;
+
+ENTRY(system_call)
+	/* Store IPEND */
+        p2.l = lo(IPEND);
+        p2.h = hi(IPEND);
+	csync;
+	r0 = [p2];
+	[sp + PT_IPEND] = r0;
+
+	/* Store RETS for now */
+	r0 = rets;
+	[sp + PT_RESERVED] = r0;
+	/* Set the stack for the current process */
+	r7 = sp;
+	r6.l = lo(ALIGN_PAGE_MASK);
+	r6.h = hi(ALIGN_PAGE_MASK);
+	r7 = r7 & r6;  		/*thread_info*/
+	p2 = r7;
+	p2 = [p2];
+
+	[p2+(TASK_THREAD+THREAD_KSP)] = sp;
+
+	/* Check the System Call */
+	r7 = __NR_syscall;
+	/*System call number is passed in P0 */
+	r5 = p0;
+	cc = r5 < r7;
+	if ! cc jump badsys;
+
+	/* Execute the appropriate system call */
+
+	p4 = r5;
+	p5.l = sys_call_table;
+	p5.h = sys_call_table;
+	p5 = p5 + (p4 << 2);
+	r0 = [sp + PT_R0];
+	r1 = [sp + PT_R1];
+	r2 = [sp + PT_R2];
+	p5 = [p5];
+
+   /* are we tracing syscalls?*/
+        r7 = sp;
+        r6.l = lo(ALIGN_PAGE_MASK);
+        r6.h = hi(ALIGN_PAGE_MASK);
+        r7 = r7 & r6;
+        p2 = r7;
+        r7 = [p2+TI_FLAGS];
+        CC = BITTST(r7,TIF_SYSCALL_TRACE);
+        if CC JUMP sys_trace;
+
+	[--sp] = r4;
+	[--sp] = r3;
+	SP += -12;
+	call (p5);
+	SP += 20;
+	[sp + PT_R0] = r0;
+
+resume_userspace:
+	r7 = sp;
+	r4.l = lo(ALIGN_PAGE_MASK);
+	r4.h = hi(ALIGN_PAGE_MASK);
+	r7 = r7 & r4;		/*thread_info->flags*/
+	p5 = r7;
+resume_userspace_1:
+	/* Disable interrupts.  */
+	[--sp] = reti;
+	reti = [sp++];
+
+	r7 = [p5 + TI_FLAGS];
+	r4 = _TIF_WORK_MASK;
+	r7 =  r7 & r4;
+
+syscall_resched:
+	cc = BITTST(r7, TIF_NEED_RESCHED);
+	if !cc jump syscall_sigpending;
+
+	/* Reenable interrupts.  */
+	[--sp] = reti;
+	r0 = [sp++];
+
+	SP += -12;
+	call _schedule;
+	SP += 12;
+
+	jump resume_userspace_1;
+
+syscall_sigpending:
+	cc = BITTST(r7, TIF_SIGPENDING);
+	if !cc jump syscall_really_exit;
+
+	/* Reenable interrupts.  */
+	[--sp] = reti;
+	r0 = [sp++];
+
+	r0 = 0;
+	r1 = sp;
+	SP += -12;
+	call _do_signal;
+	SP += 12;
+
+syscall_really_exit:
+	r5 = [sp + PT_RESERVED];
+	rets = r5;
+	rts;
+
+sys_trace:
+        [--sp] = r3;
+        [--sp] = r2;
+        [--sp] = r1;
+        [--sp] = r0;
+        [--sp] = p5;
+        [--sp] = p2;
+        [--sp] = p1;
+        [--sp] = p0;
+        r1 = 0;
+        call _syscall_trace;
+        p0 = [sp++];
+        p1 = [sp++];
+        p2 = [sp++];
+        p5 = [sp++];
+        r0 = [sp++];
+        r1 = [sp++];
+        r2 = [sp++];
+        r3 = [sp++];
+
+
+        [--sp] = r4;
+        [--sp] = r3;
+         SP += -12;
+        call (p5);
+        SP += 20;
+        [sp + PT_R0] = r0;
+
+        [--sp] = r3;
+        [--sp] = r2;
+        [--sp] = r1;
+        [--sp] = r0;
+        [--sp] = p5;
+        [--sp] = p2;
+        [--sp] = p1;
+        [--sp] = p0;
+        r1 = 1;
+        call _syscall_trace;
+        p0 = [sp++];
+        p1 = [sp++];
+        p2 = [sp++];
+        p5 = [sp++];
+        r0 = [sp++];
+        r1 = [sp++];
+        r2 = [sp++];
+        r3 = [sp++];
+
+        jump resume_userspace;
+
+ENTRY(resume)
+	/*
+	 * Beware - when entering resume, prev (the current task) is
+	 * in r0, next (the new task) is in r1.
+	 */
+	p0 = r0;
+	p1 = r1;
+	[--sp] = rets;
+	[--sp] = fp;
+
+	/* save usp */
+	p2 = usp;
+	[p0+(TASK_THREAD+THREAD_USP)] = p2;
+
+	/* save current kernel stack pointer */
+	[p0+(TASK_THREAD+THREAD_KSP)] = sp;
+
+	/* save program counter */
+	r1.l = new_old_task;
+	r1.h = new_old_task;
+	[p0+(TASK_THREAD+THREAD_PC)] = r1;
+
+	/* restore the kernel stack pointer */
+	sp = [p1+(TASK_THREAD+THREAD_KSP)];
+
+	/* restore user stack pointer */
+	p0 = [p1+(TASK_THREAD+THREAD_USP)];
+	usp = p0;
+
+	/* restore pc */
+	p0 = [p1+(TASK_THREAD+THREAD_PC)];
+	jump (p0);
+
+	/*
+	 * Following code actually lands up in a new (old) task.
+	 */
+
+new_old_task:
+	fp = [sp++];
+	rets = [sp++];
+
+	/*
+	 * When we come out of resume, r0 carries "old" task, becuase we are
+	 * in "new" task.
+	 */
+	rts;
+
+ENTRY(ret_from_exception)
+        p2.l = lo(IPEND);
+        p2.h = hi(IPEND);
+
+	csync;
+	r0 = [p2];
+	[sp + PT_IPEND] = r0;
+
+1:
+	r1 = 0x37(Z);
+	r2 = ~r1;
+	r2.h = 0;
+	r0 = r2 & r0;
+        cc = r0 == 0;
+        if !cc jump 4f;	/* if not return to user mode, get out */
+
+	/* Make sure any pending system call or deferred exception
+	 * return in ILAT for this process to get executed, otherwise
+	 * in case context switch happens, system call of
+	 * first process (i.e in ILAT) will be carried
+	 * forward to the switched process
+	 */
+
+        p2.l = lo(ILAT);
+        p2.h = hi(ILAT);
+        r0 = [p2];
+	r1 = (EVT_IVG14 | EVT_IVG15) (z);
+        r0 = r0 & r1;
+        cc = r0 == 0;
+        if !cc jump 5f;
+
+	/* Set the stack for the current process */
+	r7 = sp;
+	r4.l = lo(ALIGN_PAGE_MASK);
+	r4.h = hi(ALIGN_PAGE_MASK);
+	r7 = r7 & r4;		/*thread_info->flags*/
+	p5 = r7;
+	r7 = [p5 + TI_FLAGS];
+	r4 = _TIF_WORK_MASK;
+	r7 =  r7 & r4;
+	cc = r7 == 0;
+	if cc jump 4f;
+
+	p0.l = lo(EVT15);
+	p0.h = hi(EVT15);
+	p1.l = _schedule_and_signal;
+	p1.h = _schedule_and_signal;
+	[p0] = p1;
+	csync;
+	raise 15;		/* raise evt14 to do signal or reschedule */
+4:
+        r0 = syscfg;
+        bitclr(r0, 0);
+        syscfg = r0;
+5:
+	rts;
+
+ENTRY(return_from_int)
+	/* If someone else already raised IRQ 15, do nothing.  */
+	csync;
+        p2.l = lo(ILAT);
+        p2.h = hi(ILAT);
+        r0 = [p2];
+	cc = bittst (r0, EVT_IVG15_P);
+        if cc jump 2f;
+
+	/* if not return to user mode, get out */
+        p2.l = lo(IPEND);
+        p2.h = hi(IPEND);
+        r0 = [p2];
+	r1 = 0x17(Z);
+	r2 = ~r1;
+	r2.h = 0;
+	r0 = r2 & r0;
+        r1 = 1;
+        r1 = r0 - r1;
+        r2 = r0 & r1;
+        cc = r2 == 0;
+        if !cc jump 2f;
+
+	/* Lower the interrupt level to 15.  */
+	p0.l = lo(EVT15);
+	p0.h = hi(EVT15);
+	p1.l = schedule_and_signal_from_int;
+	p1.h = schedule_and_signal_from_int;
+	[p0] = p1;
+	csync;
+	r0 = 0x801f (z);
+	STI r0;
+	raise 15;	/* raise evt15 to do signal or reschedule */
+	rti;
+2:
+	rts;
+
+ENTRY(_lower_to_irq14)
+	r0 = 0x401f;
+	sti r0;
+	raise 14;
+	rti;
+ENTRY(_evt14_softirq)
+#ifdef CONFIG_DEBUG_HWERR
+	r0 = 0x3f;
+	sti r0;
+#else
+	cli r0;
+#endif
+	[--sp] = RETI;
+	SP += 4;
+	rts;
+
+schedule_and_signal_from_int:
+	/* To end up here, vector 15 was changed - so we have to change it
+	 * back.
+	 */
+	p0.l = lo(EVT15);
+	p0.h = hi(EVT15);
+	p1.l = _evt_system_call;
+	p1.h = _evt_system_call;
+	[p0] = p1;
+	csync;
+	p1 = rets;
+	[sp + PT_RESERVED] = p1;
+
+	p0.l = _irq_flags;
+	p0.h = _irq_flags;
+	r0 = [p0];
+	sti r0;
+
+	jump.s resume_userspace;
+
+_schedule_and_signal:
+	SAVE_CONTEXT_SYSCALL
+	/* To end up here, vector 15 was changed - so we have to change it
+	 * back.
+	 */
+	p0.l = lo(EVT15);
+	p0.h = hi(EVT15);
+	p1.l = _evt_system_call;
+	p1.h = _evt_system_call;
+	[p0] = p1;
+	csync;
+	p0.l = lo(1f);
+	p0.h = lo(1f);
+	[sp + PT_RESERVED] = P0;
+	call resume_userspace;
+1:
+	RESTORE_CONTEXT
+	rti;
+
+.data
+ALIGN
+ENTRY(sys_call_table)
+	.long _sys_ni_syscall	/* 0  -  old "setup()" system call*/
+	.long _sys_exit
+	.long _sys_fork
+	.long _sys_read
+	.long _sys_write
+	.long _sys_open		/* 5 */
+	.long _sys_close
+	.long _sys_waitpid
+	.long _sys_creat
+	.long _sys_link
+	.long _sys_unlink	/* 10 */
+	.long _sys_execve
+	.long _sys_chdir
+	.long _sys_time
+	.long _sys_mknod
+	.long _sys_chmod		/* 15 */
+	.long _sys_chown16
+	.long _sys_ni_syscall	/* old break syscall holder */
+	.long _sys_stat
+	.long _sys_lseek
+	.long _sys_getpid	/* 20 */
+	.long _sys_mount
+	.long _sys_oldumount
+	.long _sys_setuid16
+	.long _sys_getuid16
+	.long _sys_stime		/* 25 */
+	.long _sys_ptrace
+	.long _sys_alarm
+	.long _sys_fstat
+	.long _sys_pause
+	.long _sys_utime		/* 30 */
+	.long _sys_ni_syscall	/* old stty syscall holder */
+	.long _sys_ni_syscall	/* old gtty syscall holder */
+	.long _sys_access
+	.long _sys_nice
+	.long _sys_ni_syscall	/* 35 */ /* old ftime syscall holder */
+	.long _sys_sync
+	.long _sys_kill
+	.long _sys_rename
+	.long _sys_mkdir
+	.long _sys_rmdir		/* 40 */
+	.long _sys_dup
+	.long _sys_pipe
+	.long _sys_times
+	.long _sys_ni_syscall	/* old prof syscall holder */
+	.long _sys_brk		/* 45 */
+	.long _sys_setgid16
+	.long _sys_getgid16
+	.long _sys_signal
+	.long _sys_geteuid16
+	.long _sys_getegid16	/* 50 */
+	.long _sys_acct
+	.long _sys_umount	/* recycled never used phys() */
+	.long _sys_ni_syscall	/* old lock syscall holder */
+	.long _sys_ioctl
+	.long _sys_fcntl		/* 55 */
+	.long _sys_ni_syscall	/* old mpx syscall holder */
+	.long _sys_setpgid
+	.long _sys_ni_syscall	/* old ulimit syscall holder */
+	.long _sys_ni_syscall
+	.long _sys_umask		/* 60 */
+	.long _sys_chroot
+	.long _sys_ustat
+	.long _sys_dup2
+	.long _sys_getppid
+	.long _sys_getpgrp	/* 65 */
+	.long _sys_setsid
+	.long _sys_sigaction
+	.long _sys_sgetmask
+	.long _sys_ssetmask
+	.long _sys_setreuid16	/* 70 */
+	.long _sys_setregid16
+	.long _sys_sigsuspend
+	.long _sys_sigpending
+	.long _sys_sethostname
+	.long _sys_setrlimit	/* 75 */
+	.long _sys_old_getrlimit
+	.long _sys_getrusage
+	.long _sys_gettimeofday
+	.long _sys_settimeofday
+	.long _sys_getgroups16	/* 80 */
+	.long _sys_setgroups16
+	.long _old_select
+	.long _sys_symlink
+	.long _sys_lstat
+	.long _sys_readlink	/* 85 */
+	.long _sys_uselib
+	.long _sys_ni_syscall	/* sys_swapon */
+	.long _sys_reboot
+	.long _old_readdir
+	.long _old_mmap		/* 90 */
+	.long _sys_munmap
+	.long _sys_truncate
+	.long _sys_ftruncate
+	.long _sys_fchmod
+	.long _sys_fchown16	/* 95 */
+	.long _sys_getpriority
+	.long _sys_setpriority
+	.long _sys_ni_syscall	/* old profil syscall holder */
+	.long _sys_statfs
+	.long _sys_fstatfs	/* 100 */
+	.long _sys_ni_syscall
+	.long _sys_socketcall
+	.long _sys_syslog
+	.long _sys_setitimer
+	.long _sys_getitimer	/* 105 */
+	.long _sys_newstat
+	.long _sys_newlstat
+	.long _sys_newfstat
+	.long _sys_ni_syscall
+	.long _sys_ni_syscall	/* iopl for i386 */ /* 110 */
+	.long _sys_vhangup
+	.long _sys_ni_syscall	/* obsolete idle() syscall */
+	.long _sys_ni_syscall	/* vm86old for i386 */
+	.long _sys_wait4
+	.long _sys_ni_syscall	/* 115 */ /* sys_swapoff */
+	.long _sys_sysinfo
+	.long _sys_ipc
+	.long _sys_fsync
+	.long _sys_sigreturn
+	.long _sys_clone		/* 120 */
+	.long _sys_setdomainname
+	.long _sys_newuname
+	.long _sys_cacheflush	/* modify_ldt for i386 */
+	.long _sys_adjtimex
+	.long _sys_ni_syscall	/* 125 */ /* sys_mprotect */
+	.long _sys_sigprocmask
+	.long _sys_ni_syscall	/* old "creat_module" */
+	.long _sys_init_module
+	.long _sys_delete_module
+	.long _sys_ni_syscall	/* 130: old "get_kernel_syms" */
+	.long _sys_quotactl
+	.long _sys_getpgid
+	.long _sys_fchdir
+	.long _sys_bdflush
+	.long _sys_sysfs		/* 135 */
+	.long _sys_personality
+	.long _sys_ni_syscall	/* for afs_syscall */
+	.long _sys_setfsuid16
+	.long _sys_setfsgid16
+	.long _sys_llseek	/* 140 */
+	.long _sys_getdents
+	.long _sys_select
+	.long _sys_flock
+	.long _sys_ni_syscall	/* sys_msync */
+	.long _sys_readv		/* 145 */
+	.long _sys_writev
+	.long _sys_getsid
+	.long _sys_fdatasync
+	.long _sys_sysctl
+	.long _sys_ni_syscall	/* 150 */ /* sys_mlock */
+	.long _sys_ni_syscall	/* sys_munlock */
+	.long _sys_ni_syscall	/* sys_mlockall */
+	.long _sys_ni_syscall	/* sys_munlockall */
+	.long _sys_sched_setparam
+	.long _sys_sched_getparam /* 155 */
+	.long _sys_sched_setscheduler
+	.long _sys_sched_getscheduler
+	.long _sys_sched_yield
+	.long _sys_sched_get_priority_max
+	.long _sys_sched_get_priority_min  /* 160 */
+	.long _sys_sched_rr_get_interval
+	.long _sys_nanosleep
+	.long _sys_ni_syscall	/* sys_mremap */
+	.long _sys_setresuid16
+	.long _sys_getresuid16	/* 165 */
+	.long _sys_ni_syscall	/* for vm86 */
+	.long _sys_ni_syscall	/* old "query_module" */
+	.long _sys_poll
+	.long _sys_ni_syscall	/* sys_nfsservctl */
+	.long _sys_setresgid16	/* 170 */
+	.long _sys_getresgid16
+	.long _sys_prctl
+	.long _sys_rt_sigreturn
+	.long _sys_rt_sigaction
+	.long _sys_rt_sigprocmask /* 175 */
+	.long _sys_rt_sigpending
+	.long _sys_rt_sigtimedwait
+	.long _sys_rt_sigqueueinfo
+	.long _sys_rt_sigsuspend
+	.long _sys_pread64	/* 180 */
+	.long _sys_pwrite64
+	.long _sys_lchown16
+	.long _sys_getcwd
+	.long _sys_capget
+	.long _sys_capset	/* 185 */
+	.long _sys_sigaltstack
+	.long _sys_sendfile
+	.long _sys_ni_syscall	/* streams1 */
+	.long _sys_ni_syscall	/* streams2 */
+	.long _sys_vfork		/* 190 */
+	.long _sys_getrlimit
+	.long _sys_mmap2
+	.long _sys_truncate64
+	.long _sys_ftruncate64
+	.long _sys_stat64	/* 195 */
+	.long _sys_lstat64
+	.long _sys_fstat64
+	.long _sys_chown
+	.long _sys_getuid
+	.long _sys_getgid	/* 200 */
+	.long _sys_geteuid
+	.long _sys_getegid
+	.long _sys_setreuid
+	.long _sys_setregid
+	.long _sys_getgroups	/* 205 */
+	.long _sys_setgroups
+	.long _sys_fchown
+	.long _sys_setresuid
+	.long _sys_getresuid
+	.long _sys_setresgid	/* 210 */
+	.long _sys_getresgid
+	.long _sys_lchown
+	.long _sys_setuid
+	.long _sys_setgid
+	.long _sys_setfsuid	/* 215 */
+	.long _sys_setfsgid
+	.long _sys_pivot_root
+	.long _sys_ni_syscall	/* sys_mincore */
+	.long _sys_ni_syscall	/* sys_madvise */
+	.long _sys_getdents64	/* 220 */
+	.long _sys_fcntl64
+	.long _sys_ni_syscall	/* reserved for TUX */
+	.long _sys_ni_syscall
+	.long _sys_gettid
+	.long _sys_ni_syscall	/* 225 */ /* sys_readahead */
+	.long _sys_setxattr
+	.long _sys_lsetxattr
+	.long _sys_fsetxattr
+	.long _sys_getxattr
+	.long _sys_lgetxattr	/* 230 */
+	.long _sys_fgetxattr
+	.long _sys_listxattr
+	.long _sys_llistxattr
+	.long _sys_flistxattr
+	.long _sys_removexattr	/* 235 */
+	.long _sys_lremovexattr
+	.long _sys_fremovexattr
+	.long _sys_tkill
+	.long _sys_sendfile64
+	.long _sys_futex		/* 240 */
+	.long _sys_sched_setaffinity
+	.long _sys_sched_getaffinity
+	.long _sys_ni_syscall	/* sys_set_thread_area */
+	.long _sys_ni_syscall	/* sys_get_thread_area */
+	.long _sys_io_setup	/* 245 */
+	.long _sys_io_destroy
+	.long _sys_io_getevents
+	.long _sys_io_submit
+	.long _sys_io_cancel
+	.long _sys_ni_syscall	/* 250 */ /* sys_alloc_hugepages */
+	.long _sys_ni_syscall	/* sys_freec_hugepages */
+	.long _sys_exit_group
+	.long _sys_lookup_dcookie
+	.long _sys_bfin_spinlock
+	.rept 2
+	.long _sys_ni_syscall
+	.endr
+excpt_saved_imask:
+	.long 0;
+/* Put this in the kernel data section - that should always be covered by
+ * a CPLB.
+ */
+exception_stack:
+	.rept 1024
+	.long 0;
+	.endr
+exception_stack_top:
Index: git/linux-2.6/arch/blackfin/mach-common/flush.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-common/flush.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,401 @@
+ /*
+ * File:        arch/blackfin/mach-common/flush.S
+ * Based on:
+ * Author:      LG SOft India
+ *              COPYRIGHT 2005 Analog Devices
+ * Created:     ?
+ * Description: This is an external function being called by the user
+ * application through __flush_cache_all. Currently this function
+ * serves the purpose of flushing all the pending writes in
+ * in the instruction cache.
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/linkage.h>
+#include <asm/cplb.h>
+#include <asm/blackfin.h>
+
+.text
+
+
+ENTRY(_flush_instruction_cache)
+	[--SP] = ( R7:6, P5:4 );
+	LINK 12;
+	SP += -12;
+	P5.H = (ICPLB_ADDR0 >> 16);
+	P5.L = (ICPLB_ADDR0 & 0xFFFF);
+	P4.H = (ICPLB_DATA0 >> 16);
+	P4.L = (ICPLB_DATA0 & 0xFFFF);
+	R7 = CPLB_VALID | CPLB_L1_CHBL;
+	R6 = 16;
+inext:	R0 = [P5++];
+	R1 = [P4++];
+	[--SP] =  RETS;
+	CALL _icplb_flush;	/* R0 = page, R1 = data*/
+	RETS = [SP++];
+iskip:	R6 += -1;
+	CC = R6;
+	IF CC JUMP inext (bp);
+	SSYNC;
+	SP += 12;
+	UNLINK;
+	( R7:6, P5:4 ) = [SP++];
+	RTS;
+
+/* This is an internal function to flush all pending
+ * writes in the cache associated with a particular ICPLB.
+ *
+ * R0 -  page's start address
+ * R1 -  CPLB's data field.
+ */
+
+.align 2
+ENTRY(_icplb_flush)
+	[--SP] = ( R7:4, P5:3 );
+
+	/* If it's a 1K or 4K page, then it's quickest to
+	 * just systematically flush all the addresses in
+	 * the page, regardless of whether they're in the
+	 * cache, or dirty. If it's a 1M or 4M page, there
+	 * are too many addresses, and we have to search the
+	 * cache for lines corresponding to the page.
+	 */
+
+	CC = BITTST(R1, 17);	/* 1MB or 4MB */
+	IF !CC JUMP iflush_whole_page;
+
+	/* We're only interested in the page's size, so extract
+	 * this from the CPLB (bits 17:16), and scale to give an
+	 * offset into the page_size and page_prefix tables.
+	 */
+
+	R1 <<= 14;
+	R1 >>= 30;
+	R1 <<= 2;
+
+	/* We can also determine the sub-bank used, because this is
+	 * taken from bits 13:12 of the address.
+	 */
+
+	R3 = ((12<<8)|2);		/* Extraction pattern */
+	nop;				/*Anamoly 05000209*/
+	R4 = EXTRACT(R0, R3.L) (Z);	/* Extract bits*/
+	R3.H = R4.L << 0 ;		/* Save in extraction pattern for
+					 * later deposit.
+					 */
+
+
+	/* So:
+	 * R0 = Page start
+	 * R1 = Page length (actually, offset into size/prefix tables)
+	 * R3 = sub-bank deposit values
+  	 *
+	 * The cache has 2 Ways, and 64 sets, so we iterate through
+	 * the sets, accessing the tag for each Way, for our Bank and
+	 * sub-bank, looking for dirty, valid tags that match our
+	 * address prefix.
+	 */
+
+	P5.L = (ITEST_COMMAND & 0xFFFF);
+	P5.H = (ITEST_COMMAND >> 16);
+	P4.L = (ITEST_DATA0 & 0xFFFF);
+	P4.H = (ITEST_DATA0 >> 16);
+
+	P0.L = page_prefix_table;
+	P0.H = page_prefix_table;
+	P1 = R1;
+	R5 = 0;			/* Set counter*/
+	P0 = P1 + P0;
+	R4 = [P0];		/* This is the address prefix*/
+
+	/* We're reading (bit 1==0) the tag (bit 2==0), and we
+	 * don't care about which double-word, since we're only
+	 * fetching tags, so we only have to set Set, Bank,
+	 * Sub-bank and Way.
+	 */
+
+	P2 = 4;
+	LSETUP (ifs1, ife1) LC1 = P2;
+ifs1:	P0 = 32;		/* iterate over all sets*/
+	LSETUP (ifs0, ife0) LC0 = P0;
+ifs0:	R6 = R5 << 5;		/* Combine set*/
+	R6.H = R3.H << 0 ;	/* and sub-bank*/
+	[P5] = R6;		/* Issue Command*/
+	SSYNC;			/* CSYNC will not work here :(*/
+	R7 = [P4];		/* and read Tag.*/
+	CC = BITTST(R7, 0);	/* Check if valid*/
+	IF !CC JUMP ifskip;	/* and skip if not.*/
+
+	/* Compare against the page address. First, plant bits 13:12
+	 * into the tag, since those aren't part of the returned data.
+	 */
+
+	R7 = DEPOSIT(R7, R3);	/* set 13:12*/
+	R1 = R7 & R4;		/* Mask off lower bits*/
+	CC = R1 == R0;		/* Compare against page start.*/
+	IF !CC JUMP ifskip;	/* Skip it if it doesn't match.*/
+
+	/* Tag address matches against page, so this is an entry
+	 * we must flush.
+	 */
+
+	R7 >>= 10;		/* Mask off the non-address bits*/
+	R7 <<= 10;
+	P3 = R7;
+	IFLUSH [P3];		/* And flush the entry*/
+ifskip:
+ife0:	R5 += 1;		/* Advance to next Set*/
+ife1:	NOP;
+
+ifinished:
+	SSYNC;			/* Ensure the data gets out to mem.*/
+
+	/*Finished. Restore context.*/
+	( R7:4, P5:3 ) = [SP++];
+	RTS;
+
+iflush_whole_page:
+	/* It's a 1K or 4K page, so quicker to just flush the
+	 * entire page.
+	 */
+
+	P1 = 32;		/* For 1K pages*/
+	P2 = P1 << 2;		/* For 4K pages*/
+	P0 = R0;		/* Start of page*/
+	CC = BITTST(R1, 16);	/* Whether 1K or 4K*/
+	IF CC P1 = P2;
+	P1 += -1;		/* Unroll one iteration*/
+	SSYNC;
+	IFLUSH [P0++];		/* because CSYNC can't end loops.*/
+	LSETUP (isall, ieall) LC0 = P1;
+isall:IFLUSH [P0++];
+ieall: NOP;
+	SSYNC;
+	JUMP ifinished;
+
+/* This is an external function being called by the user
+ * application through __flush_cache_all. Currently this function
+ * serves the purpose of flushing all the pending writes in
+ * in the data cache.
+ */
+
+ENTRY(_flush_data_cache)
+	[--SP] = ( R7:6, P5:4 );
+	LINK 12;
+	SP += -12;
+	P5.H = (DCPLB_ADDR0 >> 16);
+	P5.L = (DCPLB_ADDR0 & 0xFFFF);
+	P4.H = (DCPLB_DATA0 >> 16);
+	P4.L = (DCPLB_DATA0 & 0xFFFF);
+	R7 = CPLB_VALID | CPLB_L1_CHBL | CPLB_DIRTY (Z);
+	R6 = 16;
+next:	R0 = [P5++];
+	R1 = [P4++];
+	CC = BITTST(R1, 14);	/* Is it write-through?*/
+	IF CC JUMP skip;	/* If so, ignore it.*/
+	R2 = R1 & R7;		/* Is it a dirty, cached page?*/
+	CC = R2;
+	IF !CC JUMP skip;	/* If not, ignore it.*/
+	[--SP] = RETS;
+	CALL _dcplb_flush;	/* R0 = page, R1 = data*/
+	RETS = [SP++];
+skip:	R6 += -1;
+	CC = R6;
+	IF CC JUMP next (bp);
+	SSYNC;
+	SP += 12;
+	UNLINK;
+	( R7:6, P5:4 ) = [SP++];
+	RTS;
+
+/* This is an internal function to flush all pending
+ * writes in the cache associated with a particular DCPLB.
+ *
+ * R0 -  page's start address
+ * R1 -  CPLB's data field.
+ */
+
+.align 2
+ENTRY(_dcplb_flush)
+	[--SP] = ( R7:4, P5:3 );
+
+	/* If it's a 1K or 4K page, then it's quickest to
+	 * just systematically flush all the addresses in
+	 * the page, regardless of whether they're in the
+	 * cache, or dirty. If it's a 1M or 4M page, there
+	 * are too many addresses, and we have to search the
+	 * cache for lines corresponding to the page.
+	 */
+
+	CC = BITTST(R1, 17);	/* 1MB or 4MB */
+	IF !CC JUMP dflush_whole_page;
+
+	/* We're only interested in the page's size, so extract
+	 * this from the CPLB (bits 17:16), and scale to give an
+	 * offset into the page_size and page_prefix tables.
+	 */
+
+	R1 <<= 14;
+	R1 >>= 30;
+	R1 <<= 2;
+
+	/* The page could be mapped into Bank A or Bank B, depending
+	 * on (a) whether both banks are configured as cache, and
+	 * (b) on whether address bit A[x] is set. x is determined
+	 * by DCBS in DMEM_CONTROL
+	 */
+
+	R2 = 0;			/* Default to Bank A (Bank B would be 1)*/
+
+	P0.L = (DMEM_CONTROL & 0xFFFF);
+	P0.H = (DMEM_CONTROL >> 16);
+
+	R3 = [P0];		/* If Bank B is not enabled as cache*/
+	CC = BITTST(R3, 2);	/* then Bank A is our only option.*/
+	IF CC JUMP bank_chosen;
+
+	R4 = 1<<14;		/* If DCBS==0, use A[14].*/
+	R5 = R4 << 7;		/* If DCBS==1, use A[23];*/
+	CC = BITTST(R3, 4);
+	IF CC R4 = R5;		/* R4 now has either bit 14 or bit 23 set.*/
+	R5 = R0 & R4;		/* Use it to test the Page address*/
+	CC = R5;		/* and if that bit is set, we use Bank B,*/
+	R2 = CC;		/* else we use Bank A.*/
+	R2 <<= 23;		/* The Bank selection's at posn 23.*/
+
+bank_chosen:
+
+	/* We can also determine the sub-bank used, because this is
+	 * taken from bits 13:12 of the address.
+	 */
+
+	R3 = ((12<<8)|2);		/* Extraction pattern */
+	nop;				/*Anamoly 05000209*/
+	R4 = EXTRACT(R0, R3.L) (Z);	/* Extract bits*/
+	R3.H = R4.L << 0 ;		/* Save in extraction pattern for
+					 * later deposit.
+					 */
+
+	/* So:
+	 * R0 = Page start
+	 * R1 = Page length (actually, offset into size/prefix tables)
+	 * R2 = Bank select mask
+	 * R3 = sub-bank deposit values
+  	 *
+	 * The cache has 2 Ways, and 64 sets, so we iterate through
+	 * the sets, accessing the tag for each Way, for our Bank and
+	 * sub-bank, looking for dirty, valid tags that match our
+	 * address prefix.
+	 */
+
+	P5.L = (DTEST_COMMAND & 0xFFFF);
+	P5.H = (DTEST_COMMAND >> 16);
+	P4.L = (DTEST_DATA0 & 0xFFFF);
+	P4.H = (DTEST_DATA0 >> 16);
+
+	P0.L = page_prefix_table;
+	P0.H = page_prefix_table;
+	P1 = R1;
+	R5 = 0;			/* Set counter*/
+	P0 = P1 + P0;
+	R4 = [P0];		/* This is the address prefix*/
+
+
+	/* We're reading (bit 1==0) the tag (bit 2==0), and we
+	 * don't care about which double-word, since we're only
+	 * fetching tags, so we only have to set Set, Bank,
+	 * Sub-bank and Way.
+	 */
+
+	P2 = 2;
+	LSETUP (fs1, fe1) LC1 = P2;
+fs1:	P0 = 64;		/* iterate over all sets*/
+	LSETUP (fs0, fe0) LC0 = P0;
+fs0:	R6 = R5 << 5;		/* Combine set*/
+	R6.H = R3.H << 0 ;	/* and sub-bank*/
+	R6 = R6 | R2;		/* and Bank. Leave Way==0 at first.*/
+	BITSET(R6,14);
+	[P5] = R6;		/* Issue Command*/
+	SSYNC;
+	R7 = [P4];		/* and read Tag.*/
+	CC = BITTST(R7, 0);	/* Check if valid*/
+	IF !CC JUMP fskip;	/* and skip if not.*/
+	CC = BITTST(R7, 1);	/* Check if dirty*/
+	IF !CC JUMP fskip;	/* and skip if not.*/
+
+	/* Compare against the page address. First, plant bits 13:12
+	 * into the tag, since those aren't part of the returned data.
+	 */
+
+	R7 = DEPOSIT(R7, R3);	/* set 13:12*/
+	R1 = R7 & R4;		/* Mask off lower bits*/
+	CC = R1 == R0;		/* Compare against page start.*/
+	IF !CC JUMP fskip;	/* Skip it if it doesn't match.*/
+
+	/* Tag address matches against page, so this is an entry
+	 * we must flush.
+	 */
+
+	R7 >>= 10;		/* Mask off the non-address bits*/
+	R7 <<= 10;
+	P3 = R7;
+	SSYNC;
+	FLUSHINV [P3];		/* And flush the entry*/
+fskip:
+fe0:	R5 += 1;		/* Advance to next Set*/
+fe1:	BITSET(R2, 26);		/* Go to next Way.*/
+
+dfinished:
+	SSYNC;			/* Ensure the data gets out to mem.*/
+
+	/*Finished. Restore context.*/
+	( R7:4, P5:3 ) = [SP++];
+	RTS;
+
+dflush_whole_page:
+
+	/* It's a 1K or 4K page, so quicker to just flush the
+	 * entire page.
+	 */
+
+	P1 = 32;		/* For 1K pages*/
+	P2 = P1 << 2;		/* For 4K pages*/
+	P0 = R0;		/* Start of page*/
+	CC = BITTST(R1, 16);	/* Whether 1K or 4K*/
+	IF CC P1 = P2;
+	P1 += -1;		/* Unroll one iteration*/
+    SSYNC;
+	FLUSHINV [P0++];	/* because CSYNC can't end loops.*/
+	LSETUP (eall, eall) LC0 = P1;
+eall:	FLUSHINV [P0++];
+	SSYNC;
+	JUMP dfinished;
+
+.align 4;
+page_prefix_table:
+.byte4 	0xFFFFFC00;	/* 1K */
+.byte4	0xFFFFF000;	/* 4K */
+.byte4	0xFFF00000;	/* 1M */
+.byte4	0xFFC00000;	/* 4M */
+.page_prefix_table.end:
Index: git/linux-2.6/arch/blackfin/mach-common/interrupt.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-common/interrupt.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,254 @@
+ /*
+ * File:        arch/blackfin/mach-common/interrupt.S
+ * Based on:
+ * Author:      D. Jeff Dionne <jeff@ryeham.ee.ryerson.ca>
+ *              Kenneth Albanowski <kjahds@kjahds.com>
+ *              COPYRIGHT 2005 Analog Devices
+ * Created:     ?
+ * Description: Interrupt Entries
+ *
+ * Rev:
+ *
+ * Modified:    LG Soft India
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#define ASSEMBLY
+
+#include <asm/blackfin.h>
+#include <asm/mach/irq.h>
+#include <linux/autoconf.h>
+#include <linux/linkage.h>
+#include <asm/entry.h>
+#include <asm/asm-offsets.h>
+
+.text
+.align 4 	/* just in case */
+
+/*
+ * initial interrupt handlers
+ */
+
+#ifndef CONFIG_KGDB
+ 	/* interrupt routine for emulation - 0 */
+	/* Currently used only if GDB stub is not in - invalid */
+	/* gdb-stub set the evt itself */
+	/* save registers for post-mortem only */
+ENTRY(_evt_emulation)
+	SAVE_ALL_SYS
+#ifdef CONFIG_FRAME_POINTER
+	fp = 0;
+#endif
+	r0 = IRQ_EMU;
+	r1 = sp;
+	SP += -12;
+	call _irq_panic;
+	SP += 12;
+	/* - GDB stub fills this in by itself (if defined) */
+	rte;
+#endif
+
+/* interrupt routine for ivhw - 5 */
+ENTRY(_evt_ivhw)
+	SAVE_CONTEXT
+#ifdef CONFIG_FRAME_POINTER
+	fp = 0;
+#endif
+	p0.l = lo(TBUFCTL);
+	p0.h = hi(TBUFCTL);
+	r0 = 1;
+	[p0] = r0;
+	r0 = IRQ_HWERR;
+	r1 = sp;
+
+	r7 = SEQSTAT;           /* reason code is in bit 5:0 */
+	r6.l = lo(SEQSTAT_HWERRCAUSE);
+	r6.h = hi(SEQSTAT_HWERRCAUSE);
+	r7 = r7 & r6;
+	r5 = 0x12;
+	cc = r7 == r5;
+	if cc jump call_do_ovf; /*deal with performance counter overflow*/
+
+	SP += -12;
+	call _irq_panic;
+	SP += 12;
+	rti;
+
+call_do_ovf:
+
+	SP += -12;
+	call _do_irq;
+	SP += 12;
+	call return_from_int;
+
+        RESTORE_CONTEXT
+
+	rti;
+/* interrupt routine for core timer - 6 */
+ENTRY(_evt_timer)
+	SAVE_CONTEXT
+#ifdef CONFIG_FRAME_POINTER
+	fp = 0;
+#endif
+	/* SAVE_CONTEXT ignores IPEND; we need to save it since the user_mode
+	   macro accesses it to determine where to account time.  */
+	p2.l = lo(IPEND);
+	p2.h = hi(IPEND);
+	csync;
+	r0 = [p2];
+	[sp + PT_IPEND] = r0;
+
+ 	r0 = EVT_IVTMR_P;
+	r1 =  sp;
+	SP += -12;
+	call _do_irq;
+	SP += 12;
+	call return_from_int;
+	RESTORE_CONTEXT
+	rti;
+
+/* interrupt routine for evt2 - 2.  This is NMI.  */
+ENTRY(_evt_evt2)
+	SAVE_CONTEXT
+#ifdef CONFIG_FRAME_POINTER
+	fp = 0;
+#endif
+	r0 = IRQ_NMI;
+	r1 =  sp;
+	SP += -12;
+	call _asm_do_IRQ;
+	SP += 12;
+	RESTORE_CONTEXT
+	rtn;
+
+/* interrupt routine for evt7 - 7 */
+ENTRY(_evt_evt7)
+	SAVE_CONTEXT
+#ifdef CONFIG_FRAME_POINTER
+	fp = 0;
+#endif
+ 	r0 = EVT_IVG7_P;
+	r1 =  sp;
+	SP += -12;
+	call _do_irq;
+	SP += 12;
+	call return_from_int;
+	RESTORE_CONTEXT
+	rti;
+
+/* interrupt routine for evt8 - 8 */
+ENTRY(_evt_evt8)
+	SAVE_CONTEXT
+#ifdef CONFIG_FRAME_POINTER
+	fp = 0;
+#endif
+	r0 = EVT_IVG8_P;
+	r1 =  sp;
+	SP += -12;
+	call _do_irq;
+	SP += 12;
+	call return_from_int;
+	RESTORE_CONTEXT
+	rti;
+
+/* interrupt routine for evt9 - 9 */
+ENTRY(_evt_evt9)
+	SAVE_CONTEXT
+#ifdef CONFIG_FRAME_POINTER
+	fp = 0;
+#endif
+	r0 = EVT_IVG9_P;
+	r1 =  sp;
+	SP += -12;
+	call _do_irq;
+	SP += 12;
+	call return_from_int;
+	RESTORE_CONTEXT
+	rti;
+
+/* interrupt routine for evt10	- 10 */
+ENTRY(_evt_evt10)
+	SAVE_CONTEXT
+#ifdef CONFIG_FRAME_POINTER
+	fp = 0;
+#endif
+	r0 = EVT_IVG10_P;
+	r1 =  sp;
+	SP += -12;
+	call _do_irq;
+	SP += 12;
+	call return_from_int;
+	RESTORE_CONTEXT
+	rti;
+
+/* interrupt routine for evt11	- 11 */
+ENTRY(_evt_evt11)
+	SAVE_CONTEXT
+#ifdef CONFIG_FRAME_POINTER
+	fp = 0;
+#endif
+	r0 = EVT_IVG11_P;
+	r1 =  sp;
+	SP += -12;
+	call _do_irq;
+	SP += 12;
+	call return_from_int;
+	RESTORE_CONTEXT
+	rti;
+
+/* interrupt routine for evt12	- 12 */
+ENTRY(_evt_evt12)
+	SAVE_CONTEXT
+#ifdef CONFIG_FRAME_POINTER
+	fp = 0;
+#endif
+	r0 = EVT_IVG12_P;
+	r1 =  sp;
+	SP += -12;
+	call _do_irq;
+	SP += 12;
+	call return_from_int;
+	RESTORE_CONTEXT
+	rti;
+
+ /* interrupt routine for evt13	- 13 */
+ENTRY(_evt_evt13)
+	SAVE_CONTEXT
+#ifdef CONFIG_FRAME_POINTER
+	fp = 0;
+#endif
+	r0 = EVT_IVG13_P;
+	r1 =  sp;
+	SP += -12;
+	call _do_irq;
+	SP += 12;
+	call return_from_int;
+	RESTORE_CONTEXT
+	rti;
+
+ /* interrupt routine for system_call - 15 */
+ENTRY(_evt_system_call)
+	SAVE_CONTEXT_SYSCALL
+#ifdef CONFIG_FRAME_POINTER
+	fp = 0;
+#endif
+	call system_call;
+	RESTORE_CONTEXT
+	rti;
Index: git/linux-2.6/arch/blackfin/mach-common/ints-priority-dc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-common/ints-priority-dc.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,540 @@
+ /*
+  * File:        arch/blackfin/mach-common/ints-priority.c
+  * Based on:
+  * Author:      unknown
+  *              COPYRIGHT 2005 Analog Devices
+  * Created:     ?
+  * Description: Set up the interupt priorities
+  *
+  * Rev:          $Id$
+  *
+  * Modified:
+  *              1996 Roman Zippel
+  *              1999 D. Jeff Dionne <jeff@uclinux.org>
+  *              2000-2001 Lineo, Inc. D. Jefff Dionne <jeff@lineo.ca>
+  *              2002 Arcturus Networks Inc. MaTed <mated@sympatico.ca>
+  *              2003 Metrowerks/Motorola
+  *              2003 Bas Vermeulen <bas@buyways.nl>,
+  *                   BuyWays B.V. (www.buyways.nl)
+  *              2004 LG Soft India
+  *
+  * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.
+  * If not, write to the Free Software Foundation,
+  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+  */
+
+#include <linux/module.h>
+#include <linux/kernel_stat.h>
+#include <linux/seq_file.h>
+#include <asm/irqchip.h>
+#include <asm/traps.h>
+#include <asm/blackfin.h>
+
+/*
+ * NOTES:
+ * - we have separated the physical Hardware interrupt from the
+ * levels that the LINUX kernel sees (see the description in irq.h)
+ * -
+ */
+
+volatile unsigned long irq_flags = 0;
+
+/* The number of spurious interrupts */
+volatile unsigned int num_spurious;
+
+struct ivgx {
+	/* irq number for request_irq, available in mach-bf561/irq.h */
+	int irqno;
+	/* corresponding bit in the SICA_ISR0 register */
+	int isrflag0;
+	/* corresponding bit in the SICA_ISR1 register */
+	int isrflag1;
+} ivg_table[NR_PERI_INTS];
+
+struct ivg_slice {
+	/* position of first irq in ivg_table for given ivg */
+	struct ivgx *ifirst;
+	struct ivgx *istop;
+} ivg7_13[IVG13 - IVG7 + 1];
+
+/* BASE LEVEL interrupt handler routines */
+asmlinkage void evt_emulation(void);
+asmlinkage void evt_exception(void);
+asmlinkage void trap(void);
+asmlinkage void evt_ivhw(void);
+asmlinkage void evt_timer(void);
+asmlinkage void evt_evt2(void);
+asmlinkage void evt_evt7(void);
+asmlinkage void evt_evt8(void);
+asmlinkage void evt_evt9(void);
+asmlinkage void evt_evt10(void);
+asmlinkage void evt_evt11(void);
+asmlinkage void evt_evt12(void);
+asmlinkage void evt_evt13(void);
+asmlinkage void evt_soft_int1(void);
+asmlinkage void evt_system_call(void);
+
+extern void program_IAR(void);
+static void search_IAR(void);
+
+/*
+ * Search SIC_IAR and fill tables with the irqvalues
+ * and their positions in the SIC_ISR register.
+ */
+static void __init search_IAR(void)
+{
+	unsigned ivg, irq_pos = 0;
+	for (ivg = 0; ivg <= IVG13 - IVG7; ivg++) {
+		int irqn;
+
+		ivg7_13[ivg].istop = ivg7_13[ivg].ifirst = &ivg_table[irq_pos];
+
+		for (irqn = 0; irqn < NR_PERI_INTS; irqn++) {
+			int iar_shift = (irqn & 7) * 4;
+			if (ivg == (0xf & pSICA_IAR0[irqn >> 3] >> iar_shift)) {
+				ivg_table[irq_pos].irqno = IVG7 + irqn;
+				ivg_table[irq_pos].isrflag0 =
+				    (irqn < 32 ? (1 << irqn) : 0);
+				ivg_table[irq_pos].isrflag1 =
+				    (irqn < 32 ? 0 : (1 << (irqn - 32)));
+				ivg7_13[ivg].istop++;
+				irq_pos++;
+			}
+		}
+	}
+}
+
+/*
+ * This is for BF561 internal IRQs
+ */
+
+static void ack_noop(unsigned int irq)
+{
+	/* Dummy function.  */
+}
+
+static void bf561_core_mask_irq(unsigned int irq)
+{
+	irq_flags &= ~(1 << irq);
+	if (!irqs_disabled())
+		local_irq_enable();
+}
+
+static void bf561_core_unmask_irq(unsigned int irq)
+{
+	irq_flags |= 1 << irq;
+	/*
+	 * If interrupts are enabled, IMASK must contain the same value
+	 * as irq_flags.  Make sure that invariant holds.  If interrupts
+	 * are currently disabled we need not do anything; one of the
+	 * callers will take care of setting IMASK to the proper value
+	 * when reenabling interrupts.
+	 * local_irq_enable just does "STI irq_flags", so it's exactly
+	 * what we need.
+	 */
+	if (!irqs_disabled())
+		local_irq_enable();
+	return;
+}
+
+static void bf561_internal_mask_irq(unsigned int irq)
+{
+	unsigned long irq_mask;
+	if ((irq - (IRQ_CORETMR + 1)) < 32) {
+		irq_mask = (1 << (irq - (IRQ_CORETMR + 1)));
+		*pSICA_IMASK0 &= ~irq_mask;
+	} else {
+		irq_mask = (1 << (irq - (IRQ_CORETMR + 1) - 32));
+		*pSICA_IMASK1 &= ~irq_mask;
+	}
+}
+
+static void bf561_internal_unmask_irq(unsigned int irq)
+{
+	unsigned long irq_mask;
+
+	if ((irq - (IRQ_CORETMR + 1)) < 32) {
+		irq_mask = (1 << (irq - (IRQ_CORETMR + 1)));
+		*pSICA_IMASK0 |= irq_mask;
+	} else {
+		irq_mask = (1 << (irq - (IRQ_CORETMR + 1) - 32));
+		*pSICA_IMASK1 |= irq_mask;
+	}
+	__builtin_bfin_ssync();
+}
+
+static struct irqchip bf561_core_irqchip = {
+	.ack = ack_noop,
+	.mask = bf561_core_mask_irq,
+	.unmask = bf561_core_unmask_irq,
+};
+
+static struct irqchip bf561_internal_irqchip = {
+	.ack = ack_noop,
+	.mask = bf561_internal_mask_irq,
+	.unmask = bf561_internal_unmask_irq,
+};
+
+#ifdef CONFIG_IRQCHIP_DEMUX_GPIO
+static int gpio_enabled[3];
+static int gpio_edge_triggered[3];
+
+static void bf561_gpio_ack_irq(unsigned int irq)
+{
+	int gpionr = irq - IRQ_PF0;
+	int mask;
+	if (gpionr < 16) {
+		mask = (1L << gpionr);
+		*pFIO0_FLAG_C = mask;
+	} else if (gpionr < 32) {
+		mask = (1L << (gpionr - 16));
+		*pFIO1_FLAG_C = mask;
+	} else {
+		mask = (1L << (gpionr - 32));
+		*pFIO2_FLAG_C = mask;
+	}
+/*	if (gpio_edge_triggered & mask) {
+		* ack *
+	} else {
+		* ack and mask *
+	}
+*/
+	__builtin_bfin_ssync();
+}
+
+static void bf561_gpio_mask_irq(unsigned int irq)
+{
+	int gpionr = irq - IRQ_PF0;
+	int mask;
+	if (gpionr < 16) {
+		mask = (1L << gpionr);
+		*pFIO0_FLAG_C = mask;
+		__builtin_bfin_ssync();
+		*pFIO0_MASKB_C = mask;
+		__builtin_bfin_ssync();
+	} else if (gpionr < 32) {
+		mask = (1L << (gpionr - 16));
+		*pFIO1_FLAG_C = mask;
+		__builtin_bfin_ssync();
+		*pFIO1_MASKB_C = mask;
+		__builtin_bfin_ssync();
+	} else {
+		mask = (1L << (gpionr - 32));
+		*pFIO2_FLAG_C = mask;
+		__builtin_bfin_ssync();
+		*pFIO2_MASKB_C = mask;
+		__builtin_bfin_ssync();
+	}
+}
+
+static void bf561_gpio_unmask_irq(unsigned int irq)
+{
+	int gpionr = irq - IRQ_PF0;
+	int mask;
+	if (gpionr < 16) {
+		mask = (1L << gpionr);
+		*pFIO0_MASKB_S = mask;
+	} else if (gpionr < 32) {
+		mask = (1L << (gpionr - 16));
+		*pFIO1_MASKB_S = mask;
+	} else {
+		mask = (1L << (gpionr - 32));
+		*pFIO2_MASKB_S = mask;
+	}
+}
+
+static int bf561_gpio_irq_type(unsigned int irq, unsigned int type)
+{
+	int gpionr = irq - IRQ_PF0;
+	int gpioidx = 0;
+	int mask = (1L << gpionr);
+
+	if (gpionr < 16) {
+		mask = (1L << gpionr);
+		*pFIO0_DIR &= ~mask;
+		__builtin_bfin_ssync();
+		*pFIO0_INEN |= mask;
+		__builtin_bfin_ssync();
+		gpioidx = 0;
+	} else if (gpionr < 32) {
+		mask = (1L << (gpionr - 16));
+		*pFIO1_DIR &= ~mask;
+		__builtin_bfin_ssync();
+		*pFIO1_INEN |= mask;
+		__builtin_bfin_ssync();
+		gpioidx = 1;
+	} else {
+		mask = (1L << (gpionr - 32));
+		*pFIO2_DIR &= ~mask;
+		__builtin_bfin_ssync();
+		*pFIO2_INEN |= mask;
+		__builtin_bfin_ssync();
+		gpioidx = 2;
+	}
+
+	if (type == IRQT_PROBE) {
+		/* only probe unenabled GPIO interrupt lines */
+		if (gpio_enabled[gpioidx] & mask)
+			return 0;
+		type = __IRQT_RISEDGE | __IRQT_FALEDGE;
+	}
+	if (type & (__IRQT_RISEDGE | __IRQT_FALEDGE |
+		    __IRQT_HIGHLVL | __IRQT_LOWLVL))
+		gpio_enabled[gpioidx] |= mask;
+	else
+		gpio_enabled[gpioidx] &= ~mask;
+
+	if (type & (__IRQT_RISEDGE | __IRQT_FALEDGE)) {
+		gpio_edge_triggered[gpioidx] |= mask;
+		if (gpionr < 16)
+			*pFIO0_EDGE |= mask;
+		else if (gpionr < 32)
+			*pFIO1_EDGE |= mask;
+		else
+			*pFIO2_EDGE |= mask;
+	} else {
+		if (gpionr < 16)
+			*pFIO0_EDGE &= ~mask;
+		else if (gpionr < 32)
+			*pFIO1_EDGE &= ~mask;
+		else
+			*pFIO2_EDGE &= ~mask;
+		gpio_edge_triggered[gpioidx] &= ~mask;
+	}
+	__builtin_bfin_ssync();
+
+	if ((type & (__IRQT_RISEDGE | __IRQT_FALEDGE))
+	    == (__IRQT_RISEDGE | __IRQT_FALEDGE)) {
+		if (gpionr < 16)
+			*pFIO0_BOTH |= mask;
+		else if (gpionr < 32)
+			*pFIO1_BOTH |= mask;
+		else
+			*pFIO2_BOTH |= mask;
+	} else {
+		if (gpionr < 16)
+			*pFIO0_BOTH &= ~mask;
+		else if (gpionr < 32)
+			*pFIO1_BOTH &= ~mask;
+		else
+			*pFIO2_BOTH &= ~mask;
+	}
+	__builtin_bfin_ssync();
+
+	if ((type & (__IRQT_FALEDGE | __IRQT_LOWLVL))
+	    && ((type & (__IRQT_RISEDGE | __IRQT_FALEDGE))
+		!= (__IRQT_RISEDGE | __IRQT_FALEDGE))) {
+		/* low or falling edge denoted by one */
+		if (gpionr < 16)
+			*pFIO0_POLAR |= mask;
+		else if (gpionr < 32)
+			*pFIO1_POLAR |= mask;
+		else
+			*pFIO2_POLAR |= mask;
+	} else {
+		/* high or rising edge denoted by zero */
+		if (gpionr < 16)
+			*pFIO0_POLAR &= ~mask;
+		else if (gpionr < 32)
+			*pFIO1_POLAR &= ~mask;
+		else
+			*pFIO2_POLAR &= ~mask;
+	}
+	__builtin_bfin_ssync();
+
+	if (type & (__IRQT_RISEDGE | __IRQT_FALEDGE))
+		set_irq_handler(irq, do_edge_IRQ);
+	else
+		set_irq_handler(irq, do_level_IRQ);
+
+	return 0;
+}
+static struct irqchip bf561_gpio_irqchip = {
+	.ack = bf561_gpio_ack_irq,
+	.mask = bf561_gpio_mask_irq,
+	.unmask = bf561_gpio_unmask_irq,
+	.type = bf561_gpio_irq_type
+};
+
+static void bf561_demux_gpio_irq(unsigned int intb_irq,
+				 struct irqdesc *intb_desc,
+				 struct pt_regs *regs)
+{
+	int loop = 0;
+
+	if (intb_irq == IRQ_PROG0_INTB) {
+		do {
+			int irq = IRQ_PF0;
+			int flag_d = *pFIO0_FLAG_D;
+			int mask = flag_d & (gpio_enabled[0] & *pFIO0_MASKB_D);
+			loop = mask;
+			do {
+				if (mask & 1) {
+					struct irqdesc *desc = irq_desc + irq;
+					desc->handle(irq, desc, regs);
+				}
+				irq++;
+				mask >>= 1;
+			} while (mask);
+		} while (loop);
+	} else if (intb_irq == IRQ_PROG1_INTB) {
+		do {
+			int irq = IRQ_PF16;
+			int flag_d = *pFIO1_FLAG_D;
+			int mask = flag_d & (gpio_enabled[1] & *pFIO1_MASKB_D);
+			loop = mask;
+			do {
+				if (mask & 1) {
+					struct irqdesc *desc = irq_desc + irq;
+					desc->handle(irq, desc, regs);
+				}
+				irq++;
+				mask >>= 1;
+			} while (mask);
+		} while (loop);
+	} else {
+		do {
+			int irq = IRQ_PF32;
+			int flag_d = *pFIO2_FLAG_D;
+			int mask = flag_d & (gpio_enabled[2] & *pFIO2_MASKB_D);
+			loop = mask;
+			do {
+				if (mask & 1) {
+					struct irqdesc *desc = irq_desc + irq;
+					desc->handle(irq, desc, regs);
+				}
+				irq++;
+				mask >>= 1;
+			} while (mask);
+		} while (loop);
+	}
+}
+#endif				/* CONFIG_IRQCHIP_DEMUX_GPIO */
+
+/*
+ * This function should be called during kernel startup to initialize
+ * the BFin IRQ handling routines.
+ */
+
+extern void evt14_softirq(void);
+
+int __init init_arch_irq(void)
+{
+	int irq;
+	unsigned long ilat = 0;
+	/*  Disable all the peripheral intrs  - page 4-29 HW Ref manual */
+	*pSICA_IMASK0 = SIC_UNMASK_ALL;
+	*pSICA_IMASK1 = SIC_UNMASK_ALL;
+	__builtin_bfin_ssync();
+
+	local_irq_disable();
+
+#ifndef CONFIG_KGDB
+	*pEVT0 = evt_emulation;
+#endif
+	*pEVT2 = evt_evt2;
+	*pEVT3 = trap;
+	*pEVT5 = evt_ivhw;
+	*pEVT6 = evt_timer;
+	*pEVT7 = evt_evt7;
+	*pEVT8 = evt_evt8;
+	*pEVT9 = evt_evt9;
+	*pEVT10 = evt_evt10;
+	*pEVT11 = evt_evt11;
+	*pEVT12 = evt_evt12;
+	*pEVT13 = evt_evt13;
+	*pEVT14 = evt14_softirq;
+	*pEVT15 = evt_system_call;
+	__builtin_bfin_csync();
+
+	for (irq = 0; irq < SYS_IRQS; irq++) {
+		if (irq <= IRQ_CORETMR)
+			set_irq_chip(irq, &bf561_core_irqchip);
+		else
+			set_irq_chip(irq, &bf561_internal_irqchip);
+#ifdef CONFIG_IRQCHIP_DEMUX_GPIO
+		if ((irq != IRQ_PROG0_INTB) &&
+		    (irq != IRQ_PROG1_INTB) && (irq != IRQ_PROG2_INTB)) {
+#endif
+			set_irq_handler(irq, do_simple_IRQ);
+			set_irq_flags(irq, IRQF_VALID);
+#ifdef CONFIG_IRQCHIP_DEMUX_GPIO
+		} else {
+			set_irq_chained_handler(irq, bf561_demux_gpio_irq);
+		}
+#endif
+
+	}
+
+#ifdef CONFIG_IRQCHIP_DEMUX_GPIO
+	for (irq = IRQ_PF0; irq <= IRQ_PF47; irq++) {
+		set_irq_chip(irq, &bf561_gpio_irqchip);
+		/* if configured as edge, then will be changed to do_edge_IRQ */
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	}
+#endif
+	*pIMASK = 0;
+	__builtin_bfin_csync();
+	ilat = *pILAT;
+	__builtin_bfin_csync();
+	*pILAT = ilat;
+	__builtin_bfin_csync();
+
+	printk(KERN_INFO "Configuring Blackfin Priority Driven Interrupts\n");
+	/* IMASK=xxx is equivalent to STI xx or irq_flags=xx,
+	 * local_irq_enable()
+	 */
+	program_IAR();
+	/* Therefore it's better to setup IARs before interrupts enabled */
+	search_IAR();
+
+	/* Enable interrupts IVG7-15 */
+	*pIMASK = irq_flags = irq_flags | IMASK_IVG15 |
+	    IMASK_IVG14 | IMASK_IVG13 | IMASK_IVG12 | IMASK_IVG11 |
+	    IMASK_IVG10 | IMASK_IVG9 | IMASK_IVG8 | IMASK_IVG7 | IMASK_IVGHW;
+	__builtin_bfin_csync();
+
+	local_irq_enable();
+	return 0;
+}
+
+extern asmlinkage void asm_do_IRQ(unsigned int irq, struct pt_regs *regs);
+void do_irq(int vec, struct pt_regs *fp)
+{
+	if (vec == EVT_IVTMR_P) {
+		vec = IRQ_CORETMR;
+	} else {
+		struct ivgx *ivg = ivg7_13[vec - IVG7].ifirst;
+		struct ivgx *ivg_stop = ivg7_13[vec - IVG7].istop;
+		unsigned long sic_status0, sic_status1;
+
+		__builtin_bfin_ssync();
+		sic_status0 = *pSICA_IMASK0 & *pSICA_ISR0;
+		sic_status1 = *pSICA_IMASK1 & *pSICA_ISR1;
+
+		for (;; ivg++) {
+			if (ivg >= ivg_stop) {
+				num_spurious++;
+				return;
+			} else if ((sic_status0 & ivg->isrflag0) ||
+				   (sic_status1 & ivg->isrflag1))
+				break;
+		}
+		vec = ivg->irqno;
+	}
+	asm_do_IRQ(vec, fp);
+}
Index: git/linux-2.6/arch/blackfin/mach-common/ints-priority-sc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-common/ints-priority-sc.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,512 @@
+ /*
+  * File:        arch/blackfin/mach-common/ints-priority.c
+  * Based on:
+  * Author:      unknown
+  *              COPYRIGHT 2005 Analog Devices
+  * Created:     ?
+  * Description: Set up the interupt priorities
+  *
+  * Rev:          $Id$
+  *
+  * Modified:
+  *              1996 Roman Zippel
+  *              1999 D. Jeff Dionne <jeff@uclinux.org>
+  *              2000-2001 Lineo, Inc. D. Jefff Dionne <jeff@lineo.ca>
+  *              2002 Arcturus Networks Inc. MaTed <mated@sympatico.ca>
+  *              2003 Metrowerks/Motorola
+  *              2003 Bas Vermeulen <bas@buyways.nl>,
+  *                   BuyWays B.V. (www.buyways.nl)
+  *              2004 LG Soft India
+  *
+  * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.
+  * If not, write to the Free Software Foundation,
+  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+  */
+
+#include <linux/module.h>
+#include <linux/kernel_stat.h>
+#include <linux/seq_file.h>
+#include <asm/irqchip.h>
+#include <asm/traps.h>
+#include <asm/blackfin.h>
+
+#if (defined(CONFIG_BF537) || defined(CONFIG_BF536) || defined(CONFIG_BF534))
+#define BF537_GENERIC_ERROR_INT_DEMUX
+#else
+#undef BF537_GENERIC_ERROR_INT_DEMUX
+#endif
+
+/*
+ * NOTES:
+ * - we have separated the physical Hardware interrupt from the
+ * levels that the LINUX kernel sees (see the description in irq.h)
+ * -
+ */
+
+volatile unsigned long irq_flags = 0;
+
+/* The number of spurious interrupts */
+volatile unsigned int num_spurious;
+
+struct ivgx {
+	/* irq number for request_irq, available in mach-bf533/irq.h */
+	int irqno;
+	/* corresponding bit in the SIC_ISR register */
+	int isrflag;
+} ivg_table[NR_PERI_INTS];
+
+struct ivg_slice {
+	/* position of first irq in ivg_table for given ivg */
+	struct ivgx *ifirst;
+	struct ivgx *istop;
+} ivg7_13[IVG13 - IVG7 + 1];
+
+/* BASE LEVEL interrupt handler routines */
+asmlinkage void evt_emulation(void);
+asmlinkage void evt_exception(void);
+asmlinkage void trap(void);
+asmlinkage void evt_ivhw(void);
+asmlinkage void evt_timer(void);
+asmlinkage void evt_evt2(void);
+asmlinkage void evt_evt7(void);
+asmlinkage void evt_evt8(void);
+asmlinkage void evt_evt9(void);
+asmlinkage void evt_evt10(void);
+asmlinkage void evt_evt11(void);
+asmlinkage void evt_evt12(void);
+asmlinkage void evt_evt13(void);
+asmlinkage void evt_soft_int1(void);
+asmlinkage void evt_system_call(void);
+
+extern void program_IAR(void);
+static void search_IAR(void);
+
+/*
+ * Search SIC_IAR and fill tables with the irqvalues
+ * and their positions in the SIC_ISR register.
+ */
+static void __init search_IAR(void)
+{
+	unsigned ivg, irq_pos = 0;
+	for (ivg = 0; ivg <= IVG13 - IVG7; ivg++) {
+		int irqn;
+
+		ivg7_13[ivg].istop = ivg7_13[ivg].ifirst = &ivg_table[irq_pos];
+
+		for (irqn = 0; irqn < NR_PERI_INTS; irqn++) {
+			int iar_shift = (irqn & 7) * 4;
+			if (ivg == (0xf & pSIC_IAR0[irqn >> 3] >> iar_shift)) {
+				ivg_table[irq_pos].irqno = IVG7 + irqn;
+				ivg_table[irq_pos].isrflag = 1 << irqn;
+				ivg7_13[ivg].istop++;
+				irq_pos++;
+			}
+		}
+	}
+}
+
+/*
+ * This is for BF533 internal IRQs
+ */
+
+static void ack_noop(unsigned int irq)
+{
+	/* Dummy function.  */
+}
+
+static void bf533_core_mask_irq(unsigned int irq)
+{
+	irq_flags &= ~(1 << irq);
+	if (!irqs_disabled())
+		local_irq_enable();
+}
+
+static void bf533_core_unmask_irq(unsigned int irq)
+{
+	irq_flags |= 1 << irq;
+	/*
+	 * If interrupts are enabled, IMASK must contain the same value
+	 * as irq_flags.  Make sure that invariant holds.  If interrupts
+	 * are currently disabled we need not do anything; one of the
+	 * callers will take care of setting IMASK to the proper value
+	 * when reenabling interrupts.
+	 * local_irq_enable just does "STI irq_flags", so it's exactly
+	 * what we need.
+	 */
+	if (!irqs_disabled())
+		local_irq_enable();
+	return;
+}
+
+static void bf533_internal_mask_irq(unsigned int irq)
+{
+	*pSIC_IMASK &= ~(1 << (irq - (IRQ_CORETMR + 1)));
+	__builtin_bfin_ssync();
+}
+
+static void bf533_internal_unmask_irq(unsigned int irq)
+{
+	*pSIC_IMASK |= (1 << (irq - (IRQ_CORETMR + 1)));
+	__builtin_bfin_ssync();
+}
+
+static struct irqchip bf533_core_irqchip = {
+	.ack = ack_noop,
+	.mask = bf533_core_mask_irq,
+	.unmask = bf533_core_unmask_irq,
+};
+
+static struct irqchip bf533_internal_irqchip = {
+	.ack = ack_noop,
+	.mask = bf533_internal_mask_irq,
+	.unmask = bf533_internal_unmask_irq,
+};
+
+#ifdef BF537_GENERIC_ERROR_INT_DEMUX
+static int error_int_mask;
+
+static void bf537_generic_error_ack_irq(unsigned int irq)
+{
+
+}
+
+static void bf537_generic_error_mask_irq(unsigned int irq)
+{
+	error_int_mask &= ~(1L << (irq - IRQ_PPI_ERROR));
+
+	if (!error_int_mask) {
+		local_irq_disable();
+		*pSIC_IMASK |= 1 << (IRQ_GENERIC_ERROR - (IRQ_CORETMR + 1));
+		__builtin_bfin_ssync();
+		local_irq_enable();
+	}
+}
+
+static void bf537_generic_error_unmask_irq(unsigned int irq)
+{
+	local_irq_disable();
+	*pSIC_IMASK |= 1 << (IRQ_GENERIC_ERROR - (IRQ_CORETMR + 1));
+	__builtin_bfin_ssync();
+	local_irq_enable();
+
+	error_int_mask |= 1L << (irq - IRQ_PPI_ERROR);
+}
+
+static struct irqchip bf537_generic_error_irqchip = {
+	.ack = bf537_generic_error_ack_irq,
+	.mask = bf537_generic_error_mask_irq,
+	.unmask = bf537_generic_error_unmask_irq,
+};
+
+static void bf537_demux_error_irq(unsigned int int_err_irq,
+				  struct irqdesc *intb_desc,
+				  struct pt_regs *regs)
+{
+	int irq = 0;
+
+	__builtin_bfin_ssync();
+
+#if (defined(CONFIG_BF537) || defined(CONFIG_BF536))
+	if (*pEMAC_SYSTAT & EMAC_ERR_MASK)
+		irq = IRQ_MAC_ERROR;
+	else
+#endif
+	if (*pSPORT0_STAT & SPORT_ERR_MASK)
+		irq = IRQ_SPORT0_ERROR;
+	else if (*pSPORT1_STAT & SPORT_ERR_MASK)
+		irq = IRQ_SPORT1_ERROR;
+	else if (*pPPI_STATUS & PPI_ERR_MASK)
+		irq = IRQ_PPI_ERROR;
+	else if (*pCAN_GIF & CAN_ERR_MASK)
+		irq = IRQ_CAN_ERROR;
+	else if (*pSPI_STAT & SPI_ERR_MASK)
+		irq = IRQ_SPI_ERROR;
+	else if ((*pUART0_IIR & UART_ERR_MASK_STAT1) &&
+		 (*pUART0_IIR & UART_ERR_MASK_STAT0))
+		irq = IRQ_UART0_ERROR;
+	else if ((*pUART1_IIR & UART_ERR_MASK_STAT1) &&
+		 (*pUART1_IIR & UART_ERR_MASK_STAT0))
+		irq = IRQ_UART1_ERROR;
+
+	if (irq) {
+		if (error_int_mask & (1L << (irq - IRQ_PPI_ERROR))) {
+			struct irqdesc *desc = irq_desc + irq;
+			desc->handle(irq, desc, regs);
+		} else
+			printk(KERN_ERR "%s : %s : LINE %d  : \nIRQ %d:"
+			       " MASKED PERIPHERAL ERROR INTERRUPT ASSERTED\n",
+			       __FUNCTION__, __FILE__, __LINE__, irq);
+	} else
+		printk(KERN_ERR "%s : %s : LINE %d :\nIRQ ?: PERIPHERAL ERROR"
+		       " INTERRUPT ASSERTED BUT NO SOURCE FOUND\n",
+		       __FUNCTION__, __FILE__, __LINE__);
+
+}
+#endif				/* BF537_GENERIC_ERROR_INT_DEMUX */
+
+#ifdef CONFIG_IRQCHIP_DEMUX_GPIO
+static int gpio_enabled;
+static int gpio_edge_triggered;
+
+static void bf533_gpio_ack_irq(unsigned int irq)
+{
+	int gpionr = irq - IRQ_PF0;
+	int mask = (1L << gpionr);
+	*pFIO_FLAG_C = mask;
+/*	if (gpio_edge_triggered & mask) {
+		* ack *
+	} else {
+		* ack and mask *
+	}
+*/
+	__builtin_bfin_ssync();
+}
+
+static void bf533_gpio_mask_irq(unsigned int irq)
+{
+	int gpionr = irq - IRQ_PF0;
+	int mask = (1L << gpionr);
+	*pFIO_FLAG_C = mask;
+	__builtin_bfin_ssync();
+	*pFIO_MASKB_C = mask;
+	__builtin_bfin_ssync();
+}
+
+static void bf533_gpio_unmask_irq(unsigned int irq)
+{
+	int gpionr = irq - IRQ_PF0;
+	int mask = (1L << gpionr);
+	*pFIO_MASKB_S = mask;
+}
+
+static int bf533_gpio_irq_type(unsigned int irq, unsigned int type)
+{
+	int gpionr = irq - IRQ_PF0;
+	int mask = (1L << gpionr);
+
+	*pFIO_DIR &= ~mask;
+	__builtin_bfin_ssync();
+	*pFIO_INEN |= mask;
+	__builtin_bfin_ssync();
+
+	if (type == IRQT_PROBE) {
+		/* only probe unenabled GPIO interrupt lines */
+		if (gpio_enabled & mask)
+			return 0;
+		type = __IRQT_RISEDGE | __IRQT_FALEDGE;
+	}
+	if (type & (__IRQT_RISEDGE | __IRQT_FALEDGE |
+		    __IRQT_HIGHLVL | __IRQT_LOWLVL))
+		gpio_enabled |= mask;
+	else
+		gpio_enabled &= ~mask;
+
+	if (type & (__IRQT_RISEDGE | __IRQT_FALEDGE)) {
+		gpio_edge_triggered |= mask;
+		*pFIO_EDGE |= mask;
+	} else {
+		*pFIO_EDGE &= ~mask;
+		gpio_edge_triggered &= ~mask;
+	}
+	__builtin_bfin_ssync();
+
+	if ((type & (__IRQT_RISEDGE | __IRQT_FALEDGE))
+	    == (__IRQT_RISEDGE | __IRQT_FALEDGE))
+		*pFIO_BOTH |= mask;
+	else
+		*pFIO_BOTH &= ~mask;
+	__builtin_bfin_ssync();
+
+	if ((type & (__IRQT_FALEDGE | __IRQT_LOWLVL))
+	    && ((type & (__IRQT_RISEDGE | __IRQT_FALEDGE))
+		!= (__IRQT_RISEDGE | __IRQT_FALEDGE)))
+		*pFIO_POLAR |= mask;	/* low or falling edge denoted by one */
+	else
+		*pFIO_POLAR &= ~mask;	/* high or rising edge denoted by zero */
+	__builtin_bfin_ssync();
+
+	if (type & (__IRQT_RISEDGE | __IRQT_FALEDGE))
+		set_irq_handler(irq, do_edge_IRQ);
+	else
+		set_irq_handler(irq, do_level_IRQ);
+
+	return 0;
+}
+static struct irqchip bf533_gpio_irqchip = {
+	.ack = bf533_gpio_ack_irq,
+	.mask = bf533_gpio_mask_irq,
+	.unmask = bf533_gpio_unmask_irq,
+	.type = bf533_gpio_irq_type
+};
+
+static void bf533_demux_gpio_irq(unsigned int intb_irq,
+				 struct irqdesc *intb_desc,
+				 struct pt_regs *regs)
+{
+	int loop = 0;
+
+	do {
+		int irq = IRQ_PF0;
+		int flag_d = *pFIO_FLAG_D;
+		int mask = flag_d & (gpio_enabled & *pFIO_MASKB_C);
+		loop = mask;
+		do {
+			if (mask & 1) {
+				struct irqdesc *desc = irq_desc + irq;
+				desc->handle(irq, desc, regs);
+			}
+			irq++;
+			mask >>= 1;
+		} while (mask);
+	} while (loop);
+}
+#endif				/* CONFIG_IRQCHIP_DEMUX_GPIO */
+
+/*
+ * This function should be called during kernel startup to initialize
+ * the BFin IRQ handling routines.
+ */
+
+extern void evt14_softirq(void);
+
+int __init init_arch_irq(void)
+{
+	int irq;
+	unsigned long ilat = 0;
+	/*  Disable all the peripheral intrs  - page 4-29 HW Ref manual */
+	*pSIC_IMASK = SIC_UNMASK_ALL;
+	__builtin_bfin_ssync();
+
+	local_irq_disable();
+
+#ifndef CONFIG_KGDB
+	*pEVT0 = evt_emulation;
+#endif
+	*pEVT2 = evt_evt2;
+	*pEVT3 = trap;
+	*pEVT5 = evt_ivhw;
+	*pEVT6 = evt_timer;
+	*pEVT7 = evt_evt7;
+	*pEVT8 = evt_evt8;
+	*pEVT9 = evt_evt9;
+	*pEVT10 = evt_evt10;
+	*pEVT11 = evt_evt11;
+	*pEVT12 = evt_evt12;
+	*pEVT13 = evt_evt13;
+	*pEVT14 = evt14_softirq;
+	*pEVT15 = evt_system_call;
+	__builtin_bfin_csync();
+
+	for (irq = 0; irq < SYS_IRQS; irq++) {
+		if (irq <= IRQ_CORETMR)
+			set_irq_chip(irq, &bf533_core_irqchip);
+		else
+			set_irq_chip(irq, &bf533_internal_irqchip);
+#ifdef BF537_GENERIC_ERROR_INT_DEMUX
+		if (irq != IRQ_GENERIC_ERROR) {
+#endif
+
+#ifdef CONFIG_IRQCHIP_DEMUX_GPIO
+			if (irq != IRQ_PROG_INTB) {
+#endif
+				set_irq_handler(irq, do_simple_IRQ);
+				set_irq_flags(irq, IRQF_VALID);
+#ifdef CONFIG_IRQCHIP_DEMUX_GPIO
+			} else {
+				set_irq_chained_handler(irq,
+							bf533_demux_gpio_irq);
+			}
+#endif
+
+#ifdef BF537_GENERIC_ERROR_INT_DEMUX
+		} else {
+			set_irq_handler(irq, bf537_demux_error_irq);
+		}
+#endif
+	}
+#ifdef BF537_GENERIC_ERROR_INT_DEMUX
+	for (irq = IRQ_PPI_ERROR; irq <= IRQ_UART1_ERROR; irq++) {
+		set_irq_chip(irq, &bf537_generic_error_irqchip);
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+#endif
+
+#ifdef BF537_GENERIC_ERROR_INT_DEMUX
+	for (irq = IRQ_PPI_ERROR; irq <= IRQ_UART1_ERROR; irq++) {
+		set_irq_chip(irq, &bf537_generic_error_irqchip);
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+#endif
+
+#ifdef CONFIG_IRQCHIP_DEMUX_GPIO
+	for (irq = IRQ_PF0; irq <= IRQ_PF15; irq++) {
+		set_irq_chip(irq, &bf533_gpio_irqchip);
+		/* if configured as edge, then will be changed to do_edge_IRQ */
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	}
+#endif
+	*pIMASK = 0;
+	__builtin_bfin_csync();
+	ilat = *pILAT;
+	__builtin_bfin_csync();
+	*pILAT = ilat;
+	__builtin_bfin_csync();
+
+	printk(KERN_INFO "Configuring Blackfin Priority Driven Interrupts\n");
+	/* IMASK=xxx is equivalent to STI xx or irq_flags=xx,
+	 * local_irq_enable()
+	 */
+	program_IAR();
+	/* Therefore it's better to setup IARs before interrupts enabled */
+	search_IAR();
+
+	/* Enable interrupts IVG7-15 */
+	*pIMASK = irq_flags = irq_flags | IMASK_IVG15 |
+	    IMASK_IVG14 | IMASK_IVG13 | IMASK_IVG12 | IMASK_IVG11 |
+	    IMASK_IVG10 | IMASK_IVG9 | IMASK_IVG8 | IMASK_IVG7 | IMASK_IVGHW;
+	__builtin_bfin_csync();
+
+	local_irq_enable();
+	return 0;
+}
+
+extern asmlinkage void asm_do_IRQ(unsigned int irq, struct pt_regs *regs);
+void do_irq(int vec, struct pt_regs *fp)
+{
+	if (vec == EVT_IVTMR_P) {
+		vec = IRQ_CORETMR;
+	} else {
+		struct ivgx *ivg = ivg7_13[vec - IVG7].ifirst;
+		struct ivgx *ivg_stop = ivg7_13[vec - IVG7].istop;
+		unsigned long sic_status;
+
+		__builtin_bfin_ssync();
+		sic_status = *pSIC_IMASK & *pSIC_ISR;
+
+		for (;; ivg++) {
+			if (ivg >= ivg_stop) {
+				num_spurious++;
+				return;
+			} else if (sic_status & ivg->isrflag)
+				break;
+		}
+		vec = ivg->irqno;
+	}
+	asm_do_IRQ(vec, fp);
+}
Index: git/linux-2.6/arch/blackfin/mach-common/irqpanic.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-common/irqpanic.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,91 @@
+ /*
+  * File:        arch/blackfin/mach-common/irqpanic.c
+  * Based on:
+  * Author:      unknown
+  *              COPYRIGHT 2005 Analog Devices
+  * Created:     ?
+  * Description: panic kernel with dump information
+  *
+  * Rev:          $Id$
+  *
+  * Modified:
+  *
+  *
+  * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.
+  * If not, write to the Free Software Foundation,
+  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+  */
+
+#include <linux/module.h>
+#include <linux/kernel_stat.h>
+#include <asm/traps.h>
+#include <asm/blackfin.h>
+
+extern void dump(struct pt_regs *regs, void *);
+
+/*********
+ * irq_panic
+ * - calls panic with string setup
+ *********/
+asmlinkage void irq_panic(int reason, struct pt_regs *regs)
+{
+	int sig = 0;
+	siginfo_t info;
+
+	printk("\n\nException: IRQ 0x%x entered\n", reason);
+	printk(" code=[0x%08x],  ", (unsigned int)regs->seqstat);
+	printk(" stack frame=0x%04x,  ", (unsigned int)(unsigned long)regs);
+	printk(" bad PC=0x%04x\n", (unsigned int)regs->pc);
+	if (reason == 0x5) {
+
+		printk("\n----------- HARDWARE ERROR -----------\n\n");
+
+		/* There is only need to check for Hardware Errors, since other
+		 * EXCEPTIONS are handled in TRAPS.c (MH)
+		 */
+		switch (((unsigned int)regs->seqstat) >> 14) {
+		case (0x2):	/* System MMR Error */
+			info.si_code = BUS_ADRALN;
+			sig = SIGBUS;
+			printk(HWC_x2);
+			break;
+		case (0x3):	/* External Memory Addressing Error */
+			info.si_code = BUS_ADRERR;
+			sig = SIGBUS;
+			printk(HWC_x3);
+			break;
+		case (0x12):	/* Performance Monitor Overflow */
+			printk(HWC_x12);
+			break;
+		case (0x18):	/* RAISE 5 instruction */
+			printk(HWC_x18);
+			break;
+		default:	/* Reserved */
+			printk(HWC_default);
+			break;
+		}
+	}
+
+	regs->ipend = *pIPEND;
+	dump(regs, regs->pc);
+	if (0 == (info.si_signo = sig) || 0 == user_mode(regs))	/* in kernelspace */
+		panic("Unhandled IRQ or exceptions!\n");
+	else {			/* in userspace */
+		info.si_errno = 0;
+		info.si_addr = (void *)regs->pc;
+		force_sig_info(sig, &info, current);
+	}
+}
Index: git/linux-2.6/arch/blackfin/mach-common/lock.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mach-common/lock.S	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,215 @@
+ /*
+ * File:        arch/blackfin/mach-common/lock.S
+ * Based on:
+ * Author:      LG Soft India
+ *              COPYRIGHT 2005 Analog Devices
+ * Created:     ?
+ * Description: kernel locks
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/linkage.h>
+#include <asm/cplb.h>
+#include <asm/blackfin.h>
+
+.text
+
+#ifdef CONFIG_BLKFIN_CACHE_LOCK
+
+.global _cache_grab_lock
+.type	_cache_grab_lock, STT_FUNC;
+
+.global _cache_lock
+.type	_cache_lock, STT_FUNC;
+
+/* When you come here, it is assumed that
+ * R0 - Which way to be locked
+ */
+
+ENTRY(_cache_grab_lock)
+
+	[--SP]=( R7:0,P5:0 );
+
+	P1.H = (IMEM_CONTROL >> 16);
+	P1.L = (IMEM_CONTROL & 0xFFFF);
+	P5.H = (ICPLB_ADDR0 >> 16);
+	P5.L = (ICPLB_ADDR0 & 0xFFFF);
+	P4.H = (ICPLB_DATA0 >> 16);
+	P4.L = (ICPLB_DATA0 & 0xFFFF);
+	R7 = R0;
+
+	/* If the code of interest already resides in the cache
+	 * invalidate the entire cache itself.
+  	 * invalidate_entire_icache;
+	 */
+
+	SP += -12;
+	[--SP] = RETS;
+	CALL _invalidate_entire_icache;
+	RETS = [SP++];
+	SP += 12;
+
+	/* Disable the Interrupts*/
+
+	CLI R3;
+
+LOCK_WAY:
+
+	/* Way0 - 0xFFA133E0
+	 * Way1 - 0xFFA137E0
+	 * Way2 - 0xFFA13BE0	Total Way Size = 4K
+	 * Way3 - 0xFFA13FE0
+	 */
+
+	/* Procedure Ex. -Set the locks for other ways by setting ILOC[3:1]
+	 * Only Way0 of the instruction cache can now be
+	 * replaced by a new code
+	 */
+
+	R5 = R7;
+	CC = BITTST(R7,0);
+	IF CC JUMP CLEAR1;
+	R7 = 0;
+	BITSET(R7,0);
+	JUMP DONE1;
+
+CLEAR1:
+	R7 = 0;
+	BITCLR(R7,0);
+DONE1:	R4 = R7 << 3;
+	R7 = [P1];
+	R7 = R7 | R4;
+	SSYNC;		/* SSYNC required writing to IMEM_CONTROL. */
+	.align 8;
+	[P1] = R7;
+	SSYNC;
+
+	R7 = R5;
+	CC = BITTST(R7,1);
+	IF CC JUMP CLEAR2;
+	R7 = 0;
+	BITSET(R7,1);
+	JUMP DONE2;
+
+CLEAR2:
+	R7 = 0;
+	BITCLR(R7,1);
+DONE2:	R4 = R7 << 3;
+	R7 = [P1];
+	R7 = R7 | R4;
+	SSYNC;		/* SSYNC required writing to IMEM_CONTROL. */
+	.align 8;
+	[P1] = R7;
+	SSYNC;
+
+	R7 = R5;
+	CC = BITTST(R7,2);
+	IF CC JUMP CLEAR3;
+	R7 = 0;
+	BITSET(R7,2);
+	JUMP DONE3;
+CLEAR3:
+	R7 = 0;
+	BITCLR(R7,2);
+DONE3:	R4 = R7 << 3;
+	R7 = [P1];
+	R7 = R7 | R4;
+	SSYNC;		/* SSYNC required writing to IMEM_CONTROL. */
+	.align 8;
+	[P1] = R7;
+	SSYNC;
+
+
+	R7 = R5;
+	CC = BITTST(R7,3);
+	IF CC JUMP CLEAR4;
+	R7 = 0;
+	BITSET(R7,3);
+	JUMP DONE4;
+CLEAR4:
+	R7 = 0;
+	BITCLR(R7,3);
+DONE4:	R4 = R7 << 3;
+	R7 = [P1];
+	R7 = R7 | R4;
+	SSYNC;		/* SSYNC required writing to IMEM_CONTROL. */
+	.align 8;
+	[P1] = R7;
+	SSYNC;
+
+	STI R3;
+
+	( R7:0,P5:0 ) = [SP++];
+
+	RTS;
+
+/* After the execution of critical code, the code is now locked into
+ * the cache way. Now we need to set ILOC.
+ *
+ * R0 - Which way to be locked
+ */
+
+_cache_lock:
+
+	[--SP]=( R7:0,P5:0 );
+
+	P1.H = (IMEM_CONTROL >> 16);
+	P1.L = (IMEM_CONTROL & 0xFFFF);
+
+	/* Disable the Interrupts*/
+	CLI R3;
+
+	R7 = [P1];
+	R2 = 0xFF87;
+	R7 = R7 & R2;
+	R0 = R0 << 3;
+	R7 = R0 | R7;
+	SSYNC;		/* SSYNC required writing to IMEM_CONTROL. */
+	.align 8;
+	[P1] = R7;
+	SSYNC;
+	/* Renable the Interrupts */
+	STI R3;
+
+	( R7:0,P5:0 ) = [SP++];
+	RTS;
+
+#endif	/*BLKFIN_CACHE_LOCK*/
+
+/* Return the ILOC bits of IMEM_CONTROL
+ */
+
+.global _read_iloc
+.type _read_iloc, STT_FUNC;
+
+_read_iloc:
+
+	P1.H = (IMEM_CONTROL >> 16);
+	P1.L = (IMEM_CONTROL & 0xFFFF);
+	R1 = 0xF;
+	R0 = [P1];
+	R0 = R0 >> 3;
+	R0 = R0 & R1;
+
+	RTS;
Index: git/linux-2.6/arch/blackfin/mm/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mm/Makefile	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,5 @@
+#
+# Makefile for the linux blackfin specific parts of the memory manager.
+#
+
+obj-y := blackfin_sram.o init.o kmap.o
Index: git/linux-2.6/arch/blackfin/mm/blackfin_sram.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mm/blackfin_sram.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,319 @@
+/*
+ * File:         arch/blackfin/mm/blackfin_sram.c
+ * Based on:
+ * Author:
+ * Created:
+ * Description:  SRAM driver for Blackfin ADSP-BF533
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/autoconf.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/ioport.h>
+#include <linux/fcntl.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/rtc.h>
+#include <asm/blackfin.h>
+
+spinlock_t l1sram_lock, l1_data_A_sram_lock;
+
+#define L1_MAX_PIECE        16
+
+#define SRAM_SLT_NULL      0
+#define SRAM_SLT_FREE      1
+#define SRAM_SLT_ALLOCATED 2
+
+void l1sram_init(void);
+void l1_data_A_sram_init(void);
+extern unsigned long table_start, table_end;
+
+/* the data structure for L1 scratchpad and DATA SRAM */
+struct l1_sram_piece {
+	unsigned long paddr;
+	int size;
+	int flag;
+};
+
+struct l1_sram_piece l1_ssram[L1_MAX_PIECE];
+
+struct l1_sram_piece l1_data_A_sram[L1_MAX_PIECE];
+
+#if 0 != L1_DATA_B_LENGTH
+struct l1_sram_piece l1_data_B_sram[L1_MAX_PIECE];
+#endif
+
+/* L1 Scratchpad SRAM initialization function */
+void l1sram_init(void)
+{
+	printk("Blackfin Scratchpad data SRAM: %d KB\n",
+	       L1_SCRATCH_LENGTH >> 10);
+
+	memset((void *)&l1_ssram, 0, sizeof(l1_ssram));
+	l1_ssram[0].paddr = L1_SCRATCH_START;
+	l1_ssram[0].size = L1_SCRATCH_LENGTH;
+	l1_ssram[0].flag = SRAM_SLT_FREE;
+
+	/* mutex initialize */
+	spin_lock_init(&l1sram_lock);
+}
+
+void l1_data_A_sram_init(void)
+{
+	extern char _sdata_l1, _ebss_l1;
+
+	memset((void *)&l1_data_A_sram, 0, sizeof(l1_data_A_sram));
+#if 0 != L1_DATA_A_LENGTH
+	printk("Blackfin DATA_A SRAM: %d KB\n", L1_DATA_A_LENGTH >> 10);
+
+	l1_data_A_sram[0].paddr = L1_DATA_A_START + (&_ebss_l1 - &_sdata_l1);
+	l1_data_A_sram[0].size = L1_DATA_A_LENGTH - (&_ebss_l1 - &_sdata_l1);
+	l1_data_A_sram[0].flag = SRAM_SLT_FREE;
+#endif
+#if 0 != L1_DATA_B_LENGTH
+	printk("Blackfin DATA_B SRAM: %d KB\n", L1_DATA_B_LENGTH >> 10);
+
+	memset((void *)&l1_data_B_sram, 0, sizeof(l1_data_B_sram));
+	l1_data_B_sram[0].paddr = L1_DATA_B_START;
+	l1_data_B_sram[0].size = L1_DATA_B_LENGTH;
+	l1_data_B_sram[0].flag = SRAM_SLT_FREE;
+#endif
+
+	/* mutex initialize */
+	spin_lock_init(&l1_data_A_sram_lock);
+}
+
+/* L1 memory allocate function */
+static unsigned long l1_sram_alloc(unsigned long size,
+				   struct l1_sram_piece *pfree, int count)
+{
+	int i, index = 0;
+	unsigned long addr = 0;
+
+	if (size <= 0)
+		return 0;
+
+	/* Align the size */
+	size = (size + 3) & ~3;
+
+	/* not use the good method to match the best slot !!! */
+	/* search an available memeory slot */
+	for (i = 0; i < count; i++) {
+		if ((pfree[i].flag == SRAM_SLT_FREE) && (pfree[i].size >= size)) {
+			addr = pfree[i].paddr;
+			pfree[i].flag = SRAM_SLT_ALLOCATED;
+			index = i;
+			break;
+		}
+	}
+	if (i >= count)
+		return 0;
+
+	/* updated the NULL memeory slot !!! */
+	if (pfree[i].size > size) {
+		for (i = 0; i < count; i++) {
+			if (pfree[i].flag == SRAM_SLT_NULL) {
+				pfree[i].flag = SRAM_SLT_FREE;
+				pfree[i].paddr = addr + size;
+				pfree[i].size = pfree[index].size - size;
+				pfree[index].size = size;
+				break;
+			}
+		}
+	}
+
+	memset((void *)addr, 0, size);
+	return addr;
+}
+
+/* L1 memory free function */
+static int l1_sram_free(unsigned long addr,
+			struct l1_sram_piece *pfree, int count)
+{
+	int i, index = 0;
+
+	/* search the relevant memory slot */
+	for (i = 0; i < count; i++) {
+		if (pfree[i].paddr == addr) {
+			if (pfree[i].flag != SRAM_SLT_ALLOCATED) {
+				/* error log */
+				return -1;
+			}
+			index = i;
+			break;
+		}
+	}
+	if (i >= count)
+		return -1;
+
+	pfree[index].flag = SRAM_SLT_FREE;
+
+	/* link the next address slot */
+	for (i = 0; i < count; i++) {
+		if (((pfree[index].paddr + pfree[index].size) == pfree[i].paddr)
+		    && (pfree[i].flag == SRAM_SLT_FREE)) {
+			pfree[i].flag = SRAM_SLT_NULL;
+			pfree[index].size += pfree[i].size;
+			pfree[index].flag = SRAM_SLT_FREE;
+			break;
+		}
+	}
+
+	/* link the last address slot */
+	for (i = 0; i < count; i++) {
+		if (((pfree[i].paddr + pfree[i].size) == pfree[index].paddr) &&
+		    (pfree[i].flag == SRAM_SLT_FREE)) {
+			pfree[index].flag = SRAM_SLT_NULL;
+			pfree[i].size += pfree[index].size;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+unsigned long l1_data_A_sram_alloc(unsigned long size)
+{
+	unsigned flags;
+	unsigned long addr;
+
+	/* add mutex operation */
+	spin_lock_irqsave(&l1_data_A_sram_lock, flags);
+
+	addr = l1_sram_alloc(size, l1_data_A_sram, ARRAY_SIZE(l1_data_A_sram));
+
+#if 0 != L1_DATA_B_LENGTH
+	if (!addr)
+		addr = l1_sram_alloc(size,
+				     l1_data_B_sram,
+				     ARRAY_SIZE(l1_data_B_sram));
+#endif
+	/* add mutex operation */
+	spin_unlock_irqrestore(&l1_data_A_sram_lock, flags);
+
+	//printk ("Allocated address in l1sram_alloc is 0x%lx+0x%lx\n",addr,size);
+	return addr;
+}
+
+int l1_data_A_sram_free(unsigned long addr)
+{
+	unsigned flags;
+	int ret;
+
+	/* add mutex operation */
+	spin_lock_irqsave(&l1_data_A_sram_lock, flags);
+
+#if 0 != L1_DATA_B_LENGTH
+	if (L1_DATA_B_START == (addr & ~0xffff))
+		ret = l1_sram_free(addr,
+				   l1_data_B_sram, ARRAY_SIZE(l1_data_B_sram));
+	else
+#endif
+		ret = l1_sram_free(addr,
+				   l1_data_A_sram, ARRAY_SIZE(l1_data_A_sram));
+
+	/* add mutex operation */
+	spin_unlock_irqrestore(&l1_data_A_sram_lock, flags);
+
+	return ret;
+}
+
+#if 0 != L1_DATA_B_LENGTH
+unsigned long l1_data_B_sram_alloc(unsigned long size)
+{
+	unsigned flags;
+	unsigned long addr;
+
+	/* add mutex operation */
+	spin_lock_irqsave(&l1_data_A_sram_lock, flags);
+
+	addr = l1_sram_alloc(size, l1_data_B_sram, ARRAY_SIZE(l1_data_B_sram));
+
+	/* add mutex operation */
+	spin_unlock_irqrestore(&l1_data_A_sram_lock, flags);
+
+	//printk ("Allocated address in l1sram_alloc is 0x%lx+0x%lx\n",addr,size);
+	return addr;
+}
+
+int l1_data_B_sram_free(unsigned long addr)
+{
+	unsigned flags;
+	int ret;
+
+	/* add mutex operation */
+	spin_lock_irqsave(&l1_data_A_sram_lock, flags);
+
+	ret = l1_sram_free(addr, l1_data_B_sram, ARRAY_SIZE(l1_data_B_sram));
+
+	/* add mutex operation */
+	spin_unlock_irqrestore(&l1_data_A_sram_lock, flags);
+
+	return ret;
+}
+#endif
+
+/* L1 Scratchpad memory allocate function */
+unsigned long l1sram_alloc(unsigned long size)
+{
+	unsigned flags;
+	unsigned long addr;
+
+	/* add mutex operation */
+	spin_lock_irqsave(&l1sram_lock, flags);
+
+	addr = l1_sram_alloc(size, l1_ssram, ARRAY_SIZE(l1_ssram));
+
+	/* add mutex operation */
+	spin_unlock_irqrestore(&l1sram_lock, flags);
+
+	return addr;
+}
+
+/* L1 Scratchpad memory free function */
+int l1sram_free(unsigned long addr)
+{
+	unsigned flags;
+	int ret;
+
+	/* add mutex operation */
+	spin_lock_irqsave(&l1sram_lock, flags);
+
+	ret = l1_sram_free(addr, l1_ssram, ARRAY_SIZE(l1_ssram));
+
+	/* add mutex operation */
+	spin_unlock_irqrestore(&l1sram_lock, flags);
+
+	return ret;
+}
+
+EXPORT_SYMBOL(l1sram_alloc);
+EXPORT_SYMBOL(l1sram_free);
+EXPORT_SYMBOL(l1_data_A_sram_alloc);
+EXPORT_SYMBOL(l1_data_A_sram_free);
Index: git/linux-2.6/arch/blackfin/mm/init.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mm/init.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,215 @@
+/*
+ * File:         arch/blackfin/mm/init.c
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/swap.h>
+#include <linux/bootmem.h>
+
+#undef DEBUG
+
+extern void free_initmem(void);
+extern void l1sram_init(void);
+extern void l1_data_A_sram_init(void);
+
+/*
+ * BAD_PAGE is the page that is used for page faults when linux
+ * is out-of-memory. Older versions of linux just did a
+ * do_exit(), but using this instead means there is less risk
+ * for a process dying in kernel mode, possibly leaving a inode
+ * unused etc..
+ *
+ * BAD_PAGETABLE is the accompanying page-table: it is initialized
+ * to point to BAD_PAGE entries.
+ *
+ * ZERO_PAGE is a special page that is used for zero-initialized
+ * data and COW.
+ */
+static unsigned long empty_bad_page_table;
+
+static unsigned long empty_bad_page;
+
+unsigned long empty_zero_page;
+
+void show_mem(void)
+{
+	unsigned long i;
+	int free = 0, total = 0, reserved = 0, shared = 0;
+
+	int cached = 0;
+	printk(KERN_INFO "\nMem-info:\n");
+	show_free_areas();
+	i = max_mapnr;
+	while (i-- > 0) {
+		total++;
+		if (PageReserved(mem_map + i))
+			reserved++;
+		else if (PageSwapCache(mem_map + i))
+			cached++;
+		else if (!page_count(mem_map + i))
+			free++;
+		else
+			shared += page_count(mem_map + i) - 1;
+	}
+	printk(KERN_INFO "%d pages of RAM\n", total);
+	printk(KERN_INFO "%d free pages\n", free);
+	printk(KERN_INFO "%d reserved pages\n", reserved);
+	printk(KERN_INFO "%d pages shared\n", shared);
+	printk(KERN_INFO "%d pages swap cached\n", cached);
+}
+
+extern unsigned long memory_start;
+extern unsigned long memory_end;
+
+/*
+ * paging_init() continues the virtual memory environment setup which
+ * was begun by the code in arch/head.S.
+ * The parameters are pointers to where to stick the starting and ending
+ * addresses  of available kernel virtual memory.
+ */
+void paging_init(void)
+{
+	/*
+	 * make sure start_mem is page aligned,  otherwise bootmem and
+	 * page_alloc get different views og the world
+	 */
+#ifdef DEBUG
+	unsigned long start_mem = PAGE_ALIGN(memory_start);
+#endif
+	unsigned long end_mem = memory_end & PAGE_MASK;
+
+#ifdef DEBUG
+	printk("start_mem is %#lx\nvirtual_end is %#lx\n", start_mem, end_mem);
+#endif
+
+	/*
+	 * initialize the bad page table and bad page to point
+	 * to a couple of allocated pages
+	 */
+	empty_bad_page_table = (unsigned long)alloc_bootmem_pages(PAGE_SIZE);
+	empty_bad_page = (unsigned long)alloc_bootmem_pages(PAGE_SIZE);
+	empty_zero_page = (unsigned long)alloc_bootmem_pages(PAGE_SIZE);
+	memset((void *)empty_zero_page, 0, PAGE_SIZE);
+
+	/*
+	 * Set up SFC/DFC registers (user data space)
+	 */
+	set_fs(USER_DS);
+
+#ifdef DEBUG
+	printk(KERN_DEBUG
+	       "free_area_init -> start_mem is %#lx  virtual_end is %#lx\n",
+	       start_mem, end_mem);
+#endif
+
+	{
+		unsigned long zones_size[MAX_NR_ZONES] = { 0, 0, 0 };
+
+		zones_size[ZONE_DMA] = 0;
+		zones_size[ZONE_NORMAL] = (end_mem - PAGE_OFFSET) >> PAGE_SHIFT;
+#ifdef CONFIG_HIGHMEM
+		zones_size[ZONE_HIGHMEM] = 0;
+#endif
+		free_area_init(zones_size);
+	}
+}
+
+void mem_init(void)
+{
+	unsigned int codek = 0, datak = 0, initk = 0;
+	unsigned long tmp;
+	extern char _etext, _stext, _sdata, _ebss, __init_begin, __init_end;
+	extern unsigned int _ramend, _rambase;
+	unsigned int len = _ramend - _rambase;
+	unsigned long start_mem = memory_start;
+	unsigned long end_mem = memory_end;
+
+	end_mem &= PAGE_MASK;
+	high_memory = (void *)end_mem;
+
+	start_mem = PAGE_ALIGN(start_mem);
+	max_mapnr = num_physpages = MAP_NR(high_memory);
+	printk("Physical pages: %lx\n", num_physpages);
+
+	/* this will put all memory onto the freelists */
+	totalram_pages = free_all_bootmem();
+
+	codek = (&_etext - &_stext) >> 10;
+	datak = (&_ebss - &_sdata) >> 10;
+	initk = (&__init_end - &__init_begin) >> 10;
+
+	tmp = nr_free_pages() << PAGE_SHIFT;
+	printk
+	    ("Memory available: %luk/%uk RAM, (%uk init code, %uk kernel code, %uk data, %luk dma)\n",
+	     tmp >> 10, len >> 10, initk, codek, datak,
+	     (_ramend - memory_end) >> 10);
+	/*Initialize the blackfin L1 Memory */
+	l1sram_init();
+	l1_data_A_sram_init();
+}
+
+#ifdef CONFIG_BLK_DEV_INITRD
+void free_initrd_mem(unsigned long start, unsigned long end)
+{
+	int pages = 0;
+	for (; start < end; start += PAGE_SIZE) {
+		ClearPageReserved(virt_to_page(start));
+		set_page_count(virt_to_page(start), 1);
+		free_page(start);
+		totalram_pages++;
+		pages++;
+	}
+	printk(KERN_NOTICE "Freeing initrd memory: %dk freed\n", pages);
+}
+#endif
+
+void free_initmem()
+{
+#ifdef CONFIG_RAMKERNEL
+	unsigned long addr;
+	extern char __init_begin, __init_end;
+/*
+ *	the following code should be cool even if these sections
+ *	are not page aligned.
+ */
+	addr = PAGE_ALIGN((unsigned long)(&__init_begin));
+	/* next to check that the page we free is not a partial page */
+	for (; addr + PAGE_SIZE < (unsigned long)(&__init_end);
+	     addr += PAGE_SIZE) {
+		ClearPageReserved(virt_to_page(addr));
+		set_page_count(virt_to_page(addr), 1);
+		free_page(addr);
+		totalram_pages++;
+	}
+	printk(KERN_NOTICE
+	       "Freeing unused kernel memory: %ldk freed (0x%x - 0x%x)\n",
+	       (addr - PAGE_ALIGN((long)&__init_begin)) >> 10,
+	       (int)(PAGE_ALIGN((unsigned long)(&__init_begin))),
+	       (int)(addr - PAGE_SIZE));
+#endif
+}
Index: git/linux-2.6/arch/blackfin/mm/kmap.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/mm/kmap.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,85 @@
+/*
+ * File:         arch/blackfin/mm/kmap.c
+ * Based on:     arch/m68knommu/mm/kmap.c
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:          $Id$
+ *
+ * Modified:
+ *               Copyright 2004-2005 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#undef DEBUG
+
+/*
+ * Map some physical address range into the kernel address space.
+ */
+
+void *__ioremap(unsigned long physaddr, unsigned long size, int cacheflag)
+{
+	return (void *)physaddr;
+}
+
+/*
+ * Unmap a ioremap()ed region again
+ */
+void iounmap(void *addr)
+{
+}
+
+/*
+ * __iounmap unmaps nearly everything, so be careful
+ * it doesn't free currently pointer/page tables anymore but it
+ * wans't used anyway and might be added later.
+ */
+void __iounmap(void *addr, unsigned long size)
+{
+}
+
+/*
+ * Set new cache mode for some kernel address space.
+ * The caller must push data for that range itself, if such data may already
+ * be in the cache.
+ */
+void kernel_set_cachemode(void *addr, unsigned long size, int cmode)
+{
+}
+
+int is_in_rom(unsigned long addr)
+{
+	extern unsigned long _ramstart, _ramend;
+
+	/*
+	 *      What we are really trying to do is determine if addr is
+	 *      in an allocated kernel memory region. If not then assume
+	 *      we cannot free it or otherwise de-allocate it. Ideally
+	 *      we could restrict this to really being in a ROM or flash,
+	 *      but that would need to be done on a board by board basis,
+	 *      not globally.
+	 */
+	if ((addr < _ramstart) || (addr >= _ramend))
+		return (1);
+
+	/* Default case, not in ROM */
+	return (0);
+}
Index: git/linux-2.6/arch/blackfin/oprofile/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/oprofile/Kconfig	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,21 @@
+menu "Profiling support"
+depends on EXPERIMENTAL
+
+config PROFILING
+bool "Profiling support (EXPERIMENTAL)"
+help
+  Say Y here to enable the extended profiling support mechanisms used
+  by profilers such as OProfile.
+
+
+config OPROFILE
+tristate "OProfile system profiling (EXPERIMENTAL)"
+depends on PROFILING && EXPERIMENTAL
+help
+  OProfile is a profiling system capable of profiling the
+  whole system, include the kernel, kernel modules, libraries,
+  and applications.
+
+  If unsure, say N.
+
+endmenu
Index: git/linux-2.6/arch/blackfin/oprofile/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/oprofile/Makefile	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,9 @@
+obj-$(CONFIG_OPROFILE) += oprofile.o
+
+DRIVER_OBJS := $(addprefix ../../../drivers/oprofile/, \
+oprof.o cpu_buffer.o buffer_sync.o \
+event_buffer.o oprofile_files.o \
+oprofilefs.o oprofile_stats.o \
+timer_int.o )
+
+oprofile-y := $(DRIVER_OBJS) op_model_bf533.o common.o
Index: git/linux-2.6/arch/blackfin/oprofile/common.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/oprofile/common.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2004 Anton Blanchard <anton@au.ibm.com>, IBM
+ *
+ * Based on alpha version.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/oprofile.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/errno.h>
+
+#include <asm/ptrace.h>
+#include <asm/system.h>
+#include <asm/semaphore.h>
+#include <asm/blackfin.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include "op_blackfin.h"
+
+#define BFIN_533_ID  0xE5040003
+
+static int pfmon_enabled;
+static struct semaphore pfmon_sem;
+
+extern struct op_bfin533_model op_model_bfin533;
+struct op_bfin533_model *model;
+
+struct op_counter_config ctr[OP_MAX_COUNTER];
+
+static int op_bfin_setup(void)
+{
+	int ret;
+
+	/* Pre-compute the values to stuff in the hardware registers.  */
+	spin_lock(&oprofilefs_lock);
+	ret = model->reg_setup(ctr);
+	spin_unlock(&oprofilefs_lock);
+
+	return ret;
+}
+
+static void op_bfin_shutdown(void)
+{
+#if 0
+	/* what is the difference between shutdown and stop? */
+#endif
+}
+
+static int op_bfin_start(void)
+{
+	int ret = -EBUSY;
+
+	down(&pfmon_sem);
+	if (!pfmon_enabled) {
+		ret = model->start(ctr);
+		pfmon_enabled = !ret;
+	}
+	up(&pfmon_sem);
+
+	return ret;
+}
+
+static void op_bfin_stop(void)
+{
+	down(&pfmon_sem);
+	if (pfmon_enabled) {
+		model->stop();
+		pfmon_enabled = 0;
+	}
+	up(&pfmon_sem);
+}
+
+static int op_bfin_create_files(struct super_block *sb, struct dentry *root)
+{
+	int i;
+
+	for (i = 0; i < model->num_counters; ++i) {
+		struct dentry *dir;
+		char buf[3];
+		printk("Oprofile: creating files... \n");
+
+		snprintf(buf, sizeof buf, "%d", i);
+		dir = oprofilefs_mkdir(sb, root, buf);
+
+		oprofilefs_create_ulong(sb, dir, "enabled", &ctr[i].enabled);
+		oprofilefs_create_ulong(sb, dir, "event", &ctr[i].event);
+		oprofilefs_create_ulong(sb, dir, "count", &ctr[i].count);
+		/*
+		 * We dont support per counter user/kernel selection, but
+		 * we leave the entries because userspace expects them
+		 */
+		oprofilefs_create_ulong(sb, dir, "kernel", &ctr[i].kernel);
+		oprofilefs_create_ulong(sb, dir, "user", &ctr[i].user);
+		oprofilefs_create_ulong(sb, dir, "unit_mask",
+					&ctr[i].unit_mask);
+	}
+
+	return 0;
+}
+
+static struct oprofile_operations oprof_bfin_ops = {
+	.create_files = op_bfin_create_files,
+	.setup = op_bfin_setup,
+	.shutdown = op_bfin_shutdown,
+	.start = op_bfin_start,
+	.stop = op_bfin_stop,
+	.cpu_type = NULL	/* To be filled in below. */
+};
+
+int __init oprofile_arch_init(struct oprofile_operations *ops)
+{
+	unsigned int dspid;
+
+	init_MUTEX(&pfmon_sem);
+
+	dspid = *pDSPID;
+
+	printk("Oprofile got the cpu id is 0x%x. \n", dspid);
+
+	switch (dspid) {
+	case BFIN_533_ID:
+		model = &op_model_bfin533;
+		model->num_counters = 2;
+		oprof_bfin_ops.cpu_type = model->name;
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	ops = &oprof_bfin_ops;
+
+	printk(KERN_INFO "oprofile: using %s performance monitoring.\n",
+	       oprof_bfin_ops.cpu_type);
+
+	return 0;
+}
+
+void oprofile_arch_exit(void)
+{
+}
Index: git/linux-2.6/arch/blackfin/oprofile/op_blackfin.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/oprofile/op_blackfin.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2004 Anton Blanchard <anton@au.ibm.com>, IBM
+ *
+ * Based on alpha version.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef OP_BLACKFIN_H
+#define OP_BLACKFIN_H 1
+
+#define OP_MAX_COUNTER 2
+
+#include <asm/blackfin.h>
+
+/* Per-counter configuration as set via oprofilefs.  */
+struct op_counter_config {
+	unsigned long valid;
+	unsigned long enabled;
+	unsigned long event;
+	unsigned long count;
+	unsigned long kernel;
+	unsigned long user;
+	unsigned long unit_mask;
+};
+
+/* System-wide configuration as set via oprofilefs.  */
+struct op_system_config {
+	unsigned long enable_kernel;
+	unsigned long enable_user;
+};
+
+/* Per-arch configuration */
+struct op_bfin533_model {
+	int (*reg_setup) (struct op_counter_config *);
+	int (*start) (struct op_counter_config *);
+	void (*stop) (void);
+	int num_counters;
+	char *name;
+};
+
+static inline unsigned int ctr_read(void)
+{
+	unsigned int tmp;
+
+	tmp = *pPFCTL;
+	__builtin_bfin_csync();
+
+	return tmp;
+}
+
+static inline void ctr_write(unsigned int val)
+{
+	*pPFCTL = val;
+	__builtin_bfin_csync();
+}
+
+static inline void count_read(unsigned int *count)
+{
+	count[0] = *pPFCNTR0;
+	count[1] = *pPFCNTR1;
+	__builtin_bfin_csync();
+}
+
+static inline void count_write(unsigned int *count)
+{
+	*pPFCNTR0 = count[0];
+	*pPFCNTR1 = count[1];
+	__builtin_bfin_csync();
+}
+
+#endif
Index: git/linux-2.6/arch/blackfin/oprofile/op_model_bf533.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/arch/blackfin/oprofile/op_model_bf533.c	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2004 Anton Blanchard <anton@au.ibm.com>, IBM
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/oprofile.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/interrupt.h>
+#include <asm/ptrace.h>
+#include <asm/system.h>
+#include <asm/processor.h>
+#include <asm/blackfin.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include "op_blackfin.h"
+
+#define dbg(args...) printk(args)
+#define PM_ENABLE 0x01;
+#define PM_CTL1_ENABLE  0x18
+#define PM_CTL0_ENABLE  0xC000
+#define COUNT_EDGE_ONLY 0x3000000
+
+static int oprofile_running;
+
+unsigned curr_pfctl, curr_count[2];
+
+static int bfin533_handle_interrupt(int irq, void *dummy, struct pt_regs *regs);
+
+static int bfin533_reg_setup(struct op_counter_config *ctr)
+{
+	unsigned int pfctl = ctr_read();
+	unsigned int count[2];
+
+	/* set Blackfin perf monitor regs with ctr */
+	if (ctr[0].enabled) {
+		pfctl |= (PM_CTL0_ENABLE | ((char)ctr[0].event << 5));
+		count[0] = 0xFFFFFFFF - ctr[0].count;
+		curr_count[0] = count[0];
+	}
+	if (ctr[1].enabled) {
+		pfctl |= (PM_CTL1_ENABLE | ((char)ctr[1].event << 16));
+		count[1] = 0xFFFFFFFF - ctr[1].count;
+		curr_count[1] = count[1];
+	}
+
+	pfctl |= COUNT_EDGE_ONLY;
+	curr_pfctl = pfctl;
+
+	ctr_write(pfctl);
+	count_write(count);
+
+	return 0;
+}
+
+static int bfin533_start(struct op_counter_config *ctr)
+{
+	int ret;
+	unsigned int pfctl = ctr_read();
+
+	/* Install our interrupt handler into the existing hook.  */
+	ret =
+	    request_irq(IRQ_HWERR, bfin533_handle_interrupt,
+			SA_INTERRUPT | SA_SHIRQ, "Blackfin Perfmon", NULL);
+	if (ret < 0) {
+		dbg(KERN_ERR "oprofile: unable to request IRQ for perfmon.\n");
+		return ret;
+	} else {
+		dbg("requested hardware errorr IRQ. \n");
+	}
+
+	pfctl |= PM_ENABLE;
+	curr_pfctl = pfctl;
+
+	ctr_write(pfctl);
+
+	oprofile_running = 1;
+	dbg("start oprofile counter \n");
+
+	enable_irq(IRQ_HWERR);
+
+	return 0;
+}
+
+static void bfin533_stop(void)
+{
+	int pfctl;
+
+	pfctl = ctr_read();
+	pfctl &= ~PM_ENABLE;
+	/* freeze counters */
+	ctr_write(pfctl);
+
+	oprofile_running = 0;
+	free_irq(IRQ_HWERR, NULL);
+	dbg("stop oprofile counter \n");
+}
+
+static int get_kernel(void)
+{
+	int ipend, is_kernel;
+
+	ipend = *pIPEND;
+
+	/* test bit 15 */
+	is_kernel = ((ipend & 0x8000) != 0);
+
+	return is_kernel;
+}
+
+static int bfin533_handle_interrupt(int irq, void *dummy, struct pt_regs *regs)
+{
+	int is_kernel;
+	int i, cpu;
+	unsigned int pc, pfctl;
+	unsigned int count[2];
+
+	if (oprofile_running == 0) {
+		dbg("error: entering interrupt when oprofile is stopped.\n\r");
+		return -1;
+	}
+
+	is_kernel = get_kernel();
+	cpu = smp_processor_id();
+	pc = regs->pc;
+	pfctl = ctr_read();
+
+	/* read the two event counter regs */
+	count_read(count);
+
+	/* if the counter overflows, add sample to oprofile buffer */
+	for (i = 0; i < 2; ++i) {
+		if (oprofile_running && (count[i] == 0xFFFFFFFF)) {
+			oprofile_add_sample(regs, i);
+		}
+	}
+
+	/* reset the perfmon counter */
+	ctr_write(curr_pfctl);
+	count_write(curr_count);
+	return 0;
+}
+
+struct op_bfin533_model op_model_bfin533 = {
+	.reg_setup = bfin533_reg_setup,
+	.start = bfin533_start,
+	.stop = bfin533_stop,
+	.num_counters = 2,
+	.name = "Blackfin 533"
+};
Index: git/linux-2.6/include/asm-blackfin/a.out.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/a.out.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,25 @@
+#ifndef __BFIN_A_OUT_H__
+#define __BFIN_A_OUT_H__
+
+struct exec {
+	unsigned long a_info;	/* Use macros N_MAGIC, etc for access */
+	unsigned a_text;	/* length of text, in bytes */
+	unsigned a_data;	/* length of data, in bytes */
+	unsigned a_bss;		/* length of uninitialized data area for file, in bytes */
+	unsigned a_syms;	/* length of symbol table data in file, in bytes */
+	unsigned a_entry;	/* start address */
+	unsigned a_trsize;	/* length of relocation info for text, in bytes */
+	unsigned a_drsize;	/* length of relocation info for data, in bytes */
+};
+
+#define N_TRSIZE(a)	((a).a_trsize)
+#define N_DRSIZE(a)	((a).a_drsize)
+#define N_SYMSIZE(a)	((a).a_syms)
+
+#ifdef __KERNEL__
+
+#define STACK_TOP	TASK_SIZE
+
+#endif
+
+#endif				/* __BFIN_A_OUT_H__ */
Index: git/linux-2.6/include/asm-blackfin/atomic.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/atomic.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,176 @@
+#ifndef __ARCH_BLACKFIN_ATOMIC__
+#define __ARCH_BLACKFIN_ATOMIC__
+
+/*
+ * Atomic operations that C can't guarantee us.  Useful for
+ * resource counting etc..
+ *
+ * Generally we do not concern about SMP BFIN systems, so we don't have
+ * to deal with that.
+ *
+ * Tony Kou (tonyko@lineo.ca)   Lineo Inc.   2001
+ */
+
+typedef struct {
+	int counter;
+} atomic_t;
+#define ATOMIC_INIT(i)	{ (i) }
+
+#define atomic_read(v)		((v)->counter)
+#define atomic_set(v, i)	(((v)->counter) = i)
+
+static __inline__ void atomic_add(int i, atomic_t * v)
+{
+	int __temp = 0;
+	__asm__ __volatile__(
+		"cli R3;\n\t"
+			     "%0 = %1;\n\t"
+			     "%0 = %0 + %2;\n\t"
+			     "%1 = %0;\n\t"
+		"sti R3;\n\t"
+		: "=d" (__temp), "=m" (v->counter)
+			     :"d"(i), "m"(v->counter), "0"(__temp)
+			     :"R3");
+}
+
+static __inline__ void atomic_sub(int i, atomic_t * v)
+{
+	int __temp = 0;
+	__asm__ __volatile__(
+		"cli R3;\n\t"
+			     "%0 = %1;\n\t"
+			     "%0 = %0 - %2;\n\t"
+			     "%1 = %0;\n\t"
+		"sti R3;\n\t"
+		: "=d" (__temp), "=m" (v->counter)
+			     :"d"(i), "m"(v->counter), "0"(__temp)
+			     :"R3");
+}
+
+static inline int atomic_add_return(int i, atomic_t * v)
+{
+	int __temp = 0;
+	__asm__ __volatile__(
+		"cli R3;\n\t"
+			     "%0 = %1;\n\t"
+			     "%0 = %0 + %2;\n\t"
+			     "%1 = %0;\n\t"
+		"sti R3;\n\t"
+		: "=d" (__temp), "=m" (v->counter)
+			     :"d"(i), "m"(v->counter), "0"(__temp)
+			     :"R3");
+
+	return __temp;
+}
+
+#define atomic_add_negative(a, v)	(atomic_add_return((a), (v)) < 0)
+static inline int atomic_sub_return(int i, atomic_t * v)
+{
+	int __temp = 0;
+	__asm__ __volatile__(
+		"cli R3;\n\t"
+			     "%0 = %1;\n\t"
+			     "%0 = %0 - %2;\n\t"
+			     "%1 = %0;\n\t"
+		"sti R3;\n\t"
+		: "=d" (__temp), "=m" (v->counter)
+			     :"d"(i), "m"(v->counter), "0"(__temp)
+			     :"R3");
+
+	return __temp;
+}
+
+static __inline__ void atomic_inc(volatile atomic_t * v)
+{
+	int __temp = 0;
+	__asm__ __volatile__(
+		"cli R3;\n\t"
+			     "%0 = %1;\n\t"
+			     "%0 += 1;\n\t"
+			     "%1 = %0;\n\t"
+		"sti R3;\n\t"
+		: "=d" (__temp), "=m" (v->counter)
+			     :"m"(v->counter), "0"(__temp)
+			     :"R3");
+}
+
+
+#define atomic_cmpxchg(v, o, n) ((int)cmpxchg(&((v)->counter), (o), (n)))
+
+#define atomic_add_unless(v, a, u)				\
+({								\
+	int c, old;						\
+	c = atomic_read(v);					\
+	while (c != (u) && (old = atomic_cmpxchg((v), c, c + (a))) != c) \
+		c = old;					\
+	c != (u);						\
+})
+#define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
+
+static __inline__ void atomic_dec(volatile atomic_t * v)
+{
+	int __temp = 0;
+	__asm__ __volatile__(
+		"cli R3;\n\t"
+			     "%0 = %1;\n\t"
+			     "%0 += -1;\n\t"
+			     "%1 = %0;\n\t"
+		"sti R3;\n\t"
+		: "=d" (__temp), "=m" (v->counter)
+			     :"m"(v->counter), "0"(__temp)
+			     :"R3");
+}
+
+static __inline__ void atomic_clear_mask(unsigned int mask, atomic_t * v)
+{
+	int __temp = 0;
+        __asm__ __volatile__(
+		"cli R3;\n\t"
+			     "%0 = %1;\n\t"
+			     "%0 = %0 & %2;\n\t"
+			     "%1 = %0;\n\t"
+		"sti R3;\n\t"
+		: "=d" (__temp), "=m" (v->counter)
+			     :"d"(~(mask)), "m"(v->counter), "0"(__temp)
+			     :"R3");
+}
+
+static __inline__ void atomic_set_mask(unsigned int mask, atomic_t * v)
+{
+	int __temp = 0;
+        __asm__ __volatile__(
+		"cli R3;\n\t"
+			     "%0 = %1;\n\t"
+			     "%0 = %0 | %2;\n\t"
+			     "%1 = %0;\n\t"
+		"sti R3;\n\t"
+		: "=d" (__temp), "=m" (v->counter)
+			     :"d"(mask), "m"(v->counter), "0"(__temp)
+			     :"R3");
+}
+
+/* Atomic operations are already serializing */
+#define smp_mb__before_atomic_dec()    barrier()
+#define smp_mb__after_atomic_dec() barrier()
+#define smp_mb__before_atomic_inc()    barrier()
+#define smp_mb__after_atomic_inc() barrier()
+
+#define atomic_dec_return(v) atomic_sub_return(1,(v))
+#define atomic_inc_return(v) atomic_add_return(1,(v))
+
+/*
+ * atomic_inc_and_test - increment and test
+ * @v: pointer of type atomic_t
+ *
+ * Atomically increments @v by 1
+ * and returns true if the result is zero, or false for all
+ * other cases.
+ */
+#define atomic_inc_and_test(v) (atomic_inc_return(v) == 0)
+
+#define atomic_sub_and_test(i,v) (atomic_sub_return((i), (v)) == 0)
+#define atomic_dec_and_test(v) (atomic_sub_return(1, (v)) == 0)
+
+//#include <asm-generic/atomic.h>
+
+#endif				/* __ARCH_BLACKFIN_ATOMIC __ */
Index: git/linux-2.6/include/asm-blackfin/bf533_timers.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/bf533_timers.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,120 @@
+/*
+ * include/asm/bf533_timers.h
+ *
+ * This file contains the major Data structures and constants
+ * used for General Purpose Timer Implementation in BF533
+ *
+ * Copyright (C) 2005 John DeHority
+ *
+*/
+
+#ifndef _BLACKFIN_TIMERS_H_
+#define _BLACKFIN_TIMERS_H_
+
+
+#define SSYNC() asm("ssync;")
+
+#ifdef BFIN_TIMER_DEBUG
+#define assert(expr) do {} while(0)
+#else
+#define assert(expr)                        \
+    if (!(expr)) {                      \
+	    printk("Assertion failed! %s, %s, %s, line=%d \n",  \
+		    #expr, __FILE__,__FUNCTION__,__LINE__);         \
+	}
+#endif
+
+
+/*-------------------------
+ * config reg bits value
+ *-------------------------*/
+
+/* used in masks for timer_enable() and timer_disable() */
+#define	TIMER0bit	1  /*  0001b */
+#define	TIMER1bit	2  /*  0010b */
+#define	TIMER2bit	4  /*  0100b */
+
+#define TIMER0_id	0
+#define TIMER1_id	1
+#define TIMER2_id	2
+
+/*
+** Timer Configuration Register Bits
+*/
+#define TIMER_EMU_RUN		0x0200
+#define	TIMER_TOGGLE_HI		0x0100
+#define	TIMER_CLK_SEL		0x0080
+#define TIMER_OUT_DIS		0x0040
+#define TIMER_TIN_SEL		0x0020
+#define TIMER_IRQ_ENA		0x0001
+#define TIMER_PERIOD_CNT	0x0008
+#define TIMER_PULSE_HI		0x0004
+#define TIMER_MODE			0x0003
+#define TIMER_MODE_PWM		0x0001
+#define TIMER_MODE_WDTH		0x0002
+#define TIMER_MODE_EXT_CLK	0x0003
+
+/*
+** Timer Status Register Bits
+*/
+#define	TIMER_STATUS_TIMIL0	0x0001
+#define TIMER_STATUS_TIMIL1	0x0002
+#define TIMER_STATUS_TIMIL2	0x0004
+#define TIMER_STATUS_INTR	0x0007	/* any timer interrupt */
+
+#define TIMER_STATUS_TOVF0	0x0010	/* timer 0 overflow error */
+#define TIMER_STATUS_TOVF1	0x0020
+#define TIMER_STATUS_TOVF2	0x0040
+#define TIMER_STATUS_OFLOW	0x0070	/* any timer overflow */
+
+/*
+** Timer Slave Enable Status : write 1 to clear
+*/
+#define TIMER_STATUS_TRUN0	0x1000
+#define TIMER_STATUS_TRUN1	0x2000
+#define TIMER_STATUS_TRUN2	0x4000
+#define TIMER_STATUS_TRUN	0x7000
+
+
+#define MAX_BLACKFIN_GPTIMERS	4
+
+typedef struct {
+	short	config;
+	short	empty1;
+	int	counter;
+	int	period;
+	int	width;
+}GPTIMER_timer_regs;
+
+
+/* starting address  0xFFC0 0600 */
+typedef struct {
+	GPTIMER_timer_regs	a_timer[MAX_BLACKFIN_GPTIMERS];
+	short		enable;	/* address  0xFFC0 0640 */
+	short		empty2;
+	short		disable;
+	short		empty3;
+	short		status;
+	short		empty4;
+}GPTIMER_registers;
+
+/*******************************************************************************
+*	GP_TIMER API's
+*******************************************************************************/
+
+void 	set_gptimer_pwidth		(int timer_id, int width);
+int	get_gptimer_pwidth		(int timer_id);
+void 	set_gptimer_period		(int timer_id, int period);
+int	get_gptimer_period		(int timer_id);
+int	get_gptimer_count		(int timer_id);
+short	get_gptimer_running		(int	timer_id);
+short	get_gptimer_intr		(int	timer_id);
+void	set_gptimer_config		(int timer_id, short config);
+short	get_gptimer_config		(int timer_id);
+void	set_gptimer_pulse_hi	(int timer_id);
+void	clear_gptimer_pulse_hi	(int timer_id);
+void	enable_gptimers			(short mask);
+void	disable_gptimers		(short mask);
+
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/bf5xx_rtc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/bf5xx_rtc.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,19 @@
+/*
+ * BF533 RTC support functions.
+ */
+
+#ifndef _BF533_RTC_H_
+#define _BF533_RTC_H_
+
+#include <linux/time.h>
+
+/* Intialize the BF533 RTC */
+int rtc_init(void);
+
+/* Get the time stored in RTC. time_in_seconds is no. of seconds from Jan 1970 */
+int rtc_get(time_t * time_in_seconds);
+
+/* Set a new time in the RTC. time_in_seconds is no. of seconds from Jan 1970  */
+int rtc_set(time_t time_in_seconds);
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/bfin_spi_channel.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/bfin_spi_channel.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,182 @@
+/************************************************************
+*
+* Copyright (C) 2003, Motorola. All Rights Reserved
+*
+* FILE spi.h
+* PROGRAMMER(S): J.X.Chang (jxchang@motorola.com)
+*
+*
+* DATE OF CREATION: March 8, 2003
+*
+* SYNOPSIS:
+*
+* DESCRIPTION: It's driver of SPI in ADSP25535(ADI's DSP). It can
+*              only be used in unix or linux.
+* CAUTION:     User should use 'ioctl' to change it's
+               configuration just after openning device.
+**************************************************************
+* MODIFICATION HISTORY:
+* March 8, 2003   File spi.h Created.
+************************************************************/
+
+#ifndef _SPI_CHANNEL_H_
+#define _SPI_CHANNEL_H_
+
+#include <linux/interrupt.h>
+
+#define SPI0_REGBASE       0xffc00500
+
+#define SPI_READ              0
+#define SPI_WRITE             1
+
+typedef struct Spi_Device_t
+{
+	char  *dev_name;
+
+	unsigned short     flag;
+	unsigned short     bdrate;
+
+	unsigned short     enable;
+	unsigned short     master;
+	unsigned short     out_opendrain;
+	unsigned short     polar;
+	unsigned short     phase;
+	unsigned short     byteorder;  /* 0: MSB first; 1: LSB first; */
+	unsigned short     size;     /* 0: 8 bits; 1: 16 bits */
+	unsigned short     emiso;
+	unsigned short     send_zero;
+	unsigned short     more_data;
+	unsigned short     slave_sel;
+	unsigned short     ti_mod;
+
+	unsigned short     dma;         /* use dma mode or not */
+	unsigned short     dma_config;  /* only valid if dma enabled */
+
+	irqreturn_t        (*irq_handler)(int irq, void *dev_id, struct pt_regs *regs);
+	void               *priv_data;
+}spi_device_t;
+
+
+#define SPI_CTRL_OFF            0x0
+#define SPI_FLAG_OFF            0x4
+#define SPI_STAT_OFF            0x8
+#define SPI_TXBUFF_OFF          0xc
+#define SPI_RXBUFF_OFF          0x10
+#define SPI_BAUD_OFF            0x14
+#define SPI_SHAW_OFF            0x18
+
+#define CMD_SPI_OUT_ENABLE    1
+#define CMD_SPI_SET_BAUDRATE  2
+#define CMD_SPI_SET_POLAR     3
+#define CMD_SPI_SET_PHASE     4
+#define CMD_SPI_SET_MASTER    5
+#define CMD_SPI_SET_SENDOPT   6
+#define CMD_SPI_SET_RECVOPT   7
+#define CMD_SPI_SET_ORDER     8
+#define CMD_SPI_SET_LENGTH16  9
+#define CMD_SPI_GET_STAT      11
+#define CMD_SPI_GET_CFG       12
+#define CMD_SPI_SET_CSAVAIL   13
+#define CMD_SPI_SET_CSHIGH    14 /* CS unavail */
+#define CMD_SPI_SET_CSLOW     15 /* CS avail */
+#define CMD_SPI_MISO_ENABLE   16
+#define CMD_SPI_SET_CSENABLE  17
+#define CMD_SPI_SET_CSDISABLE 18
+
+#define CMD_SPI_SET_TRIGGER_MODE  19
+#define CMD_SPI_SET_TRIGGER_SENSE 20
+#define CMD_SPI_SET_TRIGGER_EDGE  21
+#define CMD_SPI_SET_TRIGGER_LEVEL 22
+
+#define CMD_SPI_SET_TIME_SPS 	  23
+#define CMD_SPI_SET_TIME_SAMPLES  24
+#define CMD_SPI_GET_SYSTEMCLOCK   25
+
+#define CMD_SPI_SET_WRITECONTINUOUS     26
+
+#define CMD_SPI_GET_ALLCONFIG 32 /* For debug */
+
+#define SPI_DEFAULT_BARD    0x0100
+
+#define SPI0_IRQ_NUM        20
+#define SPI_ERR_TRIG	   -1
+
+#define BIT_CTL_ENABLE      0x4000
+#define BIT_CTL_OPENDRAIN   0x2000
+#define BIT_CTL_MASTER      0x1000
+#define BIT_CTL_POLAR       0x0800
+#define BIT_CTL_PHASE       0x0400
+#define BIT_CTL_BITORDER    0x0200
+#define BIT_CTL_WORDSIZE    0x0100
+#define BIT_CTL_MISOENABLE  0x0020
+#define BIT_CTL_RXMOD       0x0000
+#define BIT_CTL_TXMOD       0x0001
+#define BIT_CTL_TIMOD_DMA_TX 0x0003
+#define BIT_CTL_TIMOD_DMA_RX 0x0002
+#define BIT_CTL_SENDOPT     0x0004
+
+#define BIT_STU_SENDOVER    0x0001
+#define BIT_STU_RECVFULL    0x0020
+
+#define CFG_SPI_ENABLE      1
+#define CFG_SPI_DISABLE     0
+
+#define CFG_SPI_OUTENABLE   1
+#define CFG_SPI_OUTDISABLE  0
+
+#define CFG_SPI_ACTLOW      1
+#define CFG_SPI_ACTHIGH     0
+
+#define CFG_SPI_PHASESTART  1
+#define CFG_SPI_PHASEMID    0
+
+#define CFG_SPI_MASTER      1
+#define CFG_SPI_SLAVE       0
+
+#define CFG_SPI_SENELAST    1
+#define CFG_SPI_SENDZERO    0
+
+#define CFG_SPI_RCVFLUSH    1
+#define CFG_SPI_RCVDISCARD  0
+
+#define CFG_SPI_LSBFIRST    1
+#define CFG_SPI_MSBFIRST    0
+
+#define CFG_SPI_WORDSIZE16  1
+#define CFG_SPI_WORDSIZE8   0
+
+#define CFG_SPI_MISOENABLE   1
+#define CFG_SPI_MISODISABLE  0
+
+#define CFG_SPI_CSCLEARALL  0x0000
+#define CFG_SPI_CHIPSEL1    0x0002
+#define CFG_SPI_CHIPSEL2    0x0004
+#define CFG_SPI_CHIPSEL3    0x0008
+#define CFG_SPI_CHIPSEL4    0x0010
+#define CFG_SPI_CHIPSEL5    0x0020
+#define CFG_SPI_CHIPSEL6    0x0040
+#define CFG_SPI_CHIPSEL7    0x0080
+
+#define CFG_SPI_CS1VALUE    0x0200
+#define CFG_SPI_CS2VALUE    0x0400
+#define CFG_SPI_CS3VALUE    0x0800
+#define CFG_SPI_CS4VALUE    0x1000
+#define CFG_SPI_CS5VALUE    0x2000
+#define CFG_SPI_CS6VALUE    0x4000
+#define CFG_SPI_CS7VALUE    0x8000
+
+
+void spi_send_data(unsigned short data);
+unsigned short spi_receive_data(void);
+void spi_enable(spi_device_t *spi_dev);
+void spi_disable(spi_device_t *spi_dev);
+int spi_dma_read(spi_device_t *spi_dev, void *buffer, unsigned int count);
+int spi_dma_write(spi_device_t *spi_dev, void *buffer, unsigned int count);
+void spi_clear_irqstat(spi_device_t *spi_dev);
+void spi_set_ctl(spi_device_t *spi_dev);
+void spi_get_stat(unsigned short *data);
+void spi_get_ctl(unsigned short *data);
+int spi_channel_request(spi_device_t *spi_dev);
+int spi_channel_release (spi_device_t *spi_dev);
+
+#endif /* _SPI_CHANNEL_H_ */
Index: git/linux-2.6/include/asm-blackfin/bitops.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/bitops.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,400 @@
+#ifndef _BLACKFIN_BITOPS_H
+#define _BLACKFIN_BITOPS_H
+
+/*
+ * Copyright 1992, Linus Torvalds.
+ */
+
+#include <asm/system.h>		/* save_flags */
+
+#ifdef __KERNEL__
+
+/*
+ *	Generic __ffs().
+ */
+static inline int __ffs(int x)
+{
+	int r = 0;
+
+	if (!x)
+		return 0;
+	if (!(x & 0xffff)) {
+		x >>= 16;
+		r += 16;
+	}
+	if (!(x & 0xff)) {
+		x >>= 8;
+		r += 8;
+	}
+	if (!(x & 0xf)) {
+		x >>= 4;
+		r += 4;
+	}
+	if (!(x & 3)) {
+		x >>= 2;
+		r += 2;
+	}
+	if (!(x & 1)) {
+		x >>= 1;
+		r += 1;
+	}
+	return r;
+}
+
+/*
+ * Every architecture must define this function. It's the fastest
+ * way of searching a 140-bit bitmap where the first 100 bits are
+ * unlikely to be set. It's guaranteed that at least one of the 140
+ * bits is cleared.
+ */
+static inline int sched_find_first_bit(unsigned long *b)
+{
+	if (unlikely(b[0]))
+		return __ffs(b[0]);
+	if (unlikely(b[1]))
+		return __ffs(b[1]) + 32;
+	if (unlikely(b[2]))
+		return __ffs(b[2]) + 64;
+	if (b[3])
+		return __ffs(b[3]) + 96;
+	return __ffs(b[4]) + 128;
+}
+
+/*
+ * The __ functions are not atomic
+ */
+
+/*
+ * ffz = Find First Zero in word. Undefined if no zero exists,
+ * so code should check against ~0UL first..
+ */
+static __inline__ unsigned long ffz(unsigned long word)
+{
+	unsigned long result = 0;
+
+	while (word & 1) {
+		result++;
+		word >>= 1;
+	}
+	return result;
+}
+
+static __inline__ void set_bit(int nr, volatile unsigned long *addr)
+{
+	int *a = (int *)addr;
+	int mask;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	local_irq_save(flags);
+	*a |= mask;
+	local_irq_restore(flags);
+}
+
+static __inline__ void __set_bit(int nr, volatile unsigned long *addr)
+{
+	int *a = (int *)addr;
+	int mask;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	*a |= mask;
+}
+
+/*
+ * clear_bit() doesn't provide any barrier for the compiler.
+ */
+#define smp_mb__before_clear_bit()	barrier()
+#define smp_mb__after_clear_bit()	barrier()
+
+static __inline__ void clear_bit(int nr, volatile unsigned long *addr)
+{
+	int *a = (int *)addr;
+	int mask;
+	unsigned long flags;
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	local_irq_save(flags);
+	*a &= ~mask;
+	local_irq_restore(flags);
+}
+
+static __inline__ void __clear_bit(int nr, volatile unsigned long *addr)
+{
+	int *a = (int *)addr;
+	int mask;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	*a &= ~mask;
+}
+
+static __inline__ void change_bit(int nr, volatile unsigned long *addr)
+{
+	int mask, flags;
+	unsigned long *ADDR = (unsigned long *)addr;
+
+	ADDR += nr >> 5;
+	mask = 1 << (nr & 31);
+	local_irq_save(flags);
+	*ADDR ^= mask;
+	local_irq_restore(flags);
+}
+
+static __inline__ void __change_bit(int nr, volatile unsigned long *addr)
+{
+	int mask;
+	unsigned long *ADDR = (unsigned long *)addr;
+
+	ADDR += nr >> 5;
+	mask = 1 << (nr & 31);
+	*ADDR ^= mask;
+}
+
+static __inline__ int test_and_set_bit(int nr, void *addr)
+{
+	int mask, retval;
+	volatile unsigned int *a = (volatile unsigned int *)addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	local_irq_save(flags);
+	retval = (mask & *a) != 0;
+	*a |= mask;
+	local_irq_restore(flags);
+
+	return retval;
+}
+
+static __inline__ int __test_and_set_bit(int nr, volatile unsigned long *addr)
+{
+	int mask, retval;
+	volatile unsigned int *a = (volatile unsigned int *)addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	retval = (mask & *a) != 0;
+	*a |= mask;
+	return retval;
+}
+
+static __inline__ int test_and_clear_bit(int nr, volatile unsigned long *addr)
+{
+	int mask, retval;
+	volatile unsigned int *a = (volatile unsigned int *)addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	local_irq_save(flags);
+	retval = (mask & *a) != 0;
+	*a &= ~mask;
+	local_irq_restore(flags);
+
+	return retval;
+}
+
+static __inline__ int __test_and_clear_bit(int nr, volatile unsigned long *addr)
+{
+	int mask, retval;
+	volatile unsigned int *a = (volatile unsigned int *)addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	retval = (mask & *a) != 0;
+	*a &= ~mask;
+	return retval;
+}
+
+static __inline__ int test_and_change_bit(int nr, volatile unsigned long *addr)
+{
+	int mask, retval;
+	volatile unsigned int *a = (volatile unsigned int *)addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	local_irq_save(flags);
+	retval = (mask & *a) != 0;
+	*a ^= mask;
+	local_irq_restore(flags);
+	return retval;
+}
+
+static __inline__ int __test_and_change_bit(int nr,
+					    volatile unsigned long *addr)
+{
+	int mask, retval;
+	volatile unsigned int *a = (volatile unsigned int *)addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	retval = (mask & *a) != 0;
+	*a ^= mask;
+	return retval;
+}
+
+/*
+ * This routine doesn't need to be atomic.
+ */
+static __inline__ int __constant_test_bit(int nr, const void *addr)
+{
+	return ((1UL << (nr & 31)) &
+		(((const volatile unsigned int *)addr)[nr >> 5])) != 0;
+}
+
+static __inline__ int __test_bit(int nr, const void *addr)
+{
+	int *a = (int *)addr;
+	int mask;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	return ((mask & *a) != 0);
+}
+
+#define test_bit(nr,addr) \
+(__builtin_constant_p(nr) ? \
+ __constant_test_bit((nr),(addr)) : \
+ __test_bit((nr),(addr)))
+
+#define find_first_zero_bit(addr, size) \
+        find_next_zero_bit((addr), (size), 0)
+#define find_first_bit(addr, size) \
+	find_next_bit((addr), (size), 0)
+
+static __inline__ int find_next_zero_bit(const void *addr, int size,
+					 int offset)
+{
+	unsigned long *p = ((unsigned long *)addr) + (offset >> 5);
+	unsigned long result = offset & ~31UL;
+	unsigned long tmp;
+
+	if (offset >= size)
+		return size;
+	size -= result;
+	offset &= 31UL;
+	if (offset) {
+		tmp = *(p++);
+		tmp |= ~0UL >> (32 - offset);
+		if (size < 32)
+			goto found_first;
+		if (~tmp)
+			goto found_middle;
+		size -= 32;
+		result += 32;
+	}
+	while (size & ~31UL) {
+		if (~(tmp = *(p++)))
+			goto found_middle;
+		result += 32;
+		size -= 32;
+	}
+	if (!size)
+		return result;
+	tmp = *p;
+      found_first:
+	tmp |= ~0UL >> size;
+	if (tmp == ~0UL)	/* Are any bits zero? */
+		return result + size;	/* Nope. */
+      found_middle:
+	return result + ffz(tmp);
+}
+
+/*
+ * Find next one bit in a bitmap reasonably efficiently.
+ */
+static __inline__ unsigned long find_next_bit(const unsigned long *addr,
+					      unsigned long size,
+					      unsigned long offset)
+{
+	unsigned int *p = ((unsigned int *)addr) + (offset >> 5);
+	unsigned int result = offset & ~31UL;
+	unsigned int tmp;
+
+	if (offset >= size)
+		return size;
+	size -= result;
+	offset &= 31UL;
+	if (offset) {
+		tmp = *p++;
+		tmp &= ~0UL << offset;
+		if (size < 32)
+			goto found_first;
+		if (tmp)
+			goto found_middle;
+		size -= 32;
+		result += 32;
+	}
+	while (size >= 32) {
+		if ((tmp = *(p++)))
+			goto found_middle;
+		result += 32;
+		size -= 32;
+	}
+	if (!size)
+		return result;
+	tmp = *p;
+
+      found_first:
+	tmp &= ~0UL >> (32 - size);
+	if (tmp == 0UL)		/* Are any bits set? */
+		return result + size;	/* Nope. */
+      found_middle:
+	return result + __ffs(tmp);
+}
+
+/*
+ * ffs: find first bit set. This is defined the same way as
+ * the libc and compiler builtin ffs routines, therefore
+ * differs in spirit from the above ffz (man ffs).
+ */
+
+#define ffs(x) generic_ffs(x)
+#define fls(x) generic_fls(x)
+
+/*
+ * hweightN: returns the hamming weight (i.e. the number
+ * of bits set) of a N-bit word
+ */
+
+#define hweight32(x) generic_hweight32(x)
+#define hweight16(x) generic_hweight16(x)
+#define hweight8(x) generic_hweight8(x)
+
+#define ext2_set_bit_atomic(lock, nr, addr)		\
+	({						\
+		int ret;				\
+		spin_lock(lock);			\
+		ret = ext2_set_bit((nr), (addr));	\
+		spin_unlock(lock);			\
+		ret;					\
+	})
+
+#define ext2_clear_bit_atomic(lock, nr, addr)		\
+	({						\
+		int ret;				\
+		spin_lock(lock);			\
+		ret = ext2_clear_bit((nr), (addr));	\
+		spin_unlock(lock);			\
+		ret;					\
+	})
+
+#define ext2_set_bit			test_and_set_bit
+#define ext2_clear_bit			test_and_clear_bit
+#define ext2_test_bit			test_bit
+#define ext2_find_first_zero_bit	find_first_zero_bit
+#define ext2_find_next_zero_bit		find_next_zero_bit
+
+/* Bitmap functions for the minix filesystem.  */
+#define minix_test_and_set_bit(nr,addr) test_and_set_bit(nr,addr)
+#define minix_set_bit(nr,addr) set_bit(nr,addr)
+#define minix_test_and_clear_bit(nr,addr) test_and_clear_bit(nr,addr)
+#define minix_test_bit(nr,addr) test_bit(nr,addr)
+#define minix_find_first_zero_bit(addr,size) find_first_zero_bit(addr,size)
+
+#endif				/* __KERNEL__ */
+
+#endif				/* _BLACKFIN_BITOPS_H */
Index: git/linux-2.6/include/asm-blackfin/blackfin.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/blackfin.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,13 @@
+/*
+ * Common header file for blackfin family of processors.
+ *
+ */
+
+#ifndef _BLACKFIN_H_
+#define _BLACKFIN_H_
+
+#include <linux/config.h>
+#include <asm/macros.h>
+#include <asm/mach/blackfin.h>
+
+#endif				/* _BLACKFIN_H_ */
Index: git/linux-2.6/include/asm-blackfin/board/eagle.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/board/eagle.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,4 @@
+#ifndef _EAGLE_H_
+#define _EAGLE_H_
+
+#endif				/* _EAGLE_H_ */
Index: git/linux-2.6/include/asm-blackfin/board/ezkit.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/board/ezkit.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,4 @@
+#ifndef _EZKIT_H_
+#define _EZKIT_H_
+
+#endif				/* _EZKIT_H_ */
Index: git/linux-2.6/include/asm-blackfin/board/hawk.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/board/hawk.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,4 @@
+#ifndef _HAWK_H_
+#define _HAWK_H_
+
+#endif				/* _HAWK_H_ */
Index: git/linux-2.6/include/asm-blackfin/board/pub.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/board/pub.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,17 @@
+#ifndef _PUB_H_
+#define _PUB_H_
+
+/*
+ * The PUB board uses the ADI21535 Rev0.2 silicon.
+ *
+ * According to ADI21535 Anomaly List (Dec3, 2002),
+ * the polarity of SIC_MASK reg in Rev0.2 silicon
+ * is inverted. Value '1' will disable interrupt
+ * while '0' will enable interrupt.
+ *
+ * HuTao, Jun 20 2003, 5:50PM
+ */
+#undef SIC_MASK_ALL
+#define SIC_MASK_ALL	(~0x80000000)
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/bug.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/bug.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,5 @@
+#ifndef _BLACKFIN_BUG_H
+#define _BLACKFIN_BUG_H
+
+#include <asm-generic/bug.h>
+#endif
Index: git/linux-2.6/include/asm-blackfin/bugs.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/bugs.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,16 @@
+/*
+ *  include/asm-blackfin/bugs.h
+ *
+ *  Copyright (C) 1994  Linus Torvalds
+ */
+
+/*
+ * This is included by init/main.c to check for architecture-dependent bugs.
+ *
+ * Needs:
+ *	void check_bugs(void);
+ */
+
+static void check_bugs(void)
+{
+}
Index: git/linux-2.6/include/asm-blackfin/byteorder.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/byteorder.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,48 @@
+#ifndef _BLACKFIN_BYTEORDER_H
+#define _BLACKFIN_BYTEORDER_H
+
+#include <asm/types.h>
+#include <linux/compiler.h>
+
+#ifdef __GNUC__
+
+static __inline__ __attribute_const__ __u32 ___arch__swahb32(__u32 xx)
+{
+	__u32 tmp;
+	__asm__("%1 = %0 >> 8 (V);\n\t"
+		"%0 = %0 << 8 (V);\n\t"
+		"%0 = %0 | %1;\n\t"
+		: "+d"(xx), "=&d"(tmp));
+	return xx;
+}
+
+static __inline__ __attribute_const__ __u32 ___arch__swahw32(__u32 xx)
+{
+	__u32 rv;
+	__asm__("%0 = PACK(%1.L, %1.H);\n\t": "=d"(rv): "d"(xx));
+	return rv;
+}
+
+#define __arch__swahb32(x) ___arch__swahb32(x)
+#define __arch__swahw32(x) ___arch__swahw32(x)
+#define __arch__swab32(x) ___arch__swahb32(___arch__swahw32(x))
+
+static __inline__ __attribute_const__ __u16 ___arch__swab16(__u16 xx)
+{
+	__u32 xw = xx;
+	__asm__("%0 <<= 8;\n	%0.L = %0.L + %0.H (NS);\n": "+d"(xw));
+	return (__u16)xw;
+}
+
+#define __arch__swab16(x) ___arch__swab16(x)
+
+#endif
+
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__) || defined(__KERNEL__)
+#  define __BYTEORDER_HAS_U64__
+#  define __SWAB_64_THRU_32__
+#endif
+
+#include <linux/byteorder/little_endian.h>
+
+#endif				/* _BLACKFIN_BYTEORDER_H */
Index: git/linux-2.6/include/asm-blackfin/cache.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/cache.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,18 @@
+#ifndef __ARCH_BLACKFIN_CACHE_H
+#define __ARCH_BLACKFIN_CACHE_H
+
+/* bytes per L1 cache line */
+#define        L1_CACHE_SHIFT  5	/* BlackFin loads 32 bytes for cache */
+#define        L1_CACHE_BYTES  (1 << L1_CACHE_SHIFT)
+
+/* For speed we do need to align these ...MaTed---*/
+/*  But include/linux/cache.h does this for us if we DO not define ...MaTed---*/
+#define __cacheline_aligned	/***** maybe no need this   Tony *****/
+#define ____cacheline_aligned
+
+/*
+ * largest L1 which this arch supports
+ */
+#define L1_CACHE_SHIFT_MAX	5
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/cacheflush.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/cacheflush.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,103 @@
+/*
+ * File:         include/asm-blackfin/cacheflush.h
+ * Based on:	 include/asm-m68knommu/cacheflush.h
+ * Author:       LG Soft India
+ *               Copyright (C) 2004 Analog Devices Inc.
+ * Created:      Tue Sep 21 2004
+ * Description:  Blackfin low-level cache routines adapted from the i386
+ * 		 and PPC versions by Greg Ungerer (gerg@snapgear.com)
+ * Rev:          $Id$
+ *
+ * Modified:
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _BLACKFIN_CACHEFLUSH_H
+#define _BLACKFIN_CACHEFLUSH_H
+
+#include <asm/cplb.h>
+
+extern void flush_instruction_cache(void);
+extern void blackfin_icache_dcache_flush_range(unsigned int, unsigned int);
+extern void blackfin_icache_flush_range(unsigned int, unsigned int);
+extern void blackfin_dcache_flush_range(unsigned int, unsigned int);
+extern void blackfin_dcache_invalidate_range(unsigned int, unsigned int);
+extern void blackfin_dflush_page(void *);
+extern void flush_data_cache(void);
+
+#define flush_dcache_mmap_lock(mapping)		do { } while (0)
+#define flush_dcache_mmap_unlock(mapping)	do { } while (0)
+#define flush_cache_mm(mm)			do { } while (0)
+#define flush_cache_range(vma, start, end)	do { } while (0)
+#define flush_cache_page(vma, vmaddr)		do { } while (0)
+#define flush_cache_vmap(start, end)		do { } while (0)
+#define flush_cache_vunmap(start, end)		do { } while (0)
+
+static inline void flush_icache_range(unsigned start, unsigned end)
+{
+#if defined( CONFIG_BLKFIN_DCACHE ) && defined( CONFIG_BLKFIN_CACHE )
+
+#if defined( CONFIG_BLKFIN_WT )
+	blackfin_icache_flush_range((start), (end));
+#else
+	blackfin_icache_dcache_flush_range((start), (end));
+#endif
+
+#else
+
+#if defined( CONFIG_BLKFIN_CACHE )
+	blackfin_icache_flush_range((start), (end));
+#endif
+#if defined( CONFIG_BLKFIN_DCACHE )
+	blackfin_dcache_flush_range((start), (end));
+#endif
+
+#endif
+}
+
+#define copy_to_user_page(vma, page, vaddr, dst, src, len) \
+do { memcpy(dst, src, len); \
+     flush_icache_range (vaddr, vaddr + len); \
+} while (0)
+#define copy_from_user_page(vma, page, vaddr, dst, src, len)	memcpy(dst, src, len)
+
+#if defined( CONFIG_BLKFIN_DCACHE )
+#define invalidate_dcache_range(start,end)	blackfin_dcache_invalidate_range((start), (end))
+#else
+#define invalidate_dcache_range(start,end)	do { } while (0)
+#endif
+#if defined( CONFIG_BLKFIN_DCACHE ) && defined( CONFIG_BLKFIN_WB )
+#	define flush_dcache_range(start,end)		blackfin_dcache_flush_range((start), (end))
+#	define flush_dcache_page(page)			blackfin_dflush_page(page_address(page))
+#else
+#	define flush_dcache_range(start,end)		do { } while (0)
+#	define flush_dcache_page(page)			do { } while (0)
+#endif
+
+static inline void flush_cache_all(void)
+{
+#ifdef CONFIG_BLKFIN_CACHE
+	flush_instruction_cache();
+#endif
+#ifdef CONFIG_BLKFIN_DCACHE
+	flush_data_cache();
+#endif
+}
+
+#endif				/* _BLACKFIN_CACHEFLUSH_H */
Index: git/linux-2.6/include/asm-blackfin/checksum.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/checksum.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,102 @@
+#ifndef _BFIN_CHECKSUM_H
+#define _BFIN_CHECKSUM_H
+
+/*
+ * MODIFIED FOR BFIN April 30, 2001 akbar.hussain@lineo.com
+ *
+ * computes the checksum of a memory block at buff, length len,
+ * and adds in "sum" (32-bit)
+ *
+ * returns a 32-bit number suitable for feeding into itself
+ * or csum_tcpudp_magic
+ *
+ * this function must be called with even lengths, except
+ * for the last fragment, which may be odd
+ *
+ * it's best to have buff aligned on a 32-bit boundary
+ */
+unsigned int csum_partial(const unsigned char *buff, int len, unsigned int sum);
+
+/*
+ * the same as csum_partial, but copies from src while it
+ * checksums
+ *
+ * here even more important to align src and dst on a 32-bit (or even
+ * better 64-bit) boundary
+ */
+
+unsigned int csum_partial_copy(const unsigned char *src, unsigned char *dst,
+	int len, int sum);
+
+
+/*
+ * the same as csum_partial_copy, but copies from user space.
+ *
+ * here even more important to align src and dst on a 32-bit (or even
+ * better 64-bit) boundary
+ */
+
+extern unsigned int csum_partial_copy_from_user(const unsigned char *src,
+						unsigned char *dst, int len,
+						int sum, int *csum_err);
+
+#define csum_partial_copy_nocheck(src, dst, len, sum)	\
+	csum_partial_copy((src), (dst), (len), (sum))
+
+unsigned short ip_fast_csum(unsigned char *iph, unsigned int ihl);
+
+/*
+ *	Fold a partial checksum
+ */
+
+static inline unsigned int csum_fold(unsigned int sum)
+{
+	while (sum >> 16)
+		sum = (sum & 0xffff) + (sum >> 16);
+	return ((~(sum << 16)) >> 16);
+}
+
+/*
+ * computes the checksum of the TCP/UDP pseudo-header
+ * returns a 16-bit checksum, already complemented
+ */
+
+static inline unsigned int
+csum_tcpudp_nofold(unsigned long saddr, unsigned long daddr, unsigned short len,
+		   unsigned short proto, unsigned int sum)
+{
+
+	__asm__ ("%0 = %0 + %1;\n\t"
+		 "CC = AC0;\n\t"
+		 "if !CC jump 4;\n\t"
+		 "%0 = %0 + %4;\n\t"
+		 "%0 = %0 + %2;\n\t"
+		 "CC = AC0;\n\t"
+                 "if !CC jump 4;\n\t"
+                 "%0 = %0 + %4;\n\t"
+ 		 "%0 = %0 + %3;\n\t"
+		 "CC = AC0;\n\t"
+                 "if !CC jump 4;\n\t"
+                 "%0 = %0 + %4;\n\t"
+                 "NOP;\n\t"
+ 		 : "=d" (sum)
+		 : "d" (daddr), "d" (saddr), "d" ((ntohs(len)<<16)+proto*256), "d" (1), "0"(sum));
+
+	return (sum);
+}
+
+static inline unsigned short int
+csum_tcpudp_magic(unsigned long saddr, unsigned long daddr, unsigned short len,
+		  unsigned short proto, unsigned int sum)
+{
+	return csum_fold(csum_tcpudp_nofold(saddr, daddr, len, proto, sum));
+}
+
+/*
+ * this routine is used for miscellaneous IP-like checksums, mainly
+ * in icmp.c
+ */
+
+extern unsigned short ip_compute_csum(const unsigned char *buff, int len);
+
+#endif				/* _BFIN_CHECKSUM_H */
Index: git/linux-2.6/include/asm-blackfin/cplb.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/cplb.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,50 @@
+/************************************************************************
+ *
+ * cplb.h
+ *
+ * (c) Copyright 2002-2003 Analog Devices, Inc.  All rights reserved.
+ *
+ ************************************************************************/
+
+/* Defines necessary for cplb initialisation routines. */
+
+#ifndef _CPLB_H
+#define _CPLB_H
+
+# include <asm/blackfin.h>
+
+#define CPLB_ENABLE_ICACHE_P	0
+#define CPLB_ENABLE_DCACHE_P	1
+#define CPLB_ENABLE_DCACHE2_P	2
+#define CPLB_ENABLE_CPLBS_P	3	/* Deprecated! */
+#define CPLB_ENABLE_ICPLBS_P	4
+#define CPLB_ENABLE_DCPLBS_P	5
+
+#define CPLB_ENABLE_ICACHE	(1<<CPLB_ENABLE_ICACHE_P)
+#define CPLB_ENABLE_DCACHE	(1<<CPLB_ENABLE_DCACHE_P)
+#define CPLB_ENABLE_DCACHE2	(1<<CPLB_ENABLE_DCACHE2_P)
+#define CPLB_ENABLE_CPLBS	(1<<CPLB_ENABLE_CPLBS_P)
+#define CPLB_ENABLE_ICPLBS	(1<<CPLB_ENABLE_ICPLBS_P)
+#define CPLB_ENABLE_DCPLBS	(1<<CPLB_ENABLE_DCPLBS_P)
+#define CPLB_ENABLE_ANY_CPLBS	CPLB_ENABLE_CPLBS | \
+				CPLB_ENABLE_ICPLBS | \
+				CPLB_ENABLE_DCPLBS
+
+#define CPLB_RELOADED		0x0000
+#define CPLB_NO_UNLOCKED	0x0001
+#define CPLB_NO_ADDR_MATCH	0x0002
+#define CPLB_PROT_VIOL		0x0003
+
+#define CPLB_DEF_CACHE		CPLB_L1_CHBL | CPLB_WT
+#define CPLB_CACHE_ENABLED	CPLB_L1_CHBL | CPLB_DIRTY
+
+#define CPLB_ALL_ACCESS	CPLB_SUPV_WR | CPLB_USER_RD | CPLB_USER_WR
+
+#define CPLB_I_PAGE_MGMT	CPLB_LOCK | CPLB_VALID
+#define CPLB_D_PAGE_MGMT	CPLB_LOCK | CPLB_ALL_ACCESS | CPLB_VALID
+#define CPLB_DNOCACHE		CPLB_ALL_ACCESS | CPLB_VALID
+#define CPLB_DDOCACHE		CPLB_DNOCACHE | CPLB_DEF_CACHE
+#define CPLB_INOCACHE   	CPLB_USER_RD | CPLB_VALID
+#define CPLB_IDOCACHE   	CPLB_INOCACHE | CPLB_L1_CHBL
+
+#endif				/* _CPLB_H */
Index: git/linux-2.6/include/asm-blackfin/cplbtab.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/cplbtab.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,572 @@
+/*This file is subject to the terms and conditions of the GNU General Public
+ * License.
+ *
+ * Blackfin BF533/2.6 support : LG Soft India
+ * Updated : Ashutosh Singh / Jahid Khan : Rrap Software Pvt Ltd
+ * Updated : 1. SDRAM_KERNEL, SDRAM_DKENEL are added as initial cplb's
+ *	        shouldn't be victimized. cplbmgr.S search logic is corrected
+ *	        to findout the appropriate victim.
+ *	     2. SDRAM_IGENERIC in dpdt_table is replaced with SDRAM_DGENERIC
+ *	     : LG Soft India
+ */
+
+#ifndef __ARCH_BLACKFIN_CPLBTAB_H
+#define __ARCH_BLACKFIN_CPLBTAB_H
+
+/*************************************************************************
+ *  			ICPLB TABLE
+ *************************************************************************/
+
+.data
+/* This table is configurable */
+    .align 4;
+
+.global _icplb_table
+_icplb_table:
+.byte4        0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 10 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 20 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 30 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0xffffffff;		/* end of section - termination */
+
+.align 4;
+.global _ipdt_table
+_ipdt_table:
+.byte4        0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 10 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 20 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 30 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 40 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 50 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 60 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 70 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 80 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 90 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 100 */
+.byte4 0xffffffff;		/* end of section - termination */
+
+/*********************************************************************
+ *			DCPLB TABLE
+ ********************************************************************/
+
+.global _dcplb_table
+_dcplb_table:
+.byte4        0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 10 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 20 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 30 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0xffffffff;		/*end of section - termination */
+
+/**********************************************************************
+ *		PAGE DESCRIPTOR TABLE
+ *
+ **********************************************************************/
+
+/* Till here we are discussing about the static memory management model.
+ * However, the operating envoronments commonly define more CPLB
+ * descriptors to cover the entire addressable memory than will fit into
+ * the available on-chip 16 CPLB MMRs. When this happens, the below table
+ * will be used which will hold all the potentially required CPLB descriptors
+ *
+ * This is how Page descriptor Table is implemented in uClinux/Blackfin.
+ */
+.global _dpdt_table
+_dpdt_table:
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 10 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 20 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 30 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 40 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 50 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 60 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 70 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 80 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 90 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 100 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 110 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 120 */
+
+.byte4 0xffffffff;		/*end of section - termination */
+
+#ifdef CONFIG_CPLB_INFO
+.global _ipdt_swapcount_table;	/* swapin count first, then swapout count */
+_ipdt_swapcount_table:
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 10 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 20 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 30 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 40 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 50 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 60 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 70 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 80 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 90 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 100 */
+
+.global _dpdt_swapcount_table;	/* swapin count first, then swapout count */
+_dpdt_swapcount_table:
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 10 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 20 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 30 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 40 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 50 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 60 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 70 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 80 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 80 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 100 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 110 */
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;
+.byte4 0x00000000;		/* 120 */
+
+#endif
+
+#endif	/*__ARCH_BLACKFIN_CPLBTAB_H*/
Index: git/linux-2.6/include/asm-blackfin/cpumask.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/cpumask.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,6 @@
+#ifndef _ASM_BLACKFIN_CPUMASK_H
+#define _ASM_BLACKFIN_CPUMASK_H
+
+#include <asm-generic/cpumask.h>
+
+#endif				/* _ASM_BLACKFIN_CPUMASK_H */
Index: git/linux-2.6/include/asm-blackfin/cputime.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/cputime.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,6 @@
+#ifndef __BLACKFIN_CPUTIME_H
+#define __BLACKFIN_CPUTIME_H
+
+#include <asm-generic/cputime.h>
+
+#endif				/* __BLACKFIN_CPUTIME_H */
Index: git/linux-2.6/include/asm-blackfin/current.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/current.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,23 @@
+#ifndef _BLACKFIN_CURRENT_H
+#define _BLACKFIN_CURRENT_H
+/*
+ *	current.h
+ *	(C) Copyright 2000, Lineo, David McCullough <davidm@lineo.com>
+ *
+ *	rather than dedicate a register (as the m68k source does), we
+ *	just keep a global,  we should probably just change it all to be
+ *	current and lose _current_task.
+ */
+#include <linux/thread_info.h>
+
+struct task_struct;
+
+static inline struct task_struct *get_current(void) __attribute__ ((__const__));
+static inline struct task_struct *get_current(void)
+{
+	return (current_thread_info()->task);
+}
+
+#define	current	(get_current())
+
+#endif				/* _BLACKFIN_CURRENT_H */
Index: git/linux-2.6/include/asm-blackfin/delay.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/delay.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,41 @@
+#ifndef _BLACKFIN_DELAY_H
+#define _BLACKFIN_DELAY_H
+
+static inline void __delay(unsigned long loops)
+{
+
+/* FIXME: Currently the assembler doesn't recognize Loop Register Clobbers,
+   uncomment this as soon those are implemented */
+//      __asm__ __volatile__ (  "\t LSETUP (1,1) LC0= %0\n\t"
+//                              "l:\t NOP;\n\t"
+//                              : :"a" (loops)
+//                              : "LT0","LB0","LC0");
+
+	__asm__ __volatile__("[--SP] = LC0;\n\t"
+			     "[--SP] = LT0;\n\t"
+			     "[--SP] = LB0;\n\t"
+			     "LSETUP (1f,1f) LC0 = %0;\n\t"
+			     "1:\t NOP;\n\t"
+			     "LB0 = [SP++];\n\t"
+				"LT0 = [SP++];\n\t"
+				"LC0 = [SP++];\n"
+				:
+				:"a" (loops));
+}
+
+#include <linux/param.h>	/* needed for HZ */
+
+/*
+ * Use only for very small delays ( < 1 msec).  Should probably use a
+ * lookup table, really, as the multiplications take much too long with
+ * short delays.  This is a "reasonable" implementation, though (and the
+ * first constant multiplications gets optimized away if the delay is
+ * a constant)
+ */
+static inline void udelay(unsigned long usecs)
+{
+	extern unsigned long loops_per_jiffy;
+	__delay(usecs * loops_per_jiffy / (1000000 / HZ));
+}
+
+#endif				/* defined(_BLACKFIN_DELAY_H) */
Index: git/linux-2.6/include/asm-blackfin/div64.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/div64.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/div64.h>
Index: git/linux-2.6/include/asm-blackfin/dma-mapping.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/dma-mapping.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,69 @@
+#ifndef _BLACKFIN_DMA_MAPPING_H
+#define _BLACKFIN_DMA_MAPPING_H
+
+#include <linux/config.h>
+#include <asm/scatterlist.h>
+
+void dma_alloc_init(unsigned long start, unsigned long end);
+void *dma_alloc_coherent(struct device *dev, size_t size,
+			 dma_addr_t * dma_handle, gfp_t gfp);
+void dma_free_coherent(struct device *dev, size_t size, void *vaddr,
+		       dma_addr_t dma_handle);
+
+/*
+ * Map a single buffer of the indicated size for DMA in streaming mode.
+ * The 32-bit bus address to use is returned.
+ *
+ * Once the device is given the dma address, the device owns this memory
+ * until either pci_unmap_single or pci_dma_sync_single is performed.
+ */
+extern dma_addr_t dma_map_single(struct device *dev, void *ptr, size_t size,
+				 enum dma_data_direction direction);
+
+/*
+ * Unmap a single streaming mode DMA translation.  The dma_addr and size
+ * must match what was provided for in a previous pci_map_single call.  All
+ * other usages are undefined.
+ *
+ * After this call, reads by the cpu to the buffer are guarenteed to see
+ * whatever the device wrote there.
+ */
+static inline
+    void dma_unmap_single(struct device *dev, dma_addr_t dma_addr, size_t size,
+			  enum dma_data_direction direction)
+{
+	BUG_ON(direction == DMA_NONE);
+}
+
+/*
+ * Map a set of buffers described by scatterlist in streaming
+ * mode for DMA.  This is the scather-gather version of the
+ * above pci_map_single interface.  Here the scatter gather list
+ * elements are each tagged with the appropriate dma address
+ * and length.  They are obtained via sg_dma_{address,length}(SG).
+ *
+ * NOTE: An implementation may be able to use a smaller number of
+ *       DMA address/length pairs than there are SG table elements.
+ *       (for example via virtual mapping capabilities)
+ *       The routine returns the number of addr/length pairs actually
+ *       used, at most nents.
+ *
+ * Device ownership issues as mentioned above for pci_map_single are
+ * the same here.
+ */
+extern int dma_map_sg(struct device *dev, struct scatterlist *sg, int nents,
+		      enum dma_data_direction direction);
+
+/*
+ * Unmap a set of streaming mode DMA translations.
+ * Again, cpu read rules concerning calls here are the same as for
+ * pci_unmap_single() above.
+ */
+static inline
+    void dma_unmap_sg(struct device *dev, struct scatterlist *sg,
+		      int nhwentries, enum dma_data_direction direction)
+{
+	BUG_ON(direction == DMA_NONE);
+}
+
+#endif				/* _BLACKFIN_DMA_MAPPING_H */
Index: git/linux-2.6/include/asm-blackfin/dma.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/dma.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,208 @@
+/*
+ * File:         include/asm-blackfin/simple_bf533_dma.h
+ * Based on:     none - original work
+ * Author:       LG Soft India
+ *               Copyright (C) 2004-2005 Analog Devices Inc.
+ * Created:      Tue Sep 21 2004
+ * Description:  This file contains the major Data structures and constants
+ * 		 used for DMA Implementation in BF533
+ * Rev:          $Id$
+ * Modified:
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _BLACKFIN_DMA_H_
+#define _BLACKFIN_DMA_H_
+
+#include <asm/io.h>
+#include <linux/slab.h>
+#include <asm/irq.h>
+#include <asm/irq.h>
+#include <asm/signal.h>
+#include <asm/semaphore.h>
+
+#include <linux/kernel.h>
+#include <asm/mach/dma.h>
+#include <linux/config.h>
+#include <linux/mm.h>
+#include <asm/blackfin.h>
+
+#define MAX_DMA_ADDRESS PAGE_OFFSET
+
+#undef BFIN_DMA_DEBUG
+#undef BFIN_DMA_NDEBUG
+
+#ifdef BFIN_DMA_DEBUG
+#define DMA_DBG(fmt, args...) 					\
+do { printk("Blackfin DMA driver: "fmt, ##args);} while (0)
+#else
+#define DMA_DBG(fmt, args...)
+#endif
+
+#ifdef BFIN_DMA_NDEBUG
+#define assert(expr) do {} while(0)
+#else
+#define assert(expr) 						\
+	if (!(expr)) {						\
+	printk("Assertion failed! %s, %s, %s, line=%d \n",	\
+	#expr, __FILE__,__FUNCTION__,__LINE__); 		\
+	}
+#endif
+
+/*****************************************************************************
+*        Generic DMA  Declarations
+*
+****************************************************************************/
+typedef enum {
+	DMA_CHANNEL_FREE,
+	DMA_CHANNEL_REQUESTED,
+	DMA_CHANNEL_ENABLED,
+} dma_chan_status_t;
+
+/*-------------------------
+ * config reg bits value
+ *-------------------------*/
+#define DATA_SIZE_8 		0
+#define DATA_SIZE_16 		1
+#define DATA_SIZE_32 		2
+
+#define FLOW_STOP 		0
+#define FLOW_AUTO 		1
+#define FLOW_ARRAY 		4
+#define FLOW_SMALL 		6
+#define FLOW_LARGE 		7
+
+#define DIMENSION_LINEAR    0
+#define DIMENSION_2D           1
+
+#define DIR_READ     0
+#define DIR_WRITE    1
+
+#define INTR_DISABLE   0	//00b
+#define INTR_ON_BUF    2	//10b
+#define INTR_ON_ROW   3		//11b
+
+#pragma pack(2)
+typedef struct _dmasglarge_t {
+	unsigned long next_desc_addr;
+	unsigned long start_addr;
+	unsigned short cfg;
+	unsigned short x_count;
+	unsigned short x_modify;
+	unsigned short y_count;
+	unsigned short y_modify;
+} dmasg_t;
+#pragma pack()
+
+typedef struct {
+	unsigned long next_desc_ptr;	/* DMA Next Descriptor Pointer register */
+	unsigned long start_addr;	/* DMA Start address  register */
+
+	unsigned short cfg;	/* DMA Configuration register */
+	unsigned short dummy1;	/* DMA Configuration register */
+
+	unsigned long reserved;
+
+	unsigned short x_count;	/* DMA x_count register */
+	unsigned short dummy2;
+
+	unsigned short x_modify;	/* DMA x_modify register */
+	unsigned short dummy3;
+
+	unsigned short y_count;	/* DMA y_count register */
+	unsigned short dummy4;
+
+	unsigned short y_modify;	/* DMA y_modify register */
+	unsigned short dummy5;
+
+	unsigned long curr_desc_ptr;	/* DMA Current Descriptor Pointer
+					   register */
+	unsigned short curr_addr_ptr_lo;	/* DMA Current Address Pointer
+						   register */
+	unsigned short curr_addr_ptr_hi;	/* DMA Current Address Pointer
+						   register */
+	unsigned short irq_status;	/* DMA irq status register */
+	unsigned short dummy6;
+
+	unsigned short peripheral_map;	/* DMA peripheral map register */
+	unsigned short dummy7;
+
+	unsigned short curr_x_count;	/* DMA Current x-count register */
+	unsigned short dummy8;
+
+	unsigned long reserved2;
+
+	unsigned short curr_y_count;	/* DMA Current y-count register */
+	unsigned short dummy9;
+
+	unsigned long reserved3;
+
+} dma_register_t;
+
+typedef irqreturn_t(*dma_interrupt_t) (int irq, void *dev_id,
+				       struct pt_regs * pt_regs);
+
+typedef struct {
+	struct semaphore dmalock;
+	char *device_id;
+	dma_chan_status_t chan_status;
+	dma_register_t *regs;
+	dmasg_t *sg;		/* large mode descriptor */
+	unsigned int ctrl_num;	/* controller number */
+	dma_interrupt_t irq_callback;
+	void *data;
+	unsigned int dma_enable_flag;
+	unsigned int loopback_flag;
+} dma_channel_t;
+
+/*******************************************************************************
+*	DMA API's
+*******************************************************************************/
+//functions to set register mode
+void set_dma_start_addr(unsigned int channel, unsigned long addr);
+void set_dma_x_count(unsigned int channel, unsigned short x_count);
+void set_dma_x_modify(unsigned int channel, unsigned short x_modify);
+void set_dma_y_count(unsigned int channel, unsigned short y_count);
+void set_dma_y_modify(unsigned int channel, unsigned short y_modify);
+void set_dma_config(unsigned int channel, unsigned short config);
+unsigned short set_bfin_dma_config(char direction, char flow_mode,
+				   char intr_mode, char dma_mode, char width);
+
+// get curr status for polling
+unsigned short get_dma_curr_irqstat(unsigned int channel);
+unsigned short get_dma_curr_xcount(unsigned int channel);
+unsigned short get_dma_curr_ycount(unsigned int channel);
+
+//set large DMA mode descriptor
+void set_dma_sg(unsigned int channel, dmasg_t * sg, int nr_sg);
+
+//check if current channel is in use
+int dma_channel_active(unsigned int channel);
+
+//common functions must be called in any mode
+void free_dma(unsigned int channel);	//free resources
+int dma_channel_active(unsigned int channel);	//check if a channel is in use
+void disable_dma(unsigned int channel);	//disable
+void enable_dma(unsigned int channel);	//enable
+int request_dma(unsigned int channel, char *device_id);
+int set_dma_callback(unsigned int channel, dma_interrupt_t callback,
+		     void *data);
+void clear_dma_irqstat(unsigned int channel);
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/dpmc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/dpmc.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,64 @@
+/*
+ * include/asm-blackfin/dpmc.h -  Miscellaneous IOCTL commands for Dynamic Power
+ *   			 	Management Controller Driver.
+ * Copyright (C) 2004 Analog Device Inc.
+ *
+ */
+#ifndef _BLACKFIN_DPMC_H_
+#define _BLACKFIN_DPMC_H_
+
+#define SLEEP_MODE		1
+#define DEEP_SLEEP_MODE		2
+#define ACTIVE_PLL_DISABLED	3
+#define FULLON_MODE		4
+#define ACTIVE_PLL_ENABLED	5
+#define HIBERNATE_MODE		6
+
+#define IOCTL_FULL_ON_MODE	_IO('s', 0xA0)
+#define IOCTL_ACTIVE_MODE	_IO('s', 0xA1)
+#define IOCTL_SLEEP_MODE	_IO('s', 0xA2)
+#define IOCTL_DEEP_SLEEP_MODE	_IO('s', 0xA3)
+#define IOCTL_HIBERNATE_MODE	_IO('s', 0xA4)
+#define IOCTL_CHANGE_FREQUENCY	_IOW('s', 0xA5, unsigned long)
+#define IOCTL_CHANGE_VOLTAGE	_IOW('s', 0xA6, unsigned long)
+#define IOCTL_SET_CCLK		_IOW('s', 0xA7, unsigned long)
+#define IOCTL_SET_SCLK		_IOW('s', 0xA8, unsigned long)
+#define IOCTL_GET_PLLSTATUS	_IOW('s', 0xA9, unsigned long)
+#define IOCTL_GET_CORECLOCK	_IOW('s', 0xAA, unsigned long)
+#define IOCTL_GET_SYSTEMCLOCK	_IOW('s', 0xAB, unsigned long)
+#define IOCTL_GET_VCO		_IOW('s', 0xAC, unsigned long)
+#define IOCTL_DISABLE_WDOG_TIMER _IO('s', 0xAD)
+#define IOCTL_UNMASK_WDOG_WAKEUP_EVENT _IO('s',0xAE)
+#define IOCTL_PROGRAM_WDOG_TIMER _IOW('s',0xAF,unsigned long)
+#define IOCTL_CLEAR_WDOG_WAKEUP_EVENT _IO('s',0xB0)
+
+#define DPMC_MINOR		254
+
+#define ON	0
+#define OFF	1
+
+unsigned long calc_volt(void);
+int calc_vlev(int vlt);
+unsigned long change_voltage(unsigned long volt);
+int calc_msel(int vco_hz);
+unsigned long change_frequency(unsigned long vco_mhz);
+int set_pll_div(unsigned short sel, unsigned char flag);
+int get_vco(void);
+unsigned long change_system_clock(unsigned long clock);
+unsigned long change_core_clock(unsigned long clock);
+unsigned long get_pll_status(void);
+void change_baud(int baud);
+void fullon_mode(void);
+void active_mode(void);
+void sleep_mode(void);
+void deep_sleep(void);
+void hibernate_mode(void);
+void program_wdog_timer(unsigned long);
+void unmask_wdog_wakeup_evt(void);
+void clear_wdog_wakeup_evt(void);
+void disable_wdog_timer(void);
+
+extern unsigned long get_cclk(void);
+extern unsigned long get_sclk(void);
+
+#endif	/*_BLACKFIN_DPMC_H_*/
Index: git/linux-2.6/include/asm-blackfin/elf.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/elf.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,110 @@
+/* Changes made by  LG Soft Oct 2004*/
+
+#ifndef __ASMBFIN_ELF_H
+#define __ASMBFIN_ELF_H
+
+/*
+ * ELF register definitions..
+ */
+
+#include <linux/config.h>
+#include <asm/ptrace.h>
+#include <asm/user.h>
+
+typedef unsigned long elf_greg_t;
+
+#define ELF_NGREG (sizeof(struct user_regs_struct) / sizeof(elf_greg_t))
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+typedef struct user_bfinfp_struct elf_fpregset_t;
+/*
+ * This is used to ensure we don't load something for the wrong architecture.
+ */
+#define elf_check_arch(x) ((x)->e_machine == EM_BLACKFIN)
+
+/* EM_BLACKFIN defined in linux/elf.h	*/
+
+/*
+ * These are used to set parameters in the core dumps.
+ */
+#define ELF_CLASS	ELFCLASS32
+#define ELF_DATA	ELFDATA2LSB
+#define ELF_ARCH	EM_BLACKFIN
+
+#define ELF_PLAT_INIT(_r)	_r->p1 = 0
+
+#define USE_ELF_CORE_DUMP
+#define ELF_EXEC_PAGESIZE	4096
+
+#define	R_unused0	0	/* relocation type 0 is not defined */
+#define R_pcrel5m2	1	/*LSETUP part a */
+#define R_unused1	2	/* relocation type 2 is not defined */
+#define R_pcrel10	3	/* type 3, if cc jump <target>  */
+#define R_pcrel12_jump	4	/* type 4, jump <target> */
+#define R_rimm16	5	/* type 0x5, rN = <target> */
+#define R_luimm16	6	/* # 0x6, preg.l=<target> Load imm 16 to lower half */
+#define R_huimm16  	7	/* # 0x7, preg.h=<target> Load imm 16 to upper half */
+#define R_pcrel12_jump_s 8	/* # 0x8 jump.s <target> */
+#define R_pcrel24_jump_x 9	/* # 0x9 jump.x <target> */
+#define R_pcrel24       10	/* # 0xa call <target> , not expandable */
+#define R_unusedb       11	/* # 0xb not generated */
+#define R_unusedc       12	/* # 0xc  not used */
+#define R_pcrel24_jump_l 13	/*0xd jump.l <target> */
+#define R_pcrel24_call_x 14	/* 0xE, call.x <target> if <target> is above 24 bit limit call through P1 */
+#define R_var_eq_symb    15	/* 0xf, linker should treat it same as 0x12 */
+#define R_byte_data      16	/* 0x10, .byte var = symbol */
+#define R_byte2_data     17	/* 0x11, .byte2 var = symbol */
+#define R_byte4_data     18	/* 0x12, .byte4 var = symbol and .var var=symbol */
+#define R_pcrel11        19	/* 0x13, lsetup part b */
+#define R_unused14      20	/* 0x14, undefined */
+#define R_unused15       21	/* not generated by VDSP 3.5 */
+
+/* arithmetic relocations */
+#define R_push		 0xE0
+#define R_const		 0xE1
+#define R_add		 0xE2
+#define R_sub		 0xE3
+#define R_mult		 0xE4
+#define R_div		 0xE5
+#define R_mod		 0xE6
+#define R_lshift	 0xE7
+#define R_rshift	 0xE8
+#define R_and		 0xE9
+#define R_or		 0xEA
+#define R_xor		 0xEB
+#define R_land		 0xEC
+#define R_lor		 0xED
+#define R_len		 0xEE
+#define R_neg		 0xEF
+#define R_comp		 0xF0
+#define R_page		 0xF1
+#define R_hwpage	 0xF2
+#define R_addr		 0xF3
+
+/* This is the location that an ET_DYN program is loaded if exec'ed.  Typical
+   use of this is to invoke "./ld.so someprog" to test out a new version of
+   the loader.  We need to make sure that it is out of the way of the program
+   that it will "exec", and that there is sufficient room for the brk.  */
+
+#define ELF_ET_DYN_BASE         0xD0000000UL
+
+#define ELF_CORE_COPY_REGS(pr_reg, regs)	\
+        memcpy((char *) &pr_reg, (char *)regs,  \
+               sizeof(struct pt_regs));
+
+/* This yields a mask that user programs can use to figure out what
+   instruction set this cpu supports.  */
+
+#define ELF_HWCAP	(0)
+
+/* This yields a string that ld.so will use to load implementation
+   specific libraries for optimization.  This is more specific in
+   intent than poking at uname or /proc/cpuinfo.  */
+
+#define ELF_PLATFORM  (NULL)
+
+#ifdef __KERNEL__
+#define SET_PERSONALITY(ex, ibcs2) set_personality((ibcs2)?PER_SVR4:PER_LINUX)
+#endif
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/emergency-restart.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/emergency-restart.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,6 @@
+#ifndef _ASM_EMERGENCY_RESTART_H
+#define _ASM_EMERGENCY_RESTART_H
+
+#include <asm-generic/emergency-restart.h>
+
+#endif /* _ASM_EMERGENCY_RESTART_H */
Index: git/linux-2.6/include/asm-blackfin/entry.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/entry.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,345 @@
+#ifndef __BFIN_ENTRY_H
+#define __BFIN_ENTRY_H
+
+#include <linux/config.h>
+#include <asm/setup.h>
+#include <asm/page.h>
+
+#ifdef __ASSEMBLY__
+
+#define	LFLUSH_I_AND_D	0x00000808
+#define	LSIGTRAP	5
+
+/* process bits for task_struct.flags */
+#define	PF_TRACESYS_OFF	3
+#define	PF_TRACESYS_BIT	5
+#define	PF_PTRACED_OFF	3
+#define	PF_PTRACED_BIT	4
+#define	PF_DTRACE_OFF	1
+#define	PF_DTRACE_BIT	5
+
+/* This one is used for exceptions, emulation, and NMI.  It doesn't push
+   RETI and doesn't do cli.  */
+#define SAVE_ALL_SYS		save_context_no_interrupts
+/* This is used for all normal interrupts.  First we do CLI, then push
+   RETI, to keep interrupts disabled, but to allow this state to be changed
+   by local_bh_enable.  */
+#define SAVE_CONTEXT		save_context_with_interrupts
+/* This one pushes RETI without using CLI.  Interrupts are enabled.  */
+#define SAVE_CONTEXT_SYSCALL	save_context_syscall
+
+#define RESTORE_ALL_SYS		restore_context_no_interrupts
+#define RESTORE_CONTEXT		restore_context_with_interrupts
+
+/*
+ * Code to save processor context.
+ *  We even save the register which are preserved by a function call
+ *	 - r4, r5, r6, r7, p3, p4, p5
+ */
+.macro save_context_with_interrupts
+	[--sp] = SYSCFG;
+
+	[--sp] = P0;	/*orig_p0*/
+	[--sp] = R0;	/*orig_r0*/
+	[--sp] = ( R7:0, P5:0 );
+	[--sp] = fp;
+	[--sp] = usp;
+
+	[--sp] = i0;
+	[--sp] = i1;
+	[--sp] = i2;
+	[--sp] = i3;
+
+	[--sp] = m0;
+	[--sp] = m1;
+	[--sp] = m2;
+	[--sp] = m3;
+
+	[--sp] = l0;
+	[--sp] = l1;
+	[--sp] = l2;
+	[--sp] = l3;
+
+	[--sp] = b0;
+	[--sp] = b1;
+	[--sp] = b2;
+	[--sp] = b3;
+	[--sp] = a0.x;
+	[--sp] = a0.w;
+	[--sp] = a1.x;
+	[--sp] = a1.w;
+
+	[--sp] = LC0;
+	[--sp] = LC1;
+	[--sp] = LT0;
+	[--sp] = LT1;
+	[--sp] = LB0;
+	[--sp] = LB1;
+
+	[--sp] = ASTAT;
+
+	[--sp] = r0;	/* Skip reserved */
+	[--sp] = RETS;
+	r0 = RETI;
+	[--sp] = r0;
+	[--sp] = RETX;
+	[--sp] = RETN;
+	[--sp] = RETE;
+	[--sp] = SEQSTAT;
+	[--sp] = r0;	/* Skip IPEND as well. */
+	/* Switch to other method of keeping interrupts disabled.  */
+#ifdef CONFIG_DEBUG_HWERR
+	r0 = 0x3f;
+	sti r0;
+#else
+	cli r0;
+#endif
+	[--sp] = RETI;  /*orig_pc*/
+	/* Clear all L registers.  */
+	r0 = 0 (x);
+	l0 = r0;
+	l1 = r0;
+	l2 = r0;
+	l3 = r0;
+.endm
+
+.macro save_context_syscall
+	[--sp] = SYSCFG;
+
+	[--sp] = P0;	/*orig_p0*/
+	[--sp] = R0;	/*orig_r0*/
+	[--sp] = ( R7:0, P5:0 );
+	[--sp] = fp;
+	[--sp] = usp;
+
+	[--sp] = i0;
+	[--sp] = i1;
+	[--sp] = i2;
+	[--sp] = i3;
+
+	[--sp] = m0;
+	[--sp] = m1;
+	[--sp] = m2;
+	[--sp] = m3;
+
+	[--sp] = l0;
+	[--sp] = l1;
+	[--sp] = l2;
+	[--sp] = l3;
+
+	[--sp] = b0;
+	[--sp] = b1;
+	[--sp] = b2;
+	[--sp] = b3;
+	[--sp] = a0.x;
+	[--sp] = a0.w;
+	[--sp] = a1.x;
+	[--sp] = a1.w;
+
+	[--sp] = LC0;
+	[--sp] = LC1;
+	[--sp] = LT0;
+	[--sp] = LT1;
+	[--sp] = LB0;
+	[--sp] = LB1;
+
+	[--sp] = ASTAT;
+
+	[--sp] = r0;	/* Skip reserved */
+	[--sp] = RETS;
+	r0 = RETI;
+	[--sp] = r0;
+	[--sp] = RETX;
+	[--sp] = RETN;
+	[--sp] = RETE;
+	[--sp] = SEQSTAT;
+	[--sp] = r0;	/* Skip IPEND as well. */
+	[--sp] = RETI;  /*orig_pc*/
+	/* Clear all L registers.  */
+	r0 = 0 (x);
+	l0 = r0;
+	l1 = r0;
+	l2 = r0;
+	l3 = r0;
+.endm
+
+.macro save_context_no_interrupts
+	[--sp] = SYSCFG;
+	[--sp] = P0;	/* orig_p0 */
+	[--sp] = R0;	/* orig_r0 */
+	[--sp] = ( R7:0, P5:0 );
+	[--sp] = fp;
+	[--sp] = usp;
+
+	[--sp] = i0;
+	[--sp] = i1;
+	[--sp] = i2;
+	[--sp] = i3;
+
+	[--sp] = m0;
+	[--sp] = m1;
+	[--sp] = m2;
+	[--sp] = m3;
+
+	[--sp] = l0;
+	[--sp] = l1;
+	[--sp] = l2;
+	[--sp] = l3;
+
+	[--sp] = b0;
+	[--sp] = b1;
+	[--sp] = b2;
+	[--sp] = b3;
+	[--sp] = a0.x;
+	[--sp] = a0.w;
+	[--sp] = a1.x;
+	[--sp] = a1.w;
+
+	[--sp] = LC0;
+	[--sp] = LC1;
+	[--sp] = LT0;
+	[--sp] = LT1;
+	[--sp] = LB0;
+	[--sp] = LB1;
+
+	[--sp] = ASTAT;
+
+	[--sp] = r0;	/* Skip reserved */
+	[--sp] = RETS;
+	r0 = RETI;
+	[--sp] = r0;
+	[--sp] = RETX;
+	[--sp] = RETN;
+	[--sp] = RETE;
+	[--sp] = SEQSTAT;
+	[--sp] = r0;	/* Skip IPEND as well. */
+	[--sp] = r0;  /*orig_pc*/
+	/* Clear all L registers.  */
+	r0 = 0 (x);
+	l0 = r0;
+	l1 = r0;
+	l2 = r0;
+	l3 = r0;
+.endm
+
+.macro restore_context_no_interrupts
+	sp += 4;	/* Skip orig_pc */
+	sp += 4;	/* Skip IPEND */
+	SEQSTAT = [sp++];
+	RETE = [sp++];
+	RETN = [sp++];
+	RETX = [sp++];
+	r0 = [sp++];
+	RETI = r0;	/* Restore RETI indirectly when in exception */
+	RETS = [sp++];
+
+	sp += 4;	/* Skip Reserved */
+
+	ASTAT = [sp++];
+
+	LB1 = [sp++];
+	LB0 = [sp++];
+	LT1 = [sp++];
+	LT0 = [sp++];
+	LC1 = [sp++];
+	LC0 = [sp++];
+
+	a1.w = [sp++];
+	a1.x = [sp++];
+	a0.w = [sp++];
+	a0.x = [sp++];
+	b3 = [sp++];
+	b2 = [sp++];
+	b1 = [sp++];
+	b0 = [sp++];
+
+	l3 = [sp++];
+	l2 = [sp++];
+	l1 = [sp++];
+	l0 = [sp++];
+
+	m3 = [sp++];
+	m2 = [sp++];
+	m1 = [sp++];
+	m0 = [sp++];
+
+	i3 = [sp++];
+	i2 = [sp++];
+	i1 = [sp++];
+	i0 = [sp++];
+
+	sp += 4;
+	fp = [sp++];
+
+	( R7 : 0, P5 : 0) = [ SP ++ ];
+	sp += 8;	/* Skip orig_r0/orig_p0 */
+	SYSCFG = [sp++];
+.endm
+
+.macro restore_context_with_interrupts
+	sp += 4;	/* Skip orig_pc */
+	sp += 4;	/* Skip IPEND */
+	SEQSTAT = [sp++];
+	RETE = [sp++];
+	RETN = [sp++];
+	RETX = [sp++];
+	RETI = [sp++];
+	RETS = [sp++];
+
+	p0.h = _irq_flags;
+	p0.l = _irq_flags;
+	r0 = [p0];
+	sti r0;
+
+	sp += 4;	/* Skip Reserved */
+
+	ASTAT = [sp++];
+
+	LB1 = [sp++];
+	LB0 = [sp++];
+	LT1 = [sp++];
+	LT0 = [sp++];
+	LC1 = [sp++];
+	LC0 = [sp++];
+
+	a1.w = [sp++];
+	a1.x = [sp++];
+	a0.w = [sp++];
+	a0.x = [sp++];
+	b3 = [sp++];
+	b2 = [sp++];
+	b1 = [sp++];
+	b0 = [sp++];
+
+	l3 = [sp++];
+	l2 = [sp++];
+	l1 = [sp++];
+	l0 = [sp++];
+
+	m3 = [sp++];
+	m2 = [sp++];
+	m1 = [sp++];
+	m0 = [sp++];
+
+	i3 = [sp++];
+	i2 = [sp++];
+	i1 = [sp++];
+	i0 = [sp++];
+
+	sp += 4;
+	fp = [sp++];
+
+	( R7 : 0, P5 : 0) = [ SP ++ ];
+	sp += 8;	/* Skip orig_r0/orig_p0 */
+	csync;
+	SYSCFG = [sp++];
+	csync;
+.endm
+
+#define STR(X) STR1(X)
+#define STR1(X) #X
+# define PT_OFF_ORIG_P0		208
+# define PT_OFF_SR		8
+
+#endif	/* __ASSEMBLY__	*/
+#endif	/* __BFIN_ENTRY_H */
Index: git/linux-2.6/include/asm-blackfin/errno.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/errno.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,6 @@
+#ifndef _BFIN_ERRNO_H
+#define _BFIN_ERRNO_H
+
+#include<asm-generic/errno.h>
+
+#endif				/* _BFIN_ERRNO_H */
Index: git/linux-2.6/include/asm-blackfin/fcntl.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/fcntl.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,87 @@
+#ifndef _BFIN_FCNTL_H
+#define _BFIN_FCNTL_H
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	  0003
+#define O_RDONLY	    00
+#define O_WRONLY	    01
+#define O_RDWR		    02
+#define O_CREAT		  0100	/* not fcntl */
+#define O_EXCL		  0200	/* not fcntl */
+#define O_NOCTTY	  0400	/* not fcntl */
+#define O_TRUNC		 01000	/* not fcntl */
+#define O_APPEND	 02000
+#define O_NONBLOCK	 04000
+#define O_NDELAY	O_NONBLOCK
+#define O_SYNC		010000
+#define FASYNC		020000	/* fcntl, for BSD compatibility */
+#define O_DIRECTORY	040000	/* must be a directory */
+#define O_NOFOLLOW	0100000	/* don't follow links */
+#define O_DIRECT	0200000	/* direct disk access hint - currently ignored */
+#define O_LARGEFILE	0400000
+#define O_NOATIME	01000000
+
+#define F_DUPFD		0	/* dup */
+#define F_GETFD		1	/* get close_on_exec */
+#define F_SETFD		2	/* set/clear close_on_exec */
+#define F_GETFL		3	/* get file->f_flags */
+#define F_SETFL		4	/* set file->f_flags */
+#define F_GETLK		5
+#define F_SETLK		6
+#define F_SETLKW	7
+
+#define F_SETOWN	8	/*  for sockets. */
+#define F_GETOWN	9	/*  for sockets. */
+#define F_SETSIG	10	/*  for sockets. */
+#define F_GETSIG	11	/*  for sockets. */
+
+#define F_GETLK64	12	/*  using 'struct flock64' */
+#define F_SETLK64	13
+#define F_SETLKW64	14
+
+/* for F_[GET|SET]FL */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* for posix fcntl() and lockf() */
+#define F_RDLCK		0
+#define F_WRLCK		1
+#define F_UNLCK		2
+
+/* for old implementation of bsd flock () */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+/* for leases */
+#define F_INPROGRESS	16
+
+/* operations for bsd flock(), also used by the kernel implementation */
+#define LOCK_SH		1	/* shared lock */
+#define LOCK_EX		2	/* exclusive lock */
+#define LOCK_NB		4	/* or'd with one of the above to prevent
+				   blocking */
+#define LOCK_UN		8	/* remove lock */
+
+#define LOCK_MAND	32	/* This is a mandatory flock */
+#define LOCK_READ	64	/* ... Which allows concurrent read operations */
+#define LOCK_WRITE	128	/* ... Which allows concurrent write operations */
+#define LOCK_RW		192	/* ... Which allows concurrent read & write ops */
+
+struct flock {
+	short l_type;
+	short l_whence;
+	off_t l_start;
+	off_t l_len;
+	pid_t l_pid;
+};
+
+struct flock64 {
+	short l_type;
+	short l_whence;
+	loff_t l_start;
+	loff_t l_len;
+	pid_t l_pid;
+};
+
+#define F_LINUX_SPECIFIC_BASE	1024
+#endif				/* _BFIN_FCNTL_H */
Index: git/linux-2.6/include/asm-blackfin/flat.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/flat.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,19 @@
+/*
+ * include/asm-blackfin/flat.h -- uClinux flat-format executables
+ *
+ * Copyright (C) 2003,
+ *
+ */
+
+#ifndef __BLACKFIN_FLAT_H__
+#define __BLACKFIN_FLAT_H__
+
+#define	flat_stack_align(sp)	/* nothing needed */
+#define	flat_argvp_envp_on_stack()		0
+#define	flat_old_ram_flag(flags)		(flags)
+#define	flat_reloc_valid(reloc, size)		((reloc) <= (size))
+#define	flat_get_addr_from_rp(rp, relval,flags)		get_unaligned(rp)
+#define	flat_put_addr_at_rp(rp, val, relval)	put_unaligned(val,rp)
+#define	flat_get_relocate_addr(rel)		(rel)
+
+#endif				/* __BLACKFIN_FLAT_H__ */
Index: git/linux-2.6/include/asm-blackfin/futex.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/futex.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,53 @@
+#ifndef _ASM_FUTEX_H
+#define _ASM_FUTEX_H
+
+#ifdef __KERNEL__
+
+#include <linux/futex.h>
+#include <asm/errno.h>
+#include <asm/uaccess.h>
+
+static inline int
+futex_atomic_op_inuser (int encoded_op, int __user *uaddr)
+{
+	int op = (encoded_op >> 28) & 7;
+	int cmp = (encoded_op >> 24) & 15;
+	int oparg = (encoded_op << 8) >> 20;
+	int cmparg = (encoded_op << 20) >> 20;
+	int oldval = 0, ret;
+	if (encoded_op & (FUTEX_OP_OPARG_SHIFT << 28))
+		oparg = 1 << oparg;
+
+	if (! access_ok (VERIFY_WRITE, uaddr, sizeof(int)))
+		return -EFAULT;
+
+	inc_preempt_count();
+
+	switch (op) {
+	case FUTEX_OP_SET:
+	case FUTEX_OP_ADD:
+	case FUTEX_OP_OR:
+	case FUTEX_OP_ANDN:
+	case FUTEX_OP_XOR:
+	default:
+		ret = -ENOSYS;
+	}
+
+	dec_preempt_count();
+
+	if (!ret) {
+		switch (cmp) {
+		case FUTEX_OP_CMP_EQ: ret = (oldval == cmparg); break;
+		case FUTEX_OP_CMP_NE: ret = (oldval != cmparg); break;
+		case FUTEX_OP_CMP_LT: ret = (oldval < cmparg); break;
+		case FUTEX_OP_CMP_GE: ret = (oldval >= cmparg); break;
+		case FUTEX_OP_CMP_LE: ret = (oldval <= cmparg); break;
+		case FUTEX_OP_CMP_GT: ret = (oldval > cmparg); break;
+		default: ret = -ENOSYS;
+		}
+	}
+	return ret;
+}
+
+#endif
+#endif
Index: git/linux-2.6/include/asm-blackfin/hardirq.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/hardirq.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,41 @@
+#ifndef __BFIN_HARDIRQ_H
+#define __BFIN_HARDIRQ_H
+
+#include <linux/config.h>
+#include <linux/cache.h>
+#include <linux/threads.h>
+
+typedef struct {
+	unsigned int __softirq_pending;
+	unsigned int __syscall_count;
+	struct task_struct *__ksoftirqd_task;
+} ____cacheline_aligned irq_cpustat_t;
+
+#include <linux/irq_cpustat.h>	/* Standard mappings for irq_cpustat_t above */
+
+/*
+ * We put the hardirq and softirq counter into the preemption
+ * counter. The bitmask has the following meaning:
+ *
+ * - bits 0-7 are the preemption count (max preemption depth: 256)
+ * - bits 8-15 are the softirq count (max # of softirqs: 256)
+ * - bits 16-23 are the hardirq count (max # of hardirqs: 256)
+ *
+ * - ( bit 26 is the PREEMPT_ACTIVE flag. )
+ *
+ * PREEMPT_MASK: 0x000000ff
+ * HARDIRQ_MASK: 0x0000ff00
+ * SOFTIRQ_MASK: 0x00ff0000
+ */
+
+#define HARDIRQ_BITS	8
+
+#ifdef NR_IRQS
+# if (1 << HARDIRQ_BITS) < NR_IRQS
+# error HARDIRQ_BITS is too low!
+# endif
+#endif
+
+#define __ARCH_IRQ_EXIT_IRQS_DISABLED	1
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/ide.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/ide.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,27 @@
+/****************************************************************************/
+
+/*
+ *  linux/include/asm-blackfin/ide.h
+ *
+ *  Copyright (C) 1994-1996  Linus Torvalds & authors
+ *  Copyright (C) 2001       Lineo Inc., davidm@snapgear.com
+ *  Copyright (C) 2002       Greg Ungerer (gerg@snapgear.com)
+ *  Copyright (C) 2002       Yoshinori Sato (ysato@users.sourceforge.jp)
+ *  Copyright (C) 2005       Hennerich Michael (hennerich@blackfin.uclinux.org)
+ */
+
+/****************************************************************************/
+#ifndef _BLACKFIN_IDE_H
+#define _BLACKFIN_IDE_H
+/****************************************************************************/
+#ifdef __KERNEL__
+/****************************************************************************/
+
+#define MAX_HWIFS	1
+
+#include <asm-generic/ide_iops.h>
+
+/****************************************************************************/
+#endif				/* __KERNEL__ */
+#endif				/* _BLACKFIN_IDE_H */
+/****************************************************************************/
Index: git/linux-2.6/include/asm-blackfin/io.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/io.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,146 @@
+#ifndef _BFIN_IO_H
+#define _BFIN_IO_H
+
+#ifdef __KERNEL__
+
+/*
+ * These are for ISA/PCI shared memory _only_ and should never be used
+ * on any other type of memory, including Zorro memory. They are meant to
+ * access the bus in the bus byte order which is little-endian!.
+ *
+ * readX/writeX() are used to access memory mapped devices. On some
+ * architectures the memory mapped IO stuff needs to be accessed
+ * differently. On the bfin architecture, we just read/write the
+ * memory location directly.
+ */
+#define readb(addr) ({ unsigned __v; \
+		       int _tmp; \
+                       __builtin_bfin_csync(); \
+		       __asm__ __volatile__ ("cli %1;\n\t"\
+	         			 "NOP;NOP;NOP;\n\t"\
+					     "%0 = b [%2] (z);\n\t"\
+					     "sti %1;\n\t" \
+  : "=d"(__v), "=d"(_tmp): "a"(addr)); (unsigned char)__v; })
+
+#define readw(addr) ({ unsigned __v; \
+					   int _tmp; \
+                       __builtin_bfin_csync(); \
+                       __asm__ __volatile__ ("cli %1;\n\t"\
+	         			    				 "NOP;NOP;NOP;\n\t"\
+	         			     				 "%0 = w [%2] (z);\n\t"\
+                                             "sti %1;\n\t" \
+  : "=d"(__v), "=d"(_tmp): "a"(addr)); (unsigned short)__v; })
+
+#define readl(addr) ({ unsigned __v; \
+					   int _tmp; \
+                      __builtin_bfin_csync(); \
+                      __asm__ __volatile__ ("cli %1;\n\t"\
+	         			    				 "NOP;NOP;NOP;\n\t"\
+                                            "%0 = [%2];\n\t"\
+                                            "sti %1;\n\t" \
+  : "=d"(__v), "=d"(_tmp): "a"(addr)); __v; })
+
+#define writeb(b,addr) (void)((*(volatile unsigned char *) (addr)) = (b))
+#define writew(b,addr) (void)((*(volatile unsigned short *) (addr)) = (b))
+#define writel(b,addr) (void)((*(volatile unsigned int *) (addr)) = (b))
+
+#define __raw_readb readb
+#define __raw_readw readw
+#define __raw_readl readl
+#define __raw_writeb writeb
+#define __raw_writew writew
+#define __raw_writel writel
+#define memset_io(a,b,c)	memset((void *)(a),(b),(c))
+#define memcpy_fromio(a,b,c)	memcpy((a),(void *)(b),(c))
+#define memcpy_toio(a,b,c)	memcpy((void *)(a),(b),(c))
+
+#define inb(addr)    readb(addr)
+#define inw(addr)    readw(addr)
+#define inl(addr)    readl(addr)
+#define outb(x,addr) ((void) writeb(x,addr))
+#define outw(x,addr) ((void) writew(x,addr))
+#define outl(x,addr) ((void) writel(x,addr))
+
+#define inb_p(addr)    inb(addr)
+#define inw_p(addr)    inw(addr)
+#define inl_p(addr)    inl(addr)
+#define outb_p(x,addr) outb(x,addr)
+#define outw_p(x,addr) outw(x,addr)
+#define outl_p(x,addr) outl(x,addr)
+
+#define ioread8_rep(a,d,c)	insb(a,d,c)
+#define ioread16_rep(a,d,c)	insw(a,d,c)
+#define ioread32_rep(a,d,c)	insl(a,d,c)
+#define iowrite8_rep(a,s,c)	outsb(a,s,c)
+#define iowrite16_rep(a,s,c)	outsw(a,s,c)
+#define iowrite32_rep(a,s,c)	outsl(a,s,c)
+
+#define ioread8(X)			readb(X)
+#define ioread16(X)			readw(X)
+#define ioread32(X)			readl(X)
+#define iowrite8(val,X)			writeb(val,X)
+#define iowrite16(val,X)		writew(val,X)
+#define iowrite32(val,X)		writel(val,X)
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/* Values for nocacheflag and cmode */
+#define IOMAP_NOCACHE_SER		1
+
+#ifndef __ASSEMBLY__
+
+extern void outsb(unsigned long port, const void *addr, unsigned long count);
+extern void outsw(unsigned long port, const void *addr, unsigned long count);
+extern void outsl(unsigned long port, const void *addr, unsigned long count);
+
+extern void insb(unsigned long port, void *addr, unsigned long count);
+extern void insw(unsigned long port, void *addr, unsigned long count);
+extern void insl(unsigned long port, void *addr, unsigned long count);
+
+extern void *__ioremap(unsigned long physaddr, unsigned long size,
+		       int cacheflag);
+extern void iounmap(void *addr);
+
+static inline void *ioremap(unsigned long physaddr, unsigned long size)
+{
+	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
+}
+static inline void *ioremap_nocache(unsigned long physaddr, unsigned long size)
+{
+	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
+}
+
+extern void blkfin_inv_cache_all(void);
+
+#endif
+
+#define dma_cache_inv(_start,_size) do { blkfin_inv_cache_all();} while (0)
+#define dma_cache_wback(_start,_size) do { } while (0)
+#define dma_cache_wback_inv(_start,_size) do { blkfin_inv_cache_all();} while (0)
+
+/* Pages to physical address... */
+#define page_to_phys(page)      ((page - mem_map) << PAGE_SHIFT)
+#define page_to_bus(page)       ((page - mem_map) << PAGE_SHIFT)
+
+#define mm_ptov(vaddr)		((void *) (vaddr))
+#define mm_vtop(vaddr)		((unsigned long) (vaddr))
+#define phys_to_virt(vaddr)	((void *) (vaddr))
+#define virt_to_phys(vaddr)	((unsigned long) (vaddr))
+
+#define virt_to_bus virt_to_phys
+#define bus_to_virt phys_to_virt
+
+/*
+ * Convert a physical pointer to a virtual kernel pointer for /dev/mem
+ * access
+ */
+#define xlate_dev_mem_ptr(p)	__va(p)
+
+/*
+ * Convert a virtual cached pointer to an uncached pointer
+ */
+#define xlate_dev_kmem_ptr(p)	p
+
+#endif				/* __KERNEL__ */
+
+#endif				/* _BFIN_IO_H */
Index: git/linux-2.6/include/asm-blackfin/ioctl.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/ioctl.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,80 @@
+/* $Id$
+ *
+ * linux/ioctl.h for Linux by H.H. Bergman.
+ */
+
+#ifndef _BFIN_IOCTL_H
+#define _BFIN_IOCTL_H
+
+/* ioctl command encoding: 32 bits total, command in lower 16 bits,
+ * size of the parameter structure in the lower 14 bits of the
+ * upper 16 bits.
+ * Encoding the size of the parameter structure in the ioctl request
+ * is useful for catching programs compiled with old versions
+ * and to avoid overwriting user space outside the user buffer area.
+ * The highest 2 bits are reserved for indicating the ``access mode''.
+ * NOTE: This limits the max parameter size to 16kB -1 !
+ */
+
+/*
+ * I don't really have any idea about what this should look like, so
+ * for the time being, this is heavily based on the PC definitions.
+ */
+
+/*
+ * The following is for compatibility across the various Linux
+ * platforms.  The i386 ioctl numbering scheme doesn't really enforce
+ * a type field.  De facto, however, the top 8 bits of the lower 16
+ * bits are indeed used as a type field, so we might just as well make
+ * this explicit here.  Please be sure to use the decoding macros
+ * below from now on.
+ */
+#define _IOC_NRBITS	8
+#define _IOC_TYPEBITS	8
+#define _IOC_SIZEBITS	14
+#define _IOC_DIRBITS	2
+
+#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
+#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
+#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
+#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
+
+#define _IOC_NRSHIFT	0
+#define _IOC_TYPESHIFT	(_IOC_NRSHIFT+_IOC_NRBITS)
+#define _IOC_SIZESHIFT	(_IOC_TYPESHIFT+_IOC_TYPEBITS)
+#define _IOC_DIRSHIFT	(_IOC_SIZESHIFT+_IOC_SIZEBITS)
+
+/*
+ * Direction bits.
+ */
+#define _IOC_NONE	0U
+#define _IOC_WRITE	1U
+#define _IOC_READ	2U
+
+#define _IOC(dir,type,nr,size) \
+	(((dir)  << _IOC_DIRSHIFT) | \
+	 ((type) << _IOC_TYPESHIFT) | \
+	 ((nr)   << _IOC_NRSHIFT) | \
+	 ((size) << _IOC_SIZESHIFT))
+
+/* used to create numbers */
+#define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)
+#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),sizeof(size))
+#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))
+#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))
+
+/* used to decode ioctl numbers.. */
+#define _IOC_DIR(nr)		(((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK)
+#define _IOC_TYPE(nr)		(((nr) >> _IOC_TYPESHIFT) & _IOC_TYPEMASK)
+#define _IOC_NR(nr)		(((nr) >> _IOC_NRSHIFT) & _IOC_NRMASK)
+#define _IOC_SIZE(nr)		(((nr) >> _IOC_SIZESHIFT) & _IOC_SIZEMASK)
+
+/* ...and for the drivers/sound files... */
+
+#define IOC_IN		(_IOC_WRITE << _IOC_DIRSHIFT)
+#define IOC_OUT		(_IOC_READ << _IOC_DIRSHIFT)
+#define IOC_INOUT	((_IOC_WRITE|_IOC_READ) << _IOC_DIRSHIFT)
+#define IOCSIZE_MASK	(_IOC_SIZEMASK << _IOC_SIZESHIFT)
+#define IOCSIZE_SHIFT	(_IOC_SIZESHIFT)
+
+#endif				/* _BFIN_IOCTL_H */
Index: git/linux-2.6/include/asm-blackfin/ioctls.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/ioctls.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,82 @@
+#ifndef __ARCH_BFIN_IOCTLS_H__
+#define __ARCH_BFIN_IOCTLS_H__
+
+#include <asm/ioctl.h>
+
+/* 0x54 is just a magic number to make these relatively unique ('T') */
+
+#define TCGETS		0x5401
+#define TCSETS		0x5402
+#define TCSETSW		0x5403
+#define TCSETSF		0x5404
+#define TCGETA		0x5405
+#define TCSETA		0x5406
+#define TCSETAW		0x5407
+#define TCSETAF		0x5408
+#define TCSBRK		0x5409
+#define TCXONC		0x540A
+#define TCFLSH		0x540B
+#define TIOCEXCL	0x540C
+#define TIOCNXCL	0x540D
+#define TIOCSCTTY	0x540E
+#define TIOCGPGRP	0x540F
+#define TIOCSPGRP	0x5410
+#define TIOCOUTQ	0x5411
+#define TIOCSTI		0x5412
+#define TIOCGWINSZ	0x5413
+#define TIOCSWINSZ	0x5414
+#define TIOCMGET	0x5415
+#define TIOCMBIS	0x5416
+#define TIOCMBIC	0x5417
+#define TIOCMSET	0x5418
+#define TIOCGSOFTCAR	0x5419
+#define TIOCSSOFTCAR	0x541A
+#define FIONREAD	0x541B
+#define TIOCINQ		FIONREAD
+#define TIOCLINUX	0x541C
+#define TIOCCONS	0x541D
+#define TIOCGSERIAL	0x541E
+#define TIOCSSERIAL	0x541F
+#define TIOCPKT		0x5420
+#define FIONBIO		0x5421
+#define TIOCNOTTY	0x5422
+#define TIOCSETD	0x5423
+#define TIOCGETD	0x5424
+#define TCSBRKP		0x5425	/* Needed for POSIX tcsendbreak() */
+#define TIOCTTYGSTRUCT	0x5426	/* For debugging only */
+#define TIOCSBRK	0x5427	/* BSD compatibility */
+#define TIOCCBRK	0x5428	/* BSD compatibility */
+#define TIOCGSID	0x5429	/* Return the session ID of FD */
+#define TIOCGPTN	_IOR('T',0x30, unsigned int)	/* Get Pty Number (of pty-mux device) */
+#define TIOCSPTLCK	_IOW('T',0x31, int)	/* Lock/unlock Pty */
+
+#define FIONCLEX	0x5450	/* these numbers need to be adjusted. */
+#define FIOCLEX		0x5451
+#define FIOASYNC	0x5452
+#define TIOCSERCONFIG	0x5453
+#define TIOCSERGWILD	0x5454
+#define TIOCSERSWILD	0x5455
+#define TIOCGLCKTRMIOS	0x5456
+#define TIOCSLCKTRMIOS	0x5457
+#define TIOCSERGSTRUCT	0x5458	/* For debugging only */
+#define TIOCSERGETLSR   0x5459	/* Get line status register */
+#define TIOCSERGETMULTI 0x545A	/* Get multiport config  */
+#define TIOCSERSETMULTI 0x545B	/* Set multiport config */
+
+#define TIOCMIWAIT	0x545C	/* wait for a change on serial input line(s) */
+#define TIOCGICOUNT	0x545D	/* read serial port inline interrupt counts */
+
+#define FIOQSIZE	0x545E
+
+/* Used for packet mode */
+#define TIOCPKT_DATA		 0
+#define TIOCPKT_FLUSHREAD	 1
+#define TIOCPKT_FLUSHWRITE	 2
+#define TIOCPKT_STOP		 4
+#define TIOCPKT_START		 8
+#define TIOCPKT_NOSTOP		16
+#define TIOCPKT_DOSTOP		32
+
+#define TIOCSER_TEMT    0x01	/* Transmitter physically empty */
+
+#endif				/* __ARCH_BFIN_IOCTLS_H__ */
Index: git/linux-2.6/include/asm-blackfin/ipc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/ipc.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,31 @@
+#ifndef __BFIN_IPC_H__
+#define __BFIN_IPC_H__
+
+/*
+ * These are used to wrap system calls on bfin.
+ *
+ * See arch/blackfin/kernel/sys_bfin.c for ugly details..
+ */
+struct ipc_kludge {
+	struct msgbuf *msgp;
+	long msgtyp;
+};
+
+#define SEMOP		 1
+#define SEMGET		 2
+#define SEMCTL		 3
+#define MSGSND		11
+#define MSGRCV		12
+#define MSGGET		13
+#define MSGCTL		14
+#define SHMAT		21
+#define SHMDT		22
+#define SHMGET		23
+#define SHMCTL		24
+
+/* Used by the DIPC package, try and avoid reusing it */
+#define DIPC		25
+
+#define IPCCALL(version,op)	((version)<<16 | (op))
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/ipcbuf.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/ipcbuf.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,30 @@
+/* Changes origined from m68k version.    Lineo Inc.  May 2001   */
+
+#ifndef __BFIN_IPCBUF_H__
+#define __BFIN_IPCBUF_H__
+
+/*
+ * The user_ipc_perm structure for m68k architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 32-bit mode_t and seq
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct ipc64_perm {
+	__kernel_key_t key;
+	__kernel_uid32_t uid;
+	__kernel_gid32_t gid;
+	__kernel_uid32_t cuid;
+	__kernel_gid32_t cgid;
+	__kernel_mode_t mode;
+	unsigned short __pad1;
+	unsigned short seq;
+	unsigned short __pad2;
+	unsigned long __unused1;
+	unsigned long __unused2;
+};
+
+#endif				/* __BFIN_IPCBUF_H__ */
Index: git/linux-2.6/include/asm-blackfin/irq.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/irq.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,93 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ * Changed by HuTao Apr18, 2003
+ *
+ * Copyright was missing when I got the code so took from MIPS arch ...MaTed---
+ * Copyright (C) 1994 by Waldorf GMBH, written by Ralf Baechle
+ * Copyright (C) 1995, 96, 97, 98, 99, 2000, 2001 by Ralf Baechle
+ *
+ * Adapted for BlackFin (ADI) by Ted Ma <mated@sympatico.ca>
+ * Copyright (c) 2002 Arcturus Networks Inc. (www.arcturusnetworks.com)
+ * Copyright (c) 2002 Lineo, Inc. <mattw@lineo.com>
+ */
+
+#ifndef _BFIN_IRQ_H_
+#define _BFIN_IRQ_H_
+
+#include <linux/config.h>
+#include <asm/mach/irq.h>
+#include <asm/ptrace.h>
+
+/*******************************************************************************
+ *****   INTRODUCTION ***********
+ *   On the Blackfin, the interrupt structure allows remmapping of the hardware
+ *   levels.
+ * - I'm going to assume that the H/W level is going to stay at the default
+ *   settings. If someone wants to go through and abstart this out, feel free
+ *   to mod the interrupt numbering scheme.
+ * - I'm abstracting the interrupts so that uClinux does not know anything
+ *   about the H/W levels. If you want to change the H/W AND keep the abstracted
+ *   levels that uClinux sees, you should be able to do most of it here.
+ * - I've left the "abstract" numbering sparce in case someone wants to pull the
+ *   interrupts apart (just the TX/RX for the various devices)
+ *******************************************************************************/
+
+/* SYS_IRQS and NR_IRQS are defined in <asm/mach-bf5xx/irq.h>*/
+
+/*
+ * Machine specific interrupt sources.
+ *
+ * Adding an interrupt service routine for a source with this bit
+ * set indicates a special machine specific interrupt source.
+ * The machine specific files define these sources.
+ *
+ * The IRQ_MACHSPEC bit is now gone - the only thing it did was to
+ * introduce unnecessary overhead.
+ *
+ * All interrupt handling is actually machine specific so it is better
+ * to use function pointers, as used by the Sparc port, and select the
+ * interrupt handling functions when initializing the kernel. This way
+ * we save some unnecessary overhead at run-time.
+ *                                                      01/11/97 - Jes
+ */
+
+extern int sys_request_irq(unsigned int,
+			   int (*)(int, void *, struct pt_regs *),
+			   unsigned long, const char *, void *);
+extern void sys_free_irq(unsigned int, void *);
+
+static __inline__ int irq_canonicalize(int irq)
+{
+	return irq;
+}
+
+/* count of spurious interrupts */
+extern volatile unsigned int num_spurious;
+void enable_irq(unsigned int irq);
+void disable_irq(unsigned int irq);
+
+#define disable_irq_nosync(x)	disable_irq(x)
+
+#ifndef NO_IRQ
+#define NO_IRQ ((unsigned int)(-1))
+#endif
+
+#define __IRQT_FALEDGE	(1 << 0)
+#define __IRQT_RISEDGE	(1 << 1)
+#define __IRQT_LOWLVL	(1 << 2)
+#define __IRQT_HIGHLVL	(1 << 3)
+
+#define IRQT_NOEDGE	(0)
+#define IRQT_RISING	(__IRQT_RISEDGE)
+#define IRQT_FALLING	(__IRQT_FALEDGE)
+#define IRQT_BOTHEDGE	(__IRQT_RISEDGE|__IRQT_FALEDGE)
+#define IRQT_LOW	(__IRQT_LOWLVL)
+#define IRQT_HIGH	(__IRQT_HIGHLVL)
+#define IRQT_PROBE	(1 << 4)
+
+int set_irq_type(unsigned int irq, unsigned int type);
+
+#endif				/* _BFIN_IRQ_H_ */
Index: git/linux-2.6/include/asm-blackfin/irqchip.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/irqchip.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,132 @@
+/*
+ *  include/asm-blackfin/irq.h
+ *  Borrowed from linux/include/asm-arm/mach/irq.h
+ *
+ *  Copyright (C) 1995-2000 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_BFIN_MACH_IRQ_H
+#define __ASM_BFIN_MACH_IRQ_H
+
+struct irqdesc;
+struct pt_regs;
+struct seq_file;
+
+typedef void (*irq_handler_t) (unsigned int, struct irqdesc *,
+			       struct pt_regs *);
+typedef void (*irq_control_t) (unsigned int);
+
+struct irqchip {
+	/*
+	 * Acknowledge the IRQ.
+	 * If this is a level-based IRQ, then it is expected to mask the IRQ
+	 * as well.
+	 */
+	void (*ack) (unsigned int);
+	/*
+	 * Mask the IRQ in hardware.
+	 */
+	void (*mask) (unsigned int);
+	/*
+	 * Unmask the IRQ in hardware.
+	 */
+	void (*unmask) (unsigned int);
+	/*
+	 * Ask the hardware to re-trigger the IRQ.
+	 * Note: This method _must_ _not_ call the interrupt handler.
+	 * If you are unable to retrigger the interrupt, do not
+	 * provide a function, or if you do, return non-zero.
+	 */
+	int (*retrigger) (unsigned int);
+	/*
+	 * Set the type of the IRQ.
+	 */
+	int (*type) (unsigned int, unsigned int);
+	/*
+	 * Set wakeup-enable on the selected IRQ
+	 */
+	int (*wake) (unsigned int, unsigned int);
+};
+
+struct irqdesc {
+	irq_handler_t handle;
+	struct irqchip *chip;
+	struct irqaction *action;
+	struct list_head pend;
+	void *chipdata;
+	void *data;
+	unsigned int disable_depth;
+
+	unsigned int triggered:1;	/* IRQ has occurred           */
+	unsigned int running:1;	/* IRQ is running             */
+	unsigned int pending:1;	/* IRQ is pending             */
+	unsigned int probing:1;	/* IRQ in use for a probe     */
+	unsigned int probe_ok:1;	/* IRQ can be used for probe  */
+	unsigned int valid:1;	/* IRQ claimable              */
+	unsigned int noautoenable:1;	/* don't automatically enable IRQ */
+	unsigned int unused:25;
+
+	/*
+	 * IRQ lock detection
+	 */
+	unsigned int lck_cnt;
+	unsigned int lck_pc;
+	unsigned int lck_jif;
+};
+
+extern struct irqdesc irq_desc[];
+
+/*
+ * This is internal.  Do not use it.
+ */
+extern void init_FIQ(void);
+extern int show_fiq_list(struct seq_file *, void *);
+void __set_irq_handler(unsigned int irq, irq_handler_t, int);
+
+/*
+ * External stuff.
+ */
+#define set_irq_handler(irq,handler)		__set_irq_handler(irq,handler,0)
+#define set_irq_chained_handler(irq,handler)	__set_irq_handler(irq,handler,1)
+#define set_irq_data(irq,d)			do { irq_desc[irq].data = d; } while (0)
+#define set_irq_chipdata(irq,d)			do { irq_desc[irq].chipdata = d; } while (0)
+#define get_irq_chipdata(irq)			(irq_desc[irq].chipdata)
+
+void set_irq_chip(unsigned int irq, struct irqchip *);
+void set_irq_flags(unsigned int irq, unsigned int flags);
+
+#ifdef not_yet
+/*
+ * This is to be used by the top-level machine IRQ decoder only.
+ */
+static inline void call_irq(struct pt_regs *regs, unsigned int irq)
+{
+	struct irqdesc *desc = irq_desc + irq;
+
+	spin_lock(&irq_controller_lock);
+	desc->handle(irq, desc, regs);
+	spin_unlock(&irq_controller_lock);
+
+	if (softirq_pending(smp_processor_id()))
+		do_softirq();
+}
+#endif
+
+#define IRQF_VALID	(1 << 0)
+#define IRQF_PROBE	(1 << 1)
+#define IRQF_NOAUTOEN	(1 << 2)
+
+/*
+ * Built-in IRQ handlers.
+ */
+void do_level_IRQ(unsigned int irq, struct irqdesc *desc, struct pt_regs *regs);
+void do_edge_IRQ(unsigned int irq, struct irqdesc *desc, struct pt_regs *regs);
+void do_simple_IRQ(unsigned int irq, struct irqdesc *desc,
+		   struct pt_regs *regs);
+void do_bad_IRQ(unsigned int irq, struct irqdesc *desc, struct pt_regs *regs);
+void dummy_mask_unmask_irq(unsigned int irq);
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/kmap_types.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/kmap_types.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,21 @@
+#ifndef _ASM_KMAP_TYPES_H
+#define _ASM_KMAP_TYPES_H
+
+enum km_type {
+	KM_BOUNCE_READ,
+	KM_SKB_SUNRPC_DATA,
+	KM_SKB_DATA_SOFTIRQ,
+	KM_USER0,
+	KM_USER1,
+	KM_BIO_SRC_IRQ,
+	KM_BIO_DST_IRQ,
+	KM_PTE0,
+	KM_PTE1,
+	KM_IRQ0,
+	KM_IRQ1,
+	KM_SOFTIRQ0,
+	KM_SOFTIRQ1,
+	KM_TYPE_NR
+};
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/linkage.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/linkage.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,7 @@
+#ifndef __ASM_LINKAGE_H
+#define __ASM_LINKAGE_H
+
+#define __ALIGN .align 4
+#define __ALIGN_STR ".align 4"
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/local.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/local.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,6 @@
+#ifndef __BLACKFIN_LOCAL_H
+#define __BLACKFIN_LOCAL_H
+
+#include <asm-generic/local.h>
+
+#endif				/* __BLACKFIN_LOCAL_H */
Index: git/linux-2.6/include/asm-blackfin/mach-bf533/bf533.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf533/bf533.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,290 @@
+
+ /*
+  * File:         include/asm-blackfin/mach-bf533/bf533.h
+  * Based on:
+  * Author:
+  *
+  * Created:
+  * Description:
+  *
+  * Rev:
+  *
+  * Modified:
+  *
+  *
+  * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.
+  * If not, write to the Free Software Foundation,
+  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+  */
+
+#ifndef _BLKFin_H_
+#define _BLKFin_H_
+
+#include <linux/config.h>
+
+#define SUPPORTED_DSPID 2
+
+#define OFFSET_( x ) ((x) & 0x0000FFFF)	/* define macro for offset */
+
+/*some misc defines*/
+#define IMASK_IVG15		0x8000
+#define IMASK_IVG14		0x4000
+#define IMASK_IVG13		0x2000
+#define IMASK_IVG12		0x1000
+
+#define IMASK_IVG11		0x0800
+#define IMASK_IVG10		0x0400
+#define IMASK_IVG9		0x0200
+#define IMASK_IVG8		0x0100
+
+#define IMASK_IVG7		0x0080
+#define IMASK_IVGTMR		0x0040
+#define IMASK_IVGHW		0x0020
+
+/***************************/
+
+#define BLKFIN_ICACHESIZE	(16*1024)
+
+#if defined(CONFIG_BF533) || defined(CONFIG_BF532)
+#define BLKFIN_DCACHESIZE	(32*1024)
+#define BLKFIN_DSUPBANKS	2
+#else
+#define BLKFIN_DCACHESIZE	(16*1024)
+#define BLKFIN_DSUPBANKS	1
+#endif
+
+#define BLKFIN_DSUBBANKS	4
+#define BLKFIN_DWAYS		2
+#define BLKFIN_DLINES		64
+#define BLKFIN_ISUBBANKS	4
+#define BLKFIN_IWAYS		4
+#define BLKFIN_ILINES		32
+
+#define WAY0_L			0x1
+#define WAY1_L			0x2
+#define WAY01_L			0x3
+#define WAY2_L			0x4
+#define WAY02_L			0x5
+#define	WAY12_L			0x6
+#define	WAY012_L		0x7
+
+#define	WAY3_L			0x8
+#define	WAY03_L			0x9
+#define	WAY13_L			0xA
+#define	WAY013_L		0xB
+
+#define	WAY32_L			0xC
+#define	WAY320_L		0xD
+#define	WAY321_L		0xE
+#define	WAYALL_L		0xF
+
+#define DMC_ENABLE (2<<2)	/*yes, 2, not 1 */
+
+/* IAR0 BIT FIELDS*/
+#define RTC_ERROR_BIT			0x0FFFFFFF
+#define UART_ERROR_BIT			0xF0FFFFFF
+#define SPORT1_ERROR_BIT		0xFF0FFFFF
+#define SPI_ERROR_BIT			0xFFF0FFFF
+#define SPORT0_ERROR_BIT		0xFFFF0FFF
+#define PPI_ERROR_BIT			0xFFFFF0FF
+#define DMA_ERROR_BIT			0xFFFFFF0F
+#define PLLWAKE_ERROR_BIT		0xFFFFFFFF
+
+/* IAR1 BIT FIELDS*/
+#define DMA7_UARTTX_BIT			0x0FFFFFFF
+#define DMA6_UARTRX_BIT			0xF0FFFFFF
+#define DMA5_SPI_BIT			0xFF0FFFFF
+#define DMA4_SPORT1TX_BIT		0xFFF0FFFF
+#define DMA3_SPORT1RX_BIT		0xFFFF0FFF
+#define DMA2_SPORT0TX_BIT		0xFFFFF0FF
+#define DMA1_SPORT0RX_BIT		0xFFFFFF0F
+#define DMA0_PPI_BIT			0xFFFFFFFF
+
+/* IAR2 BIT FIELDS*/
+#define WDTIMER_BIT			0x0FFFFFFF
+#define MEMDMA1_BIT			0xF0FFFFFF
+#define MEMDMA0_BIT			0xFF0FFFFF
+#define PFB_BIT				0xFFF0FFFF
+#define PFA_BIT				0xFFFF0FFF
+#define TIMER2_BIT			0xFFFFF0FF
+#define TIMER1_BIT			0xFFFFFF0F
+#define TIMER0_BIT		        0xFFFFFFFF
+
+#define ZERO		0x0
+
+/********************************* EBIU Settings ************************************/
+#define AMBCTL0VAL	((CONFIG_BANK_1 << 16) | CONFIG_BANK_0)
+#define AMBCTL1VAL	((CONFIG_BANK_3 << 16) | CONFIG_BANK_2)
+
+#ifdef CONFIG_C_AMBEN_ALL
+#define V_AMBEN AMBEN_ALL
+#endif
+#ifdef CONFIG_C_AMBEN
+#define V_AMBEN 0x0
+#endif
+#ifdef CONFIG_C_AMBEN_B0
+#define V_AMBEN AMBEN_B0
+#endif
+#ifdef CONFIG_C_AMBEN_B0_B1
+#define V_AMBEN AMBEN_B0_B1
+#endif
+#ifdef CONFIG_C_AMBEN_B0_B1_B2
+#define V_AMBEN AMBEN_B0_B1_B2
+#endif
+#ifdef CONFIG_C_AMCKEN
+#define V_AMCKEN AMCKEN
+#else
+#define V_AMCKEN 0x0
+#endif
+#ifdef CONFIG_C_CDPRIO
+#define V_CDPRIO 0x100
+#else
+#define V_CDPRIO 0x0
+#endif
+
+#define AMGCTLVAL	(V_AMBEN | V_AMCKEN | V_CDPRIO)
+
+#ifdef CONFIG_BFIN_KERNEL_CLOCK
+/********************************PLL Settings **************************************/
+#if (CONFIG_VCO_MULT < 0)
+#error "VCO Multiplier is less than 0. Please select a different value"
+#endif
+
+#if (CONFIG_VCO_MULT == 0)
+#error "VCO Multiplier should be greater than 0. Please select a different value"
+#endif
+
+#if(CONFIG_VCO_MULT > 64)
+#error "VCO Multiplier is more than 64. Please select a different value"
+#endif
+
+#if(CONFIG_CLKIN_HALF == 0)
+#define CONFIG_VCO_HZ	(CONFIG_CLKIN_HZ * CONFIG_VCO_MULT)
+#else
+#define CONFIG_VCO_HZ	((CONFIG_CLKIN_HZ * CONFIG_VCO_MULT)/2)
+#endif
+
+#if(CONFIG_PLL_BYPASS == 0)
+#define CONFIG_CCLK_HZ	(CONFIG_VCO_HZ/CONFIG_CCLK_DIV)
+#define CONFIG_SCLK_HZ	(CONFIG_VCO_HZ/CONFIG_SCLK_DIV)
+#else
+#define CONFIG_CCLK_HZ	CONFIG_CLKIN_HZ
+#define CONFIG_SCLK_HZ	CONFIG_CLKIN_HZ
+#endif
+
+#if (CONFIG_SCLK_DIV < 1)
+#error "SCLK DIV cannot be less than 1 or more than 15. Please select a proper value"
+#endif
+
+#if (CONFIG_SCLK_DIV > 15)
+#error "SCLK DIV cannot be less than 1 or more than 15. Please select a proper value"
+#endif
+
+#if (CONFIG_CCLK_DIV != 1)
+#if (CONFIG_CCLK_DIV != 2)
+#if (CONFIG_CCLK_DIV != 4)
+#if (CONFIG_CCLK_DIV != 8)
+#error "CCLK DIV can be 1,2,4 or 8 only.Please select a proper value"
+#endif
+#endif
+#endif
+#endif
+
+#define MAX_VC	650000000
+
+#if(CONFIG_VCO_HZ > MAX_VC)
+#error "VCO selected is more than maximum value. Please change the VCO multipler"
+#endif
+
+#if (CONFIG_SCLK_HZ > 133000000)
+#error "Sclk value selected is more than maximum.Please select a proper value for SCLK multiplier"
+#endif
+
+#if (CONFIG_SCLK_HZ < 27000000)
+#error "Sclk value selected is less than minimum.Please select a proper value for SCLK multiplier"
+#endif
+
+#if (CONFIG_SCLK_HZ > CONFIG_CCLK_HZ)
+#if(CONFIG_SCLK_HZ != CONFIG_CLKIN_HZ)
+#if(CONFIG_CCLK_HZ != CONFIG_CLKIN_HZ)
+#error "Please select sclk less than cclk"
+#endif
+#endif
+#endif
+
+#if (CONFIG_CCLK_DIV == 1)
+#define CONFIG_CCLK_ACT_DIV   CCLK_DIV1
+#endif
+#if (CONFIG_CCLK_DIV == 2)
+#define CONFIG_CCLK_ACT_DIV   CCLK_DIV2
+#endif
+#if (CONFIG_CCLK_DIV == 4)
+#define CONFIG_CCLK_ACT_DIV   CCLK_DIV4
+#endif
+#if (CONFIG_CCLK_DIV == 8)
+#define CONFIG_CCLK_ACT_DIV   CCLK_DIV8
+#endif
+#ifndef CONFIG_CCLK_ACT_DIV
+#define CONFIG_CCLK_ACT_DIV   CONFIG_CCLK_DIV_not_defined_properly
+#endif
+
+#endif /* CONFIG_BFIN_KERNEL_CLOCK */
+
+#ifdef CONFIG_BF533
+#define CPU "BF533"
+#endif
+#ifdef CONFIG_BF532
+#define CPU "BF532"
+#endif
+#ifdef CONFIG_BF531
+#define CPU "BF531"
+#endif
+#ifndef CPU
+#define	CPU "UNKOWN"
+#endif
+
+#if (CONFIG_MEM_SIZE % 4)
+#error "SDRAM mem size must be multible of 4MB"
+#endif
+
+#define SDRAM_IGENERIC    (CPLB_L1_CHBL | CPLB_USER_RD | CPLB_VALID | CPLB_PORTPRIO)
+#define SDRAM_IKERNEL     (SDRAM_IGENERIC | CPLB_LOCK)
+#define L1_IMEMORY        (               CPLB_USER_RD | CPLB_VALID | CPLB_LOCK)
+#define SDRAM_INON_CHBL   (               CPLB_USER_RD | CPLB_VALID)
+
+/*Use the menuconfig cache policy here - CONFIG_BLKFIN_WT/CONFIG_BLKFIN_WB*/
+
+#define ANOMALY_05000158		0x200
+#ifdef CONFIG_BLKFIN_WB		/*Write Back Policy */
+#define SDRAM_DGENERIC   (CPLB_L1_CHBL | CPLB_DIRTY \
+			| CPLB_SUPV_WR | CPLB_USER_WR | CPLB_USER_RD | CPLB_VALID | ANOMALY_05000158)
+#else				/*Write Through */
+#define SDRAM_DGENERIC   (CPLB_L1_CHBL | CPLB_WT | CPLB_L1_AOW \
+			| CPLB_SUPV_WR | CPLB_USER_WR | CPLB_USER_RD | CPLB_VALID | ANOMALY_05000158)
+#endif
+#define SDRAM_DKERNEL    (SDRAM_DGENERIC | CPLB_LOCK)
+
+#define L1_DMEMORY       (CPLB_SUPV_WR | CPLB_USER_WR | CPLB_USER_RD | CPLB_VALID | ANOMALY_05000158)
+#define SDRAM_DNON_CHBL  (CPLB_SUPV_WR | CPLB_USER_WR | CPLB_USER_RD | CPLB_VALID | ANOMALY_05000158)
+#define SDRAM_EBIU       (CPLB_SUPV_WR | CPLB_USER_WR | CPLB_USER_RD | CPLB_VALID | ANOMALY_05000158)
+#define SDRAM_OOPS  	 (CPLB_VALID | ANOMALY_05000158 | CPLB_LOCK)
+
+#define SIZE_1K 0x00000400	/* 1K */
+#define SIZE_4K 0x00001000	/* 4K */
+#define SIZE_1M 0x00100000	/* 1M */
+#define SIZE_4M 0x00400000	/* 4M */
+
+#endif				/* _BLKFin_H_  */
Index: git/linux-2.6/include/asm-blackfin/mach-bf533/blackfin.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf533/blackfin.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,47 @@
+/*
+ * Common header file for blackfin family of processors.
+ *
+ */
+ /*
+  * File:         include/asm-blackfin/mach-bf533/blackfin.h
+  * Based on:
+  * Author:
+  *
+  * Created:
+  * Description:
+  *
+  * Rev:
+  *
+  * Modified:
+  *
+  *
+  * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.
+  * If not, write to the Free Software Foundation,
+  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+  */
+
+#ifndef _MACH_BLACKFIN_H_
+#define _MACH_BLACKFIN_H_
+
+#include "bf533.h"
+#include "mem_map.h"
+#include "defBF532.h"
+
+#if !(defined(__ASSEMBLY__) || defined(ASSEMBLY))
+#include "cdefBF532.h"
+#endif
+
+#endif				/* _MACH_BLACKFIN_H_ */
Index: git/linux-2.6/include/asm-blackfin/mach-bf533/cdefBF532.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf533/cdefBF532.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,392 @@
+
+ /*
+  * File:         include/asm-blackfin/mach-bf533/bf533.h
+
+  * Based on:
+  * Author:
+  *
+  * Created:
+  * Description:
+  *
+  * Rev:
+  *
+  * Modified:
+  *
+  *
+  * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.
+  * If not, write to the Free Software Foundation,
+  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+  */
+
+#ifndef _CDEF_BF532_H
+#define _CDEF_BF532_H
+/*
+#if !defined(__ADSPLPBLACKFIN__)
+#warning cdefBF532.h should only be included for 532 compatible chips.
+#endif
+*/
+/*include all Core registers and bit definitions*/
+#include "defBF532.h"
+
+/*include core specific register pointer definitions*/
+#include <asm/mach-common/cdef_LPBlackfin.h>
+
+/* Clock and System Control (0xFFC0 0400-0xFFC0 07FF) */
+#define pPLL_CTL ((volatile unsigned short *)PLL_CTL)
+#define pPLL_STAT ((volatile unsigned short *)PLL_STAT)
+#define pPLL_LOCKCNT ((volatile unsigned short *)PLL_LOCKCNT)
+#define pSWRST ((volatile unsigned short *)SWRST)
+#define pSYSCR ((volatile unsigned short *)SYSCR)
+#define pPLL_DIV ((volatile unsigned short *)PLL_DIV)
+#define pVR_CTL ((volatile unsigned short *)VR_CTL)
+
+/* System Interrupt Controller (0xFFC0 0C00-0xFFC0 0FFF) */
+#define pSIC_IAR0 ((volatile unsigned long *)SIC_IAR0)
+#define pSIC_IAR1 ((volatile unsigned long *)SIC_IAR1)
+#define pSIC_IAR2 ((volatile unsigned long *)SIC_IAR2)
+#define pSIC_IAR3 ((volatile unsigned long *)SIC_IAR3)
+#define pSIC_IMASK ((volatile unsigned long *)SIC_IMASK)
+#define pSIC_ISR ((volatile unsigned long *)SIC_ISR)
+#define pSIC_IWR ((volatile unsigned long *)SIC_IWR)
+
+/* Watchdog Timer (0xFFC0 1000-0xFFC0 13FF) */
+#define pWDOG_CTL ((volatile unsigned short *)WDOG_CTL)
+#define pWDOG_CNT ((volatile unsigned long *)WDOG_CNT)
+#define pWDOG_STAT ((volatile unsigned long *)WDOG_STAT)
+
+/* Real Time Clock (0xFFC0 1400-0xFFC0 17FF) */
+#define pRTC_STAT ((volatile unsigned long *)RTC_STAT)
+#define pRTC_ICTL ((volatile unsigned short *)RTC_ICTL)
+#define pRTC_ISTAT ((volatile unsigned short *)RTC_ISTAT)
+#define pRTC_SWCNT ((volatile unsigned short *)RTC_SWCNT)
+#define pRTC_ALARM ((volatile unsigned long *)RTC_ALARM)
+#define pRTC_FAST ((volatile unsigned short *)RTC_FAST)
+#define pRTC_PREN ((volatile unsigned short *)RTC_PREN)
+
+/* General Purpose IO (0xFFC0 2400-0xFFC0 27FF) */
+#define pFIO_DIR ((volatile unsigned short *)FIO_DIR)
+#define pFIO_FLAG_C ((volatile unsigned short *)FIO_FLAG_C)
+#define pFIO_FLAG_S ((volatile unsigned short *)FIO_FLAG_S)
+#define pFIO_MASKA_C ((volatile unsigned short *)FIO_MASKA_C)
+#define pFIO_MASKA_S ((volatile unsigned short *)FIO_MASKA_S)
+#define pFIO_MASKB_C ((volatile unsigned short *)FIO_MASKB_C)
+#define pFIO_MASKB_S ((volatile unsigned short *)FIO_MASKB_S)
+#define pFIO_POLAR ((volatile unsigned short *)FIO_POLAR)
+#define pFIO_EDGE ((volatile unsigned short *)FIO_EDGE)
+#define pFIO_BOTH ((volatile unsigned short *)FIO_BOTH)
+#define pFIO_INEN ((volatile unsigned short *)FIO_INEN)
+#define pFIO_FLAG_D ((volatile unsigned short *)FIO_FLAG_D)
+#define pFIO_FLAG_T ((volatile unsigned short *)FIO_FLAG_T)
+#define pFIO_MASKA_D ((volatile unsigned short *)FIO_MASKA_D)
+#define pFIO_MASKA_T ((volatile unsigned short *)FIO_MASKA_T)
+#define pFIO_MASKB_D ((volatile unsigned short *)FIO_MASKB_D)
+#define pFIO_MASKB_T ((volatile unsigned short *)FIO_MASKB_T)
+
+/* DMA Traffic controls */
+#define pDMA_TCPER ((volatile unsigned short *)DMA_TCPER)
+#define pDMA_TCCNT ((volatile unsigned short *)DMA_TCCNT)
+#define pDMA_TC_PER ((volatile unsigned short *)DMA_TC_PER)
+#define pDMA_TC_CNT ((volatile unsigned short *)DMA_TC_CNT)
+
+/* DMA Controller */
+#define pDMA0_CONFIG ((volatile unsigned short *)DMA0_CONFIG)
+#define pDMA0_NEXT_DESC_PTR ((volatile void **)DMA0_NEXT_DESC_PTR)
+#define pDMA0_START_ADDR ((volatile void **)DMA0_START_ADDR)
+#define pDMA0_X_COUNT ((volatile unsigned short *)DMA0_X_COUNT)
+#define pDMA0_Y_COUNT ((volatile unsigned short *)DMA0_Y_COUNT)
+#define pDMA0_X_MODIFY ((volatile signed short *)DMA0_X_MODIFY)
+#define pDMA0_Y_MODIFY ((volatile signed short *)DMA0_Y_MODIFY)
+#define pDMA0_CURR_DESC_PTR ((volatile void **)DMA0_CURR_DESC_PTR)
+#define pDMA0_CURR_ADDR ((volatile void **)DMA0_CURR_ADDR)
+#define pDMA0_CURR_X_COUNT ((volatile unsigned short *)DMA0_CURR_X_COUNT)
+#define pDMA0_CURR_Y_COUNT ((volatile unsigned short *)DMA0_CURR_Y_COUNT)
+#define pDMA0_IRQ_STATUS ((volatile unsigned short *)DMA0_IRQ_STATUS)
+#define pDMA0_PERIPHERAL_MAP ((volatile unsigned short *)DMA0_PERIPHERAL_MAP)
+
+#define pDMA1_CONFIG ((volatile unsigned short *)DMA1_CONFIG)
+#define pDMA1_NEXT_DESC_PTR ((volatile void **)DMA1_NEXT_DESC_PTR)
+#define pDMA1_START_ADDR ((volatile void **)DMA1_START_ADDR)
+#define pDMA1_X_COUNT ((volatile unsigned short *)DMA1_X_COUNT)
+#define pDMA1_Y_COUNT ((volatile unsigned short *)DMA1_Y_COUNT)
+#define pDMA1_X_MODIFY ((volatile signed short *)DMA1_X_MODIFY)
+#define pDMA1_Y_MODIFY ((volatile signed short *)DMA1_Y_MODIFY)
+#define pDMA1_CURR_DESC_PTR ((volatile void **)DMA1_CURR_DESC_PTR)
+#define pDMA1_CURR_ADDR ((volatile void **)DMA1_CURR_ADDR)
+#define pDMA1_CURR_X_COUNT ((volatile unsigned short *)DMA1_CURR_X_COUNT)
+#define pDMA1_CURR_Y_COUNT ((volatile unsigned short *)DMA1_CURR_Y_COUNT)
+#define pDMA1_IRQ_STATUS ((volatile unsigned short *)DMA1_IRQ_STATUS)
+#define pDMA1_PERIPHERAL_MAP ((volatile unsigned short *)DMA1_PERIPHERAL_MAP)
+
+#define pDMA2_CONFIG ((volatile unsigned short *)DMA2_CONFIG)
+#define pDMA2_NEXT_DESC_PTR ((volatile void **)DMA2_NEXT_DESC_PTR)
+#define pDMA2_START_ADDR ((volatile void **)DMA2_START_ADDR)
+#define pDMA2_X_COUNT ((volatile unsigned short *)DMA2_X_COUNT)
+#define pDMA2_Y_COUNT ((volatile unsigned short *)DMA2_Y_COUNT)
+#define pDMA2_X_MODIFY ((volatile signed short *)DMA2_X_MODIFY)
+#define pDMA2_Y_MODIFY ((volatile signed short *)DMA2_Y_MODIFY)
+#define pDMA2_CURR_DESC_PTR ((volatile void **)DMA2_CURR_DESC_PTR)
+#define pDMA2_CURR_ADDR ((volatile void **)DMA2_CURR_ADDR)
+#define pDMA2_CURR_X_COUNT ((volatile unsigned short *)DMA2_CURR_X_COUNT)
+#define pDMA2_CURR_Y_COUNT ((volatile unsigned short *)DMA2_CURR_Y_COUNT)
+#define pDMA2_IRQ_STATUS ((volatile unsigned short *)DMA2_IRQ_STATUS)
+#define pDMA2_PERIPHERAL_MAP ((volatile unsigned short *)DMA2_PERIPHERAL_MAP)
+
+#define pDMA3_CONFIG ((volatile unsigned short *)DMA3_CONFIG)
+#define pDMA3_NEXT_DESC_PTR ((volatile void **)DMA3_NEXT_DESC_PTR)
+#define pDMA3_START_ADDR ((volatile void **)DMA3_START_ADDR)
+#define pDMA3_X_COUNT ((volatile unsigned short *)DMA3_X_COUNT)
+#define pDMA3_Y_COUNT ((volatile unsigned short *)DMA3_Y_COUNT)
+#define pDMA3_X_MODIFY ((volatile signed short *)DMA3_X_MODIFY)
+#define pDMA3_Y_MODIFY ((volatile signed short *)DMA3_Y_MODIFY)
+#define pDMA3_CURR_DESC_PTR ((volatile void **)DMA3_CURR_DESC_PTR)
+#define pDMA3_CURR_ADDR ((volatile void **)DMA3_CURR_ADDR)
+#define pDMA3_CURR_X_COUNT ((volatile unsigned short *)DMA3_CURR_X_COUNT)
+#define pDMA3_CURR_Y_COUNT ((volatile unsigned short *)DMA3_CURR_Y_COUNT)
+#define pDMA3_IRQ_STATUS ((volatile unsigned short *)DMA3_IRQ_STATUS)
+#define pDMA3_PERIPHERAL_MAP ((volatile unsigned short *)DMA3_PERIPHERAL_MAP)
+
+#define pDMA4_CONFIG ((volatile unsigned short *)DMA4_CONFIG)
+#define pDMA4_NEXT_DESC_PTR ((volatile void **)DMA4_NEXT_DESC_PTR)
+#define pDMA4_START_ADDR ((volatile void **)DMA4_START_ADDR)
+#define pDMA4_X_COUNT ((volatile unsigned short *)DMA4_X_COUNT)
+#define pDMA4_Y_COUNT ((volatile unsigned short *)DMA4_Y_COUNT)
+#define pDMA4_X_MODIFY ((volatile signed short *)DMA4_X_MODIFY)
+#define pDMA4_Y_MODIFY ((volatile signed short *)DMA4_Y_MODIFY)
+#define pDMA4_CURR_DESC_PTR ((volatile void **)DMA4_CURR_DESC_PTR)
+#define pDMA4_CURR_ADDR ((volatile void **)DMA4_CURR_ADDR)
+#define pDMA4_CURR_X_COUNT ((volatile unsigned short *)DMA4_CURR_X_COUNT)
+#define pDMA4_CURR_Y_COUNT ((volatile unsigned short *)DMA4_CURR_Y_COUNT)
+#define pDMA4_IRQ_STATUS ((volatile unsigned short *)DMA4_IRQ_STATUS)
+#define pDMA4_PERIPHERAL_MAP ((volatile unsigned short *)DMA4_PERIPHERAL_MAP)
+
+#define pDMA5_CONFIG ((volatile unsigned short *)DMA5_CONFIG)
+#define pDMA5_NEXT_DESC_PTR ((volatile void **)DMA5_NEXT_DESC_PTR)
+#define pDMA5_START_ADDR ((volatile void **)DMA5_START_ADDR)
+#define pDMA5_X_COUNT ((volatile unsigned short *)DMA5_X_COUNT)
+#define pDMA5_Y_COUNT ((volatile unsigned short *)DMA5_Y_COUNT)
+#define pDMA5_X_MODIFY ((volatile signed short *)DMA5_X_MODIFY)
+#define pDMA5_Y_MODIFY ((volatile signed short *)DMA5_Y_MODIFY)
+#define pDMA5_CURR_DESC_PTR ((volatile void **)DMA5_CURR_DESC_PTR)
+#define pDMA5_CURR_ADDR ((volatile void **)DMA5_CURR_ADDR)
+#define pDMA5_CURR_X_COUNT ((volatile unsigned short *)DMA5_CURR_X_COUNT)
+#define pDMA5_CURR_Y_COUNT ((volatile unsigned short *)DMA5_CURR_Y_COUNT)
+#define pDMA5_IRQ_STATUS ((volatile unsigned short *)DMA5_IRQ_STATUS)
+#define pDMA5_PERIPHERAL_MAP ((volatile unsigned short *)DMA5_PERIPHERAL_MAP)
+
+#define pDMA6_CONFIG ((volatile unsigned short *)DMA6_CONFIG)
+#define pDMA6_NEXT_DESC_PTR ((volatile void **)DMA6_NEXT_DESC_PTR)
+#define pDMA6_START_ADDR ((volatile void **)DMA6_START_ADDR)
+#define pDMA6_X_COUNT ((volatile unsigned short *)DMA6_X_COUNT)
+#define pDMA6_Y_COUNT ((volatile unsigned short *)DMA6_Y_COUNT)
+#define pDMA6_X_MODIFY ((volatile signed short *)DMA6_X_MODIFY)
+#define pDMA6_Y_MODIFY ((volatile signed short *)DMA6_Y_MODIFY)
+#define pDMA6_CURR_DESC_PTR ((volatile void **)DMA6_CURR_DESC_PTR)
+#define pDMA6_CURR_ADDR ((volatile void **)DMA6_CURR_ADDR)
+#define pDMA6_CURR_X_COUNT ((volatile unsigned short *)DMA6_CURR_X_COUNT)
+#define pDMA6_CURR_Y_COUNT ((volatile unsigned short *)DMA6_CURR_Y_COUNT)
+#define pDMA6_IRQ_STATUS ((volatile unsigned short *)DMA6_IRQ_STATUS)
+#define pDMA6_PERIPHERAL_MAP ((volatile unsigned short *)DMA6_PERIPHERAL_MAP)
+
+#define pDMA7_CONFIG ((volatile unsigned short *)DMA7_CONFIG)
+#define pDMA7_NEXT_DESC_PTR ((volatile void **)DMA7_NEXT_DESC_PTR)
+#define pDMA7_START_ADDR ((volatile void **)DMA7_START_ADDR)
+#define pDMA7_X_COUNT ((volatile unsigned short *)DMA7_X_COUNT)
+#define pDMA7_Y_COUNT ((volatile unsigned short *)DMA7_Y_COUNT)
+#define pDMA7_X_MODIFY ((volatile signed short *)DMA7_X_MODIFY)
+#define pDMA7_Y_MODIFY ((volatile signed short *)DMA7_Y_MODIFY)
+#define pDMA7_CURR_DESC_PTR ((volatile void **)DMA7_CURR_DESC_PTR)
+#define pDMA7_CURR_ADDR ((volatile void **)DMA7_CURR_ADDR)
+#define pDMA7_CURR_X_COUNT ((volatile unsigned short *)DMA7_CURR_X_COUNT)
+#define pDMA7_CURR_Y_COUNT ((volatile unsigned short *)DMA7_CURR_Y_COUNT)
+#define pDMA7_IRQ_STATUS ((volatile unsigned short *)DMA7_IRQ_STATUS)
+#define pDMA7_PERIPHERAL_MAP ((volatile unsigned short *)DMA7_PERIPHERAL_MAP)
+
+#define pMDMA_D1_CONFIG ((volatile unsigned short *)MDMA_D1_CONFIG)
+#define pMDMA_D1_NEXT_DESC_PTR ((volatile void **)MDMA_D1_NEXT_DESC_PTR)
+#define pMDMA_D1_START_ADDR ((volatile void **)MDMA_D1_START_ADDR)
+#define pMDMA_D1_X_COUNT ((volatile unsigned short *)MDMA_D1_X_COUNT)
+#define pMDMA_D1_Y_COUNT ((volatile unsigned short *)MDMA_D1_Y_COUNT)
+#define pMDMA_D1_X_MODIFY ((volatile signed short *)MDMA_D1_X_MODIFY)
+#define pMDMA_D1_Y_MODIFY ((volatile signed short *)MDMA_D1_Y_MODIFY)
+#define pMDMA_D1_CURR_DESC_PTR ((volatile void **)MDMA_D1_CURR_DESC_PTR)
+#define pMDMA_D1_CURR_ADDR ((volatile void **)MDMA_D1_CURR_ADDR)
+#define pMDMA_D1_CURR_X_COUNT ((volatile unsigned short *)MDMA_D1_CURR_X_COUNT)
+#define pMDMA_D1_CURR_Y_COUNT ((volatile unsigned short *)MDMA_D1_CURR_Y_COUNT)
+#define pMDMA_D1_IRQ_STATUS ((volatile unsigned short *)MDMA_D1_IRQ_STATUS)
+#define pMDMA_D1_PERIPHERAL_MAP ((volatile unsigned short *)MDMA_D1_PERIPHERAL_MAP)
+
+#define pMDMA_S1_CONFIG ((volatile unsigned short *)MDMA_S1_CONFIG)
+#define pMDMA_S1_NEXT_DESC_PTR ((volatile void **)MDMA_S1_NEXT_DESC_PTR)
+#define pMDMA_S1_START_ADDR ((volatile void **)MDMA_S1_START_ADDR)
+#define pMDMA_S1_X_COUNT ((volatile unsigned short *)MDMA_S1_X_COUNT)
+#define pMDMA_S1_Y_COUNT ((volatile unsigned short *)MDMA_S1_Y_COUNT)
+#define pMDMA_S1_X_MODIFY ((volatile signed short *)MDMA_S1_X_MODIFY)
+#define pMDMA_S1_Y_MODIFY ((volatile signed short *)MDMA_S1_Y_MODIFY)
+#define pMDMA_S1_CURR_DESC_PTR ((volatile void **)MDMA_S1_CURR_DESC_PTR)
+#define pMDMA_S1_CURR_ADDR ((volatile void **)MDMA_S1_CURR_ADDR)
+#define pMDMA_S1_CURR_X_COUNT ((volatile unsigned short *)MDMA_S1_CURR_X_COUNT)
+#define pMDMA_S1_CURR_Y_COUNT ((volatile unsigned short *)MDMA_S1_CURR_Y_COUNT)
+#define pMDMA_S1_IRQ_STATUS ((volatile unsigned short *)MDMA_S1_IRQ_STATUS)
+#define pMDMA_S1_PERIPHERAL_MAP ((volatile unsigned short *)MDMA_S1_PERIPHERAL_MAP)
+
+#define pMDMA_D0_CONFIG ((volatile unsigned short *)MDMA_D0_CONFIG)
+#define pMDMA_D0_NEXT_DESC_PTR ((volatile void **)MDMA_D0_NEXT_DESC_PTR)
+#define pMDMA_D0_START_ADDR ((volatile void **)MDMA_D0_START_ADDR)
+#define pMDMA_D0_X_COUNT ((volatile unsigned short *)MDMA_D0_X_COUNT)
+#define pMDMA_D0_Y_COUNT ((volatile unsigned short *)MDMA_D0_Y_COUNT)
+#define pMDMA_D0_X_MODIFY ((volatile signed short *)MDMA_D0_X_MODIFY)
+#define pMDMA_D0_Y_MODIFY ((volatile signed short *)MDMA_D0_Y_MODIFY)
+#define pMDMA_D0_CURR_DESC_PTR ((volatile void **)MDMA_D0_CURR_DESC_PTR)
+#define pMDMA_D0_CURR_ADDR ((volatile void **)MDMA_D0_CURR_ADDR)
+#define pMDMA_D0_CURR_X_COUNT ((volatile unsigned short *)MDMA_D0_CURR_X_COUNT)
+#define pMDMA_D0_CURR_Y_COUNT ((volatile unsigned short *)MDMA_D0_CURR_Y_COUNT)
+#define pMDMA_D0_IRQ_STATUS ((volatile unsigned short *)MDMA_D0_IRQ_STATUS)
+#define pMDMA_D0_PERIPHERAL_MAP ((volatile unsigned short *)MDMA_D0_PERIPHERAL_MAP)
+
+#define pMDMA_S0_CONFIG ((volatile unsigned short *)MDMA_S0_CONFIG)
+#define pMDMA_S0_NEXT_DESC_PTR ((volatile void **)MDMA_S0_NEXT_DESC_PTR)
+#define pMDMA_S0_START_ADDR ((volatile void **)MDMA_S0_START_ADDR)
+#define pMDMA_S0_X_COUNT ((volatile unsigned short *)MDMA_S0_X_COUNT)
+#define pMDMA_S0_Y_COUNT ((volatile unsigned short *)MDMA_S0_Y_COUNT)
+#define pMDMA_S0_X_MODIFY ((volatile signed short *)MDMA_S0_X_MODIFY)
+#define pMDMA_S0_Y_MODIFY ((volatile signed short *)MDMA_S0_Y_MODIFY)
+#define pMDMA_S0_CURR_DESC_PTR ((volatile void **)MDMA_S0_CURR_DESC_PTR)
+#define pMDMA_S0_CURR_ADDR ((volatile void **)MDMA_S0_CURR_ADDR)
+#define pMDMA_S0_CURR_X_COUNT ((volatile unsigned short *)MDMA_S0_CURR_X_COUNT)
+#define pMDMA_S0_CURR_Y_COUNT ((volatile unsigned short *)MDMA_S0_CURR_Y_COUNT)
+#define pMDMA_S0_IRQ_STATUS ((volatile unsigned short *)MDMA_S0_IRQ_STATUS)
+#define pMDMA_S0_PERIPHERAL_MAP ((volatile unsigned short *)MDMA_S0_PERIPHERAL_MAP)
+
+/* Aysnchronous Memory Controller - External Bus Interface Unit (0xFFC0 3C00-0xFFC0 3FFF) */
+#define pEBIU_AMGCTL ((volatile unsigned short *)EBIU_AMGCTL)
+#define pEBIU_AMBCTL0 ((volatile unsigned long *)EBIU_AMBCTL0)
+#define pEBIU_AMBCTL1 ((volatile unsigned long *)EBIU_AMBCTL1)
+
+/* SDRAM Controller External Bus Interface Unit (0xFFC0 4C00-0xFFC0 4FFF) */
+#define pEBIU_SDGCTL ((volatile unsigned long *)EBIU_SDGCTL)
+#define pEBIU_SDRRC ((volatile unsigned short *)EBIU_SDRRC)
+#define pEBIU_SDSTAT ((volatile unsigned short *)EBIU_SDSTAT)
+#define pEBIU_SDBCTL ((volatile unsigned short *)EBIU_SDBCTL)
+
+/* UART Controller */
+#define pUART_THR ((volatile unsigned short *)UART_THR)
+#define pUART_RBR ((volatile unsigned short *)UART_RBR)
+#define pUART_DLL ((volatile unsigned short *)UART_DLL)
+#define pUART_IER ((volatile unsigned short *)UART_IER)
+#define pUART_DLH ((volatile unsigned short *)UART_DLH)
+#define pUART_IIR ((volatile unsigned short *)UART_IIR)
+#define pUART_LCR ((volatile unsigned short *)UART_LCR)
+#define pUART_MCR ((volatile unsigned short *)UART_MCR)
+#define pUART_LSR ((volatile unsigned short *)UART_LSR)
+/*
+#define UART_MSR
+*/
+#define pUART_SCR ((volatile unsigned short *)UART_SCR)
+#define pUART_GCTL ((volatile unsigned short *)UART_GCTL)
+
+/* SPI Controller */
+#define pSPI_CTL ((volatile unsigned short *)SPI_CTL)
+#define pSPI_FLG ((volatile unsigned short *)SPI_FLG)
+#define pSPI_STAT ((volatile unsigned short *)SPI_STAT)
+#define pSPI_TDBR ((volatile unsigned short *)SPI_TDBR)
+#define pSPI_RDBR ((volatile unsigned short *)SPI_RDBR)
+#define pSPI_BAUD ((volatile unsigned short *)SPI_BAUD)
+#define pSPI_SHADOW ((volatile unsigned short *)SPI_SHADOW)
+
+/* TIMER 0, 1, 2 Registers */
+#define pTIMER0_CONFIG ((volatile unsigned short *)TIMER0_CONFIG)
+#define pTIMER0_COUNTER ((volatile unsigned long *)TIMER0_COUNTER)
+#define pTIMER0_PERIOD ((volatile unsigned long *)TIMER0_PERIOD)
+#define pTIMER0_WIDTH ((volatile unsigned long *)TIMER0_WIDTH)
+
+#define pTIMER1_CONFIG ((volatile unsigned short *)TIMER1_CONFIG)
+#define pTIMER1_COUNTER ((volatile unsigned long *)TIMER1_COUNTER)
+#define pTIMER1_PERIOD ((volatile unsigned long *)TIMER1_PERIOD)
+#define pTIMER1_WIDTH ((volatile unsigned long *)TIMER1_WIDTH)
+
+#define pTIMER2_CONFIG ((volatile unsigned short *)TIMER2_CONFIG)
+#define pTIMER2_COUNTER ((volatile unsigned long *)TIMER2_COUNTER)
+#define pTIMER2_PERIOD ((volatile unsigned long *)TIMER2_PERIOD)
+#define pTIMER2_WIDTH ((volatile unsigned long *)TIMER2_WIDTH)
+
+#define pTIMER_ENABLE ((volatile unsigned short *)TIMER_ENABLE)
+#define pTIMER_DISABLE ((volatile unsigned short *)TIMER_DISABLE)
+#define pTIMER_STATUS ((volatile unsigned short *)TIMER_STATUS)
+
+/* SPORT0 Controller */
+#define pSPORT0_TCR1 ((volatile unsigned short *)SPORT0_TCR1)
+#define pSPORT0_TCR2 ((volatile unsigned short *)SPORT0_TCR2)
+#define pSPORT0_TCLKDIV ((volatile unsigned short *)SPORT0_TCLKDIV)
+#define pSPORT0_TFSDIV ((volatile unsigned short *)SPORT0_TFSDIV)
+#define pSPORT0_TX ((volatile long *)SPORT0_TX)
+#define pSPORT0_RX ((volatile long *)SPORT0_RX)
+#define pSPORT0_TX32 ((volatile long *)SPORT0_TX)
+#define pSPORT0_RX32 ((volatile long *)SPORT0_RX)
+#define pSPORT0_TX16 ((volatile unsigned short *)SPORT0_TX)
+#define pSPORT0_RX16 ((volatile unsigned short *)SPORT0_RX)
+#define pSPORT0_RCR1 ((volatile unsigned short *)SPORT0_RCR1)
+#define pSPORT0_RCR2 ((volatile unsigned short *)SPORT0_RCR2)
+#define pSPORT0_RCLKDIV ((volatile unsigned short *)SPORT0_RCLKDIV)
+#define pSPORT0_RFSDIV ((volatile unsigned short *)SPORT0_RFSDIV)
+#define pSPORT0_STAT ((volatile unsigned short *)SPORT0_STAT)
+#define pSPORT0_CHNL ((volatile unsigned short *)SPORT0_CHNL)
+#define pSPORT0_MCMC1 ((volatile unsigned short *)SPORT0_MCMC1)
+#define pSPORT0_MCMC2 ((volatile unsigned short *)SPORT0_MCMC2)
+#define pSPORT0_MTCS0 ((volatile unsigned long *)SPORT0_MTCS0)
+#define pSPORT0_MTCS1 ((volatile unsigned long *)SPORT0_MTCS1)
+#define pSPORT0_MTCS2 ((volatile unsigned long *)SPORT0_MTCS2)
+#define pSPORT0_MTCS3 ((volatile unsigned long *)SPORT0_MTCS3)
+#define pSPORT0_MRCS0 ((volatile unsigned long *)SPORT0_MRCS0)
+#define pSPORT0_MRCS1 ((volatile unsigned long *)SPORT0_MRCS1)
+#define pSPORT0_MRCS2 ((volatile unsigned long *)SPORT0_MRCS2)
+#define pSPORT0_MRCS3 ((volatile unsigned long *)SPORT0_MRCS3)
+
+/* SPORT1 Controller */
+#define pSPORT1_TCR1 ((volatile unsigned short *)SPORT1_TCR1)
+#define pSPORT1_TCR2 ((volatile unsigned short *)SPORT1_TCR2)
+#define pSPORT1_TCLKDIV ((volatile unsigned short *)SPORT1_TCLKDIV)
+#define pSPORT1_TFSDIV ((volatile unsigned short *)SPORT1_TFSDIV)
+#define pSPORT1_TX ((volatile long *)SPORT1_TX)
+#define pSPORT1_RX ((volatile long *)SPORT1_RX)
+#define pSPORT1_TX32 ((volatile long *)SPORT1_TX)
+#define pSPORT1_RX32 ((volatile long *)SPORT1_RX)
+#define pSPORT1_TX16 ((volatile unsigned short *)SPORT1_TX)
+#define pSPORT1_RX16 ((volatile unsigned short *)SPORT1_RX)
+#define pSPORT1_RCR1 ((volatile unsigned short *)SPORT1_RCR1)
+#define pSPORT1_RCR2 ((volatile unsigned short *)SPORT1_RCR2)
+#define pSPORT1_RCLKDIV ((volatile unsigned short *)SPORT1_RCLKDIV)
+#define pSPORT1_RFSDIV ((volatile unsigned short *)SPORT1_RFSDIV)
+#define pSPORT1_STAT ((volatile unsigned short *)SPORT1_STAT)
+#define pSPORT1_CHNL ((volatile unsigned short *)SPORT1_CHNL)
+#define pSPORT1_MCMC1 ((volatile unsigned short *)SPORT1_MCMC1)
+#define pSPORT1_MCMC2 ((volatile unsigned short *)SPORT1_MCMC2)
+#define pSPORT1_MTCS0 ((volatile unsigned long *)SPORT1_MTCS0)
+#define pSPORT1_MTCS1 ((volatile unsigned long *)SPORT1_MTCS1)
+#define pSPORT1_MTCS2 ((volatile unsigned long *)SPORT1_MTCS2)
+#define pSPORT1_MTCS3 ((volatile unsigned long *)SPORT1_MTCS3)
+#define pSPORT1_MRCS0 ((volatile unsigned long *)SPORT1_MRCS0)
+#define pSPORT1_MRCS1 ((volatile unsigned long *)SPORT1_MRCS1)
+#define pSPORT1_MRCS2 ((volatile unsigned long *)SPORT1_MRCS2)
+#define pSPORT1_MRCS3 ((volatile unsigned long *)SPORT1_MRCS3)
+
+/* Parallel Peripheral Interface (PPI) */
+#define pPPI_CONTROL ((volatile unsigned short *)PPI_CONTROL)
+#define pPPI_STATUS ((volatile unsigned short *)PPI_STATUS)
+#define pPPI_DELAY ((volatile unsigned short *)PPI_DELAY)
+#define pPPI_COUNT ((volatile unsigned short *)PPI_COUNT)
+#define pPPI_FRAME ((volatile unsigned short *)PPI_FRAME)
+
+#endif				/* _CDEF_BF532_H */
Index: git/linux-2.6/include/asm-blackfin/mach-bf533/defBF532.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf533/defBF532.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,1170 @@
+/************************************************************************
+ *
+ * $Id$
+ *
+ * This file is subject to the terms and conditions of the GNU Public
+ * License. See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Non-GPL License also available as part of VisualDSP++
+ * http://www.analog.com/processors/resources/crosscore/visualDspDevSoftware.html
+ *
+ * (c) Copyright 2001-2005 Analog Devices, Inc. All rights reserved
+ *
+ * This file under source code control, please send bugs or changes to:
+ * dsptools.support@analog.com
+ *
+ ************************************************************************/
+/*
+ * File:         include/asm-blackfin/mach-bf533/defBF532.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+/* SYSTEM & MM REGISTER BIT & ADDRESS DEFINITIONS FOR ADSP-BF532 */
+
+#ifndef _DEF_BF532_H
+#define _DEF_BF532_H
+/*
+#if !defined(__ADSPLPBLACKFIN__)
+#warning defBF532.h should only be included for 532 compatible chips
+#endif
+*/
+/* include all Core registers and bit definitions */
+#include <asm/mach-common/def_LPBlackfin.h>
+
+/*********************************************************************************** */
+/* System MMR Register Map */
+/*********************************************************************************** */
+/*// Clock and System Control (0xFFC00000 - 0xFFC000FF) */
+
+#define PLL_CTL                0xFFC00000       /* PLL Control register (16-bit) */
+#define PLL_DIV			 0xFFC00004		/* PLL Divide Register (16-bit) */
+#define VR_CTL			 0xFFC00008		/* Voltage Regulator Control Register (16-bit) */
+#define PLL_STAT               0xFFC0000C       /* PLL Status register (16-bit) */
+#define PLL_LOCKCNT            0xFFC00010   	/* PLL Lock Count register (16-bit) */
+#define SWRST                  0xFFC00100       /* Software Reset Register (16-bit) */
+#define SYSCR                  0xFFC00104       /* System Configuration registe */
+
+/* System Interrupt Controller (0xFFC00100 - 0xFFC001FF) */
+#define SIC_RVECT             		0xFFC00108  /* Interrupt Reset Vector Address Register */
+#define SIC_IMASK             		0xFFC0010C  /* Interrupt Mask Register */
+#define SIC_IAR0               		0xFFC00110  /* Interrupt Assignment Register 0 */
+#define SIC_IAR1               		0xFFC00114  /* Interrupt Assignment Register 1 */
+#define SIC_IAR2              		0xFFC00118  /* Interrupt Assignment Register 2 */
+#define SIC_ISR                		0xFFC00120  /* Interrupt Status Register */
+#define SIC_IWR                		0xFFC00124  /* Interrupt Wakeup Register */
+
+/*// Watchdog Timer (0xFFC00200 - 0xFFC002FF) */
+#define WDOG_CTL                	0xFFC00200  /* Watchdog Control Register */
+#define WDOG_CNT                	0xFFC00204  /* Watchdog Count Register */
+#define WDOG_STAT               	0xFFC00208  /* Watchdog Status Register */
+
+/*// Real Time Clock (0xFFC00300 - 0xFFC003FF) */
+#define RTC_STAT                	0xFFC00300  /* RTC Status Register */
+#define RTC_ICTL                	0xFFC00304  /* RTC Interrupt Control Register */
+#define RTC_ISTAT               	0xFFC00308  /* RTC Interrupt Status Register */
+#define RTC_SWCNT               	0xFFC0030C  /* RTC Stopwatch Count Register */
+#define RTC_ALARM               	0xFFC00310  /* RTC Alarm Time Register */
+#define RTC_FAST                	0xFFC00314  /* RTC Prescaler Enable Register */
+#define RTC_PREN			0xFFC00314  /* RTC Prescaler Enable Register (alternate macro) */
+
+/* UART Controller (0xFFC00400 - 0xFFC004FF) */
+#define UART_THR             		 0xFFC00400  /* Transmit Holding register */
+#define UART_RBR             		 0xFFC00400  /* Receive Buffer register */
+#define UART_DLL              		 0xFFC00400  /* Divisor Latch (Low-Byte) */
+#define UART_IER              		 0xFFC00404  /* Interrupt Enable Register */
+#define UART_DLH              		 0xFFC00404  /* Divisor Latch (High-Byte) */
+#define UART_IIR              		 0xFFC00408  /* Interrupt Identification Register */
+#define UART_LCR              		 0xFFC0040C  /* Line Control Register */
+#define UART_MCR			 0xFFC00410  /* Modem Control Register */
+#define UART_LSR              		 0xFFC00414  /* Line Status Register */
+/*#define UART_MSR            		 0xFFC00418  // Modem Status Register //(UNUSED in ADSP-BF532) */
+#define UART_SCR              		 0xFFC0041C  /* SCR Scratch Register */
+#define UART_GCTL      	      		 0xFFC00424  /* Global Control Register */
+
+/* SPI Controller (0xFFC00500 - 0xFFC005FF) */
+#define SPI_CTL               		0xFFC00500  /* SPI Control Register */
+#define SPI_FLG               		0xFFC00504  /* SPI Flag register */
+#define SPI_STAT              		0xFFC00508  /* SPI Status register */
+#define SPI_TDBR              		0xFFC0050C  /* SPI Transmit Data Buffer Register */
+#define SPI_RDBR              		0xFFC00510  /* SPI Receive Data Buffer Register */
+#define SPI_BAUD              		0xFFC00514  /* SPI Baud rate Register */
+#define SPI_SHADOW            		0xFFC00518  /* SPI_RDBR Shadow Register */
+
+/* TIMER 0, 1, 2 Registers (0xFFC00600 - 0xFFC006FF) */
+
+#define TIMER0_CONFIG          		0xFFC00600     /* Timer 0 Configuration Register */
+#define TIMER0_COUNTER			0xFFC00604     /* Timer 0 Counter Register */
+#define TIMER0_PERIOD       		0xFFC00608     /* Timer 0 Period Register */
+#define TIMER0_WIDTH        		0xFFC0060C     /* Timer 0 Width Register */
+
+#define TIMER1_CONFIG          		0xFFC00610  	/*  Timer 1 Configuration Register   */
+#define TIMER1_COUNTER         		0xFFC00614   	/*  Timer 1 Counter Register         */
+#define TIMER1_PERIOD          		0xFFC00618      /*  Timer 1 Period Register          */
+#define TIMER1_WIDTH           		0xFFC0061C      /*  Timer 1 Width Register           */
+
+#define TIMER2_CONFIG          		0xFFC00620  	/* Timer 2 Configuration Register   */
+#define TIMER2_COUNTER         		0xFFC00624      /* Timer 2 Counter Register         */
+#define TIMER2_PERIOD          		0xFFC00628      /* Timer 2 Period Register          */
+#define TIMER2_WIDTH           		0xFFC0062C      /* Timer 2 Width Register           */
+
+#define TIMER_ENABLE			0xFFC00640   	/* Timer Enable Register */
+#define TIMER_DISABLE			0xFFC00644   	/* Timer Disable Register */
+#define TIMER_STATUS			0xFFC00648   	/* Timer Status Register */
+
+/*// General Purpose IO (0xFFC00700 - 0xFFC007FF) */
+
+#define FIO_FLAG_D	       		0xFFC00700  /* Flag Mask to directly specify state of pins */
+#define FIO_FLAG_C             		0xFFC00704  /* Peripheral Interrupt Flag Register (clear) */
+#define FIO_FLAG_S             		0xFFC00708  /* Peripheral Interrupt Flag Register (set) */
+#define FIO_FLAG_T			0xFFC0070C  /* Flag Mask to directly toggle state of pins */
+#define FIO_MASKA_D            		0xFFC00710  /* Flag Mask Interrupt A Register (set directly) */
+#define FIO_MASKA_C            		0xFFC00714  /* Flag Mask Interrupt A Register (clear) */
+#define FIO_MASKA_S            		0xFFC00718  /* Flag Mask Interrupt A Register (set) */
+#define FIO_MASKA_T            		0xFFC0071C  /* Flag Mask Interrupt A Register (toggle) */
+#define FIO_MASKB_D            		0xFFC00720  /* Flag Mask Interrupt B Register (set directly) */
+#define FIO_MASKB_C            		0xFFC00724  /* Flag Mask Interrupt B Register (clear) */
+#define FIO_MASKB_S            		0xFFC00728  /* Flag Mask Interrupt B Register (set) */
+#define FIO_MASKB_T            		0xFFC0072C  /* Flag Mask Interrupt B Register (toggle) */
+#define FIO_DIR                		0xFFC00730  /* Peripheral Flag Direction Register */
+#define FIO_POLAR              		0xFFC00734  /* Flag Source Polarity Register */
+#define FIO_EDGE               		0xFFC00738  /* Flag Source Sensitivity Register */
+#define FIO_BOTH               		0xFFC0073C  /* Flag Set on BOTH Edges Register */
+#define FIO_INEN					0xFFC00740  /* Flag Input Enable Register  */
+
+/*// SPORT0 Controller (0xFFC00800 - 0xFFC008FF) */
+#define SPORT0_TCR1     	 	0xFFC00800  /* SPORT0 Transmit Configuration 1 Register */
+#define SPORT0_TCR2      	 	0xFFC00804  /* SPORT0 Transmit Configuration 2 Register */
+#define SPORT0_TCLKDIV        		0xFFC00808  /* SPORT0 Transmit Clock Divider */
+#define SPORT0_TFSDIV          		0xFFC0080C  /* SPORT0 Transmit Frame Sync Divider */
+#define SPORT0_TX	             	0xFFC00810  /* SPORT0 TX Data Register */
+#define SPORT0_RX	            	0xFFC00818  /* SPORT0 RX Data Register */
+#define SPORT0_RCR1      	 	0xFFC00820  /* SPORT0 Transmit Configuration 1 Register */
+#define SPORT0_RCR2      	 	0xFFC00824  /* SPORT0 Transmit Configuration 2 Register */
+#define SPORT0_RCLKDIV        		0xFFC00828  /* SPORT0 Receive Clock Divider */
+#define SPORT0_RFSDIV          		0xFFC0082C  /* SPORT0 Receive Frame Sync Divider */
+#define SPORT0_STAT            		0xFFC00830  /* SPORT0 Status Register */
+#define SPORT0_CHNL            		0xFFC00834  /* SPORT0 Current Channel Register */
+#define SPORT0_MCMC1           		0xFFC00838  /* SPORT0 Multi-Channel Configuration Register 1 */
+#define SPORT0_MCMC2           		0xFFC0083C  /* SPORT0 Multi-Channel Configuration Register 2 */
+#define SPORT0_MTCS0           		0xFFC00840  /* SPORT0 Multi-Channel Transmit Select Register 0 */
+#define SPORT0_MTCS1           		0xFFC00844  /* SPORT0 Multi-Channel Transmit Select Register 1 */
+#define SPORT0_MTCS2           		0xFFC00848  /* SPORT0 Multi-Channel Transmit Select Register 2 */
+#define SPORT0_MTCS3           		0xFFC0084C  /* SPORT0 Multi-Channel Transmit Select Register 3 */
+#define SPORT0_MRCS0           		0xFFC00850  /* SPORT0 Multi-Channel Receive Select Register 0 */
+#define SPORT0_MRCS1           		0xFFC00854  /* SPORT0 Multi-Channel Receive Select Register 1 */
+#define SPORT0_MRCS2           		0xFFC00858  /* SPORT0 Multi-Channel Receive Select Register 2 */
+#define SPORT0_MRCS3           		0xFFC0085C  /* SPORT0 Multi-Channel Receive Select Register 3 */
+
+/*// SPORT1 Controller (0xFFC00900 - 0xFFC009FF) */
+#define SPORT1_TCR1     	 	0xFFC00900  /* SPORT1 Transmit Configuration 1 Register */
+#define SPORT1_TCR2      	 	0xFFC00904  /* SPORT1 Transmit Configuration 2 Register */
+#define SPORT1_TCLKDIV        		0xFFC00908  /* SPORT1 Transmit Clock Divider */
+#define SPORT1_TFSDIV          		0xFFC0090C  /* SPORT1 Transmit Frame Sync Divider */
+#define SPORT1_TX	             	0xFFC00910  /* SPORT1 TX Data Register */
+#define SPORT1_RX	            	0xFFC00918  /* SPORT1 RX Data Register */
+#define SPORT1_RCR1      	 	0xFFC00920  /* SPORT1 Transmit Configuration 1 Register */
+#define SPORT1_RCR2      	 	0xFFC00924  /* SPORT1 Transmit Configuration 2 Register */
+#define SPORT1_RCLKDIV        		0xFFC00928  /* SPORT1 Receive Clock Divider */
+#define SPORT1_RFSDIV          		0xFFC0092C  /* SPORT1 Receive Frame Sync Divider */
+#define SPORT1_STAT            		0xFFC00930  /* SPORT1 Status Register */
+#define SPORT1_CHNL            		0xFFC00934  /* SPORT1 Current Channel Register */
+#define SPORT1_MCMC1           		0xFFC00938  /* SPORT1 Multi-Channel Configuration Register 1 */
+#define SPORT1_MCMC2           		0xFFC0093C  /* SPORT1 Multi-Channel Configuration Register 2 */
+#define SPORT1_MTCS0           		0xFFC00940  /* SPORT1 Multi-Channel Transmit Select Register 0 */
+#define SPORT1_MTCS1           		0xFFC00944  /* SPORT1 Multi-Channel Transmit Select Register 1 */
+#define SPORT1_MTCS2           		0xFFC00948  /* SPORT1 Multi-Channel Transmit Select Register 2 */
+#define SPORT1_MTCS3           		0xFFC0094C  /* SPORT1 Multi-Channel Transmit Select Register 3 */
+#define SPORT1_MRCS0           		0xFFC00950  /* SPORT1 Multi-Channel Receive Select Register 0 */
+#define SPORT1_MRCS1           		0xFFC00954  /* SPORT1 Multi-Channel Receive Select Register 1 */
+#define SPORT1_MRCS2           		0xFFC00958  /* SPORT1 Multi-Channel Receive Select Register 2 */
+#define SPORT1_MRCS3           		0xFFC0095C  /* SPORT1 Multi-Channel Receive Select Register 3 */
+
+/* Asynchronous Memory Controller - External Bus Interface Unit  */
+#define EBIU_AMGCTL			0xFFC00A00  /* Asynchronous Memory Global Control Register */
+#define EBIU_AMBCTL0			0xFFC00A04  /* Asynchronous Memory Bank Control Register 0 */
+#define EBIU_AMBCTL1			0xFFC00A08  /* Asynchronous Memory Bank Control Register 1 */
+
+/* SDRAM Controller External Bus Interface Unit (0xFFC00A00 - 0xFFC00AFF) */
+
+#define EBIU_SDGCTL			0xFFC00A10  /* SDRAM Global Control Register */
+#define EBIU_SDBCTL			0xFFC00A14  /* SDRAM Bank Control Register */
+#define EBIU_SDRRC 			0xFFC00A18  /* SDRAM Refresh Rate Control Register */
+#define EBIU_SDSTAT			0xFFC00A1C  /* SDRAM Status Register */
+
+/* DMA Traffic controls */
+#define DMA_TCPER 0xFFC00B0C	/* Traffic Control Periods Register */
+#define DMA_TCCNT 0xFFC00B10	/* Traffic Control Current Counts Register */
+#define DMA_TC_PER 0xFFC00B0C	/* Traffic Control Periods Register */
+#define DMA_TC_CNT 0xFFC00B10	/* Traffic Control Current Counts Register */
+
+/* DMA Controller (0xFFC00C00 - 0xFFC00FFF) */
+#define DMA0_CONFIG		0xFFC00C08	/* DMA Channel 0 Configuration Register */
+#define DMA0_NEXT_DESC_PTR	0xFFC00C00	/* DMA Channel 0 Next Descriptor Pointer Register */
+#define DMA0_START_ADDR		0xFFC00C04	/* DMA Channel 0 Start Address Register */
+#define DMA0_X_COUNT		0xFFC00C10	/* DMA Channel 0 X Count Register */
+#define DMA0_Y_COUNT		0xFFC00C18	/* DMA Channel 0 Y Count Register */
+#define DMA0_X_MODIFY		0xFFC00C14	/* DMA Channel 0 X Modify Register */
+#define DMA0_Y_MODIFY		0xFFC00C1C	/* DMA Channel 0 Y Modify Register */
+#define DMA0_CURR_DESC_PTR	0xFFC00C20	/* DMA Channel 0 Current Descriptor Pointer Register */
+#define DMA0_CURR_ADDR		0xFFC00C24	/* DMA Channel 0 Current Address Register */
+#define DMA0_CURR_X_COUNT	0xFFC00C30	/* DMA Channel 0 Current X Count Register */
+#define DMA0_CURR_Y_COUNT	0xFFC00C38	/* DMA Channel 0 Current Y Count Register */
+#define DMA0_IRQ_STATUS		0xFFC00C28	/* DMA Channel 0 Interrupt/Status Register */
+#define DMA0_PERIPHERAL_MAP	0xFFC00C2C	/* DMA Channel 0 Peripheral Map Register */
+
+#define DMA1_CONFIG		0xFFC00C48	/* DMA Channel 1 Configuration Register */
+#define DMA1_NEXT_DESC_PTR	0xFFC00C40	/* DMA Channel 1 Next Descriptor Pointer Register */
+#define DMA1_START_ADDR		0xFFC00C44	/* DMA Channel 1 Start Address Register */
+#define DMA1_X_COUNT		0xFFC00C50	/* DMA Channel 1 X Count Register */
+#define DMA1_Y_COUNT		0xFFC00C58	/* DMA Channel 1 Y Count Register */
+#define DMA1_X_MODIFY		0xFFC00C54	/* DMA Channel 1 X Modify Register */
+#define DMA1_Y_MODIFY		0xFFC00C5C	/* DMA Channel 1 Y Modify Register */
+#define DMA1_CURR_DESC_PTR	0xFFC00C60	/* DMA Channel 1 Current Descriptor Pointer Register */
+#define DMA1_CURR_ADDR		0xFFC00C64	/* DMA Channel 1 Current Address Register */
+#define DMA1_CURR_X_COUNT	0xFFC00C70	/* DMA Channel 1 Current X Count Register */
+#define DMA1_CURR_Y_COUNT	0xFFC00C78	/* DMA Channel 1 Current Y Count Register */
+#define DMA1_IRQ_STATUS		0xFFC00C68	/* DMA Channel 1 Interrupt/Status Register */
+#define DMA1_PERIPHERAL_MAP	0xFFC00C6C	/* DMA Channel 1 Peripheral Map Register */
+
+#define DMA2_CONFIG		0xFFC00C88	/* DMA Channel 2 Configuration Register */
+#define DMA2_NEXT_DESC_PTR	0xFFC00C80	/* DMA Channel 2 Next Descriptor Pointer Register */
+#define DMA2_START_ADDR		0xFFC00C84	/* DMA Channel 2 Start Address Register */
+#define DMA2_X_COUNT		0xFFC00C90	/* DMA Channel 2 X Count Register */
+#define DMA2_Y_COUNT		0xFFC00C98	/* DMA Channel 2 Y Count Register */
+#define DMA2_X_MODIFY		0xFFC00C94	/* DMA Channel 2 X Modify Register */
+#define DMA2_Y_MODIFY		0xFFC00C9C	/* DMA Channel 2 Y Modify Register */
+#define DMA2_CURR_DESC_PTR	0xFFC00CA0	/* DMA Channel 2 Current Descriptor Pointer Register */
+#define DMA2_CURR_ADDR		0xFFC00CA4	/* DMA Channel 2 Current Address Register */
+#define DMA2_CURR_X_COUNT	0xFFC00CB0	/* DMA Channel 2 Current X Count Register */
+#define DMA2_CURR_Y_COUNT	0xFFC00CB8	/* DMA Channel 2 Current Y Count Register */
+#define DMA2_IRQ_STATUS		0xFFC00CA8	/* DMA Channel 2 Interrupt/Status Register */
+#define DMA2_PERIPHERAL_MAP	0xFFC00CAC	/* DMA Channel 2 Peripheral Map Register */
+
+#define DMA3_CONFIG		0xFFC00CC8	/* DMA Channel 3 Configuration Register */
+#define DMA3_NEXT_DESC_PTR	0xFFC00CC0	/* DMA Channel 3 Next Descriptor Pointer Register */
+#define DMA3_START_ADDR		0xFFC00CC4	/* DMA Channel 3 Start Address Register */
+#define DMA3_X_COUNT		0xFFC00CD0	/* DMA Channel 3 X Count Register */
+#define DMA3_Y_COUNT		0xFFC00CD8	/* DMA Channel 3 Y Count Register */
+#define DMA3_X_MODIFY		0xFFC00CD4	/* DMA Channel 3 X Modify Register */
+#define DMA3_Y_MODIFY		0xFFC00CDC	/* DMA Channel 3 Y Modify Register */
+#define DMA3_CURR_DESC_PTR	0xFFC00CE0	/* DMA Channel 3 Current Descriptor Pointer Register */
+#define DMA3_CURR_ADDR		0xFFC00CE4	/* DMA Channel 3 Current Address Register */
+#define DMA3_CURR_X_COUNT	0xFFC00CF0	/* DMA Channel 3 Current X Count Register */
+#define DMA3_CURR_Y_COUNT	0xFFC00CF8	/* DMA Channel 3 Current Y Count Register */
+#define DMA3_IRQ_STATUS		0xFFC00CE8	/* DMA Channel 3 Interrupt/Status Register */
+#define DMA3_PERIPHERAL_MAP	0xFFC00CEC	/* DMA Channel 3 Peripheral Map Register */
+
+#define DMA4_CONFIG		0xFFC00D08	/* DMA Channel 4 Configuration Register */
+#define DMA4_NEXT_DESC_PTR	0xFFC00D00	/* DMA Channel 4 Next Descriptor Pointer Register */
+#define DMA4_START_ADDR		0xFFC00D04	/* DMA Channel 4 Start Address Register */
+#define DMA4_X_COUNT		0xFFC00D10	/* DMA Channel 4 X Count Register */
+#define DMA4_Y_COUNT		0xFFC00D18	/* DMA Channel 4 Y Count Register */
+#define DMA4_X_MODIFY		0xFFC00D14	/* DMA Channel 4 X Modify Register */
+#define DMA4_Y_MODIFY		0xFFC00D1C	/* DMA Channel 4 Y Modify Register */
+#define DMA4_CURR_DESC_PTR	0xFFC00D20	/* DMA Channel 4 Current Descriptor Pointer Register */
+#define DMA4_CURR_ADDR		0xFFC00D24	/* DMA Channel 4 Current Address Register */
+#define DMA4_CURR_X_COUNT	0xFFC00D30	/* DMA Channel 4 Current X Count Register */
+#define DMA4_CURR_Y_COUNT	0xFFC00D38	/* DMA Channel 4 Current Y Count Register */
+#define DMA4_IRQ_STATUS		0xFFC00D28	/* DMA Channel 4 Interrupt/Status Register */
+#define DMA4_PERIPHERAL_MAP	0xFFC00D2C	/* DMA Channel 4 Peripheral Map Register */
+
+#define DMA5_CONFIG		0xFFC00D48	/* DMA Channel 5 Configuration Register */
+#define DMA5_NEXT_DESC_PTR	0xFFC00D40	/* DMA Channel 5 Next Descriptor Pointer Register */
+#define DMA5_START_ADDR		0xFFC00D44	/* DMA Channel 5 Start Address Register */
+#define DMA5_X_COUNT		0xFFC00D50	/* DMA Channel 5 X Count Register */
+#define DMA5_Y_COUNT		0xFFC00D58	/* DMA Channel 5 Y Count Register */
+#define DMA5_X_MODIFY		0xFFC00D54	/* DMA Channel 5 X Modify Register */
+#define DMA5_Y_MODIFY		0xFFC00D5C	/* DMA Channel 5 Y Modify Register */
+#define DMA5_CURR_DESC_PTR	0xFFC00D60	/* DMA Channel 5 Current Descriptor Pointer Register */
+#define DMA5_CURR_ADDR		0xFFC00D64	/* DMA Channel 5 Current Address Register */
+#define DMA5_CURR_X_COUNT	0xFFC00D70	/* DMA Channel 5 Current X Count Register */
+#define DMA5_CURR_Y_COUNT	0xFFC00D78	/* DMA Channel 5 Current Y Count Register */
+#define DMA5_IRQ_STATUS		0xFFC00D68	/* DMA Channel 5 Interrupt/Status Register */
+#define DMA5_PERIPHERAL_MAP	0xFFC00D6C	/* DMA Channel 5 Peripheral Map Register */
+
+#define DMA6_CONFIG		0xFFC00D88	/* DMA Channel 6 Configuration Register */
+#define DMA6_NEXT_DESC_PTR	0xFFC00D80	/* DMA Channel 6 Next Descriptor Pointer Register */
+#define DMA6_START_ADDR		0xFFC00D84	/* DMA Channel 6 Start Address Register */
+#define DMA6_X_COUNT		0xFFC00D90	/* DMA Channel 6 X Count Register */
+#define DMA6_Y_COUNT		0xFFC00D98	/* DMA Channel 6 Y Count Register */
+#define DMA6_X_MODIFY		0xFFC00D94	/* DMA Channel 6 X Modify Register */
+#define DMA6_Y_MODIFY		0xFFC00D9C	/* DMA Channel 6 Y Modify Register */
+#define DMA6_CURR_DESC_PTR	0xFFC00DA0	/* DMA Channel 6 Current Descriptor Pointer Register */
+#define DMA6_CURR_ADDR		0xFFC00DA4	/* DMA Channel 6 Current Address Register */
+#define DMA6_CURR_X_COUNT	0xFFC00DB0	/* DMA Channel 6 Current X Count Register */
+#define DMA6_CURR_Y_COUNT	0xFFC00DB8	/* DMA Channel 6 Current Y Count Register */
+#define DMA6_IRQ_STATUS		0xFFC00DA8	/* DMA Channel 6 Interrupt/Status Register */
+#define DMA6_PERIPHERAL_MAP	0xFFC00DAC	/* DMA Channel 6 Peripheral Map Register */
+
+#define DMA7_CONFIG		0xFFC00DC8	/* DMA Channel 7 Configuration Register */
+#define DMA7_NEXT_DESC_PTR	0xFFC00DC0	/* DMA Channel 7 Next Descriptor Pointer Register */
+#define DMA7_START_ADDR		0xFFC00DC4	/* DMA Channel 7 Start Address Register */
+#define DMA7_X_COUNT		0xFFC00DD0	/* DMA Channel 7 X Count Register */
+#define DMA7_Y_COUNT		0xFFC00DD8	/* DMA Channel 7 Y Count Register */
+#define DMA7_X_MODIFY		0xFFC00DD4	/* DMA Channel 7 X Modify Register */
+#define DMA7_Y_MODIFY		0xFFC00DDC	/* DMA Channel 7 Y Modify Register */
+#define DMA7_CURR_DESC_PTR	0xFFC00DE0	/* DMA Channel 7 Current Descriptor Pointer Register */
+#define DMA7_CURR_ADDR		0xFFC00DE4	/* DMA Channel 7 Current Address Register */
+#define DMA7_CURR_X_COUNT	0xFFC00DF0	/* DMA Channel 7 Current X Count Register */
+#define DMA7_CURR_Y_COUNT	0xFFC00DF8	/* DMA Channel 7 Current Y Count Register */
+#define DMA7_IRQ_STATUS		0xFFC00DE8	/* DMA Channel 7 Interrupt/Status Register */
+#define DMA7_PERIPHERAL_MAP	0xFFC00DEC	/* DMA Channel 7 Peripheral Map Register */
+
+#define MDMA_D1_CONFIG		0xFFC00E88	/* MemDMA Stream 1 Destination Configuration Register */
+#define MDMA_D1_NEXT_DESC_PTR	0xFFC00E80	/* MemDMA Stream 1 Destination Next Descriptor Pointer Register */
+#define MDMA_D1_START_ADDR	0xFFC00E84	/* MemDMA Stream 1 Destination Start Address Register */
+#define MDMA_D1_X_COUNT		0xFFC00E90	/* MemDMA Stream 1 Destination X Count Register */
+#define MDMA_D1_Y_COUNT		0xFFC00E98	/* MemDMA Stream 1 Destination Y Count Register */
+#define MDMA_D1_X_MODIFY	0xFFC00E94	/* MemDMA Stream 1 Destination X Modify Register */
+#define MDMA_D1_Y_MODIFY	0xFFC00E9C	/* MemDMA Stream 1 Destination Y Modify Register */
+#define MDMA_D1_CURR_DESC_PTR	0xFFC00EA0	/* MemDMA Stream 1 Destination Current Descriptor Pointer Register */
+#define MDMA_D1_CURR_ADDR	0xFFC00EA4	/* MemDMA Stream 1 Destination Current Address Register */
+#define MDMA_D1_CURR_X_COUNT	0xFFC00EB0	/* MemDMA Stream 1 Destination Current X Count Register */
+#define MDMA_D1_CURR_Y_COUNT	0xFFC00EB8	/* MemDMA Stream 1 Destination Current Y Count Register */
+#define MDMA_D1_IRQ_STATUS	0xFFC00EA8	/* MemDMA Stream 1 Destination Interrupt/Status Register */
+#define MDMA_D1_PERIPHERAL_MAP	0xFFC00EAC	/* MemDMA Stream 1 Destination Peripheral Map Register */
+
+#define MDMA_S1_CONFIG		0xFFC00EC8	/* MemDMA Stream 1 Source Configuration Register */
+#define MDMA_S1_NEXT_DESC_PTR	0xFFC00EC0	/* MemDMA Stream 1 Source Next Descriptor Pointer Register */
+#define MDMA_S1_START_ADDR	0xFFC00EC4	/* MemDMA Stream 1 Source Start Address Register */
+#define MDMA_S1_X_COUNT		0xFFC00ED0	/* MemDMA Stream 1 Source X Count Register */
+#define MDMA_S1_Y_COUNT		0xFFC00ED8	/* MemDMA Stream 1 Source Y Count Register */
+#define MDMA_S1_X_MODIFY	0xFFC00ED4	/* MemDMA Stream 1 Source X Modify Register */
+#define MDMA_S1_Y_MODIFY	0xFFC00EDC	/* MemDMA Stream 1 Source Y Modify Register */
+#define MDMA_S1_CURR_DESC_PTR	0xFFC00EE0	/* MemDMA Stream 1 Source Current Descriptor Pointer Register */
+#define MDMA_S1_CURR_ADDR	0xFFC00EE4	/* MemDMA Stream 1 Source Current Address Register */
+#define MDMA_S1_CURR_X_COUNT	0xFFC00EF0	/* MemDMA Stream 1 Source Current X Count Register */
+#define MDMA_S1_CURR_Y_COUNT	0xFFC00EF8	/* MemDMA Stream 1 Source Current Y Count Register */
+#define MDMA_S1_IRQ_STATUS	0xFFC00EE8	/* MemDMA Stream 1 Source Interrupt/Status Register */
+#define MDMA_S1_PERIPHERAL_MAP	0xFFC00EEC	/* MemDMA Stream 1 Source Peripheral Map Register */
+
+#define MDMA_D0_CONFIG		0xFFC00E08	/* MemDMA Stream 0 Destination Configuration Register */
+#define MDMA_D0_NEXT_DESC_PTR	0xFFC00E00	/* MemDMA Stream 0 Destination Next Descriptor Pointer Register */
+#define MDMA_D0_START_ADDR	0xFFC00E04	/* MemDMA Stream 0 Destination Start Address Register */
+#define MDMA_D0_X_COUNT		0xFFC00E10	/* MemDMA Stream 0 Destination X Count Register */
+#define MDMA_D0_Y_COUNT		0xFFC00E18	/* MemDMA Stream 0 Destination Y Count Register */
+#define MDMA_D0_X_MODIFY	0xFFC00E14	/* MemDMA Stream 0 Destination X Modify Register */
+#define MDMA_D0_Y_MODIFY	0xFFC00E1C	/* MemDMA Stream 0 Destination Y Modify Register */
+#define MDMA_D0_CURR_DESC_PTR	0xFFC00E20	/* MemDMA Stream 0 Destination Current Descriptor Pointer Register */
+#define MDMA_D0_CURR_ADDR	0xFFC00E24	/* MemDMA Stream 0 Destination Current Address Register */
+#define MDMA_D0_CURR_X_COUNT	0xFFC00E30	/* MemDMA Stream 0 Destination Current X Count Register */
+#define MDMA_D0_CURR_Y_COUNT	0xFFC00E38	/* MemDMA Stream 0 Destination Current Y Count Register */
+#define MDMA_D0_IRQ_STATUS	0xFFC00E28	/* MemDMA Stream 0 Destination Interrupt/Status Register */
+#define MDMA_D0_PERIPHERAL_MAP	0xFFC00E2C	/* MemDMA Stream 0 Destination Peripheral Map Register */
+
+#define MDMA_S0_CONFIG		0xFFC00E48	/* MemDMA Stream 0 Source Configuration Register */
+#define MDMA_S0_NEXT_DESC_PTR	0xFFC00E40	/* MemDMA Stream 0 Source Next Descriptor Pointer Register */
+#define MDMA_S0_START_ADDR	0xFFC00E44	/* MemDMA Stream 0 Source Start Address Register */
+#define MDMA_S0_X_COUNT		0xFFC00E50	/* MemDMA Stream 0 Source X Count Register */
+#define MDMA_S0_Y_COUNT		0xFFC00E58	/* MemDMA Stream 0 Source Y Count Register */
+#define MDMA_S0_X_MODIFY	0xFFC00E54	/* MemDMA Stream 0 Source X Modify Register */
+#define MDMA_S0_Y_MODIFY	0xFFC00E5C	/* MemDMA Stream 0 Source Y Modify Register */
+#define MDMA_S0_CURR_DESC_PTR	0xFFC00E60	/* MemDMA Stream 0 Source Current Descriptor Pointer Register */
+#define MDMA_S0_CURR_ADDR	0xFFC00E64	/* MemDMA Stream 0 Source Current Address Register */
+#define MDMA_S0_CURR_X_COUNT	0xFFC00E70	/* MemDMA Stream 0 Source Current X Count Register */
+#define MDMA_S0_CURR_Y_COUNT	0xFFC00E78	/* MemDMA Stream 0 Source Current Y Count Register */
+#define MDMA_S0_IRQ_STATUS	0xFFC00E68	/* MemDMA Stream 0 Source Interrupt/Status Register */
+#define MDMA_S0_PERIPHERAL_MAP	0xFFC00E6C	/* MemDMA Stream 0 Source Peripheral Map Register */
+
+/*// Parallel Peripheral Interface (PPI) (0xFFC01000 - 0xFFC010FF) */
+
+#define PPI_CONTROL			0xFFC01000	/* PPI Control Register */
+#define PPI_STATUS			0xFFC01004	/* PPI Status Register */
+#define PPI_COUNT			0xFFC01008	/* PPI Transfer Count Register */
+#define PPI_DELAY			0xFFC0100C	/* PPI Delay Count Register */
+#define PPI_FRAME			0xFFC01010	/* PPI Frame Length Register */
+
+/*********************************************************************************** */
+/* System MMR Register Bits */
+/******************************************************************************* */
+
+/* ********************* PLL AND RESET MASKS ************************ */
+
+/*// PLL_CTL Masks */
+#define PLL_CLKIN              0x00000000  /* Pass CLKIN to PLL */
+#define PLL_CLKIN_DIV2         0x00000001  /* Pass CLKIN/2 to PLL */
+#define PLL_OFF                0x00000002  /* Shut off PLL clocks */
+#define STOPCK_OFF             0x00000008  /* Core clock off */
+#define PDWN                   0x00000020  /* Put the PLL in a Deep Sleep state */
+#define BYPASS                 0x00000100  /* Bypass the PLL */
+
+/*// PLL_DIV Masks */
+
+#define SCLK_DIV(x)  (x)		   /* SCLK = VCO / x */
+
+#define CCLK_DIV1              0x00000000  /* CCLK = VCO / 1 */
+#define CCLK_DIV2              0x00000010  /* CCLK = VCO / 2 */
+#define CCLK_DIV4              0x00000020  /* CCLK = VCO / 4 */
+#define CCLK_DIV8              0x00000030  /* CCLK = VCO / 8 */
+
+/* SWRST Mask */
+#define SYSTEM_RESET           0x00000007  /* Initiates a system software reset */
+
+/* *************  SYSTEM INTERRUPT CONTROLLER MASKS ***************** */
+
+    /* SIC_IAR0 Masks */
+
+#define P0_IVG(x)    ((x)-7)		   /* Peripheral #0 assigned IVG #x  */
+#define P1_IVG(x)    ((x)-7) << 0x4	   /* Peripheral #1 assigned IVG #x  */
+#define P2_IVG(x)    ((x)-7) << 0x8	   /* Peripheral #2 assigned IVG #x  */
+#define P3_IVG(x)    ((x)-7) << 0xC	   /* Peripheral #3 assigned IVG #x  */
+#define P4_IVG(x)    ((x)-7) << 0x10	   /* Peripheral #4 assigned IVG #x  */
+#define P5_IVG(x)    ((x)-7) << 0x14	   /* Peripheral #5 assigned IVG #x  */
+#define P6_IVG(x)    ((x)-7) << 0x18	   /* Peripheral #6 assigned IVG #x  */
+#define P7_IVG(x)    ((x)-7) << 0x1C	   /* Peripheral #7 assigned IVG #x  */
+
+/* SIC_IAR1 Masks */
+
+#define P8_IVG(x)     ((x)-7)		   /* Peripheral #8 assigned IVG #x  */
+#define P9_IVG(x)     ((x)-7) << 0x4	   /* Peripheral #9 assigned IVG #x  */
+#define P10_IVG(x)    ((x)-7) << 0x8	   /* Peripheral #10 assigned IVG #x  */
+#define P11_IVG(x)    ((x)-7) << 0xC	   /* Peripheral #11 assigned IVG #x  */
+#define P12_IVG(x)    ((x)-7) << 0x10	   /* Peripheral #12 assigned IVG #x  */
+#define P13_IVG(x)    ((x)-7) << 0x14	   /* Peripheral #13 assigned IVG #x  */
+#define P14_IVG(x)    ((x)-7) << 0x18	   /* Peripheral #14 assigned IVG #x  */
+#define P15_IVG(x)    ((x)-7) << 0x1C	   /* Peripheral #15 assigned IVG #x  */
+
+/* SIC_IAR2 Masks */
+#define P16_IVG(x)    ((x)-7)		   /* Peripheral #16 assigned IVG #x  */
+#define P17_IVG(x)    ((x)-7) << 0x4	   /* Peripheral #17 assigned IVG #x  */
+#define P18_IVG(x)    ((x)-7) << 0x8	   /* Peripheral #18 assigned IVG #x  */
+#define P19_IVG(x)    ((x)-7) << 0xC	   /* Peripheral #19 assigned IVG #x  */
+#define P20_IVG(x)    ((x)-7) << 0x10	   /* Peripheral #20 assigned IVG #x  */
+#define P21_IVG(x)    ((x)-7) << 0x14	   /* Peripheral #21 assigned IVG #x  */
+#define P22_IVG(x)    ((x)-7) << 0x18	   /* Peripheral #22 assigned IVG #x  */
+#define P23_IVG(x)    ((x)-7) << 0x1C	   /* Peripheral #23 assigned IVG #x  */
+
+/* SIC_IMASK Masks */
+#define SIC_UNMASK_ALL         0x00000000  /* Unmask all peripheral interrupts */
+#define SIC_MASK_ALL           0xFFFFFFFF  /* Mask all peripheral interrupts */
+#define SIC_MASK(x)	       (1 << (x))    /* Mask Peripheral #x interrupt */
+#define SIC_UNMASK(x) (0xFFFFFFFF ^ (1 << (x))) /* Unmask Peripheral #x interrupt */
+
+/* SIC_IWR Masks */
+#define IWR_DISABLE_ALL        0x00000000  /* Wakeup Disable all peripherals */
+#define IWR_ENABLE_ALL         0xFFFFFFFF  /* Wakeup Enable all peripherals */
+#define IWR_ENABLE(x)	       (1 << (x))    /* Wakeup Enable Peripheral #x */
+#define IWR_DISABLE(x) (0xFFFFFFFF ^ (1 << (x))) /* Wakeup Disable Peripheral #x */
+
+/* *********  WATCHDOG TIMER MASKS  ********************8 */
+
+/* Watchdog Timer WDOG_CTL Register */
+#define ICTL(x) ((x<<1) & 0x0006)
+#define ENABLE_RESET     0x00000000  /* Set Watchdog Timer to generate reset */
+#define ENABLE_NMI       0x00000002  /* Set Watchdog Timer to generate non-maskable interrupt */
+#define ENABLE_GPI       0x00000004  /* Set Watchdog Timer to generate general-purpose interrupt */
+#define DISABLE_EVT      0x00000006  /* Disable Watchdog Timer interrupts */
+
+#define TMR_EN		0x0000
+#define TMR_DIS		0x0AD0
+#define TRO		0x8000
+
+#define ICTL_P0		0x01
+#define ICTL_P1		0x02
+#define TRO_P		0x0F
+
+/* RTC_STAT and RTC_ALARM register */
+#define	RTSEC		0x0000003F	/* Real-Time Clock Seconds */
+#define	RTMIN		0x00000FC0	/* Real-Time Clock Minutes */
+#define	RTHR		0x0001F000	/* Real-Time Clock Hours */
+#define	RTDAY		0xFFFE0000	/* Real-Time Clock Days */
+
+/* RTC_ICTL register */
+#define	SWIE		0x0001		/* Stopwatch Interrupt Enable */
+#define	AIE		0x0002		/* Alarm Interrupt Enable */
+#define	SIE		0x0004		/* Seconds (1 Hz) Interrupt Enable */
+#define	MIE		0x0008		/* Minutes Interrupt Enable */
+#define	HIE		0x0010		/* Hours Interrupt Enable */
+#define	DIE		0x0020		/* 24 Hours (Days) Interrupt Enable */
+#define	DAIE		0x0040		/* Day Alarm (Day, Hour, Minute, Second) Interrupt Enable */
+#define	WCIE		0x8000		/* Write Complete Interrupt Enable */
+
+/* RTC_ISTAT register */
+#define	SWEF		0x0001		/* Stopwatch Event Flag */
+#define	AEF		0x0002		/* Alarm Event Flag */
+#define	SEF		0x0004		/* Seconds (1 Hz) Event Flag */
+#define	MEF		0x0008		/* Minutes Event Flag */
+#define	HEF		0x0010		/* Hours Event Flag */
+#define	DEF		0x0020		/* 24 Hours (Days) Event Flag */
+#define	DAEF		0x0040		/* Day Alarm (Day, Hour, Minute, Second) Event Flag */
+#define	WPS		0x4000		/* Write Pending Status (RO) */
+#define	WCOM		0x8000		/* Write Complete */
+
+/*// RTC_FAST Mask (RTC_PREN Mask) */
+#define ENABLE_PRESCALE      0x00000001  /* Enable prescaler so RTC runs at 1 Hz */
+#define PREN                 0x00000001
+    /* ** Must be set after power-up for proper operation of RTC */
+
+/* ***************************** UART CONTROLLER MASKS ********************** */
+
+/* UART_LCR Register */
+
+#define DLAB	0x80
+#define SB      0x40
+#define STP      0x20
+#define EPS     0x10
+#define PEN	0x08
+#define STB	0x04
+#define WLS(x)	((x-5) & 0x03)
+
+#define DLAB_P	0x07
+#define SB_P	0x06
+#define STP_P	0x05
+#define EPS_P	0x04
+#define PEN_P	0x03
+#define STB_P	0x02
+#define WLS_P1	0x01
+#define WLS_P0	0x00
+
+/* UART_MCR Register */
+#define LOOP_ENA	0x10
+#define LOOP_ENA_P	0x04
+
+/* UART_LSR Register */
+#define TEMT	0x40
+#define THRE	0x20
+#define BI	0x10
+#define FE	0x08
+#define PE	0x04
+#define OE	0x02
+#define DR	0x01
+
+#define TEMP_P	0x06
+#define THRE_P	0x05
+#define BI_P	0x04
+#define FE_P	0x03
+#define PE_P	0x02
+#define OE_P	0x01
+#define DR_P	0x00
+
+/* UART_IER Register */
+#define ELSI	0x04
+#define ETBEI	0x02
+#define ERBFI	0x01
+
+#define ELSI_P	0x02
+#define ETBEI_P	0x01
+#define ERBFI_P	0x00
+
+/* UART_IIR Register */
+#define STATUS(x)	((x << 1) & 0x06)
+#define NINT		0x01
+#define STATUS_P1	0x02
+#define STATUS_P0	0x01
+#define NINT_P		0x00
+
+/* UART_GCTL Register */
+#define FFE	0x20
+#define FPE	0x10
+#define RPOLC	0x08
+#define TPOLC	0x04
+#define IREN	0x02
+#define UCEN	0x01
+
+#define FFE_P	0x05
+#define FPE_P	0x04
+#define RPOLC_P	0x03
+#define TPOLC_P	0x02
+#define IREN_P	0x01
+#define UCEN_P	0x00
+
+/* **********  SERIAL PORT MASKS  ********************** */
+
+/* SPORTx_TCR1 Masks */
+#define TSPEN    0x0001  /* TX enable  */
+#define ITCLK    0x0002  /* Internal TX Clock Select  */
+#define TDTYPE   0x000C  /* TX Data Formatting Select */
+#define TLSBIT   0x0010  /* TX Bit Order */
+#define ITFS     0x0200  /* Internal TX Frame Sync Select  */
+#define TFSR     0x0400  /* TX Frame Sync Required Select  */
+#define DITFS    0x0800  /* Data Independent TX Frame Sync Select  */
+#define LTFS     0x1000  /* Low TX Frame Sync Select  */
+#define LATFS    0x2000  /* Late TX Frame Sync Select  */
+#define TCKFE    0x4000  /* TX Clock Falling Edge Select  */
+
+/* SPORTx_TCR2 Masks */
+#define SLEN	    0x001F  /*TX Word Length  */
+#define TXSE        0x0100  /*TX Secondary Enable */
+#define TSFSE       0x0200  /*TX Stereo Frame Sync Enable */
+#define TRFST       0x0400  /*TX Right-First Data Order  */
+
+/* SPORTx_RCR1 Masks */
+#define RSPEN    0x0001  /* RX enable  */
+#define IRCLK    0x0002  /* Internal RX Clock Select  */
+#define RDTYPE   0x000C  /* RX Data Formatting Select */
+#define RULAW    0x0008  /* u-Law enable  */
+#define RALAW    0x000C  /* A-Law enable  */
+#define RLSBIT   0x0010  /* RX Bit Order */
+#define IRFS     0x0200  /* Internal RX Frame Sync Select  */
+#define RFSR     0x0400  /* RX Frame Sync Required Select  */
+#define LRFS     0x1000  /* Low RX Frame Sync Select  */
+#define LARFS    0x2000  /* Late RX Frame Sync Select  */
+#define RCKFE    0x4000  /* RX Clock Falling Edge Select  */
+
+/* SPORTx_RCR2 Masks */
+#define SLEN	    0x001F  /*RX Word Length  */
+#define RXSE        0x0100  /*RX Secondary Enable */
+#define RSFSE       0x0200  /*RX Stereo Frame Sync Enable */
+#define RRFST       0x0400  /*Right-First Data Order  */
+
+/*SPORTx_STAT Masks */
+#define RXNE		0x0001		/*RX FIFO Not Empty Status */
+#define RUVF	    	0x0002  	/*RX Underflow Status */
+#define ROVF		0x0004		/*RX Overflow Status */
+#define TXF		0x0008		/*TX FIFO Full Status */
+#define TUVF         	0x0010  	/*TX Underflow Status */
+#define TOVF         	0x0020  	/*TX Overflow Status */
+#define TXHRE        	0x0040  	/*TX Hold Register Empty */
+
+/*SPORTx_MCMC1 Masks */
+#define SP_WSIZE		0x0000F000 	/*Multichannel Window Size Field */
+#define SP_WOFF		0x000003FF 	/*Multichannel Window Offset Field */
+
+/*SPORTx_MCMC2 Masks */
+#define MCCRM		0x00000003 	/*Multichannel Clock Recovery Mode */
+#define MCDTXPE		0x00000004 	/*Multichannel DMA Transmit Packing */
+#define MCDRXPE		0x00000008 	/*Multichannel DMA Receive Packing */
+#define MCMEN		0x00000010 	/*Multichannel Frame Mode Enable */
+#define FSDR		0x00000080 	/*Multichannel Frame Sync to Data Relationship */
+#define MFD		0x0000F000 	/*Multichannel Frame Delay    */
+
+/*  *********  PARALLEL PERIPHERAL INTERFACE (PPI) MASKS ****************   */
+
+/*//  PPI_CONTROL Masks         */
+#define PORT_EN              0x00000001  /* PPI Port Enable  */
+#define PORT_DIR             0x00000002  /* PPI Port Direction       */
+#define XFR_TYPE             0x0000000C  /* PPI Transfer Type  */
+#define PORT_CFG             0x00000030  /* PPI Port Configuration */
+#define FLD_SEL              0x00000040  /* PPI Active Field Select */
+#define PACK_EN              0x00000080  /* PPI Packing Mode */
+#define DMA32                0x00000100  /* PPI 32-bit DMA Enable */
+#define SKIP_EN              0x00000200  /* PPI Skip Element Enable */
+#define SKIP_EO              0x00000400  /* PPI Skip Even/Odd Elements */
+#define DLENGTH              0x00003800  /* PPI Data Length  */
+#define DLEN_8		     0x0	     /* PPI Data Length mask for DLEN=8 */
+#define DLEN(x)	(((x-9) & 0x07) << 11)  /* PPI Data Length (only works for x=10-->x=16) */
+#define POL                  0x0000C000  /* PPI Signal Polarities       */
+
+/*// PPI_STATUS Masks                                          */
+#define FLD	             0x00000400  /* Field Indicator   */
+#define FT_ERR	             0x00000800  /* Frame Track Error */
+#define OVR	             0x00001000  /* FIFO Overflow Error */
+#define UNDR	             0x00002000  /* FIFO Underrun Error */
+#define ERR_DET	      	     0x00004000  /* Error Detected Indicator */
+#define ERR_NCOR	     0x00008000  /* Error Not Corrected Indicator */
+
+/* **********  DMA CONTROLLER MASKS  *********************8 */
+
+/*//DMAx_CONFIG, MDMA_yy_CONFIG Masks */
+#define DMAEN	        0x00000001  /* Channel Enable */
+#define WNR	   	0x00000002  /* Channel Direction (W/R*) */
+#define WDSIZE_8	0x00000000  /* Word Size 8 bits */
+#define WDSIZE_16	0x00000004  /* Word Size 16 bits */
+#define WDSIZE_32	0x00000008  /* Word Size 32 bits */
+#define DMA2D	        0x00000010  /* 2D/1D* Mode */
+#define RESTART         0x00000020  /* Restart */
+#define DI_SEL	        0x00000040  /* Data Interrupt Select */
+#define DI_EN	        0x00000080  /* Data Interrupt Enable */
+#define NDSIZE	        0x00000900  /* Next Descriptor Size */
+#define DMAFLOW	        0x00007000  /* Flow Control */
+
+#define DMAEN_P	            	0  /* Channel Enable */
+#define WNR_P	            	1  /* Channel Direction (W/R*) */
+#define DMA2D_P	        	4  /* 2D/1D* Mode */
+#define RESTART_P	      	5  /* Restart */
+#define DI_SEL_P	     	6  /* Data Interrupt Select */
+#define DI_EN_P	            	7  /* Data Interrupt Enable */
+
+/*//DMAx_IRQ_STATUS, MDMA_yy_IRQ_STATUS Masks */
+
+#define DMA_DONE		0x00000001  /* DMA Done Indicator */
+#define DMA_ERR	        	0x00000002  /* DMA Error Indicator */
+#define DFETCH	            	0x00000004  /* Descriptor Fetch Indicator */
+#define DMA_RUN	            	0x00000008  /* DMA Running Indicator */
+
+#define DMA_DONE_P	    	0  /* DMA Done Indicator */
+#define DMA_ERR_P     		1 /* DMA Error Indicator */
+#define DFETCH_P     		2  /* Descriptor Fetch Indicator */
+#define DMA_RUN_P     		3  /* DMA Running Indicator */
+
+/*//DMAx_PERIPHERAL_MAP, MDMA_yy_PERIPHERAL_MAP Masks */
+
+#define CTYPE	            0x00000040  /* DMA Channel Type Indicator */
+#define CTYPE_P             6       /* DMA Channel Type Indicator BIT POSITION */
+#define PCAP8	            0x00000080  /* DMA 8-bit Operation Indicator   */
+#define PCAP16	            0x00000100  /* DMA 16-bit Operation Indicator */
+#define PCAP32	            0x00000200  /* DMA 32-bit Operation Indicator */
+#define PCAPWR	            0x00000400  /* DMA Write Operation Indicator */
+#define PCAPRD	            0x00000800  /* DMA Read Operation Indicator */
+#define PMAP	            0x00007000  /* DMA Peripheral Map Field */
+
+/*  *************  GENERAL PURPOSE TIMER MASKS  ******************** */
+
+/* PWM Timer bit definitions */
+
+/* TIMER_ENABLE Register */
+#define TIMEN0	0x0001
+#define TIMEN1	0x0002
+#define TIMEN2	0x0004
+
+#define TIMEN0_P	0x00
+#define TIMEN1_P	0x01
+#define TIMEN2_P	0x02
+
+/* TIMER_DISABLE Register */
+#define TIMDIS0	0x0001
+#define TIMDIS1	0x0002
+#define TIMDIS2	0x0004
+
+#define TIMDIS0_P	0x00
+#define TIMDIS1_P	0x01
+#define TIMDIS2_P	0x02
+
+/* TIMER_STATUS Register */
+#define TIMIL0		0x0001
+#define TIMIL1		0x0002
+#define TIMIL2		0x0004
+#define TOVL_ERR0	0x0010
+#define TOVL_ERR1	0x0020
+#define TOVL_ERR2	0x0040
+#define TRUN0		0x1000
+#define TRUN1		0x2000
+#define TRUN2		0x4000
+
+#define TIMIL0_P	0x00
+#define TIMIL1_P	0x01
+#define TIMIL2_P	0x02
+#define TOVL_ERR0_P	0x04
+#define TOVL_ERR1_P	0x05
+#define TOVL_ERR2_P	0x06
+#define TRUN0_P		0x0C
+#define TRUN1_P		0x0D
+#define TRUN2_P		0x0E
+
+/* TIMERx_CONFIG Registers */
+#define PWM_OUT		0x0001
+#define WDTH_CAP	0x0002
+#define EXT_CLK		0x0003
+#define PULSE_HI	0x0004
+#define PERIOD_CNT	0x0008
+#define IRQ_ENA		0x0010
+#define TIN_SEL		0x0020
+#define OUT_DIS		0x0040
+#define CLK_SEL		0x0080
+#define TOGGLE_HI	0x0100
+#define EMU_RUN		0x0200
+#define ERR_TYP(x)	((x & 0x03) << 14)
+
+#define TMODE_P0		0x00
+#define TMODE_P1		0x01
+#define PULSE_HI_P		0x02
+#define PERIOD_CNT_P		0x03
+#define IRQ_ENA_P		0x04
+#define TIN_SEL_P		0x05
+#define OUT_DIS_P		0x06
+#define CLK_SEL_P		0x07
+#define TOGGLE_HI_P		0x08
+#define EMU_RUN_P		0x09
+#define ERR_TYP_P0		0x0E
+#define ERR_TYP_P1		0x0F
+
+/*/ ******************   PROGRAMMABLE FLAG MASKS  ********************* */
+
+/*  General Purpose IO (0xFFC00700 - 0xFFC007FF)  Masks */
+#define PF0         0x0001
+#define PF1         0x0002
+#define PF2         0x0004
+#define PF3         0x0008
+#define PF4         0x0010
+#define PF5         0x0020
+#define PF6         0x0040
+#define PF7         0x0080
+#define PF8         0x0100
+#define PF9         0x0200
+#define PF10        0x0400
+#define PF11        0x0800
+#define PF12        0x1000
+#define PF13        0x2000
+#define PF14        0x4000
+#define PF15        0x8000
+
+/*  General Purpose IO (0xFFC00700 - 0xFFC007FF)  BIT POSITIONS */
+#define PF0_P         0
+#define PF1_P         1
+#define PF2_P         2
+#define PF3_P         3
+#define PF4_P         4
+#define PF5_P         5
+#define PF6_P         6
+#define PF7_P         7
+#define PF8_P         8
+#define PF9_P         9
+#define PF10_P        10
+#define PF11_P        11
+#define PF12_P        12
+#define PF13_P        13
+#define PF14_P        14
+#define PF15_P        15
+
+/* ***********  SERIAL PERIPHERAL INTERFACE (SPI) MASKS  **************** */
+
+/* SPI_CTL Masks */
+#define TIMOD                  0x00000003  /* Transfer initiation mode and interrupt generation */
+#define SZ                     0x00000004  /* Send Zero (=0) or last (=1) word when TDBR empty. */
+#define GM                     0x00000008  /* When RDBR full, get more (=1) data or discard (=0) incoming Data */
+#define PSSE                   0x00000010  /* Enable (=1) Slave-Select input for Master. */
+#define EMISO                  0x00000020  /* Enable (=1) MISO pin as an output. */
+#define SPI_LEN                0x00000100  /* Word length (0 => 8 bits, 1 => 16 bits) */
+#define LSBF                   0x00000200  /* Data format (0 => MSB sent/received first 1 => LSB sent/received first) */
+#define CPHA                   0x00000400  /* Clock phase (0 => SPICLK starts toggling in middle of xfer, 1 => SPICLK toggles at the beginning of xfer. */
+#define CPOL                   0x00000800  /* Clock polarity (0 => active-high, 1 => active-low) */
+#define MSTR                   0x00001000  /* Configures SPI as master (=1) or slave (=0) */
+#define WOM                    0x00002000  /* Open drain (=1) data output enable (for MOSI and MISO) */
+#define SPE                    0x00004000  /* SPI module enable (=1), disable (=0) */
+
+/*// SPI_FLG Masks */
+#define FLS1                   0x00000002  /* Enables (=1) SPI_FLOUT1 as flag output for SPI Slave-select */
+#define FLS2                   0x00000004  /* Enables (=1) SPI_FLOUT2 as flag output for SPI Slave-select */
+#define FLS3                   0x00000008  /* Enables (=1) SPI_FLOUT3 as flag output for SPI Slave-select */
+#define FLS4                   0x00000010  /* Enables (=1) SPI_FLOUT4 as flag output for SPI Slave-select */
+#define FLS5                   0x00000020  /* Enables (=1) SPI_FLOUT5 as flag output for SPI Slave-select */
+#define FLS6                   0x00000040  /* Enables (=1) SPI_FLOUT6 as flag output for SPI Slave-select */
+#define FLS7                   0x00000080  /* Enables (=1) SPI_FLOUT7 as flag output for SPI Slave-select */
+#define FLG1                   0x00000200  /* Activates (=0) SPI_FLOUT1 as flag output for SPI Slave-select  */
+#define FLG2                   0x00000400  /* Activates (=0) SPI_FLOUT2 as flag output for SPI Slave-select */
+#define FLG3                   0x00000800  /* Activates (=0) SPI_FLOUT3 as flag output for SPI Slave-select  */
+#define FLG4                   0x00001000  /* Activates (=0) SPI_FLOUT4 as flag output for SPI Slave-select  */
+#define FLG5                   0x00002000  /* Activates (=0) SPI_FLOUT5 as flag output for SPI Slave-select  */
+#define FLG6                   0x00004000  /* Activates (=0) SPI_FLOUT6 as flag output for SPI Slave-select  */
+#define FLG7                   0x00008000  /* Activates (=0) SPI_FLOUT7 as flag output for SPI Slave-select */
+
+/*// SPI_FLG Bit Positions */
+#define FLS1_P                 0x00000001  /* Enables (=1) SPI_FLOUT1 as flag output for SPI Slave-select */
+#define FLS2_P                 0x00000002  /* Enables (=1) SPI_FLOUT2 as flag output for SPI Slave-select */
+#define FLS3_P                 0x00000003  /* Enables (=1) SPI_FLOUT3 as flag output for SPI Slave-select */
+#define FLS4_P                 0x00000004  /* Enables (=1) SPI_FLOUT4 as flag output for SPI Slave-select */
+#define FLS5_P                 0x00000005  /* Enables (=1) SPI_FLOUT5 as flag output for SPI Slave-select */
+#define FLS6_P                 0x00000006  /* Enables (=1) SPI_FLOUT6 as flag output for SPI Slave-select */
+#define FLS7_P                 0x00000007  /* Enables (=1) SPI_FLOUT7 as flag output for SPI Slave-select */
+#define FLG1_P                 0x00000009  /* Activates (=0) SPI_FLOUT1 as flag output for SPI Slave-select  */
+#define FLG2_P                 0x0000000A  /* Activates (=0) SPI_FLOUT2 as flag output for SPI Slave-select */
+#define FLG3_P                 0x0000000B  /* Activates (=0) SPI_FLOUT3 as flag output for SPI Slave-select  */
+#define FLG4_P                 0x0000000C  /* Activates (=0) SPI_FLOUT4 as flag output for SPI Slave-select  */
+#define FLG5_P                 0x0000000D  /* Activates (=0) SPI_FLOUT5 as flag output for SPI Slave-select  */
+#define FLG6_P                 0x0000000E  /* Activates (=0) SPI_FLOUT6 as flag output for SPI Slave-select  */
+#define FLG7_P                 0x0000000F  /* Activates (=0) SPI_FLOUT7 as flag output for SPI Slave-select */
+
+/*// SPI_STAT Masks */
+#define SPIF                   0x00000001  /* Set (=1) when SPI single-word transfer complete */
+#define MODF                   0x00000002  /* Set (=1) in a master device when some other device tries to become master */
+#define TXE                    0x00000004  /* Set (=1) when transmission occurs with no new data in SPI_TDBR */
+#define TXS                    0x00000008  /* SPI_TDBR Data Buffer Status (0=Empty, 1=Full) */
+#define RBSY                   0x00000010  /* Set (=1) when data is received with RDBR full */
+#define RXS                    0x00000020  /* SPI_RDBR Data Buffer Status (0=Empty, 1=Full)  */
+#define TXCOL                  0x00000040  /* When set (=1), corrupt data may have been transmitted  */
+
+/* *********************  ASYNCHRONOUS MEMORY CONTROLLER MASKS  ************* */
+
+/* AMGCTL Masks */
+#define AMCKEN			0x00000001  /* Enable CLKOUT */
+#define AMBEN_B0		0x00000002  /* Enable Asynchronous Memory Bank 0 only */
+#define AMBEN_B0_B1		0x00000004  /* Enable Asynchronous Memory Banks 0 & 1 only */
+#define AMBEN_B0_B1_B2		0x00000006  /* Enable Asynchronous Memory Banks 0, 1, and 2 */
+#define AMBEN_ALL		0x00000008  /* Enable Asynchronous Memory Banks (all) 0, 1, 2, and 3 */
+
+/* AMGCTL Bit Positions */
+#define AMCKEN_P		0x00000000  /* Enable CLKOUT */
+#define AMBEN_P0		0x00000001  /* Asynchronous Memory Enable, 000 - banks 0-3 disabled, 001 - Bank 0 enabled */
+#define AMBEN_P1		0x00000002  /* Asynchronous Memory Enable, 010 - banks 0&1 enabled,  011 - banks 0-3 enabled */
+#define AMBEN_P2		0x00000003 /* Asynchronous Memory Enable, 1xx - All banks (bank 0, 1, 2, and 3) enabled */
+
+/* AMBCTL0 Masks */
+#define B0RDYEN	0x00000001  /* Bank 0 RDY Enable, 0=disable, 1=enable */
+#define B0RDYPOL 0x00000002  /* Bank 0 RDY Active high, 0=active low, 1=active high */
+#define B0TT_1	0x00000004  /* Bank 0 Transition Time from Read to Write = 1 cycle */
+#define B0TT_2	0x00000008  /* Bank 0 Transition Time from Read to Write = 2 cycles */
+#define B0TT_3	0x0000000C  /* Bank 0 Transition Time from Read to Write = 3 cycles */
+#define B0TT_4	0x00000000  /* Bank 0 Transition Time from Read to Write = 4 cycles */
+#define B0ST_1	0x00000010  /* Bank 0 Setup Time from AOE asserted to Read/Write asserted=1 cycle */
+#define B0ST_2	0x00000020  /* Bank 0 Setup Time from AOE asserted to Read/Write asserted=2 cycles */
+#define B0ST_3	0x00000030  /* Bank 0 Setup Time from AOE asserted to Read/Write asserted=3 cycles */
+#define B0ST_4	0x00000000  /* Bank 0 Setup Time from AOE asserted to Read/Write asserted=4 cycles */
+#define B0HT_1	0x00000040  /* Bank 0 Hold Time from Read/Write deasserted to AOE deasserted = 1 cycle */
+#define B0HT_2	0x00000080  /* Bank 0 Hold Time from Read/Write deasserted to AOE deasserted = 2 cycles */
+#define B0HT_3	0x000000C0  /* Bank 0 Hold Time from Read/Write deasserted to AOE deasserted = 3 cycles */
+#define B0HT_0	0x00000000  /* Bank 0 Hold Time from Read/Write deasserted to AOE deasserted = 0 cycles */
+#define B0RAT_1			0x00000100  /* Bank 0 Read Access Time = 1 cycle */
+#define B0RAT_2			0x00000200  /* Bank 0 Read Access Time = 2 cycles */
+#define B0RAT_3			0x00000300  /* Bank 0 Read Access Time = 3 cycles */
+#define B0RAT_4			0x00000400  /* Bank 0 Read Access Time = 4 cycles */
+#define B0RAT_5			0x00000500  /* Bank 0 Read Access Time = 5 cycles */
+#define B0RAT_6			0x00000600  /* Bank 0 Read Access Time = 6 cycles */
+#define B0RAT_7			0x00000700  /* Bank 0 Read Access Time = 7 cycles */
+#define B0RAT_8			0x00000800  /* Bank 0 Read Access Time = 8 cycles */
+#define B0RAT_9			0x00000900  /* Bank 0 Read Access Time = 9 cycles */
+#define B0RAT_10		0x00000A00  /* Bank 0 Read Access Time = 10 cycles */
+#define B0RAT_11		0x00000B00  /* Bank 0 Read Access Time = 11 cycles */
+#define B0RAT_12		0x00000C00  /* Bank 0 Read Access Time = 12 cycles */
+#define B0RAT_13		0x00000D00  /* Bank 0 Read Access Time = 13 cycles */
+#define B0RAT_14		0x00000E00  /* Bank 0 Read Access Time = 14 cycles */
+#define B0RAT_15		0x00000F00  /* Bank 0 Read Access Time = 15 cycles */
+#define B0WAT_1			0x00001000  /* Bank 0 Write Access Time = 1 cycle */
+#define B0WAT_2			0x00002000  /* Bank 0 Write Access Time = 2 cycles */
+#define B0WAT_3			0x00003000  /* Bank 0 Write Access Time = 3 cycles */
+#define B0WAT_4			0x00004000  /* Bank 0 Write Access Time = 4 cycles */
+#define B0WAT_5			0x00005000  /* Bank 0 Write Access Time = 5 cycles */
+#define B0WAT_6			0x00006000  /* Bank 0 Write Access Time = 6 cycles */
+#define B0WAT_7			0x00007000  /* Bank 0 Write Access Time = 7 cycles */
+#define B0WAT_8			0x00008000  /* Bank 0 Write Access Time = 8 cycles */
+#define B0WAT_9			0x00009000  /* Bank 0 Write Access Time = 9 cycles */
+#define B0WAT_10		0x0000A000  /* Bank 0 Write Access Time = 10 cycles */
+#define B0WAT_11		0x0000B000  /* Bank 0 Write Access Time = 11 cycles */
+#define B0WAT_12		0x0000C000  /* Bank 0 Write Access Time = 12 cycles */
+#define B0WAT_13		0x0000D000  /* Bank 0 Write Access Time = 13 cycles */
+#define B0WAT_14		0x0000E000  /* Bank 0 Write Access Time = 14 cycles */
+#define B0WAT_15		0x0000F000  /* Bank 0 Write Access Time = 15 cycles */
+#define B1RDYEN			0x00010000  /* Bank 1 RDY enable, 0=disable, 1=enable */
+#define B1RDYPOL		0x00020000  /* Bank 1 RDY Active high, 0=active low, 1=active high */
+#define B1TT_1			0x00040000  /* Bank 1 Transition Time from Read to Write = 1 cycle */
+#define B1TT_2			0x00080000  /* Bank 1 Transition Time from Read to Write = 2 cycles */
+#define B1TT_3			0x000C0000  /* Bank 1 Transition Time from Read to Write = 3 cycles */
+#define B1TT_4			0x00000000  /* Bank 1 Transition Time from Read to Write = 4 cycles */
+#define B1ST_1			0x00100000  /* Bank 1 Setup Time from AOE asserted to Read or Write asserted = 1 cycle */
+#define B1ST_2			0x00200000  /* Bank 1 Setup Time from AOE asserted to Read or Write asserted = 2 cycles */
+#define B1ST_3			0x00300000  /* Bank 1 Setup Time from AOE asserted to Read or Write asserted = 3 cycles */
+#define B1ST_4			0x00000000  /* Bank 1 Setup Time from AOE asserted to Read or Write asserted = 4 cycles */
+#define B1HT_1			0x00400000  /* Bank 1 Hold Time from Read or Write deasserted to AOE deasserted = 1 cycle */
+#define B1HT_2			0x00800000  /* Bank 1 Hold Time from Read or Write deasserted to AOE deasserted = 2 cycles */
+#define B1HT_3			0x00C00000  /* Bank 1 Hold Time from Read or Write deasserted to AOE deasserted = 3 cycles */
+#define B1HT_0			0x00000000  /* Bank 1 Hold Time from Read or Write deasserted to AOE deasserted = 0 cycles */
+#define B1RAT_1			0x01000000  /* Bank 1 Read Access Time = 1 cycle */
+#define B1RAT_2			0x02000000  /* Bank 1 Read Access Time = 2 cycles */
+#define B1RAT_3			0x03000000  /* Bank 1 Read Access Time = 3 cycles */
+#define B1RAT_4			0x04000000  /* Bank 1 Read Access Time = 4 cycles */
+#define B1RAT_5			0x05000000  /* Bank 1 Read Access Time = 5 cycles */
+#define B1RAT_6			0x06000000  /* Bank 1 Read Access Time = 6 cycles */
+#define B1RAT_7			0x07000000  /* Bank 1 Read Access Time = 7 cycles */
+#define B1RAT_8			0x08000000  /* Bank 1 Read Access Time = 8 cycles */
+#define B1RAT_9			0x09000000  /* Bank 1 Read Access Time = 9 cycles */
+#define B1RAT_10		0x0A000000  /* Bank 1 Read Access Time = 10 cycles */
+#define B1RAT_11		0x0B000000  /* Bank 1 Read Access Time = 11 cycles */
+#define B1RAT_12		0x0C000000  /* Bank 1 Read Access Time = 12 cycles */
+#define B1RAT_13		0x0D000000  /* Bank 1 Read Access Time = 13 cycles */
+#define B1RAT_14		0x0E000000  /* Bank 1 Read Access Time = 14 cycles */
+#define B1RAT_15		0x0F000000  /* Bank 1 Read Access Time = 15 cycles */
+#define B1WAT_1			0x10000000 /* Bank 1 Write Access Time = 1 cycle */
+#define B1WAT_2			0x20000000  /* Bank 1 Write Access Time = 2 cycles */
+#define B1WAT_3			0x30000000  /* Bank 1 Write Access Time = 3 cycles */
+#define B1WAT_4			0x40000000  /* Bank 1 Write Access Time = 4 cycles */
+#define B1WAT_5			0x50000000  /* Bank 1 Write Access Time = 5 cycles */
+#define B1WAT_6			0x60000000  /* Bank 1 Write Access Time = 6 cycles */
+#define B1WAT_7			0x70000000  /* Bank 1 Write Access Time = 7 cycles */
+#define B1WAT_8			0x80000000  /* Bank 1 Write Access Time = 8 cycles */
+#define B1WAT_9			0x90000000  /* Bank 1 Write Access Time = 9 cycles */
+#define B1WAT_10		0xA0000000  /* Bank 1 Write Access Time = 10 cycles */
+#define B1WAT_11		0xB0000000  /* Bank 1 Write Access Time = 11 cycles */
+#define B1WAT_12		0xC0000000  /* Bank 1 Write Access Time = 12 cycles */
+#define B1WAT_13		0xD0000000  /* Bank 1 Write Access Time = 13 cycles */
+#define B1WAT_14		0xE0000000  /* Bank 1 Write Access Time = 14 cycles */
+#define B1WAT_15		0xF0000000  /* Bank 1 Write Access Time = 15 cycles */
+
+/* AMBCTL1 Masks */
+#define B2RDYEN			0x00000001  /* Bank 2 RDY Enable, 0=disable, 1=enable */
+#define B2RDYPOL		0x00000002  /* Bank 2 RDY Active high, 0=active low, 1=active high */
+#define B2TT_1			0x00000004  /* Bank 2 Transition Time from Read to Write = 1 cycle */
+#define B2TT_2			0x00000008  /* Bank 2 Transition Time from Read to Write = 2 cycles */
+#define B2TT_3			0x0000000C  /* Bank 2 Transition Time from Read to Write = 3 cycles */
+#define B2TT_4			0x00000000  /* Bank 2 Transition Time from Read to Write = 4 cycles */
+#define B2ST_1			0x00000010  /* Bank 2 Setup Time from AOE asserted to Read or Write asserted = 1 cycle */
+#define B2ST_2			0x00000020  /* Bank 2 Setup Time from AOE asserted to Read or Write asserted = 2 cycles */
+#define B2ST_3			0x00000030  /* Bank 2 Setup Time from AOE asserted to Read or Write asserted = 3 cycles */
+#define B2ST_4			0x00000000  /* Bank 2 Setup Time from AOE asserted to Read or Write asserted = 4 cycles */
+#define B2HT_1			0x00000040  /* Bank 2 Hold Time from Read or Write deasserted to AOE deasserted = 1 cycle */
+#define B2HT_2			0x00000080  /* Bank 2 Hold Time from Read or Write deasserted to AOE deasserted = 2 cycles */
+#define B2HT_3			0x000000C0  /* Bank 2 Hold Time from Read or Write deasserted to AOE deasserted = 3 cycles */
+#define B2HT_0			0x00000000  /* Bank 2 Hold Time from Read or Write deasserted to AOE deasserted = 0 cycles */
+#define B2RAT_1			0x00000100  /* Bank 2 Read Access Time = 1 cycle */
+#define B2RAT_2			0x00000200  /* Bank 2 Read Access Time = 2 cycles */
+#define B2RAT_3			0x00000300  /* Bank 2 Read Access Time = 3 cycles */
+#define B2RAT_4			0x00000400  /* Bank 2 Read Access Time = 4 cycles */
+#define B2RAT_5			0x00000500  /* Bank 2 Read Access Time = 5 cycles */
+#define B2RAT_6			0x00000600  /* Bank 2 Read Access Time = 6 cycles */
+#define B2RAT_7			0x00000700  /* Bank 2 Read Access Time = 7 cycles */
+#define B2RAT_8			0x00000800  /* Bank 2 Read Access Time = 8 cycles */
+#define B2RAT_9			0x00000900  /* Bank 2 Read Access Time = 9 cycles */
+#define B2RAT_10		0x00000A00  /* Bank 2 Read Access Time = 10 cycles */
+#define B2RAT_11		0x00000B00  /* Bank 2 Read Access Time = 11 cycles */
+#define B2RAT_12		0x00000C00  /* Bank 2 Read Access Time = 12 cycles */
+#define B2RAT_13		0x00000D00  /* Bank 2 Read Access Time = 13 cycles */
+#define B2RAT_14		0x00000E00  /* Bank 2 Read Access Time = 14 cycles */
+#define B2RAT_15		0x00000F00  /* Bank 2 Read Access Time = 15 cycles */
+#define B2WAT_1			0x00001000  /* Bank 2 Write Access Time = 1 cycle */
+#define B2WAT_2			0x00002000  /* Bank 2 Write Access Time = 2 cycles */
+#define B2WAT_3			0x00003000  /* Bank 2 Write Access Time = 3 cycles */
+#define B2WAT_4			0x00004000  /* Bank 2 Write Access Time = 4 cycles */
+#define B2WAT_5			0x00005000  /* Bank 2 Write Access Time = 5 cycles */
+#define B2WAT_6			0x00006000  /* Bank 2 Write Access Time = 6 cycles */
+#define B2WAT_7			0x00007000  /* Bank 2 Write Access Time = 7 cycles */
+#define B2WAT_8			0x00008000  /* Bank 2 Write Access Time = 8 cycles */
+#define B2WAT_9			0x00009000  /* Bank 2 Write Access Time = 9 cycles */
+#define B2WAT_10		0x0000A000  /* Bank 2 Write Access Time = 10 cycles */
+#define B2WAT_11		0x0000B000  /* Bank 2 Write Access Time = 11 cycles */
+#define B2WAT_12		0x0000C000  /* Bank 2 Write Access Time = 12 cycles */
+#define B2WAT_13		0x0000D000  /* Bank 2 Write Access Time = 13 cycles */
+#define B2WAT_14		0x0000E000  /* Bank 2 Write Access Time = 14 cycles */
+#define B2WAT_15		0x0000F000  /* Bank 2 Write Access Time = 15 cycles */
+#define B3RDYEN			0x00010000  /* Bank 3 RDY enable, 0=disable, 1=enable */
+#define B3RDYPOL		0x00020000  /* Bank 3 RDY Active high, 0=active low, 1=active high */
+#define B3TT_1			0x00040000  /* Bank 3 Transition Time from Read to Write = 1 cycle */
+#define B3TT_2			0x00080000  /* Bank 3 Transition Time from Read to Write = 2 cycles */
+#define B3TT_3			0x000C0000  /* Bank 3 Transition Time from Read to Write = 3 cycles */
+#define B3TT_4			0x00000000  /* Bank 3 Transition Time from Read to Write = 4 cycles */
+#define B3ST_1			0x00100000  /* Bank 3 Setup Time from AOE asserted to Read or Write asserted = 1 cycle */
+#define B3ST_2			0x00200000  /* Bank 3 Setup Time from AOE asserted to Read or Write asserted = 2 cycles */
+#define B3ST_3			0x00300000  /* Bank 3 Setup Time from AOE asserted to Read or Write asserted = 3 cycles */
+#define B3ST_4			0x00000000  /* Bank 3 Setup Time from AOE asserted to Read or Write asserted = 4 cycles */
+#define B3HT_1			0x00400000  /* Bank 3 Hold Time from Read or Write deasserted to AOE deasserted = 1 cycle */
+#define B3HT_2			0x00800000  /* Bank 3 Hold Time from Read or Write deasserted to AOE deasserted = 2 cycles */
+#define B3HT_3			0x00C00000  /* Bank 3 Hold Time from Read or Write deasserted to AOE deasserted = 3 cycles */
+#define B3HT_0			0x00000000  /* Bank 3 Hold Time from Read or Write deasserted to AOE deasserted = 0 cycles */
+#define B3RAT_1			0x01000000 /* Bank 3 Read Access Time = 1 cycle */
+#define B3RAT_2			0x02000000  /* Bank 3 Read Access Time = 2 cycles */
+#define B3RAT_3			0x03000000  /* Bank 3 Read Access Time = 3 cycles */
+#define B3RAT_4			0x04000000  /* Bank 3 Read Access Time = 4 cycles */
+#define B3RAT_5			0x05000000  /* Bank 3 Read Access Time = 5 cycles */
+#define B3RAT_6			0x06000000  /* Bank 3 Read Access Time = 6 cycles */
+#define B3RAT_7			0x07000000  /* Bank 3 Read Access Time = 7 cycles */
+#define B3RAT_8			0x08000000  /* Bank 3 Read Access Time = 8 cycles */
+#define B3RAT_9			0x09000000  /* Bank 3 Read Access Time = 9 cycles */
+#define B3RAT_10		0x0A000000  /* Bank 3 Read Access Time = 10 cycles */
+#define B3RAT_11		0x0B000000  /* Bank 3 Read Access Time = 11 cycles */
+#define B3RAT_12		0x0C000000  /* Bank 3 Read Access Time = 12 cycles */
+#define B3RAT_13		0x0D000000  /* Bank 3 Read Access Time = 13 cycles */
+#define B3RAT_14		0x0E000000  /* Bank 3 Read Access Time = 14 cycles */
+#define B3RAT_15		0x0F000000  /* Bank 3 Read Access Time = 15 cycles */
+#define B3WAT_1			0x10000000 /* Bank 3 Write Access Time = 1 cycle */
+#define B3WAT_2			0x20000000  /* Bank 3 Write Access Time = 2 cycles */
+#define B3WAT_3			0x30000000  /* Bank 3 Write Access Time = 3 cycles */
+#define B3WAT_4			0x40000000  /* Bank 3 Write Access Time = 4 cycles */
+#define B3WAT_5			0x50000000  /* Bank 3 Write Access Time = 5 cycles */
+#define B3WAT_6			0x60000000  /* Bank 3 Write Access Time = 6 cycles */
+#define B3WAT_7			0x70000000  /* Bank 3 Write Access Time = 7 cycles */
+#define B3WAT_8			0x80000000  /* Bank 3 Write Access Time = 8 cycles */
+#define B3WAT_9			0x90000000  /* Bank 3 Write Access Time = 9 cycles */
+#define B3WAT_10		0xA0000000  /* Bank 3 Write Access Time = 10 cycles */
+#define B3WAT_11		0xB0000000  /* Bank 3 Write Access Time = 11 cycles */
+#define B3WAT_12		0xC0000000  /* Bank 3 Write Access Time = 12 cycles */
+#define B3WAT_13		0xD0000000  /* Bank 3 Write Access Time = 13 cycles */
+#define B3WAT_14		0xE0000000  /* Bank 3 Write Access Time = 14 cycles */
+#define B3WAT_15		0xF0000000  /* Bank 3 Write Access Time = 15 cycles */
+
+/* **********************  SDRAM CONTROLLER MASKS  *************************** */
+
+/* SDGCTL Masks */
+#define SCTLE			0x00000001 /* Enable SCLK[0], /SRAS, /SCAS, /SWE, SDQM[3:0] */
+#define CL_2			0x00000008 /* SDRAM CAS latency = 2 cycles */
+#define CL_3			0x0000000C /* SDRAM CAS latency = 3 cycles */
+#define PFE			0x00000010 /* Enable SDRAM prefetch */
+#define PFP			0x00000020 /* Prefetch has priority over AMC requests */
+#define TRAS_1			0x00000040 /* SDRAM tRAS = 1 cycle */
+#define TRAS_2			0x00000080 /* SDRAM tRAS = 2 cycles */
+#define TRAS_3			0x000000C0 /* SDRAM tRAS = 3 cycles */
+#define TRAS_4			0x00000100 /* SDRAM tRAS = 4 cycles */
+#define TRAS_5			0x00000140 /* SDRAM tRAS = 5 cycles */
+#define TRAS_6			0x00000180 /* SDRAM tRAS = 6 cycles */
+#define TRAS_7			0x000001C0 /* SDRAM tRAS = 7 cycles */
+#define TRAS_8			0x00000200 /* SDRAM tRAS = 8 cycles */
+#define TRAS_9			0x00000240 /* SDRAM tRAS = 9 cycles */
+#define TRAS_10			0x00000280 /* SDRAM tRAS = 10 cycles */
+#define TRAS_11			0x000002C0 /* SDRAM tRAS = 11 cycles */
+#define TRAS_12			0x00000300 /* SDRAM tRAS = 12 cycles */
+#define TRAS_13			0x00000340 /* SDRAM tRAS = 13 cycles */
+#define TRAS_14			0x00000380 /* SDRAM tRAS = 14 cycles */
+#define TRAS_15			0x000003C0 /* SDRAM tRAS = 15 cycles */
+#define TRP_1			0x00000800 /* SDRAM tRP = 1 cycle */
+#define TRP_2			0x00001000 /* SDRAM tRP = 2 cycles */
+#define TRP_3			0x00001800 /* SDRAM tRP = 3 cycles */
+#define TRP_4			0x00002000 /* SDRAM tRP = 4 cycles */
+#define TRP_5			0x00002800 /* SDRAM tRP = 5 cycles */
+#define TRP_6			0x00003000 /* SDRAM tRP = 6 cycles */
+#define TRP_7			0x00003800 /* SDRAM tRP = 7 cycles */
+#define TRCD_1			0x00008000 /* SDRAM tRCD = 1 cycle */
+#define TRCD_2			0x00010000 /* SDRAM tRCD = 2 cycles */
+#define TRCD_3			0x00018000 /* SDRAM tRCD = 3 cycles */
+#define TRCD_4			0x00020000 /* SDRAM tRCD = 4 cycles */
+#define TRCD_5			0x00028000 /* SDRAM tRCD = 5 cycles */
+#define TRCD_6			0x00030000 /* SDRAM tRCD = 6 cycles */
+#define TRCD_7			0x00038000 /* SDRAM tRCD = 7 cycles */
+#define TWR_1			0x00080000 /* SDRAM tWR = 1 cycle */
+#define TWR_2			0x00100000 /* SDRAM tWR = 2 cycles */
+#define TWR_3			0x00180000 /* SDRAM tWR = 3 cycles */
+#define PUPSD			0x00200000 /*Power-up start delay */
+#define PSM			0x00400000 /* SDRAM power-up sequence = Precharge, mode register set, 8 CBR refresh cycles */
+#define PSS				0x00800000 /* enable SDRAM power-up sequence on next SDRAM access */
+#define SRFS			0x01000000 /* Start SDRAM self-refresh mode */
+#define EBUFE			0x02000000 /* Enable external buffering timing */
+#define FBBRW			0x04000000 /* Fast back-to-back read write enable */
+#define EMREN			0x10000000 /* Extended mode register enable */
+#define TCSR			0x20000000 /* Temp compensated self refresh value 85 deg C */
+#define CDDBG			0x40000000 /* Tristate SDRAM controls during bus grant */
+
+/* EBIU_SDBCTL Masks */
+#define EBE			0x00000001 /* Enable SDRAM external bank */
+#define EBSZ_16			0x00000000 /* SDRAM external bank size = 16MB */
+#define EBSZ_32			0x00000002 /* SDRAM external bank size = 32MB */
+#define EBSZ_64			0x00000004 /* SDRAM external bank size = 64MB */
+#define EBSZ_128			0x00000006 /* SDRAM external bank size = 128MB */
+#define EBCAW_8			0x00000000 /* SDRAM external bank column address width = 8 bits */
+#define EBCAW_9			0x00000010 /* SDRAM external bank column address width = 9 bits */
+#define EBCAW_10			0x00000020 /* SDRAM external bank column address width = 9 bits */
+#define EBCAW_11			0x00000030 /* SDRAM external bank column address width = 9 bits */
+
+/* EBIU_SDSTAT Masks */
+#define SDCI			0x00000001 /* SDRAM controller is idle  */
+#define SDSRA			0x00000002 /* SDRAM SDRAM self refresh is active */
+#define SDPUA			0x00000004 /* SDRAM power up active  */
+#define SDRS			0x00000008 /* SDRAM is in reset state */
+#define SDEASE		      0x00000010 /* SDRAM EAB sticky error status - W1C */
+#define BGSTAT			0x00000020 /* Bus granted */
+
+/*VR_CTL Masks*/
+#define WAKE                    0x100
+#define VLEV_6                  0x60
+#define VLEV_7                  0x70
+#define VLEV_8                  0x80
+#define VLEV_9                  0x90
+#define VLEV_10                 0xA0
+#define VLEV_11                 0xB0
+#define VLEV_12                 0xC0
+#define VLEV_13                 0xD0
+#define VLEV_14                 0xE0
+#define VLEV_15                 0xF0
+#define FREQ_3                  0x03
+
+#endif	/* _DEF_BF532_H */
Index: git/linux-2.6/include/asm-blackfin/mach-bf533/dma.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf533/dma.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,56 @@
+/*****************************************************************************
+* $Id$
+*
+*        BF-533/2/1 Specific Declarations
+*
+****************************************************************************/
+/*
+ * File:         include/asm-blackfin/mach-bf533/dma.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MACH_DMA_H_
+#define _MACH_DMA_H_
+
+#define MAX_BLACKFIN_DMA_CHANNEL 12
+
+#define CH_PPI          0
+#define CH_SPORT0_RX    1
+#define CH_SPORT0_TX    2
+#define CH_SPORT1_RX    3
+#define CH_SPORT1_TX    4
+#define CH_SPI          5
+#define CH_UART_RX      6
+#define CH_UART_TX      7
+#define CH_MEM_STREAM0_DEST     8	// TX
+#define CH_MEM_STREAM0_SRC      9	// RX
+#define CH_MEM_STREAM1_DEST     10	// TX
+#define CH_MEM_STREAM1_SRC      11	// RX
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/mach-bf533/irq.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf533/irq.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,178 @@
+/*
+ * File:         include/asm-blackfin/mach-bf533/defBF532.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _BF533_IRQ_H_
+#define _BF533_IRQ_H_
+
+/*
+ * Interrupt source definitions
+             Event Source    Core Event Name
+Core        Emulation               **
+ Events         (highest priority)  EMU         0
+            Reset                   RST         1
+            NMI                     NMI         2
+            Exception               EVX         3
+            Reserved                --          4
+            Hardware Error          IVHW        5
+            Core Timer              IVTMR       6 *
+	    PLL Wakeup Interrupt    IVG7	7
+	    DMA Error (generic)	    IVG7	8
+	    PPI Error Interrupt     IVG7	9
+	    SPORT0 Error Interrupt  IVG7	10
+	    SPORT1 Error Interrupt  IVG7	11
+	    SPI Error Interrupt	    IVG7	12
+	    UART Error Interrupt    IVG7	13
+	    RTC Interrupt	    IVG8        14
+	    DMA0 Interrupt (PPI)    IVG8	15
+	    DMA1 (SPORT0 RX)	    IVG9	16
+	    DMA2 (SPORT0 TX)	    IVG9        17
+	    DMA3 (SPORT1 RX)        IVG9	18
+	    DMA4 (SPORT1 TX)	    IVG9	19
+	    DMA5 (PPI)		    IVG10	20
+	    DMA6 (UART RX)	    IVG10	21
+	    DMA7 (UART TX)	    IVG10	22
+	    Timer0		    IVG11	23
+	    Timer1		    IVG11	24
+	    Timer2		    IVG11	25
+	    PF Interrupt A	    IVG12	26
+	    PF Interrupt B	    IVG12	27
+	    DMA8/9 Interrupt	    IVG13	28
+	    DMA10/11 Interrupt	    IVG13	29
+	    Watchdog Timer	    IVG13	30
+            Software Interrupt 1    IVG14       31
+            Software Interrupt 2    --
+                 (lowest priority)  IVG15       32 *
+ */
+#define SYS_IRQS		32
+#define NR_PERI_INTS    24
+
+/* The ABSTRACT IRQ definitions */
+/** the first seven of the following are fixed, the rest you change if you need to **/
+#define	IRQ_EMU			0	/*Emulation */
+#define	IRQ_RST			1	/*reset */
+#define	IRQ_NMI			2	/*Non Maskable */
+#define	IRQ_EVX			3	/*Exception */
+#define	IRQ_UNUSED		4	/*- unused interrupt*/
+#define	IRQ_HWERR		5	/*Hardware Error */
+#define	IRQ_CORETMR		6	/*Core timer */
+
+#define	IRQ_PLL_WAKEUP		7	/*PLL Wakeup Interrupt */
+#define	IRQ_DMA_ERROR		8	/*DMA Error (general) */
+#define	IRQ_PPI_ERROR		9	/*PPI Error Interrupt */
+#define	IRQ_SPORT0_ERROR	10	/*SPORT0 Error Interrupt */
+#define	IRQ_SPORT1_ERROR	11	/*SPORT1 Error Interrupt */
+#define	IRQ_SPI_ERROR		12	/*SPI Error Interrupt */
+#define	IRQ_UART_ERROR		13	/*UART Error Interrupt */
+#define	IRQ_RTC			14	/*RTC Interrupt */
+#define	IRQ_PPI			15	/*DMA0 Interrupt (PPI) */
+#define	IRQ_SPORT0_RX		16	/*DMA1 Interrupt (SPORT0 RX) */
+#define	IRQ_SPORT0_TX		17	/*DMA2 Interrupt (SPORT0 TX) */
+#define	IRQ_SPORT1_RX		18	/*DMA3 Interrupt (SPORT1 RX) */
+#define	IRQ_SPORT1_TX		19	/*DMA4 Interrupt (SPORT1 TX) */
+#define IRQ_SPI			20	/*DMA5 Interrupt (SPI) */
+#define	IRQ_UART_RX		21	/*DMA6 Interrupt (UART RX) */
+#define	IRQ_UART_TX		22	/*DMA7 Interrupt (UART TX) */
+#define	IRQ_TMR0		23	/*Timer 0 */
+#define	IRQ_TMR1		24	/*Timer 1 */
+#define	IRQ_TMR2		25	/*Timer 2 */
+#define	IRQ_PROG_INTA		26	/*Programmable Flags A (8) */
+#define	IRQ_PROG_INTB		27	/*Programmable Flags B (8) */
+#define	IRQ_MEM_DMA0		28	/*DMA8/9 Interrupt (Memory DMA Stream 0) */
+#define	IRQ_MEM_DMA1		29	/*DMA10/11 Interrupt (Memory DMA Stream 1) */
+#define	IRQ_WATCH	   	30	/*Watch Dog Timer */
+
+#define	IRQ_SW_INT1		31	/*Software Int 1 */
+#define	IRQ_SW_INT2		32	/*Software Int 2 (reserved for SYSCALL) */
+
+#define IRQ_PF0			33
+#define IRQ_PF1			34
+#define IRQ_PF2			35
+#define IRQ_PF3			36
+#define IRQ_PF4			37
+#define IRQ_PF5			38
+#define IRQ_PF6			39
+#define IRQ_PF7			40
+#define IRQ_PF8			41
+#define IRQ_PF9			42
+#define IRQ_PF10		43
+#define IRQ_PF11		44
+#define IRQ_PF12		45
+#define IRQ_PF13		46
+#define IRQ_PF14		47
+#define IRQ_PF15		48
+
+#ifdef CONFIG_IRQCHIP_DEMUX_GPIO
+#define	NR_IRQS		(IRQ_PF15+1)
+#else
+#define	NR_IRQS		SYS_IRQS
+#endif
+
+#define IVG7			7
+#define IVG8			8
+#define IVG9			9
+#define IVG10			10
+#define IVG11			11
+#define IVG12			12
+#define IVG13			13
+#define IVG14			14
+#define IVG15			15
+
+/* IAR0 BIT FIELDS*/
+#define RTC_ERROR_POS			28
+#define UART_ERROR_POS			24
+#define SPORT1_ERROR_POS		20
+#define SPI_ERROR_POS			16
+#define SPORT0_ERROR_POS		12
+#define PPI_ERROR_POS			8
+#define DMA_ERROR_POS			4
+#define PLLWAKE_ERROR_POS		0
+
+/* IAR1 BIT FIELDS*/
+#define DMA7_UARTTX_POS			28
+#define DMA6_UARTRX_POS			24
+#define DMA5_SPI_POS			20
+#define DMA4_SPORT1TX_POS		16
+#define DMA3_SPORT1RX_POS		12
+#define DMA2_SPORT0TX_POS		8
+#define DMA1_SPORT0RX_POS		4
+#define DMA0_PPI_POS			0
+
+/* IAR2 BIT FIELDS*/
+#define WDTIMER_POS			28
+#define MEMDMA1_POS			24
+#define MEMDMA0_POS			20
+#define PFB_POS				16
+#define PFA_POS				12
+#define TIMER2_POS			8
+#define TIMER1_POS			4
+#define TIMER0_POS			0
+
+#endif				/* _BF533_IRQ_H_ */
Index: git/linux-2.6/include/asm-blackfin/mach-bf533/mem_init.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf533/mem_init.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,314 @@
+/*
+ * File:         include/asm-blackfin/mach-bf533/mem_init.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#if ( CONFIG_MEM_MT48LC16M16A2TG_75  ||  CONFIG_MEM_MT48LC64M4A2FB_7E  || CONFIG_MEM_GENERIC_BOARD)
+#if ( CONFIG_SCLK_HZ > 119402985 )
+#define SDRAM_tRP       TRP_2
+#define SDRAM_tRP_num   2
+#define SDRAM_tRAS      TRAS_7
+#define SDRAM_tRAS_num  7
+#define SDRAM_tRCD      TRCD_2
+#define SDRAM_tWR       TWR_2
+#endif
+#if ( CONFIG_SCLK_HZ > 104477612 ) && ( CONFIG_SCLK_HZ <= 119402985 )
+#define SDRAM_tRP       TRP_2
+#define SDRAM_tRP_num   2
+#define SDRAM_tRAS      TRAS_6
+#define SDRAM_tRAS_num  6
+#define SDRAM_tRCD      TRCD_2
+#define SDRAM_tWR       TWR_2
+#endif
+#if ( CONFIG_SCLK_HZ >  89552239 ) && ( CONFIG_SCLK_HZ <= 104477612 )
+#define SDRAM_tRP       TRP_2
+#define SDRAM_tRP_num   2
+#define SDRAM_tRAS      TRAS_5
+#define SDRAM_tRAS_num  5
+#define SDRAM_tRCD      TRCD_2
+#define SDRAM_tWR       TWR_2
+#endif
+#if ( CONFIG_SCLK_HZ >  74626866 ) && ( CONFIG_SCLK_HZ <=  89552239 )
+#define SDRAM_tRP       TRP_2
+#define SDRAM_tRP_num   2
+#define SDRAM_tRAS      TRAS_4
+#define SDRAM_tRAS_num  4
+#define SDRAM_tRCD      TRCD_2
+#define SDRAM_tWR       TWR_2
+#endif
+#if ( CONFIG_SCLK_HZ >  66666667 ) && ( CONFIG_SCLK_HZ <= 74626866 )
+#define SDRAM_tRP       TRP_2
+#define SDRAM_tRP_num   2
+#define SDRAM_tRAS      TRAS_3
+#define SDRAM_tRAS_num  3
+#define SDRAM_tRCD      TRCD_2
+#define SDRAM_tWR       TWR_2
+#endif
+#if ( CONFIG_SCLK_HZ >  59701493 ) && ( CONFIG_SCLK_HZ <= 66666667 )
+#define SDRAM_tRP       TRP_1
+#define SDRAM_tRP_num   1
+#define SDRAM_tRAS      TRAS_4
+#define SDRAM_tRAS_num  3
+#define SDRAM_tRCD      TRCD_1
+#define SDRAM_tWR       TWR_2
+#endif
+#if ( CONFIG_SCLK_HZ >  44776119 ) && ( CONFIG_SCLK_HZ <=  59701493 )
+#define SDRAM_tRP       TRP_1
+#define SDRAM_tRP_num   1
+#define SDRAM_tRAS      TRAS_3
+#define SDRAM_tRAS_num  3
+#define SDRAM_tRCD      TRCD_1
+#define SDRAM_tWR       TWR_2
+#endif
+#if ( CONFIG_SCLK_HZ >  29850746 ) && ( CONFIG_SCLK_HZ <=  44776119 )
+#define SDRAM_tRP       TRP_1
+#define SDRAM_tRP_num   1
+#define SDRAM_tRAS      TRAS_2
+#define SDRAM_tRAS_num  2
+#define SDRAM_tRCD      TRCD_1
+#define SDRAM_tWR       TWR_2
+#endif
+#if ( CONFIG_SCLK_HZ <=  29850746 )
+#define SDRAM_tRP       TRP_1
+#define SDRAM_tRP_num   1
+#define SDRAM_tRAS      TRAS_1
+#define SDRAM_tRAS_num  1
+#define SDRAM_tRCD      TRCD_1
+#define SDRAM_tWR       TWR_2
+#endif
+#endif
+
+#if (CONFIG_MEM_MT48LC16M16A2TG_75)
+  /*SDRAM INFORMATION: */
+#define SDRAM_Tref  64		/* Refresh period in milliseconds   */
+#define SDRAM_NRA   8192	/* Number of row addresses in SDRAM */
+#define SDRAM_CL    CL_3
+#endif
+
+#if (CONFIG_MEM_MT48LC64M4A2FB_7E)
+  /*SDRAM INFORMATION: */
+#define SDRAM_Tref  64		/* Refresh period in milliseconds   */
+#define SDRAM_NRA   8192	/* Number of row addresses in SDRAM */
+#define SDRAM_CL    CL_3
+#endif
+
+#if (CONFIG_MEM_GENERIC_BOARD)
+  /*SDRAM INFORMATION: Modify this for your board */
+#define SDRAM_Tref  64		/* Refresh period in milliseconds   */
+#define SDRAM_NRA   8192	/* Number of row addresses in SDRAM */
+#define SDRAM_CL    CL_3
+#endif
+
+#if ( CONFIG_MEM_SIZE == 128 )
+#define SDRAM_SIZE      EBSZ_128
+#endif
+#if ( CONFIG_MEM_SIZE == 64 )
+#define SDRAM_SIZE      EBSZ_64
+#endif
+#if (  CONFIG_MEM_SIZE == 32 )
+#define SDRAM_SIZE      EBSZ_32
+#endif
+#if ( CONFIG_MEM_SIZE == 16 )
+#define SDRAM_SIZE      EBSZ_16
+#endif
+#if ( CONFIG_MEM_ADD_WIDTH == 11 )
+#define SDRAM_WIDTH     EBCAW_11
+#endif
+#if ( CONFIG_MEM_ADD_WIDTH == 10 )
+#define SDRAM_WIDTH     EBCAW_10
+#endif
+#if ( CONFIG_MEM_ADD_WIDTH == 9 )
+#define SDRAM_WIDTH     EBCAW_9
+#endif
+#if ( CONFIG_MEM_ADD_WIDTH == 8 )
+#define SDRAM_WIDTH     EBCAW_8
+#endif
+
+#define mem_SDBCTL      SDRAM_WIDTH | SDRAM_SIZE | EBE
+
+/* Equation from section 17 (p17-46) of BF533 HRM */
+#define mem_SDRRC       ((( CONFIG_SCLK_HZ / 1000) * SDRAM_Tref)  / SDRAM_NRA) - (SDRAM_tRAS_num + SDRAM_tRP_num)
+
+/* Enable SCLK Out */
+#define mem_SDGCTL        ( SCTLE | SDRAM_CL | SDRAM_tRAS | SDRAM_tRP | SDRAM_tRCD | SDRAM_tWR | PSS )
+
+#if defined CONFIG_CLKIN_HALF
+#define CLKIN_HALF       1
+#else
+#define CLKIN_HALF       0
+#endif
+
+#if defined CONFIG_PLL_BYPASS
+#define PLL_BYPASS      1
+#else
+#define PLL_BYPASS       0
+#endif
+
+/***************************************Currently Not Being Used *********************************/
+#define flash_EBIU_AMBCTL_WAT  ( ( CONFIG_FLASH_SPEED_BWAT * 4 )  / ( 4000000000 / CONFIG_SCLK_HZ ) ) + 1
+#define flash_EBIU_AMBCTL_RAT  ( ( CONFIG_FLASH_SPEED_BRAT * 4 )  / ( 4000000000 / CONFIG_SCLK_HZ ) ) + 1
+#define flash_EBIU_AMBCTL_HT   ( ( CONFIG_FLASH_SPEED_BHT  * 4 )  / ( 4000000000 / CONFIG_SCLK_HZ ) )
+#define flash_EBIU_AMBCTL_ST   ( ( CONFIG_FLASH_SPEED_BST  * 4 )  / ( 4000000000 / CONFIG_SCLK_HZ ) ) + 1
+#define flash_EBIU_AMBCTL_TT   ( ( CONFIG_FLASH_SPEED_BTT  * 4 )  / ( 4000000000 / CONFIG_SCLK_HZ ) ) + 1
+
+#if (flash_EBIU_AMBCTL_TT > 3 )
+#define flash_EBIU_AMBCTL0_TT   B0TT_4
+#endif
+#if (flash_EBIU_AMBCTL_TT == 3 )
+#define flash_EBIU_AMBCTL0_TT   B0TT_3
+#endif
+#if (flash_EBIU_AMBCTL_TT == 2 )
+#define flash_EBIU_AMBCTL0_TT   B0TT_2
+#endif
+#if (flash_EBIU_AMBCTL_TT < 2 )
+#define flash_EBIU_AMBCTL0_TT   B0TT_1
+#endif
+
+#if (flash_EBIU_AMBCTL_ST > 3 )
+#define flash_EBIU_AMBCTL0_ST   B0ST_4
+#endif
+#if (flash_EBIU_AMBCTL_ST == 3 )
+#define flash_EBIU_AMBCTL0_ST   B0ST_3
+#endif
+#if (flash_EBIU_AMBCTL_ST == 2 )
+#define flash_EBIU_AMBCTL0_ST   B0ST_2
+#endif
+#if (flash_EBIU_AMBCTL_ST < 2 )
+#define flash_EBIU_AMBCTL0_ST   B0ST_1
+#endif
+
+#if (flash_EBIU_AMBCTL_HT > 2 )
+#define flash_EBIU_AMBCTL0_HT   B0HT_3
+#endif
+#if (flash_EBIU_AMBCTL_HT == 2 )
+#define flash_EBIU_AMBCTL0_HT   B0HT_2
+#endif
+#if (flash_EBIU_AMBCTL_HT == 1 )
+#define flash_EBIU_AMBCTL0_HT   B0HT_1
+#endif
+#if (flash_EBIU_AMBCTL_HT == 0  && CONFIG_FLASH_SPEED_BHT == 0)
+#define flash_EBIU_AMBCTL0_HT   B0HT_0
+#endif
+#if (flash_EBIU_AMBCTL_HT == 0  && CONFIG_FLASH_SPEED_BHT != 0)
+#define flash_EBIU_AMBCTL0_HT   B0HT_1
+#endif
+
+#if (flash_EBIU_AMBCTL_WAT > 14)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_15
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 14)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_14
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 13)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_13
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 12)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_12
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 11)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_11
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 10)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_10
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 9)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_9
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 8)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_8
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 7)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_7
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 6)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_6
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 5)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_5
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 4)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_4
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 3)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_3
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 2)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_2
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 1)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_1
+#endif
+
+#if (flash_EBIU_AMBCTL_RAT > 14)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_15
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 14)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_14
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 13)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_13
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 12)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_12
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 11)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_11
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 10)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_10
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 9)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_9
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 8)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_8
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 7)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_7
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 6)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_6
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 5)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_5
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 4)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_4
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 3)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_3
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 2)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_2
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 1)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_1
+#endif
+
+#define flash_EBIU_AMBCTL0  flash_EBIU_AMBCTL0_WAT | flash_EBIU_AMBCTL0_RAT | flash_EBIU_AMBCTL0_HT | flash_EBIU_AMBCTL0_ST | flash_EBIU_AMBCTL0_TT | CONFIG_FLASH_SPEED_RDYEN
Index: git/linux-2.6/include/asm-blackfin/mach-bf533/mem_map.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf533/mem_map.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,136 @@
+
+/*
+ * File:         include/asm-blackfin/mach-bf533/mem_map.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MEM_MAP_533_H_
+#define _MEM_MAP_533_H_
+
+#define COREMMR_BASE           0xFFE00000	// Core MMRs
+#define SYSMMR_BASE            0xFFC00000	// System MMRs
+
+/* Level 3 SDRAM Memory */
+#define RAM_START		0x1000
+#define RAM_LENGTH		(CONFIG_MEM_SIZE * 1024 * 1024)
+#define RAM_END 		(CONFIG_MEM_SIZE * 1024 * 1024)
+
+/* Async Memory Banks */
+#define ASYNC_BANK3_BASE	0x20300000	// Async Bank 3
+#define ASYNC_BANK3_SIZE	0x00100000	/* 1M */
+#define ASYNC_BANK2_BASE	0x20200000	// Async Bank 2
+#define ASYNC_BANK2_SIZE	0x00100000	/* 1M */
+#define ASYNC_BANK1_BASE	0x20100000	// Async Bank 1
+#define ASYNC_BANK1_SIZE	0x00100000	/* 1M */
+#define ASYNC_BANK0_BASE	0x20000000	// Async Bank 0
+#define ASYNC_BANK0_SIZE	0x00100000	/* 1M */
+
+/* Level 1 Memory */
+
+/* Memory Map for ADSP-BF533 processors */
+
+#ifdef CONFIG_BF533
+#define L1_CODE_START       0xFFA00000
+#define L1_DATA_A_START     0xFF800000
+#define L1_DATA_B_START     0xFF900000
+
+#ifdef CONFIG_BLKFIN_CACHE
+#define L1_CODE_LENGTH      (0x14000 - 0x4000)
+#else
+#define L1_CODE_LENGTH      0x14000
+#endif
+
+#ifdef CONFIG_BLKFIN_DCACHE
+#define DMEM_CNTR (ACACHE_BCACHE | ENDCPLB | PORT_PREF0)
+#define L1_DATA_A_LENGTH      (0x8000 - 0x4000)
+#else
+#define DMEM_CNTR (ASRAM_BSRAM | ENDCPLB | PORT_PREF0)
+#define L1_DATA_A_LENGTH      0x8000
+#endif
+
+#ifdef CONFIG_BLKFIN_DCACHE
+#define L1_DATA_B_LENGTH      (0x8000 - 0x4000)
+#else
+#define L1_DATA_B_LENGTH      0x8000
+#endif
+#endif
+
+/* Memory Map for ADSP-BF532 processors */
+
+#ifdef CONFIG_BF532
+#define L1_CODE_START       0xFFA08000
+#define L1_DATA_A_START     0xFF804000
+#define L1_DATA_B_START     0xFF904000
+
+#ifdef CONFIG_BLKFIN_CACHE
+#define L1_CODE_LENGTH      (0xC000 - 0x4000)
+#else
+#define L1_CODE_LENGTH      0xC000
+#endif
+
+#ifdef CONFIG_BLKFIN_DCACHE
+#define DMEM_CNTR (ACACHE_BCACHE | ENDCPLB | PORT_PREF0)
+#define L1_DATA_A_LENGTH      (0x4000 - 0x4000)
+#else
+#define DMEM_CNTR (ASRAM_BSRAM | ENDCPLB | PORT_PREF0)
+#define L1_DATA_A_LENGTH      0x4000
+#endif
+
+#ifdef CONFIG_BLKFIN_DCACHE
+#define L1_DATA_B_LENGTH      (0x4000 - 0x4000)
+#else
+#define L1_DATA_B_LENGTH      0x4000
+#endif
+#endif
+
+/* Memory Map for ADSP-BF531 processors */
+
+#ifdef CONFIG_BF531
+#define L1_CODE_START       0xFFA08000
+#define L1_DATA_A_START     0xFF804000
+#define L1_DATA_B_START     0xFF904000
+#define L1_CODE_LENGTH      0x4000
+#define L1_DATA_B_LENGTH      0x0000
+#ifdef CONFIG_BLKFIN_DCACHE
+#define DMEM_CNTR (ACACHE_BSRAM | ENDCPLB)
+#define L1_DATA_A_LENGTH      (0x4000 - 0x4000)
+#else
+#define DMEM_CNTR (ASRAM_BSRAM | ENDCPLB)
+#define L1_DATA_A_LENGTH      0x4000
+#endif
+#endif
+
+/* Scratch Pad Memory */
+
+#if defined(CONFIG_BF533) || defined(CONFIG_BF532) || defined(CONFIG_BF531)
+#define L1_SCRATCH_START	0xFFB00000
+#define L1_SCRATCH_LENGTH	0x1000
+#endif
+
+#endif				/* _MEM_MAP_533_H_ */
Index: git/linux-2.6/include/asm-blackfin/mach-bf535/bf535.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf535/bf535.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,1285 @@
+
+/*
+ * File:         include/asm-blackfin/mach-bf533/bf535.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+/*
+ * Copyright (c) 2000, 2001 by Lineo, Inc./Lineo Canada Corp. (www.lineo.com),
+ * Copyright (c) 2001,2002 by Arcturus Networks Inc. (www.arcturusnetworks.com),
+ */
+
+/* FOR BlackFin DSP:     BYTE = 08 bits,  HALFWORD = 16 bit & WORD = 32 bits    */
+
+#ifndef _BF535_H_
+#define _BF535_H_
+
+#define BYTE_REF(addr)		 (*((volatile unsigned char*)addr))
+#define HALFWORD_REF(addr) 	 (*((volatile unsigned short*)addr))
+#define WORD_REF(addr)		 (*((volatile unsigned long*)addr))
+
+/*
+ * Typedefs
+ */
+typedef unsigned long UINT32;
+typedef unsigned short UINT16;
+typedef unsigned char UCHAR;
+
+#define PUT_FIELD(field, val) (((val) << field##_SHIFT) & field##_MASK)	/* ?  */
+#define GET_FIELD(reg, field) (((reg) & field##_MASK) >> field##_SHIFT)	/*  ?   */
+
+/*      FOLLOWING ARE THE BlackFin SYSTEM MMR REGISTERS (LOWER 2 MB)     */
+
+/**************************
+ *
+ * L2 MULTIPLE INPUT SIGNATURE REGISTERS (MISR) (0XFFC0000 - 0XFFC003FF)
+ *
+ **************************/
+
+#define MISR_CTL_ADDR		0xffc00000	/* Control register 32 bit */
+#define MISR_CTL			WORD_REF(MISR_CTL_ADDR)
+#define MISR_RMISR0_ADDR	0xffc00004	/* CoreL2[31:0] read bus register 32 bit */
+#define MISR_RMISR0			WORD_REF(MISR_RMISR0_ADDR)
+#define MISR_RMISR1_ADDR	0xffc00008	/* CoreL2[63:32] read bus register 32 bit */
+#define MISR_RMISR1			WORD_REF(MISR_RMISR1_ADDR)
+#define MISR_RMISR2_ADDR	0xffc0000C	/* SysL2[31:0] read bus register 32 bit */
+#define MISR_RMISR2			WORD_REF(MISR_RMISR2_ADDR)
+#define MISR_WMISR0_ADDR	0xffc00010	/* CoreL2[31:0] write bus register 32 bit */
+#define MISR_WMISR0			WORD_REF(MISR_WMISR0_ADDR)
+#define MISR_WMISR1_ADDR	0xffc00014	/* CoreL2[63:32] write bus register 32 bit */
+#define MISR_WMISR1			WORD_REF(MISR_WMISR1_ADDR)
+#define MISR_WMISR2_ADDR	0xffc00018	/* SysL2[31:0] write bus register 32 bit */
+#define MISR_WMISR2			WORD_REF(MISR_WMISR2_ADDR)
+
+/**************************
+ *
+ * CLOCK & SYSTEM CONTROL (0XFFC0400 - 0XFFC007FF)
+ *
+ **************************/
+
+#define PLLCTL_ADDR			0xffc00400	/* PLL control register 32 bit */
+#define PLLCTL				WORD_REF(PLLCTL_ADDR)
+#define PLLSTAT_ADDR		0xffc00404	/* PLL status register 16 bit */
+#define PLLSTAT				HALFWORD_REF(PLLSTAT_ADDR)
+#define LOCKCNT_ADDR		0xffc00406	/* PLL lock counter register 16 bit */
+#define LOCKCNT				HALFWORD_REF(LOCKCNT_ADDR)
+#define IOCKR_ADDR			0xffc00408	/* Peripheral clock enable register 16 bit */
+#define IOCKR				HALFWORD_REF(IOCKR_ADDR)
+#define SWRST_ADDR			0xffc00410	/* Software reset register 16 bit */
+#define SWRST				HALFWORD_REF(SWRST_ADDR)
+#define NXTSCR_ADDR			0xffc00412	/* Next system configuration register 16 bit */
+#define NXTSCR				HALFWORD_REF(NXTSCR_ADDR)
+#define SYSCR_ADDR			0xffc00414	/* Sytem Configuration register */
+#define SYSCR 				HALFWORD_REF(SYSCR_ADDR)
+
+/**************************
+ *
+ * JTAG/DEBUG COMMUNICATION CHANNEL (0XFFC00800 - 0XFFC00BFF)
+ *
+ **************************/
+
+#define INDATA_ADDR			0xffc00800	/* Indata register 16 bit */
+#define INDATA				HALFWORD_REF(INDATA_ADDR)
+#define OUTDATA_ADDR		0xffc00802	/*  Outdata register  16 bit */
+#define OUTDATA				HALFWORD_REF(OUTDATA_ADDR)
+#define JDCSR_ADDR			0xffc00804	/*  JDCC Control/Status register 32 bit */
+#define JDCSR				WORD_REF(JDCSR_ADDR)
+#define IDDEV_ADDR			0xffc00808	/*  Device ID register  32 bit */
+#define IDDEV				WORD_REF(IDDEV_ADDR)
+#define IDCORE_ADDR			0xffc0080c	/*  Core ID register 32 bit */
+#define IDCORE				WORD_REF(IDCORE_ADDR)
+
+/****************************
+ *
+ *  EXTENDED CORE INTERRUPT CONTROLLER (ECIC) 0XFFC00C00 - 0XFFC0OFFF
+ *
+ ****************************/
+
+#define RVECT_ADDR			0xffc00c00	/* Reset vector register 32 bit */
+#define RVECT				WORD_REF(RVECT_ADDR)
+#define IAR0_ADDR			0xffc00c04	/* Interrupt assignment register 0 32 bit */
+#define IAR0				WORD_REF(IAR0_ADDR)
+#define IAR1_ADDR			0xffc00c08	/* Interrupt assignment register 1 32 bit */
+#define IAR1				WORD_REF(IAR1_ADDR)
+#define IAR2_ADDR			0xffc00c0c	/* Interrupt assignment register 2 32 bit */
+#define IAR2				WORD_REF(IAR2_ADDR)
+#define IMR_ADDR			0xffc00c10	/* Interrupt mask register  32 bit */
+#define IMR				WORD_REF(IMR_ADDR)
+#define ISR_ADDR			0xffc00c14	/* Interrupt status register  32 bit */
+#define ISR				WORD_REF(ISR_ADDR)
+#define IWR_ADDR			0xffc00c18	/* Interrupt wakeup register  32 bit */
+#define IWR				WORD_REF(IWR_ADDR)
+
+/****************************
+ *
+ *  WATCHDOG TIMER  (0XFFC01000 - 0XFFC013F)
+ *
+ ****************************/
+
+#define WDOGCTL_ADDR		0xffc01000	/* Watchdog control register  32 bit */
+#define WDOGCTL				WORD_REF(WDOGCTL_ADDR)
+#define WDOGCNT_ADDR		0xffc01004	/* Watchdog count register 32 bit */
+#define WDOGCNT				WORD_REF(WDOGCNT_ADDR)
+#define WDOGSTAT_ADDR		0xffc01008	/* Watchdog status register 32 bit */
+#define WDOGSTAT			WORD_REF(WDOGSTAT_ADDR)
+
+/****************************
+ *
+ *  REAL TIME CLOCK (RTC) REGISTERS  (0XFFC01400 - 0XFFC017FF)
+ *
+ ****************************/
+
+#define RTCSTAT_ADDR		0xffc01400	/* RTC status register  32 bit */
+#define RTCSTAT				WORD_REF(RTCSTAT_ADDR)
+#define RTCICTL_ADDR		0xffc01404	/* RTC Interrupt control register  32 bit */
+#define RTCICTL				WORD_REF(RTCICTL_ADDR)
+#define RTCISTAT_ADDR		0xffc01408	/* RTC Interrupt status register  32 bit */
+#define RTCISTAT			WORD_REF(RTCISTAT_ADDR)
+#define RTCSWCNT_ADDR		0xffc0140c	/* RTC Stop watch count register  32 bit */
+#define RTCSWCNT			WORD_REF(RTCSWCNT_ADDR)
+#define RTCALARM_ADDR		0xffc01410	/* RTC Alarm time register  32 bit */
+#define RTCALARM			WORD_REF(RTCALARM_ADDR)
+#define RTCFAST_ADDR		0xffc01414	/* RTC Prescalar control register  32 bit */
+#define RTCFAST				WORD_REF(RTCFAST_ADDR)
+
+/****************************
+ *
+ *  UART 0 CONTROLLER REGISTERS  (0XFFC01800 - 0XFFC01BFF)
+ *
+ ****************************/
+
+#define UART0_THR_ADDR		0xffc01800	/* UART 0 Transmit holding register  16 bit */
+#define UART0_THR			HALFWORD_REF(UART0_THR_ADDR)
+#define UART0_THR_MASK		0x00ff	/* Data to be transmitted */
+
+#define UART0_RBR_ADDR		0xffc01800	/* UART 0 Receive buffer register  16 bit */
+#define UART0_RBR			HALFWORD_REF(UART0_RBR_ADDR)
+#define UART0_RBR_MASK		0x00ff	/* Data to be received */
+
+#define UART0_DLL_ADDR		0xffc01800	/* UART 0 Divisor latch (low byte) register  16 bit */
+#define UART0_DLL			HALFWORD_REF(UART0_DLL_ADDR)
+
+#define UART0_IER_ADDR		0xffc01802	/* UART 0 Interrupt enable register  16 bit */
+#define UART0_IER			HALFWORD_REF(UART0_IER_ADDR)
+#define UART0_IER_ERBFI			0x01	/* Enable Receive Buffer Full Interrupt(DR bit) */
+#define UART0_IER_ETBEI			0x02	/* Enable Transmit Buffer Empty Interrupt(THRE bit) */
+#define UART0_IER_ELSI			0x04	/* Enable RX Status Interrupt(gen if any of LSR[4:1] set) */
+#define UART0_IER_EDDSI			0x08	/* Enable Modem Status Interrupt(gen if any UARTx_MSR[3:0] set) */
+
+#define UART0_DLH_ADDR		0xffc01802	/* UART 0 Divisor latch (high byte) register  16 bit */
+#define UART0_DLH			HALFWORD_REF(UART0_DLH_ADDR)
+#define UART0_IIR_ADDR		0xffc01804	/* UART 0 Interrupt identification register  16 bit */
+#define UART0_IIR			HALFWORD_REF(UART0_IIR_ADDR)
+#define UART0_IIR_NOINT			0x01	/* Bit0: cleared when no interrupt */
+#define UART0_IIR_STATUS		0x06	/* mask bit for the status: bit2-1 */
+#define UART0_IIR_LSR			0x06	/* Receive line status */
+#define UART0_IIR_RBR			0x04	/* Receive data ready */
+#define UART0_IIR_THR			0x02	/* Ready to transmit  */
+#define UART0_IIR_MSR			0x00	/* Modem status       */
+
+#define UART0_LCR_ADDR		0xffc01806	/* UART 0 Line control register  16 bit */
+#define UART0_LCR			HALFWORD_REF(UART0_LCR_ADDR)
+#define UART0_LCR_WLS5			0	/* word length 5 bits */
+#define UART0_LCR_WLS6			0x01	/* word length 6 bits */
+#define UART0_LCR_WLS7			0x02	/* word length 7 bits */
+#define UART0_LCR_WLS8			0x03	/* word length 8 bits */
+#define UART0_LCR_STB			0x04	/* StopBit: 1: 2 stop bits for non-5-bit word length
+						   1/2 stop bits for 5-bit word length
+						   0: 1 stop bit */
+#define UART0_LCR_PEN			0x08	/* Parity Enable 1: for enable */
+#define UART0_LCR_EPS			0x10	/* Parity Selection: 1: for even pariety
+						   0: odd parity when PEN =1 & SP =0 */
+#define UART0_LCR_SP			0x20	/* Sticky Parity: */
+#define UART0_LCR_SB			0x40	/* Set Break: force TX pin to 0 */
+#define UART0_LCR_DLAB			0x80	/* Divisor Latch Access */
+
+#define UART0_MCR_ADDR		0xffc01808	/* UART 0 Module Control register  16 bit */
+#define UART0_MCR			HALFWORD_REF(UART0_MCR_ADDR)
+
+#define UART0_LSR_ADDR		0xffc0180a	/* UART 0 Line status register  16 bit */
+#define UART0_LSR			HALFWORD_REF(UART0_LSR_ADDR)
+#define UART0_LSR_DR			0x01	/* Data Ready */
+#define UART0_LSR_OE			0x02	/* Overrun Error */
+#define UART0_LSR_PE			0x04	/* Parity Error  */
+#define UART0_LSR_FE			0x08	/* Frame Error   */
+#define UART0_LSR_BI			0x10	/* Break Interrupt */
+#define UART0_LSR_THRE			0x20	/* THR empty, REady to accept */
+#define UART0_LSR_TEMT			0x40	/* TSR and UARTx_thr both empty */
+
+#define UART0_MSR_ADDR		0xffc0180c	/* UART 0 Modem status register  16 bit */
+#define UART0_MSR			HALFWORD_REF(UART0_MSR_ADDR
+#define UART0_SCR_ADDR		0xffc0180e	/* UART 0 Scratch register  16 bit */
+#define UART0_SCR			HALFWORD_REF(UART0_SCR_ADDR)
+#define UART0_IRCR_ADDR		0xffc01810	/* UART 0 IrDA Control register  16 bit */
+#define UART0_IRCR			HALFWORD_REF(UART0_IRCR_ADDR)
+
+#define UART0_CURR_PTR_RX_ADDR		0xffc01a00	/* UART 0 RCV DMA Current pointer register 16 bit */
+#define UART0_CURR_PTR_RX			HALFWORD_REF(UART0_CURR_PTR_RX_ADDR)
+#define UART0_CONFIG_RX_ADDR		0xffc01a02	/* UART 0 RCV DMA Configuration register 16 bit */
+#define UART0_CONFIG_RX				HALFWORD_REF(UART0_CONFIG_RX_ADDR)
+#define UART0_START_ADDR_HI_RX_ADDR	0xffc01a04	/* UART 0 RCV DMA start add. hi reg 16 bit */
+#define UART0_START_ADDR_HI_RX		HALFWORD_REF(UART0_START_ADDR_HI_RX_ADDR)
+#define UART0_START_ADDR_LO_RX_ADDR	0xffc01a06	/* UART 0 RCV DMA start add. lo reg 16 bit */
+#define UART0_START_ADDR_LO_RX		HALFWORD_REF(UART0_START_ADDR_LO_RX_ADDR)
+#define UART0_COUNT_RX_ADDR			0xffc01a08	/* UART 0 RCV DMA count register  16 bit */
+#define UART0_COUNT_RX				HALFWORD_REF(UART0_COUNT_RX_ADDR)
+#define UART0_NEXT_DESCR_RX_ADDR    0xffc01a0a	/*UART 0 RCV DMA next descripter poin reg 16 bit */
+#define UART0_NEXT_DESCR_RX			HALFWORD_REF(UART0_NEXT_DESCR_RX_ADDR)
+#define UART0_DESCR_RDY_RX_ADDR		0xffc01a0c	/* UART 0 RCV DMA descripter ready reg 16 bit */
+#define UART0_DESCR_RDY_RX			HALFWORD_REF(UART0_DESCR_RDY_RX_ADDR)
+#define UART0_IRQSTAT_RX_ADDR		0xffc01a0e	/* UART 0 RCV DMA Interrupt register  16 bit */
+#define UART0_IRQSTAT_RX			HALFWORD_REF(UART0_IRQSTAT_RX_ADDR)
+
+#define UART0_CURR_PTR_TX_ADDR		0xffc01b00	/* UART 0 XMT DMA Current pointer register 16 bit */
+#define UART0_CURR_PTR_TX			HALFWORD_REF(UART0_CURR_PTR_TX_ADDR)
+#define UART0_CONFIG_TX_ADDR		0xffc01b02	/* UART 0 XMT DMA Configuration register 16 bit */
+#define UART0_CONFIG_TX				HALFWORD_REF(UART0_CONFIG_TX_ADDR)
+#define UART0_START_ADDR_HI_TX_ADDR	0xffc01b04	/* UART 0 XMT DMA start add. hi reg 16 bit */
+#define UART0_START_ADDR_HI_TX		HALFWORD_REF(UART0_START_ADDR_HI_TX_ADDR)
+#define UART0_START_ADDR_LO_TX_ADDR	0xffc01b06	/* UART 0 XMT DMA start add. lo reg 16 bit */
+#define UART0_START_ADDR_LO_TX		HALFWORD_REF(UART0_START_ADDR_LO_TX_ADDR)
+#define UART0_COUNT_TX_ADDR			0xffc01b08	/* UART 0 XMT DMA count register  16 bit */
+#define UART0_COUNT_TX				HALFWORD_REF(UART0_COUNT_TX_ADDR)
+#define UART0_NEXT_DESCR_TX_ADDR	0xffc01b0a	/*UART 0 XMT DMA next descripter poin reg 16 bit */
+#define UART0_NEXT_DESCR_TX			HALFWORD_REF(UART0_NEXT_DESCR_TX_ADDR)
+#define UART0_DESCR_RDY_TX_ADDR		0xffc01b0c	/* UART 0 XMT DMA descripter ready reg 16 bit */
+#define UART0_DESCR_RDY_TX			HALFWORD_REF(UART0_DESCR_RDY_TX_ADDR)
+#define UART0_IRQSTAT_TX_ADDR		0xffc01b0e	/* UART 0 XMT DMA Interrupt register  16 bit */
+#define UART0_IRQSTAT_TX			HALFWORD_REF(UART0_IRQSTAT_TX_ADDR)
+
+/****************************
+ *
+ *  UART 1 CONTROLLER REGISTERS  (0XFFC01C00 - 0XFFC01FFF)
+ *
+ ****************************/
+
+#define UART1_THR_ADDR		0xffc01c00	/* UART 1 Transmit holding register  16 bit */
+#define UART1_THR			HALFWORD_REF(UART1_THR_ADDR)
+#define UART1_THR_MASK		0x00ff	/* Data to be transmitted */
+
+#define UART1_RBR_ADDR		0xffc01c00	/* UART 1 Receive buffer register  16 bit */
+#define UART1_RBR			HALFWORD_REF(UART1_RBR_ADDR)
+#define UART1_RBR_MASK		0x00ff	/* Data to be transmitted */
+
+#define UART1_DLL_ADDR		0xffc01c00	/* UART 1 Divisor latch (low byte) register  16 bit */
+#define UART1_DLL			HALFWORD_REF(UART1_DLL_ADDR)
+
+#define UART1_IER_ADDR		0xffc01c02	/* UART 1 Interrupt enable register  16 bit */
+#define UART1_IER			HALFWORD_REF(UART1_IER_ADDR)
+#define UART1_IER_ERBFI			0x01	/* Enable Receive Buffer Full Interrupt(DR bit) */
+#define UART1_IER_ETBEI			0x02	/* Enable Transmit Buffer Empty Interrupt(THRE bit) */
+#define UART1_IER_ELSI			0x04	/* Enable RX Status Interrupt(gen if any of LSR[4:1] set) */
+#define UART1_IER_EDDSI			0x08	/* Enable Modem Status Interrupt(gen if any UARTx_MSR[3:0] set) */
+
+#define UART1_DLH_ADDR		0xffc01c02	/* UART 1 Divisor latch (high byte) register  16 bit */
+#define UART1_DLH			HALFWORD_REF(UART1_DLH_ADDR)
+
+#define UART1_IIR_ADDR		0xffc01c04	/* UART 1 Interrupt identification register  16 bit */
+#define UART1_IIR			HALFWORD_REF(UART1_IIR_ADDR)
+#define UART1_IIR_NOINT     	0x01	/* Bit0: cleared when no interrupt */
+#define UART1_IIR_STATUS        0x06	/* mask bit for the status: bit2-1 */
+#define UART1_IIR_LSR           0x06	/* Receive line status */
+#define UART1_IIR_RBR           0x04	/* Receive data ready */
+#define UART1_IIR_THR           0x02	/* Ready to transmit  */
+#define UART1_IIR_MSR           0x00	/* Modem status       */
+
+#define UART1_LCR_ADDR		0xffc01c06	/* UART 1 Line control register  16 bit */
+#define UART1_LCR			HALFWORD_REF(UART1_LCR_ADDR)
+#define UART1_LCR_WLS5      	0	/* word length 5 bits */
+#define UART1_LCR_WLS6      	0x01	/* word length 6 bits */
+#define UART1_LCR_WLS7          0x02	/* word length 7 bits */
+#define UART1_LCR_WLS8          0x03	/* word length 8 bits */
+#define UART1_LCR_STB           0x04	/* StopBit: 1: 2 stop bits for non-5-bit word length
+					   1/2 stop bits for 5-bit word length
+					   0: 1 stop bit */
+#define UART1_LCR_PEN           0x08	/* Parity Enable 1: for enable */
+#define UART1_LCR_EPS           0x10	/* Parity Selection: 1: for even pariety
+					   0: odd parity when PEN =1 &
+					   SP =0 */
+#define UART1_LCR_SP            0x20	/* Sticky Parity: */
+#define UART1_LCR_SB            0x40	/* Set Break: force TX pin to 0 */
+#define UART1_LCR_DLAB          0x80	/* Divisor Latch Access */
+
+#define UART1_MCR_ADDR		0xffc01c08	/* UART 1 Module Control register  16 bit */
+#define UART1_MCR			HALFWORD_REF(UART1_MCR_ADDR)
+
+#define UART1_LSR_ADDR		0xffc01c0a	/* UART 1 Line status register  16 bit */
+#define UART1_LSR			HALFWORD_REF(UART1_LSR_ADDR)
+#define UART1_LSR_DR        	0x01	/* Data Ready */
+#define UART1_LSR_OE            0x02	/* Overrun Error */
+#define UART1_LSR_PE            0x04	/* Parity Error  */
+#define UART1_LSR_FE            0x08	/* Frame Error   */
+#define UART1_LSR_BI            0x10	/* Break Interrupt */
+#define UART1_LSR_THRE          0x20	/* THR empty, REady to accept */
+#define UART1_LSR_TEMT          0x40	/* TSR and UARTx_thr both empty */
+
+#define UART1_MSR_ADDR		0xffc01c0c	/* UART 1 Modem status register  16 bit */
+#define UART1_MSR			HALFWORD_REF(UART1_MSR_ADDR
+#define UART1_SCR_ADDR		0xffc01c0e	/* UART 1 Scratch register  16 bit */
+#define UART1_SCR			HALFWORD_REF(UART1_SCR_ADDR)
+
+#define UART1_CURR_PTR_RX_ADDR		0xffc01e00	/* UART 1 RCV DMA Current pointer register 16 bit */
+#define UART1_CURR_PTR_RX			HALFWORD_REF(UART1_CURR_PTR_RX_ADDR)
+#define UART1_CONFIG_RX_ADDR		0xffc01e02	/* UART 1 RCV DMA Configuration register 16 bit */
+#define UART1_CONFIG_RX				HALFWORD_REF(UART1_CONFIG_RX_ADDR)
+#define UART1_START_ADDR_HI_RX_ADDR	0xffc01e04	/* UART 1 RCV DMA start add. hi reg 16 bit */
+#define UART1_START_ADDR_HI_RX		HALFWORD_REF(UART1_START_ADDR_HI_RX_ADDR)
+#define UART1_START_ADDR_LO_RX_ADDR	0xffc01e06	/* UART 1 RCV DMA start add. lo reg 16 bit */
+#define UART1_START_ADDR_LO_RX		HALFWORD_REF(UART1_START_ADDR_LO_RX_ADDR)
+#define UART1_COUNT_RX_ADDR			0xffc01e08	/* UART 1 RCV DMA count register  16 bit */
+#define UART1_COUNT_RX				HALFWORD_REF(UART1_COUNT_RX_ADDR)
+#define UART1_NEXT_DESCR_RX_ADDR   	0xffc01e0a	/*UART 1 RCV DMA next descripter poin reg 16 bit */
+#define UART1_NEXT_DESCR_RX			HALFWORD_REF(UART1_NEXT_DESCR_RX_ADDR)
+#define UART1_DESCR_RDY_RX_ADDR		0xffc01e0c	/* UART 1 RCV DMA descripter ready reg 16 bit */
+#define UART1_DESCR_RDY_RX			HALFWORD_REF(UART1_DESCR_RDY_RX_ADDR)
+#define UART1_IRQSTAT_RX_ADDR		0xffc01e0e	/* UART 1 RCV DMA Interrupt register  16 bit */
+#define UART1_IRQSTAT_RX			HALFWORD_REF(UART1_IRQSTAT_RX_ADDR)
+
+#define UART1_CURR_PTR_TX_ADDR		0xffc01f00	/* UART 1 XMT DMA Current pointer register 16 bit */
+#define UART1_CURR_PTR_TX			HALFWORD_REF(UART1_CURR_PTR_TX_ADDR)
+#define UART1_CONFIG_TX_ADDR		0xffc01f02	/* UART 1 XMT DMA Configuration register 16 bit */
+#define UART1_CONFIG_TX				HALFWORD_REF(UART1_CONFIG_TX_ADDR)
+#define UART1_START_ADDR_HI_TX_ADDR	0xffc01f04	/* UART 1 XMT DMA start add. hi reg 16 bit */
+#define UART1_START_ADDR_HI_TX		HALFWORD_REF(UART1_START_ADDR_HI_TX_ADDR)
+#define UART1_START_ADDR_LO_TX_ADDR	0xffc01f06	/* UART 1 XMT DMA start add. lo reg 16 bit */
+#define UART1_START_ADDR_LO_TX		HALFWORD_REF(UART1_START_ADDR_LO_TX_ADDR)
+#define UART1_COUNT_TX_ADDR			0xffc01f08	/* UART 1 XMT DMA count register  16 bit */
+#define UART1_COUNT_TX				HALFWORD_REF(UART1_COUNT_TX_ADDR)
+#define UART1_NEXT_DESCR_TX_ADDR	0xffc01f0a	/*UART 1 XMT DMA next descripter poin reg 16 bit */
+#define UART1_NEXT_DESCR_TX			HALFWORD_REF(UART1_NEXT_DESCR_TX_ADDR)
+#define UART1_DESCR_RDY_TX_ADDR		0xffc01f0c	/* UART 1 XMT DMA descripter ready reg 16 bit */
+#define UART1_DESCR_RDY_TX			HALFWORD_REF(UART1_DESCR_RDY_TX_ADDR)
+#define UART1_IRQSTAT_TX_ADDR		0xffc01f0e	/* UART 1 XMT DMA Interrupt register  16 bit */
+#define UART1_IRQSTAT_TX			HALFWORD_REF(UART1_IRQSTAT_TX_ADDR)
+
+/****************************
+ *
+ *  TIMER REGISTERS  (0XFFC02000 - 0XFFC023FF)
+ *       THERE ARE 3 TIMERS
+ ****************************/
+
+		/*             TIMER 0              */
+
+#define TIMER0_STATUS_ADDR		0xffc02000	/* TIMER 0 Global status & sticky register  16 bit */
+#define TIMER0_STATUS			HALFWORD_REF(TIMER0_STATUS_ADDR)
+#define TIMER0_CONFIG_ADDR		0xffc02002	/* TIMER 0 configuration register  16 bit */
+#define TIMER0_CONFIG			HALFWORD_REF(TIMER0_CONFIG_ADDR)
+#define TIMER0_COUNTER_LO_ADDR	0xffc02004	/* TIMER 0 counter (low word) register   16 bit */
+#define TIMER0_COUNTER_LO		HALFWORD_REF(TIMER0_COUNTER_LO_ADDR)
+#define TIMER0_COUNTER_HI_ADDR	0xffc02006	/* TIMER 0 counter (high word) register  16 bit */
+#define TIMER0_COUNTER_HI		HALFWORD_REF(TIMER0_COUNTER_HI_ADDR)
+#define TIMER0_PERIOD_LO_ADDR	0xffc02008	/* TIMER 0 period (low word) register  16 bit */
+#define TIMER0_PERIOD_LO		HALFWORD_REF(TIMER0_PERIOD_LO_ADDR)
+#define TIMER0_PERIOD_HI_ADDR	0xffc0200a	/* TIMER 0 period (high word) register  16 bit */
+#define TIMER0_PERIOD_HI		HALFWORD_REF(TIMER0_PERIOD_HI_ADDR)
+#define TIMER0_WIDTH_LO_ADDR	0xffc0200c	/* TIMER 0 width (low word) register  16 bit */
+#define TIMER0_WIDTH_LO			HALFWORD_REF(TIMER0_WIDTH_LO_ADDR)
+#define TIMER0_WIDTH_HI_ADDR	0xffc0200e	/* TIMER 0 width (high word) register  16 bit */
+#define TIMER0_WIDTH_HI			HALFWORD_REF(TIMER0_WIDTH_HI_ADDR)
+
+		/*             TIMER 1              */
+
+#define TIMER1_STATUS_ADDR		0xffc02010	/* TIMER 1 Global status & sticky register  16 bit */
+#define TIMER1_STATUS			HALFWORD_REF(TIMER1_STATUS_ADDR)
+#define TIMER1_CONFIG_ADDR		0xffc02012	/* TIMER 1 configuration register  16 bit */
+#define TIMER1_CONFIG			HALFWORD_REF(TIMER1_CONFIG_ADDR)
+#define TIMER1_COUNTER_LO_ADDR	0xffc02014	/* TIMER 1 counter (low word) register   16 bit */
+#define TIMER1_COUNTER_LO		HALFWORD_REF(TIMER1_COUNTER_LO_ADDR)
+#define TIMER1_COUNTER_HI_ADDR	0xffc02016	/* TIMER 1 counter (high word) register  16 bit */
+#define TIMER1_COUNTER_HI		HALFWORD_REF(TIMER1_COUNTER_HI_ADDR)
+#define TIMER1_PERIOD_LO_ADDR	0xffc02018	/* TIMER 1 period (low word) register  16 bit */
+#define TIMER1_PERIOD_LO		HALFWORD_REF(TIMER1_PERIOD_LO_ADDR)
+#define TIMER1_PERIOD_HI_ADDR	0xffc0201a	/* TIMER 1 period (high word) register  16 bit */
+#define TIMER1_PERIOD_HI		HALFWORD_REF(TIMER1_PERIOD_HI_ADDR)
+#define TIMER1_WIDTH_LO_ADDR	0xffc0201c	/* TIMER 1 width (low word) register  16 bit */
+#define TIMER1_WIDTH_LO			HALFWORD_REF(TIMER1_WIDTH_LO_ADDR)
+#define TIMER1_WIDTH_HI_ADDR	0xffc0201e	/* TIMER 1 width (high word) register  16 bit */
+#define TIMER1_WIDTH_HI			HALFWORD_REF(TIMER1_WIDTH_HI_ADDR)
+
+		/*             TIMER 2              */
+
+#define TIMER2_STATUS_ADDR		0xffc02020	/* TIMER 2 Global status & sticky register  16 bit */
+#define TIMER2_STATUS			HALFWORD_REF(TIMER2_STATUS_ADDR)
+#define TIMER2_CONFIG_ADDR		0xffc02022	/* TIMER 2 configuration register  16 bit */
+#define TIMER2_CONFIG			HALFWORD_REF(TIMER2_CONFIG_ADDR)
+#define TIMER2_COUNTER_LO_ADDR	0xffc02024	/* TIMER 2 counter (low word) register   16 bit */
+#define TIMER2_COUNTER_LO		HALFWORD_REF(TIMER2_COUNTER_LO_ADDR)
+#define TIMER2_COUNTER_HI_ADDR	0xffc02026	/* TIMER 2 counter (high word) register  16 bit */
+#define TIMER2_COUNTER_HI		HALFWORD_REF(TIMER2_COUNTER_HI_ADDR)
+#define TIMER2_PERIOD_LO_ADDR	0xffc02028	/* TIMER 2 period (low word) register  16 bit */
+#define TIMER2_PERIOD_LO		HALFWORD_REF(TIMER2_PERIOD_LO_ADDR)
+#define TIMER2_PERIOD_HI_ADDR	0xffc0202a	/* TIMER 2 period (high word) register  16 bit */
+#define TIMER2_PERIOD_HI		HALFWORD_REF(TIMER2_PERIOD_HI_ADDR)
+#define TIMER2_WIDTH_LO_ADDR	0xffc0202c	/* TIMER 2 width (low word) register  16 bit */
+#define TIMER2_WIDTH_LO			HALFWORD_REF(TIMER2_WIDTH_LO_ADDR)
+#define TIMER2_WIDTH_HI_ADDR	0xffc0202e	/* TIMER 2 width (high word) register  16 bit */
+#define TIMER2_WIDTH_HI			HALFWORD_REF(TIMER2_WIDTH_HI_ADDR)
+
+/****************************
+ *
+ *  GENERAL PURPOSE IO REGISTERS  (0XFFC02400 - 0XFFC027FF)
+ *
+ ****************************/
+
+#define FIO_DIR_C_ADDR		0xffc02400	/* Peripheral flag direction (clear) register 16 bit */
+#define FIO_DIR_C			HALFWORD_REF(FIO_DIR_C_ADDR)
+#define FIO_DIR_S_ADDR		0xffc02402	/* Peripheral flag direction (set) register 16 bit */
+#define FIO_DIR_S			HALFWORD_REF(FIO_DIR_S_ADDR)
+#define FIO_FLAG_C_ADDR		0xffc02404	/* Peripheral Interrupt flag (clear) register 16 bit */
+#define FIO_FLAG_C			HALFWORD_REF(FIO_FLAG_C_ADDR)
+#define FIO_FLAG_S_ADDR		0xffc02406	/* Peripheral Interrupt flag (set) register 16 bit */
+#define FIO_FLAG_S			HALFWORD_REF(FIO_FLAG_S_ADDR)
+#define FIO_MASKA_C_ADDR	0xffc02408	/* Flag Mask Interrupt A (clear) register 16 bit */
+#define FIO_MASKA_C			HALFWORD_REF(FIO_MASKA_C_ADDR)
+#define FIO_MASKA_S_ADDR	0xffc0240a	/* Flag Mask Interrupt A (set) register 16 bit */
+#define FIO_MASKA_S			HALFWORD_REF(FIO_MASKA_S_ADDR)
+#define FIO_MASKB_C_ADDR	0xffc0240c	/* Flag Mask Interrupt B (clear) register 16 bit */
+#define FIO_MASKB_C			HALFWORD_REF(FIO_MASKB_C_ADDR)
+#define FIO_MASKB_S_ADDR	0xffc0240e	/* Flag Mask Interrupt B (set) register 16 bit */
+#define FIO_MASKB_S			HALFWORD_REF(FIO_MASKB_S_ADDR)
+#define FIO_POLAR_C_ADDR	0xffc02410	/* Flag source polarity (clear) register 16 bit */
+#define FIO_POLAR_C			HALFWORD_REF(FIO_POLAR_C_ADDR)
+#define FIO_POLAR_S_ADDR	0xffc02412	/* Flag source polarity (set) register 16 bit */
+#define FIO_POLAR_S			HALFWORD_REF(FIO_POLAR_S_ADDR)
+#define FIO_EDGE_C_ADDR		0xffc02414	/* Flag source sensitivity (clear) register 16 bit */
+#define FIO_EDGE_C			HALFWORD_REF(FIO_EDGE_C_ADDR)
+#define FIO_EDGE_S_ADDR		0xffc02416	/* Flag source sensitivity (set) register 16 bit */
+#define FIO_EDGE_S			HALFWORD_REF(FIO_EDGE_S_ADDR)
+#define FIO_BOTH_C_ADDR		0xffc02418	/* Flag set on both edges (clear) register 16 bit */
+#define FIO_BOTH_C			HALFWORD_REF(FIO_BOTH_C_ADDR)
+#define FIO_BOTH_S_ADDR		0xffc0241a	/* Flag set on both edges (set) register 16 bit */
+#define FIO_BOTH_S			HALFWORD_REF(FIO_BOTH_S_ADDR)
+
+/****************************
+ *
+ *  SPORT 0 CONTROLLER REGISTERS  (0XFFC02800 - 0XFFC02BFF)
+ *
+ ****************************/
+
+#define SPORT0_TX_CONFIG_ADDR	0xffc02800	/* SPORT 0 Transmit configuration register 16 bit */
+#define SPORT0_TX_CONFIG		HALFWORD_REF(SPORT0_TX_CONFIG_ADDR)
+#define SPORT0_RX_CONFIG_ADDR	0xffc02802	/* SPORT 0 Receive configuration register 16 bit */
+#define SPORT0_RX_CONFIG		HALFWORD_REF(SPORT0_RX_CONFIG_ADDR)
+#define SPORT0_TX_ADDR			0xffc02804	/* SPORT 0 Transmit register 16 bit */
+#define SPORT0_TX				HALFWORD_REF(SPORT0_TX_ADDR)
+#define SPORT0_RX_ADDR			0xffc02806	/* SPORT 0 Receive register 16 bit */
+#define SPORT0_RX				HALFWORD_REF(SPORT0_RX_ADDR)
+#define SPORT0_TSCLKDIV_ADDR	0xffc02808	/* SPORT 0 Transmit serial clock divider 16 bit */
+#define SPORT0_TSCLKDIV			HALFWORD_REF(SPORT0_TSCLKDIV_ADDR)
+#define SPORT0_RSCLKDIV_ADDR	0xffc0280a	/* SPORT 0 Receive serial clock divider 16 bit */
+#define SPORT0_RSCLKDIV			HALFWORD_REF(SPORT0_RSCLKDIV_ADDR)
+#define SPORT0_TFSDIV_ADDR		0xffc0280c	/* SPORT 0 Transmit frame sync divider 16 bit */
+#define SPORT0_TFSDIV			HALFWORD_REF(SPORT0_TFSDIV_ADDR)
+#define SPORT0_RFSDIV_ADDR		0xffc0280e	/* SPORT 0 Receive frame sync divider 16 bit */
+#define SPORT0_RFSDIV			HALFWORD_REF(SPORT0_RFSDIV_ADDR)
+#define SPORT0_STAT_ADDR		0xffc02810	/* SPORT 0 status register 16 bit */
+#define SPORT0_STAT				HALFWORD_REF(SPORT0_STAT_ADDR)
+#define SPORT0_MTCS0_ADDR		0xffc02812	/* SPORT 0 Multi-channel Transmit select reg 16 bit */
+#define SPORT0_MTCS0			HALFWORD_REF(SPORT0_MTCS0_ADDR)
+#define SPORT0_MTCS1_ADDR		0xffc02814	/* SPORT 0 Multi-channel Transmit select reg 16 bit */
+#define SPORT0_MTCS1			HALFWORD_REF(SPORT0_MTCS1_ADDR)
+#define SPORT0_MTCS2_ADDR		0xffc02816	/* SPORT 0 Multi-channel Transmit select reg 16 bit */
+#define SPORT0_MTCS2			HALFWORD_REF(SPORT0_MTCS2_ADDR)
+#define SPORT0_MTCS3_ADDR		0xffc02818	/* SPORT 0 Multi-channel Transmit select reg 16 bit */
+#define SPORT0_MTCS3			HALFWORD_REF(SPORT0_MTCS3_ADDR)
+#define SPORT0_MTCS4_ADDR		0xffc0281a	/* SPORT 0 Multi-channel Transmit select reg 16 bit */
+#define SPORT0_MTCS4			HALFWORD_REF(SPORT0_MTCS4_ADDR)
+#define SPORT0_MTCS5_ADDR		0xffc0281c	/* SPORT 0 Multi-channel Transmit select reg 16 bit */
+#define SPORT0_MTCS5			HALFWORD_REF(SPORT0_MTCS5_ADDR)
+#define SPORT0_MTCS6_ADDR		0xffc0281e	/* SPORT 0 Multi-channel Transmit select reg 16 bit */
+#define SPORT0_MTCS6			HALFWORD_REF(SPORT0_MTCS6_ADDR)
+#define SPORT0_MTCS7_ADDR		0xffc02820	/* SPORT 0 Multi-channel Transmit select reg 16 bit */
+#define SPORT0_MTCS7			HALFWORD_REF(SPORT0_MTCS7_ADDR)
+#define SPORT0_MRCS0_ADDR		0xffc02822	/* SPORT 0 Multi-channel Receive select reg 16 bit */
+#define SPORT0_MRCS0			HALFWORD_REF(SPORT0_MRCS0_ADDR)
+#define SPORT0_MRCS1_ADDR		0xffc02824	/* SPORT 0 Multi-channel Receive select reg 16 bit */
+#define SPORT0_MRCS1			HALFWORD_REF(SPORT0_MRCS1_ADDR)
+#define SPORT0_MRCS2_ADDR		0xffc02826	/* SPORT 0 Multi-channel Receive select reg 16 bit */
+#define SPORT0_MRCS2			HALFWORD_REF(SPORT0_MRCS2_ADDR)
+#define SPORT0_MRCS3_ADDR		0xffc02828	/* SPORT 0 Multi-channel Receive select reg 16 bit */
+#define SPORT0_MRCS3			HALFWORD_REF(SPORT0_MRCS3_ADDR)
+#define SPORT0_MRCS4_ADDR		0xffc0282a	/* SPORT 0 Multi-channel Receive select reg 16 bit */
+#define SPORT0_MRCS4			HALFWORD_REF(SPORT0_MRCS4_ADDR)
+#define SPORT0_MRCS5_ADDR		0xffc0282c	/* SPORT 0 Multi-channel Receive select reg 16 bit */
+#define SPORT0_MRCS5			HALFWORD_REF(SPORT0_MRCS5_ADDR)
+#define SPORT0_MRCS6_ADDR		0xffc0282e	/* SPORT 0 Multi-channel Receive select reg 16 bit */
+#define SPORT0_MRCS6			HALFWORD_REF(SPORT0_MRCS6_ADDR)
+#define SPORT0_MRCS7_ADDR		0xffc02830	/* SPORT 0 Multi-channel Receive select reg 16 bit */
+#define SPORT0_MRCS7			HALFWORD_REF(SPORT0_MRCS7_ADDR)
+#define SPORT0_MCMC1_ADDR		0xffc02832	/* SPORT 0 Multi-channel configuration reg 1 16 bit */
+#define SPORT0_MCMC1			HALFWORD_REF(SPORT0_MCMC1_ADDR)
+#define SPORT0_MCMC2_ADDR		0xffc02834	/* SPORT 0 Multi-channel configuration reg 2 16 bit */
+#define SPORT0_MCMC2			HALFWORD_REF(SPORT0_MCMC2_ADDR)
+
+#define SPORT0_CURR_PTR_RX_ADDR		0xffc02a00	/* SPORT 0 RCV DMA Current pointer reg 16 bit */
+#define SPORT0_CURR_PTR_RX			HALFWORD_REF(SPORT0_CURR_PTR_RX_ADDR)
+#define SPORT0_CONFIG_DMA_RX_ADDR	0xffc02a02	/* SPORT 0 RCV DMA Configuration reg 16 bit */
+
+#if 0
+#define SPORT0_CONFIG_DMA_RX		HALFWORD_REF(SPORT0_CONFIG_RX_ADDR)
+#else
+#define SPORT0_CONFIG_DMA_RX		HALFWORD_REF(SPORT0_CONFIG_DMA_RX_ADDR)
+#endif
+
+#define SPORT0_START_ADDR_HI_RX_ADDR  	0xffc02a04	/* SPORT 0 RCV DMA start add. hi reg 16 bit */
+#define SPORT0_START_ADDR_HI_RX		HALFWORD_REF(SPORT0_START_ADDR_HI_RX_ADDR)
+#define SPORT0_START_ADDR_LO_RX_ADDR  	0xffc02a06	/* SPORT 0 RCV DMA start add. lo reg 16 bit */
+#define SPORT0_START_ADDR_LO_RX		HALFWORD_REF(SPORT0_START_ADDR_LO_RX_ADDR)
+#define SPORT0_COUNT_RX_ADDR  		0xffc02a08	/* SPORT 0 RCV DMA count reg 16 bit */
+#define SPORT0_COUNT_RX				HALFWORD_REF(SPORT0_COUNT_RX_ADDR)
+#define SPORT0_NEXT_DESCR_RX_ADDR  	0xffc02a0a	/* SPORT 0 RCV DMA next descriptor poin reg 16 bit */
+#define SPORT0_NEXT_DESCR_RX		HALFWORD_REF(SPORT0_NEXT_DESCR_RX_ADDR)
+#define SPORT0_DESCR_RDY_RX_ADDR  	0xffc02a0c	/* SPORT 0 RCV DMA descriptor ready reg 16 bit */
+#define SPORT0_DESCR_RDY_RX			HALFWORD_REF(SPORT0_DESCR_RDY_RX_ADDR)
+#define SPORT0_IRQSTAT_RX_ADDR  	0xffc02a0e	/* SPORT 0 RCV DMA interrupt reg 16 bit */
+#define SPORT0_IRQSTAT_RX			HALFWORD_REF(SPORT0_IRQSTAT_RX_ADDR)
+
+#define SPORT0_CURR_PTR_TX_ADDR		0xffc02b00	/* SPORT 0 XMT DMA Current pointer reg 16 bit */
+#define SPORT0_CURR_PTR_TX			HALFWORD_REF(SPORT0_CURR_PTR_TX_ADDR)
+#define SPORT0_CONFIG_DMA_TX_ADDR	0xffc02b02	/* SPORT 0 XMT DMA Configuration reg 16 bit */
+
+/* Fixed in Jul 2 2003 for SPORT driver*/
+#if 0
+#define SPORT0_CONFIG_DMA_TX		HALFWORD_REF(SPORT0_CONFIG_TX_ADDR)
+#else
+#define SPORT0_CONFIG_DMA_TX		HALFWORD_REF(SPORT0_CONFIG_DMA_TX_ADDR)
+#endif
+
+#define SPORT0_START_ADDR_HI_TX_ADDR  	0xffc02b04	/* SPORT 0 XMT DMA start add. hi reg 16 bit */
+#define SPORT0_START_ADDR_HI_TX		HALFWORD_REF(SPORT0_START_ADDR_HI_TX_ADDR)
+#define SPORT0_START_ADDR_LO_TX_ADDR  	0xffc02b06	/* SPORT 0 XMT DMA start add. lo reg 16 bit */
+#define SPORT0_START_ADDR_LO_TX		HALFWORD_REF(SPORT0_START_ADDR_LO_TX_ADDR)
+#define SPORT0_COUNT_TX_ADDR  		0xffc02b08	/* SPORT 0 XMT DMA count reg 16 bit */
+#define SPORT0_COUNT_TX				HALFWORD_REF(SPORT0_COUNT_TX_ADDR)
+#define SPORT0_NEXT_DESCR_TX_ADDR  	0xffc02b0a	/* SPORT 0 XMT DMA next descriptor poin reg 16 bit */
+#define SPORT0_NEXT_DESCR_TX		HALFWORD_REF(SPORT0_NEXT_DESCR_TX_ADDR)
+#define SPORT0_DESCR_RDY_TX_ADDR  	0xffc02b0c	/* SPORT 0 XMT DMA descriptor ready reg 16 bit */
+#define SPORT0_DESCR_RDY_TX			HALFWORD_REF(SPORT0_DESCR_RDY_TX_ADDR)
+#define SPORT0_IRQSTAT_TX_ADDR  	0xffc02b0e	/* SPORT 0 XMT DMA interrupt reg 16 bit */
+#define SPORT0_IRQSTAT_TX			HALFWORD_REF(SPORT0_IRQSTAT_TX_ADDR)
+
+/****************************
+ *
+ *  SPORT 1 CONTROLLER REGISTERS  (0XFFC02C00 - 0XFFC02FFF)
+ *
+ ****************************/
+
+#define SPORT1_TX_CONFIG_ADDR	0xffc02c00	/* SPORT 1 Transmit configuration register 16 bit */
+#define SPORT1_TX_CONFIG		HALFWORD_REF(SPORT1_TX_CONFIG_ADDR)
+#define SPORT1_RX_CONFIG_ADDR	0xffc02c02	/* SPORT 1 Receive configuration register 16 bit */
+#define SPORT1_RX_CONFIG		HALFWORD_REF(SPORT1_RX_CONFIG_ADDR)
+#define SPORT1_TX_ADDR			0xffc02c04	/* SPORT 1 Transmit register 16 bit */
+#define SPORT1_TX				HALFWORD_REF(SPORT1_TX_ADDR)
+#define SPORT1_RX_ADDR			0xffc02c06	/* SPORT 1 Receive register 16 bit */
+#define SPORT1_RX				HALFWORD_REF(SPORT1_RX_ADDR)
+#define SPORT1_TSCLKDIV_ADDR	0xffc02c08	/* SPORT 1 Transmit serial clock divider 16 bit */
+#define SPORT1_TSCLKDIV			HALFWORD_REF(SPORT1_TSCLKDIV_ADDR)
+#define SPORT1_RSCLKDIV_ADDR	0xffc02c0a	/* SPORT 1 Receive serial clock divider 16 bit */
+#define SPORT1_RSCLKDIV			HALFWORD_REF(SPORT1_RSCLKDIV_ADDR)
+#define SPORT1_TFSDIV_ADDR		0xffc02c0c	/* SPORT 1 Transmit frame sync divider 16 bit */
+#define SPORT1_TFSDIV			HALFWORD_REF(SPORT1_TFSDIV_ADDR)
+#define SPORT1_RFSDIV_ADDR		0xffc02c0e	/* SPORT 1 Receive frame sync divider 16 bit */
+#define SPORT1_RFSDIV			HALFWORD_REF(SPORT1_RFSDIV_ADDR)
+#define SPORT1_STAT_ADDR		0xffc02c10	/* SPORT 1 status register 16 bit */
+#define SPORT1_STAT				HALFWORD_REF(SPORT1_STAT_ADDR)
+#define SPORT1_MTCS0_ADDR		0xffc02c12	/* SPORT 1 Multi-channel Transmit select reg 16 bit */
+#define SPORT1_MTCS0			HALFWORD_REF(SPORT1_MTCS0_ADDR)
+#define SPORT1_MTCS1_ADDR		0xffc02c14	/* SPORT 1 Multi-channel Transmit select reg 16 bit */
+#define SPORT1_MTCS1			HALFWORD_REF(SPORT1_MTCS1_ADDR)
+#define SPORT1_MTCS2_ADDR		0xffc02c16	/* SPORT 1 Multi-channel Transmit select reg 16 bit */
+#define SPORT1_MTCS2			HALFWORD_REF(SPORT1_MTCS2_ADDR)
+#define SPORT1_MTCS3_ADDR		0xffc02c18	/* SPORT 1 Multi-channel Transmit select reg 16 bit */
+#define SPORT1_MTCS3			HALFWORD_REF(SPORT1_MTCS3_ADDR)
+#define SPORT1_MTCS4_ADDR		0xffc02c1a	/* SPORT 1 Multi-channel Transmit select reg 16 bit */
+#define SPORT1_MTCS4			HALFWORD_REF(SPORT1_MTCS4_ADDR)
+#define SPORT1_MTCS5_ADDR		0xffc02c1c	/* SPORT 1 Multi-channel Transmit select reg 16 bit */
+#define SPORT1_MTCS5			HALFWORD_REF(SPORT1_MTCS5_ADDR)
+#define SPORT1_MTCS6_ADDR		0xffc02c1e	/* SPORT 1 Multi-channel Transmit select reg 16 bit */
+#define SPORT1_MTCS6			HALFWORD_REF(SPORT1_MTCS6_ADDR)
+#define SPORT1_MTCS7_ADDR		0xffc02c20	/* SPORT 1 Multi-channel Transmit select reg 16 bit */
+#define SPORT1_MTCS7			HALFWORD_REF(SPORT1_MTCS7_ADDR)
+#define SPORT1_MRCS0_ADDR		0xffc02c22	/* SPORT 1 Multi-channel Receive select reg 16 bit */
+#define SPORT1_MRCS0			HALFWORD_REF(SPORT1_MRCS0_ADDR)
+#define SPORT1_MRCS1_ADDR		0xffc02c24	/* SPORT 1 Multi-channel Receive select reg 16 bit */
+#define SPORT1_MRCS1			HALFWORD_REF(SPORT1_MRCS1_ADDR)
+#define SPORT1_MRCS2_ADDR		0xffc02c26	/* SPORT 1 Multi-channel Receive select reg 16 bit */
+#define SPORT1_MRCS2			HALFWORD_REF(SPORT1_MRCS2_ADDR)
+#define SPORT1_MRCS3_ADDR		0xffc02c28	/* SPORT 1 Multi-channel Receive select reg 16 bit */
+#define SPORT1_MRCS3			HALFWORD_REF(SPORT1_MRCS3_ADDR)
+#define SPORT1_MRCS4_ADDR		0xffc02c2a	/* SPORT 1 Multi-channel Receive select reg 16 bit */
+#define SPORT1_MRCS4			HALFWORD_REF(SPORT1_MRCS4_ADDR)
+#define SPORT1_MRCS5_ADDR		0xffc02c2c	/* SPORT 1 Multi-channel Receive select reg 16 bit */
+#define SPORT1_MRCS5			HALFWORD_REF(SPORT1_MRCS5_ADDR)
+#define SPORT1_MRCS6_ADDR		0xffc02c2e	/* SPORT 1 Multi-channel Receive select reg 16 bit */
+#define SPORT1_MRCS6			HALFWORD_REF(SPORT1_MRCS6_ADDR)
+#define SPORT1_MRCS7_ADDR		0xffc02c30	/* SPORT 1 Multi-channel Receive select reg 16 bit */
+#define SPORT1_MRCS7			HALFWORD_REF(SPORT1_MRCS7_ADDR)
+#define SPORT1_MCMC1_ADDR		0xffc02c32	/* SPORT 1 Multi-channel configuration reg 1 16 bit */
+#define SPORT1_MCMC1			HALFWORD_REF(SPORT1_MCMC1_ADDR)
+#define SPORT1_MCMC2_ADDR		0xffc02c34	/* SPORT 1 Multi-channel configuration reg 2 16 bit */
+#define SPORT1_MCMC2			HALFWORD_REF(SPORT1_MCMC2_ADDR)
+
+#define SPORT1_CURR_PTR_RX_ADDR		0xffc02e00	/* SPORT 1 RCV DMA Current pointer reg 16 bit */
+#define SPORT1_CURR_PTR_RX			HALFWORD_REF(SPORT1_CURR_PTR_RX_ADDR)
+#define SPORT1_CONFIG_DMA_RX_ADDR	0xffc02e02	/* SPORT 1 RCV DMA Configuration reg 16 bit */
+
+/* Fixed for SPORT driver, Jul 2 2003 */
+#if 0
+#define SPORT1_CONFIG_DMA_RX		HALFWORD_REF(SPORT1_CONFIG_RX_ADDR)
+#else
+#define SPORT1_CONFIG_DMA_RX		HALFWORD_REF(SPORT1_CONFIG_DMA_RX_ADDR)
+#endif
+
+#define SPORT1_START_ADDR_HI_RX_ADDR  	0xffc02e04	/* SPORT 1 RCV DMA start add. hi reg 16 bit */
+#define SPORT1_START_ADDR_HI_RX		HALFWORD_REF(SPORT1_START_ADDR_HI_RX_ADDR)
+#define SPORT1_START_ADDR_LO_RX_ADDR  	0xffc02e06	/* SPORT 1 RCV DMA start add. lo reg 16 bit */
+#define SPORT1_START_ADDR_LO_RX		HALFWORD_REF(SPORT1_START_ADDR_LO_RX_ADDR)
+#define SPORT1_COUNT_RX_ADDR  		0xffc02e08	/* SPORT 1 RCV DMA count reg 16 bit */
+#define SPORT1_COUNT_RX				HALFWORD_REF(SPORT1_COUNT_RX_ADDR)
+#define SPORT1_NEXT_DESCR_RX_ADDR  	0xffc02e0a	/* SPORT 1 RCV DMA next descriptor poin reg 16 bit */
+#define SPORT1_NEXT_DESCR_RX		HALFWORD_REF(SPORT1_NEXT_DESCR_RX_ADDR)
+#define SPORT1_DESCR_RDY_RX_ADDR  	0xffc02e0c	/* SPORT 1 RCV DMA descriptor ready reg 16 bit */
+#define SPORT1_DESCR_RDY_RX			HALFWORD_REF(SPORT1_DESCR_RDY_RX_ADDR)
+#define SPORT1_IRQSTAT_RX_ADDR  	0xffc02e0e	/* SPORT 1 RCV DMA interrupt reg 16 bit */
+#define SPORT1_IRQSTAT_RX			HALFWORD_REF(SPORT1_IRQSTAT_RX_ADDR)
+
+#define SPORT1_CURR_PTR_TX_ADDR		0xffc02f00	/* SPORT 1 XMT DMA Current pointer reg 16 bit */
+#define SPORT1_CURR_PTR_TX			HALFWORD_REF(SPORT1_CURR_PTR_TX_ADDR)
+#define SPORT1_CONFIG_DMA_TX_ADDR	0xffc02f02	/* SPORT 1 XMT DMA Configuration reg 16 bit */
+
+#if 0
+#define SPORT1_CONFIG_DMA_TX		HALFWORD_REF(SPORT1_CONFIG_TX_ADDR)
+#else
+#define SPORT1_CONFIG_DMA_TX		HALFWORD_REF(SPORT1_CONFIG_DMA_TX_ADDR)
+#endif
+
+#define SPORT1_START_ADDR_HI_TX_ADDR  	0xffc02f04	/* SPORT 1 XMT DMA start add. hi reg 16 bit */
+#define SPORT1_START_ADDR_HI_TX		HALFWORD_REF(SPORT1_START_ADDR_HI_TX_ADDR)
+#define SPORT1_START_ADDR_LO_TX_ADDR  	0xffc02f06	/* SPORT 1 XMT DMA start add. lo reg 16 bit */
+#define SPORT1_START_ADDR_LO_TX		HALFWORD_REF(SPORT1_START_ADDR_LO_TX_ADDR)
+#define SPORT1_COUNT_TX_ADDR  		0xffc02f08	/* SPORT 1 XMT DMA count reg 16 bit */
+#define SPORT1_COUNT_TX				HALFWORD_REF(SPORT1_COUNT_TX_ADDR)
+#define SPORT1_NEXT_DESCR_TX_ADDR  	0xffc02f0a	/* SPORT 1 XMT DMA next descriptor poin reg 16 bit */
+#define SPORT1_NEXT_DESCR_TX		HALFWORD_REF(SPORT1_NEXT_DESCR_TX_ADDR)
+#define SPORT1_DESCR_RDY_TX_ADDR  	0xffc02f0c	/* SPORT 1 XMT DMA descriptor ready reg 16 bit */
+#define SPORT1_DESCR_RDY_TX			HALFWORD_REF(SPORT1_DESCR_RDY_TX_ADDR)
+#define SPORT1_IRQSTAT_TX_ADDR  	0xffc02f0e	/* SPORT 1 XMT DMA interrupt reg 16 bit */
+#define SPORT1_IRQSTAT_TX			HALFWORD_REF(SPORT1_IRQSTAT_TX_ADDR)
+
+/****************************
+ *
+ *  SPI 0 CONTROLLER REGISTERS  (0XFFC03000 - 0XFFC033FF)
+ *
+ ****************************/
+
+#define SPI0_CTL_ADDR		0xffc03000	/* SPI 0 control register 16 bit */
+#define SPI0_CTL			HALFWORD_REF(SPI0_CTL_ADDR)
+#define SPI0_FLG_ADDR		0xffc03002	/* SPI 0 flag register 16 bit */
+#define SPI0_FLG			HALFWORD_REF(SPI0_FLG_ADDR)
+#define SPI0_ST_ADDR		0xffc03004	/* SPI 0 status register 16 bit */
+#define SPI0_ST				HALFWORD_REF(SPI0_ST_ADDR)
+#define SPI0_TDBR_ADDR		0xffc03006	/* SPI 0 transmit data buffer register 16 bit */
+#define SPI0_TDBR			HALFWORD_REF(SPI0_TDBR_ADDR)
+#define SPI0_RDBR_ADDR		0xffc03008	/* SPI 0 receive data buffer register 16 bit */
+#define SPI0_RDBR			HALFWORD_REF(SPI0_RDBR_ADDR)
+#define SPI0_BAUD_ADDR		0xffc0300a	/* SPI 0 baud rate register 16 bit */
+#define SPI0_BAUD			HALFWORD_REF(SPI0_BAUD_ADDR)
+#define SPI0_SHADOW_ADDR	0xffc0300c	/* SPI 0 RDBR register 16 bit */
+#define SPI0_SHADOW			HALFWORD_REF(SPI0_SHADOW_ADDR)
+
+#define SPI0_CURR_PTR_ADDR		0xffc03200	/* SPI 0 DMA current pointer register 16 bit */
+#define SPI0_CURR_PTR			HALFWORD_REF(SPI0_CURR_PTR_ADDR)
+#define SPI0_CONFIG_ADDR		0xffc03202	/* SPI 0 DMA configuration register 16 bit */
+#define SPI0_CONFIG				HALFWORD_REF(SPI0_CONFIG_ADDR)
+#define SPI0_START_ADDR_HI_ADDR	0xffc03204	/* SPI 0 DMA start address hi register 16 bit */
+#define SPI0_START_ADDR_HI		HALFWORD_REF(SPI0_START_ADDR_HI_ADDR)
+#define SPI0_START_ADDR_LO_ADDR	0xffc03206	/* SPI 0 DMA start address lo register 16 bit */
+#define SPI0_START_ADDR_LO		HALFWORD_REF(SPI0_START_ADDR_LO_ADDR)
+#define SPI0_COUNT_ADDR			0xffc03208	/* SPI 0 DMA count register 16 bit */
+#define SPI0_COUNT				HALFWORD_REF(SPI0_COUNT_ADDR)
+#define SPI0_NEXT_DESCR_ADDR	0xffc0320a	/* SPI 0 DMA Next descriptor pointer register 16 bit */
+#define SPI0_NEXT_DESCR			HALFWORD_REF(SPI0_NEXT_DESCR_ADDR)
+#define SPI0_DESCR_RDY_ADDR		0xffc0320c	/* SPI 0 DMA descriptor ready register 16 bit */
+#define SPI0_DESCR_RDY			HALFWORD_REF(SPI0_DESCR_RDY_ADDR)
+#define SPI0_DMA_INT_ADDR		0xffc0320e	/* SPI 0 DMA interrupt register 16 bit */
+#define SPI0_DMA_INT			HALFWORD_REF(SPI0_DMA_INT_ADDR)
+
+/****************************
+ *
+ *  SPI 1 CONTROLLER REGISTERS  (0XFFC03400 - 0XFFC037FF)
+ *
+ ****************************/
+
+#define SPI1_CTL_ADDR		0xffc03400	/* SPI 1 control register 16 bit */
+#define SPI1_CTL			HALFWORD_REF(SPI1_CTL_ADDR)
+#define SPI1_FLG_ADDR		0xffc03402	/* SPI 1 flag register 16 bit */
+#define SPI1_FLG			HALFWORD_REF(SPI1_FLG_ADDR)
+#define SPI1_ST_ADDR		0xffc03404	/* SPI 1 status register 16 bit */
+#define SPI1_ST				HALFWORD_REF(SPI1_ST_ADDR)
+#define SPI1_TDBR_ADDR		0xffc03406	/* SPI 1 transmit data buffer register 16 bit */
+#define SPI1_TDBR			HALFWORD_REF(SPI1_TDBR_ADDR)
+#define SPI1_RDBR_ADDR		0xffc03408	/* SPI 1 receive data buffer register 16 bit */
+#define SPI1_RDBR			HALFWORD_REF(SPI1_RDBR_ADDR)
+#define SPI1_BAUD_ADDR		0xffc0340a	/* SPI 1 baud rate register 16 bit */
+#define SPI1_BAUD			HALFWORD_REF(SPI1_BAUD_ADDR)
+#define SPI1_SHADOW_ADDR	0xffc0340c	/* SPI 1 RDBR register 16 bit */
+#define SPI1_SHADOW			HALFWORD_REF(SPI1_SHADOW_ADDR)
+
+#define SPI1_CURR_PTR_ADDR		0xffc03600	/* SPI 1 DMA current pointer register 16 bit */
+#define SPI1_CURR_PTR			HALFWORD_REF(SPI1_CURR_PTR_ADDR)
+#define SPI1_CONFIG_ADDR		0xffc03602	/* SPI 1 DMA configuration register 16 bit */
+#define SPI1_CONFIG				HALFWORD_REF(SPI1_CONFIG_ADDR)
+#define SPI1_START_ADDR_HI_ADDR	0xffc03604	/* SPI 1 DMA start address hi register 16 bit */
+#define SPI1_START_ADDR_HI		HALFWORD_REF(SPI1_START_ADDR_HI_ADDR)
+#define SPI1_START_ADDR_LO_ADDR	0xffc03606	/* SPI 1 DMA start address lo register 16 bit */
+#define SPI1_START_ADDR_LO		HALFWORD_REF(SPI1_START_ADDR_LO_ADDR)
+#define SPI1_COUNT_ADDR			0xffc03608	/* SPI 1 DMA count register 16 bit */
+#define SPI1_COUNT				HALFWORD_REF(SPI1_COUNT_ADDR)
+#define SPI1_NEXT_DESCR_ADDR	0xffc0360a	/* SPI 1 DMA Next descriptor pointer register 16 bit */
+#define SPI1_NEXT_DESCR			HALFWORD_REF(SPI1_NEXT_DESCR_ADDR)
+#define SPI1_DESCR_RDY_ADDR		0xffc0360c	/* SPI 1 DMA descriptor ready register 16 bit */
+#define SPI1_DESCR_RDY			HALFWORD_REF(SPI1_DESCR_RDY_ADDR)
+#define SPI1_DMA_INT_ADDR		0xffc0360e	/* SPI 1 DMA interrupt register 16 bit */
+#define SPI1_DMA_INT			HALFWORD_REF(SPI1_DMA_INT_ADDR)
+
+/****************************
+ *
+ *  MEMORY DMA CONTROLLER REGISTERS  (0XFFC03800 - 0XFFC03BFF)
+ *
+ ****************************/
+
+#define MDW_DCP_ADDR		0xffc03800	/* Current pointer write channel register 16 bit */
+#define MDW_DCP				HALFWORD_REF(MDW_DCP_ADDR)
+#define MDW_DCFG_ADDR		0xffc03802	/* DMA configuration write channel register 16 bit */
+#define MDW_DCFG			HALFWORD_REF(MDW_DCFG_ADDR)
+#define MDW_DSAH_ADDR		0xffc03804	/* Start address hi write channel register 16 bit */
+#define MDW_DSAH			HALFWORD_REF(MDW_DSAH_ADDR)
+#define MDW_DSAL_ADDR		0xffc03806	/* Start address lo write channel register 16 bit */
+#define MDW_DSAL			HALFWORD_REF(MDW_DSAL_ADDR)
+#define MDW_DCT_ADDR		0xffc03808	/* DMA count write channel register 16 bit */
+#define MDW_DCT				HALFWORD_REF(MDW_DCT_ADDR)
+#define MDW_DND_ADDR		0xffc0380a	/* Next descriptor pointer write channel register 16 bit */
+#define MDW_DND				HALFWORD_REF(MDW_DND_ADDR)
+#define MDW_DDR_ADDR		0xffc0380c	/* Descriptor ready write channel register 16 bit */
+#define MDW_DDR				HALFWORD_REF(MDW_DDR_ADDR)
+#define MDW_DI_ADDR			0xffc0380e	/* DMA interrupt write channel register 16 bit */
+#define MDW_DI				HALFWORD_REF(MDW_DI_ADDR)
+
+#define MDR_DCP_ADDR		0xffc03900	/* Current pointer read channel register 16 bit */
+#define MDR_DCP				HALFWORD_REF(MDR_DCP_ADDR)
+#define MDR_DCFG_ADDR		0xffc03902	/* DMA configuration read channel register 16 bit */
+#define MDR_DCFG			HALFWORD_REF(MDR_DCFG_ADDR)
+#define MDR_DSAH_ADDR		0xffc03904	/* Start address hi read channel register 16 bit */
+#define MDR_DSAH			HALFWORD_REF(MDR_DSAH_ADDR)
+#define MDR_DSAL_ADDR		0xffc03906	/* Start address lo read channel register 16 bit */
+#define MDR_DSAL			HALFWORD_REF(MDR_DSAL_ADDR)
+#define MDR_DCT_ADDR		0xffc03908	/* DMA count read channel register 16 bit */
+#define MDR_DCT				HALFWORD_REF(MDR_DCT_ADDR)
+#define MDR_DND_ADDR		0xffc0390a	/* Next descriptor pointer read channel register 16 bit */
+#define MDR_DND				HALFWORD_REF(MDR_DND_ADDR)
+#define MDR_DDR_ADDR		0xffc0390c	/* Descriptor ready read channel register 16 bit */
+#define MDR_DDR				HALFWORD_REF(MDR_DDR_ADDR)
+#define MDR_DI_ADDR			0xffc0390e	/* DMA interrupt read channel register 16 bit */
+#define MDR_DI				HALFWORD_REF(MDR_DI_ADDR)
+
+/****************************
+ *
+ *  ASYNCHRONOUS MEMORY CONTROLLER REGISTERS EDIU (0XFFC03C00 - 0XFFC03FFF)
+ *
+ ****************************/
+
+#define EBIU_AMGCTL_ADDR	0xffc03c00	/* Asynchronous memory global control register ? bit */
+#define EBIU_AMGCTL			WORD_REF(MDW_AMGCTL_ADDR)
+#define EBIU_AMBCTL0_ADDR	0xffc03c04	/* Asynchronous memory bank control register 0 32 bit */
+#define EBIU_AMBCTL0		WORD_REF(MDW_AMBCTL0_ADDR)
+#define EBIU_AMBCTL1_ADDR	0xffc03c08	/* Asynchronous memory bank control register 1 32 bit */
+#define EBIU_AMBCTL1		WORD_REF(MDW_AMBCTL1_ADDR)
+
+/****************************
+ *
+ *  PCI BRIDGE PAB REGISTERS  (0XFFC04000 - 0XFFC043FF)
+ *
+ ****************************/
+
+#define PCI_CTL_ADDR		0xffc04000	/* PCI bridge control register 32 bit */
+#define PCI_CTL				WORD_REF(PCI_CTL_ADDR)
+#define PCI_STAT_ADDR		0xffc04004	/* PCI bridge status register 32 bit */
+#define PCI_STAT			WORD_REF(PCI_STAT_ADDR)
+#define PCI_ICTL_ADDR		0xffc04008	/* PCI bridge interrupt control register 32 bit */
+#define PCI_ICTL			WORD_REF(PCI_ICTL_ADDR)
+#define PCI_MBAP_ADDR		0xffc0400c	/* PCI memory space base address pointer[31:27] register 32 bit */
+#define PCI_MBAP			WORD_REF(PCI_MBAP_ADDR)
+#define PCI_IBAP_ADDR		0xffc04010	/* PCI IO space base address pointer register 32 bit */
+#define PCI_IBAP			WORD_REF(PCI_IBAP_ADDR)
+#define PCI_CPAB_ADDR		0xffc04014	/* PCI config space base address port register 32 bit */
+#define PCI_CPAB			WORD_REF(PCI_CPAB_ADDR)
+#define PCI_TMBAP_ADDR		0xffc04018	/* PCI to Tahoe memory base address pointer register 32 bit */
+#define PCI_TMBAP			WORD_REF(PCI_TMBAP_ADDR)
+#define PCI_TIBAP_ADDR		0xffc0401c	/* PCI to Tahoe IO base address pointer register 32 bit */
+#define PCI_TIBAP			WORD_REF(PCI_TIBAP_ADDR)
+
+/****************************
+ *
+ *  PCI BRIDGE EXTERNAL ACCESS BUS REGISTERS  (0XEEFFFF00 - 0XEEFFFFFF)
+ *
+ ****************************/
+
+#define PCI_DMBARM_ADDR		0xeeffff00	/* PCI Device memory bar mask register 32 bit */
+#define PCI_DMBARM			WORD_REF(PCI_DMBARM_ADDR)
+#define PCI_DIBARM_ADDR		0xeeffff04	/* PCI Device IO bar mask register 32 bit */
+#define PCI_DIBARM			WORD_REF(PCI_DIBARM_ADDR)
+#define PCI_CFG_DIC_ADDR	0xeeffff08	/* PCI config Device ID register 32 bit */
+#define PCI_CFG_DIC			WORD_REF(PCI_CFG_DIC_ADDR)
+#define PCI_CFG_VIC_ADDR	0xeeffff0c	/* PCI config vendor ID register 32 bit */
+#define PCI_CFG_VIC			WORD_REF(PCI_CFG_VIC_ADDR)
+#define PCI_CFG_STAT_ADDR	0xeeffff10	/* PCI config status (read only) register 32 bit */
+#define PCI_CFG_STAT		WORD_REF(PCI_CFG_STAT_ADDR)
+#define PCI_CFG_CMD_ADDR	0xeeffff14	/* PCI config command register 32 bit */
+#define PCI_CFG_CMD			WORD_REF(PCI_CFG_CMD_ADDR)
+#define PCI_CFG_CC_ADDR		0xeeffff18	/* PCI config class code register 32 bit */
+#define PCI_CFG_CC			WORD_REF(PCI_CFG_CC_ADDR)
+#define PCI_CFG_RID_ADDR	0xeeffff1C	/* PCI config revision ID register 32 bit */
+#define PCI_CFG_RID			WORD_REF(PCI_CFG_RID_ADDR)
+#define PCI_CFG_BIST_ADDR	0xeeffff20	/* PCI config BIST register 32 bit */
+#define PCI_CFG_BIST		WORD_REF(PCI_CFG_BIST_ADDR)
+#define PCI_CFG_HT_ADDR		0xeeffff24	/* PCI config header type register 32 bit */
+#define PCI_CFG_HT			WORD_REF(PCI_CFG_HT_ADDR)
+#define PCI_CFG_MLT_ADDR	0xeeffff28	/* PCI config memory latency timer register 32 bit */
+#define PCI_CFG_MLT			WORD_REF(PCI_CFG_MLT_ADDR)
+#define PCI_CFG_CLS_ADDR	0xeeffff2C	/* PCI config cache line (block) size register 32 bit */
+#define PCI_CFG_CLS			WORD_REF(PCI_CFG_CLS_ADDR)
+#define PCI_CFG_MBAR_ADDR	0xeeffff30	/* PCI config memory base address register 32 bit */
+#define PCI_CFG_MBAR		WORD_REF(PCI_CFG_MBAR_ADDR)
+#define PCI_CFG_IBAR_ADDR	0xeeffff34	/* PCI config IO base address register 32 bit */
+#define PCI_CFG_IBAR		WORD_REF(PCI_CFG_IBAR_ADDR)
+#define PCI_CFG_SID_ADDR	0xeeffff38	/* PCI config subsystem ID register 32 bit */
+#define PCI_CFG_SID			WORD_REF(PCI_CFG_SID_ADDR)
+#define PCI_CFG_SVID_ADDR	0xeeffff3C	/* PCI config subsystem vendor ID register 32 bit */
+#define PCI_CFG_SVID		WORD_REF(PCI_CFG_SVID_ADDR)
+#define PCI_CFG_MAXL_ADDR	0xeeffff40	/* PCI config maximum latency cycles register 32 bit */
+#define PCI_CFG_MAXL		WORD_REF(PCI_CFG_MAXL_ADDR)
+#define PCI_CFG_MING_ADDR	0xeeffff44	/* PCI config minimum grant cycles register 32 bit */
+#define PCI_CFG_MING		WORD_REF(PCI_CFG_MING_ADDR)
+#define PCI_CFG_IP_ADDR		0xeeffff48	/* PCI config interrupt pin register 32 bit */
+#define PCI_CFG_IP			WORD_REF(PCI_CFG_IP_ADDR)
+#define PCI_CFG_IL_ADDR		0xeeffff4C	/* PCI config interrupt line register 32 bit */
+#define PCI_CFG_IL			WORD_REF(PCI_CFG_IL_ADDR)
+#define PCI_HMCTL_ADDR		0xeeffff50	/* PCI config blocking BAR mask 1 (host only) register 32 bit */
+#define PCI_HMCTL			WORD_REF(PCI_HMCTL_ADDR)
+
+/****************************
+ *
+ *  UNIVERSAL SERIAL BUS INTERFACE (USB) REGISTERS  (0XFFC04400 - 0XFFC047FF)
+ *
+ ****************************/
+
+#define USBD_ID_ADDR		0xffc04400	/* USB Device ID register 16 bit */
+#define USBD_ID				HALFWORD_REF(USBD_ID_ADDR)
+#define USBD_FRM_ADDR		0xffc04402	/* Current USB frame number register 16 bit */
+#define USBD_FRM			HALFWORD_REF(USBD_FRM_ADDR)
+#define USBD_FRMAT_ADDR		0xffc04404	/* Match value for USB frame number register 16 bit */
+#define USBD_FRMAT			HALFWORD_REF(USBD_FRMAT_ADDR)
+#define USBD_EPBUF_ADDR		0xffc04406	/* Enables download of configuration into UDC core register 16 bit */
+#define USBD_EPBUF			HALFWORD_REF(USBD_EPBUF_ADDR)
+#define USBD_STAT_ADDR		0xffc04408	/* Return USBD Module status register 16 bit */
+#define USBD_STAT			HALFWORD_REF(USBD_STAT_ADDR)
+#define USBD_CTRL_ADDR		0xffc0440a	/* Allows configuration & control of USBD module register 16 bit */
+#define USBD_CTRL			HALFWORD_REF(USBD_CTRL_ADDR)
+#define USBD_GINTR_ADDR		0xffc0440c	/* Global interrupt register 16 bit */
+#define USBD_GINTR			HALFWORD_REF(USBD_GINTR_ADDR)
+#define USBD_GMASK_ADDR		0xffc0440e	/* Global interrupt register mask register 16 bit */
+#define USBD_GMASK			HALFWORD_REF(USBD_GMASK_ADDR)
+
+#define USBD_DMACFG_ADDR	0xffc04440	/* DMA Master channel configuration register 16 bit */
+#define USBD_DMACFG			HALFWORD_REF(USBD_DMACFG_ADDR)
+#define USBD_DMABL_ADDR		0xffc04442	/* DMA Master channel base address low register 16 bit */
+#define USBD_DMABL			HALFWORD_REF(USBD_DMABL_ADDR)
+#define USBD_DMABH_ADDR		0xffc04444	/* DMA Master channel base address high register 16 bit */
+#define USBD_DMABH			HALFWORD_REF(USBD_DMABH_ADDR)
+#define USBD_DMACT_ADDR		0xffc04446	/* DMA Master channel count register 16 bit */
+#define USBD_DMACT			HALFWORD_REF(USBD_DMACT_ADDR)
+#define USBD_DMAIRQ_ADDR	0xffc04448	/* DMA Master channel IRQ register 16 bit */
+#define USBD_DMAIRQ			HALFWORD_REF(USBD_DMAIRQ_ADDR)
+
+#define USBD_INTR0_ADDR		0xffc04480	/* USB Endpoint 0 interrupt register 16 bit */
+#define USBD_INTR0			HALFWORD_REF(USBD_INTR0_ADDR)
+#define USBD_MASK0_ADDR		0xffc04482	/* USB Endpoint 0 mask register 16 bit */
+#define USBD_MASK0			HALFWORD_REF(USBD_MASK0_ADDR)
+#define USBD_EPCFG0_ADDR	0xffc04484	/* USB Endpoint 0 control register 16 bit */
+#define USBD_EPCFG0			HALFWORD_REF(USBD_EPCFG0_ADDR)
+#define USBD_EPADR0_ADDR	0xffc04486	/* USB Endpoint 0 address offset register 16 bit */
+#define USBD_EPADR0			HALFWORD_REF(USBD_EPADR0_ADDR)
+#define USBD_EPLEN0_ADDR	0xffc04488	/* USB Endpoint 0 buffer length register 16 bit */
+#define USBD_EPLEN0			HALFWORD_REF(USBD_EPLEN0_ADDR)
+
+#define USBD_INTR1_ADDR		0xffc0448a	/* USB Endpoint 1 interrupt register 16 bit */
+#define USBD_INTR1			HALFWORD_REF(USBD_INTR1_ADDR)
+#define USBD_MASK1_ADDR		0xffc0448c	/* USB Endpoint 1 mask register 16 bit */
+#define USBD_MASK1			HALFWORD_REF(USBD_MASK1_ADDR)
+#define USBD_EPCFG1_ADDR	0xffc0448e	/* USB Endpoint 1 control register 16 bit */
+#define USBD_EPCFG1			HALFWORD_REF(USBD_EPCFG1_ADDR)
+#define USBD_EPADR1_ADDR	0xffc04490	/* USB Endpoint 1 address offset register 16 bit */
+#define USBD_EPADR1			HALFWORD_REF(USBD_EPADR1_ADDR)
+#define USBD_EPLEN1_ADDR	0xffc04492	/* USB Endpoint 1 buffer length register 16 bit */
+#define USBD_EPLEN1			HALFWORD_REF(USBD_EPLEN1_ADDR)
+
+#define USBD_INTR2_ADDR		0xffc04494	/* USB Endpoint 2 interrupt register 16 bit */
+#define USBD_INTR2			HALFWORD_REF(USBD_INTR2_ADDR)
+#define USBD_MASK2_ADDR		0xffc04496	/* USB Endpoint 2 mask register 16 bit */
+#define USBD_MASK2			HALFWORD_REF(USBD_MASK2_ADDR)
+#define USBD_EPCFG2_ADDR	0xffc04498	/* USB Endpoint 2 control register 16 bit */
+#define USBD_EPCFG2			HALFWORD_REF(USBD_EPCFG2_ADDR)
+#define USBD_EPADR2_ADDR	0xffc0449a	/* USB Endpoint 2 address offset register 16 bit */
+#define USBD_EPADR2			HALFWORD_REF(USBD_EPADR2_ADDR)
+#define USBD_EPLEN2_ADDR	0xffc0449c	/* USB Endpoint 2 buffer length register 16 bit */
+#define USBD_EPLEN2			HALFWORD_REF(USBD_EPLEN2_ADDR)
+
+/* Fixed by HuTao, Jun18 2003 4:35PM */
+#if 0
+#define USBD_INTR3_ADDR		0xffc0448e	/* USB Endpoint 3 interrupt register 16 bit */
+#else
+#define USBD_INTR3_ADDR		0xffc0449e	/* USB Endpoint 3 interrupt register 16 bit */
+#endif
+
+#define USBD_INTR3			HALFWORD_REF(USBD_INTR3_ADDR)
+#define USBD_MASK3_ADDR		0xffc044a0	/* USB Endpoint 3 mask register 16 bit */
+#define USBD_MASK3			HALFWORD_REF(USBD_MASK3_ADDR)
+#define USBD_EPCFG3_ADDR	0xffc044a2	/* USB Endpoint 3 control register 16 bit */
+#define USBD_EPCFG3			HALFWORD_REF(USBD_EPCFG3_ADDR)
+#define USBD_EPADR3_ADDR	0xffc044a4	/* USB Endpoint 3 address offset register 16 bit */
+#define USBD_EPADR3			HALFWORD_REF(USBD_EPADR3_ADDR)
+#define USBD_EPLEN3_ADDR	0xffc044a6	/* USB Endpoint 3 buffer length register 16 bit */
+#define USBD_EPLEN3			HALFWORD_REF(USBD_EPLEN3_ADDR)
+
+#define USBD_INTR4_ADDR		0xffc044a8	/* USB Endpoint 4 interrupt register 16 bit */
+#define USBD_INTR4			HALFWORD_REF(USBD_INTR4_ADDR)
+#define USBD_MASK4_ADDR		0xffc044aa	/* USB Endpoint 4 mask register 16 bit */
+#define USBD_MASK4			HALFWORD_REF(USBD_MASK4_ADDR)
+#define USBD_EPCFG4_ADDR	0xffc044ac	/* USB Endpoint 4 control register 16 bit */
+#define USBD_EPCFG4			HALFWORD_REF(USBD_EPCFG4_ADDR)
+#define USBD_EPADR4_ADDR	0xffc044ae	/* USB Endpoint 4 address offset register 16 bit */
+#define USBD_EPADR4			HALFWORD_REF(USBD_EPADR4_ADDR)
+#define USBD_EPLEN4_ADDR	0xffc044b0	/* USB Endpoint 4 buffer length register 16 bit */
+#define USBD_EPLEN4			HALFWORD_REF(USBD_EPLEN4_ADDR)
+
+#define USBD_INTR5_ADDR		0xffc044b2	/* USB Endpoint 5 interrupt register 16 bit */
+#define USBD_INTR5			HALFWORD_REF(USBD_INTR5_ADDR)
+#define USBD_MASK5_ADDR		0xffc044b4	/* USB Endpoint 5 mask register 16 bit */
+#define USBD_MASK5			HALFWORD_REF(USBD_MASK5_ADDR)
+#define USBD_EPCFG5_ADDR	0xffc044b6	/* USB Endpoint 5 control register 16 bit */
+#define USBD_EPCFG5			HALFWORD_REF(USBD_EPCFG5_ADDR)
+#define USBD_EPADR5_ADDR	0xffc044b8	/* USB Endpoint 5 address offset register 16 bit */
+#define USBD_EPADR5			HALFWORD_REF(USBD_EPADR5_ADDR)
+#define USBD_EPLEN5_ADDR	0xffc044ba	/* USB Endpoint 5 buffer length register 16 bit */
+#define USBD_EPLEN5			HALFWORD_REF(USBD_EPLEN5_ADDR)
+
+#define USBD_INTR6_ADDR		0xffc044bc	/* USB Endpoint 6 interrupt register 16 bit */
+#define USBD_INTR6			HALFWORD_REF(USBD_INTR6_ADDR)
+#define USBD_MASK6_ADDR		0xffc044be	/* USB Endpoint 6 mask register 16 bit */
+#define USBD_MASK6			HALFWORD_REF(USBD_MASK6_ADDR)
+#define USBD_EPCFG6_ADDR	0xffc044c0	/* USB Endpoint 6 control register 16 bit */
+#define USBD_EPCFG6			HALFWORD_REF(USBD_EPCFG6_ADDR)
+#define USBD_EPADR6_ADDR	0xffc044c2	/* USB Endpoint 6 address offset register 16 bit */
+#define USBD_EPADR6			HALFWORD_REF(USBD_EPADR6_ADDR)
+#define USBD_EPLEN6_ADDR	0xffc044c4	/* USB Endpoint 6 buffer length register 16 bit */
+#define USBD_EPLEN6			HALFWORD_REF(USBD_EPLEN6_ADDR)
+
+#define USBD_INTR7_ADDR		0xffc044c6	/* USB Endpoint 7 interrupt register 16 bit */
+#define USBD_INTR7			HALFWORD_REF(USBD_INTR7_ADDR)
+#define USBD_MASK7_ADDR		0xffc044c8	/* USB Endpoint 7 mask register 16 bit */
+#define USBD_MASK7			HALFWORD_REF(USBD_MASK7_ADDR)
+#define USBD_EPCFG7_ADDR	0xffc044ca	/* USB Endpoint 7 control register 16 bit */
+#define USBD_EPCFG7			HALFWORD_REF(USBD_EPCFG7_ADDR)
+#define USBD_EPADR7_ADDR	0xffc044cc	/* USB Endpoint 7 address offset register 16 bit */
+#define USBD_EPADR7			HALFWORD_REF(USBD_EPADR7_ADDR)
+#define USBD_EPLEN7_ADDR	0xffc044ce	/* USB Endpoint 7 buffer length register 16 bit */
+#define USBD_EPLEN7			HALFWORD_REF(USBD_EPLEN7_ADDR)
+
+/****************************
+ *
+ * SYSTEM BUS INTERFACE UNIT REGISTERS  (0XFFC04800 - 0XFFC04FFF)
+ *
+ ****************************/
+
+#define L1SBAR_ADDR		0xffc04840	/* L1 SRAM base address register 16 bit */
+#define L1SBAR			HALFWORD_REF(L1SBAR_ADDR)
+#define L1CSR_ADDR		0xffc04844	/* L1 SRAM control initialization register 32 bit */
+#define L1CSR			WORD_REF(L1CSR_ADDR)
+#define DB_NDBP_ADDR		0xffc04880	/* Next descriptor base pointer register 32 bit */
+#define DB_NDBP			WORD_REF(DB_NDBP_ADDR)
+#define DB_ACOMP_ADDR		0xffc04884	/* DMA bus address comparator register 32 bit */
+#define DB_ACOMP		WORD_REF(DB_ACOMP_ADDR)
+#define DB_CCOMP_ADDR		0xffc04888	/* DMA bus control comparator register 32 bit */
+#define DB_CCOMP		WORD_REF(DB_CCOMP_ADDR)
+
+/****************************
+ *
+ * SDRAM CONTROLLER EXTERNAL BUS INTERFACE REGISTERS  (0XFFC04C00 - 0XFFC04FFF)
+ *
+ ****************************/
+
+#define EBIU_SDGCTL_ADDR	0xffc04c00	/* SDRAM Memory global control register 32 bit */
+#define EBIU_SDGCTL		WORD_REF(EBIU_SDGCTL_ADDR)
+#define EBIU_SDBCTL_ADDR	0xffc04c00	/* SDRAM Memory bank control register 32 bit */
+#define EBIU_SDBCTL		WORD_REF(EBIU_SDBCTL_ADDR)
+#define EBIU_SDRRC_ADDR		0xffc04c00	/* SDRAM Memory refresh rate count register 16 bit */
+#define EBIU_SDRRC		HALFWORD_REF(EBIU_SDRRC_ADDR)
+#define EBIU_SDSTAT_ADDR	0xffc04c00	/* SDRAM control status register 16 bit */
+#define EBIU_SDSTAT		HALFWORD_REF(EBIU_SDSTAT_ADDR)
+
+ /*      FOLLOWING ARE THE BFIN CORE MMR REGISTERS (TOP 2 MB)     */
+
+/****************************
+ *
+ *  L1 DATA MEMORY CONTROLLER REGISTERS  (0XFFE00000 - 0XFFE00404)
+ *
+ ****************************/
+
+#define SRAM_BASE_ADDR_ADDR	0xffe00000	/* read only register 32 bit */
+#define SRAM_BASE_ADDR		WORD_REF(SRAM_BASE_ADDR_ADDR)
+#define DATA_FAULT_STATUS_ADDR	0xffe00008	/* read only register 32 bit */
+#define DATA_FAULT_STATUS	WORD_REF(DATA_FAULT_STATUS_ADDR)
+#define DATA_FAULT_ADDR_ADDR	0xffe0000c	/* read only register 32 bit */
+#define DATA_FAULT_ADDR		WORD_REF(DATA_FAULT_ADDR_ADDR)
+
+		/* These are total sixtenn */
+
+#define DCPLB_ADDR_ADDR		0xffe00100	/* read/write register 32 bit */
+#define DCPLB_ADDR		WORD_REF(DCPLB_ADDR_ADDR)
+
+		/* These are total sixtenn */
+
+#define DCPLB_DATA_ADDR		0xffe00200	/* read/write register 32 bit */
+#define DCPLB_DATA		WORD_REF(DCPLB_DATA_ADDR)
+
+		/* These are total 4 */
+
+#define DTEST_DATA_ADDR		0xffe00400	/* read/write register 32 bit */
+#define DTEST_DATA		WORD_REF(DTEST_DATA_ADDR)
+
+/****************************
+ *
+ *  L1 CODE MEMORY CONTROLLER REGISTERS  (0XFFE01004 - 0XFFE1404)
+ *
+ ****************************/
+
+#define CODE_FAULT_STATUS_ADDR	0xffe01008	/* read only register 32 bit */
+#define CODE_FAULT_STATUS	WORD_REF(CODE_FAULT_STATUS_ADDR)
+#define CODE_FAULT_ADDR_ADDR	0xffe0100c	/* read only register 32 bit */
+#define CODE_FAULT_ADDR		WORD_REF(CODE_FAULT_ADDR_ADDR)
+
+		/* These are total sixtenn */
+
+#define ICPLB_ADDR_ADDR		0xffe01100	/* read/write register 32 bit */
+#define ICPLB_ADDR		WORD_REF(ICPLB_ADDR_ADDR)
+
+		/* These are total sixtenn */
+
+#define ICPLB_DATA_ADDR		0xffe01200	/* read/write register 32 bit */
+#define ICPLB_DATA		WORD_REF(ICPLB_DATA_ADDR)
+
+		/* These are total 4 */
+
+#define ITEST_DATA_ADDR		0xffe01400	/* read/write register 32 bit */
+#define ITEST_DATA		WORD_REF(ITEST_DATA_ADDR)
+
+/****************************
+ *
+ *  INTERRUPT CONTROLLER REGISTERS  (0XFFE02000 - 0XFFE0210C)
+ *
+ ****************************/
+
+ /*   EVENT VECTOR TABLE IS USED FOR 16 INTERRUPTS AS SHOWN BELOW
+    ALSO THEIR PRIORITY SEQUENCE IS ALSO GIVEN HERE
+    1           EMULATION               HIGHEST
+    2           RESET
+    3           NMI
+    4           EXCEPTION
+    5           INTERRUPTS              LOWEST */
+
+/*  Used with JTAG register 32 bit */
+#define EVT_EMULATION_ADDR	0xffe02000
+#define EVT_EMULATION		WORD_REF(EVT_EMULATION_ADDR)
+/*  register 32 bit */
+#define EVT_RESET_ADDR		0xffe02004
+#define EVT_RESET		WORD_REF(EVT_RESET_ADDR)
+/*  NMI register 32 bit */
+#define EVT_NMI_ADDR		0xffe02008
+#define EVT_NMI			WORD_REF(EVT_NMI_ADDR)
+/*  Identification with code in EXCAUSE register 32 bit */
+#define EVT_EXCEPTION_ADDR	0xffe0200c
+#define EVT_EXCEPTION		WORD_REF(EVT_EXCEPTION_ADDR)
+/*  Global interrupt enable register 32 bit */
+#define EVT_GLOBAL_INT_ENB_ADDR	0xffe02010
+#define EVT_GLOBAL_INT_ENB	WORD_REF(EVT_GLOBAL_INT_ENB_ADDR)
+/*  Active while error condition exsists register 32 bit */
+#define EVT_HARDWARE_ERROR_ADDR	0xffe02014
+#define EVT_HARDWARE_ERROR	WORD_REF(EVT_HARDWARE_ERROR_ADDR)
+/*  High priority timer register 32 bit */
+#define EVT_TIMER_ADDR		0xffe02018
+#define EVT_TIMER		WORD_REF(EVT_TIMER_ADDR)
+/*  General purpose interrupt register 32 bit */
+#define EVT_IVG7_ADDR		0xffe0201c
+#define EVT_IVG7		WORD_REF(EVT_IVG7_ADDR)
+/*  General purpose interrupt register 32 bit */
+#define EVT_IVG8_ADDR		0xffe02020
+#define EVT_IVG8		WORD_REF(EVT_IVG8_ADDR)
+/*  General purpose interrupt register 32 bit */
+#define EVT_IVG9_ADDR		0xffe02024
+#define EVT_IVG9		WORD_REF(EVT_IVG9_ADDR)
+/*  General purpose interrupt register 32 bit */
+#define EVT_IVG10_ADDR		0xffe02028
+#define EVT_IVG10		WORD_REF(EVT_IVG10_ADDR)
+/*  General purpose interrupt register 32 bit */
+#define EVT_IVG11_ADDR		0xffe0202c
+#define EVT_IVG11		WORD_REF(EVT_IVG11_ADDR)
+/*  General purpose interrupt register 32 bit */
+#define EVT_IVG12_ADDR		0xffe02030
+#define EVT_IVG12		WORD_REF(EVT_IVG12_ADDR)
+/*  General purpose interrupt register 32 bit */
+#define EVT_IVG13_ADDR		0xffe02034
+#define EVT_IVG13		WORD_REF(EVT_IVG13_ADDR)
+
+/* IVG14 & IVG15 should be used as software interrupts  */
+
+/*  General purpose interrupt register 32 bit */
+#define EVT_IVG14_ADDR		0xffe02038
+#define EVT_IVG14		WORD_REF(EVT_IVG14_ADDR)
+/*  General purpose interrupt register 32 bit */
+#define EVT_IVG15_ADDR		0xffe0203c
+#define EVT_IVG15		WORD_REF(EVT_IVG15_ADDR)
+
+#define EVT_OVERRIDE_ADDR	0xffe02100	/*  register 32 bit */
+#define EVT_OVERRIDE		WORD_REF(EVT_OVERRIDE_ADDR)
+#define IMASK_ADDR		0xffe02104	/*  register 32 bit */
+#define IMASK			WORD_REF(IMASK_ADDR)
+#define IPEND_ADDR		0xffe02108	/*  register 32 bit */
+#define IPEND			WORD_REF(IPEND_ADDR)
+#define ILAT_ADDR		0xffe0210c	/*  register 32 bit */
+#define ILAT			WORD_REF(ILAT_ADDR)
+
+/****************************
+ *
+ *  TIMER REGISTERS  (0XFFC03000 - 0XFFC0300C)
+ *
+ ****************************/
+
+#define TCNTL_ADDR		0xffe03000	/*  register 32 bit */
+#define TCNTL			WORD_REF(TCNTL_ADDR)
+#define TPERIOD_ADDR		0xffe03004	/*  register 32 bit */
+#define TPERIOD			WORD_REF(TPERIOD_ADDR)
+#define TSCALE_ADDR		0xffe03008	/*  register 32 bit */
+#define TSCALE			WORD_REF(TSCALE_ADDR)
+#define TCOUNT_ADDR		0xffe0300c	/*  register 32 bit */
+#define TCOUNT			WORD_REF(TCOUNT_ADDR)
+
+/****************************
+ *
+ *  DEBUG & EMULATION UNIT REGISTERS  (0XFFC05000 - 0XFFC0500C)
+ *
+ ****************************/
+
+#define DSPID_ADDR		0xffe05000	/*  register 32 bit */
+#define DSPID			WORD_REF(DSPID_ADDR)
+#define DBGSTAT_ADDR		0xffe05008	/*  register 32 bit */
+#define DBGSTAT			WORD_REF(DBGSTAT_ADDR)
+#define EMUDAT_ADDR		0xffe0500c	/*  register 32 bit */
+#define EMUDAT			WORD_REF(EMUDAT_ADDR)
+
+/****************************
+ *
+ *  TRACE UNIT REGISTERS  (0XFFC06000 - 0XFFC06100)
+ *
+ ****************************/
+
+#define TBUFCTL_ADDR		0xffe06000	/*  register 32 bit */
+#define TBUFCTL			WORD_REF(TBUFCTL_ADDR)
+#define TBUFSTAT_ADDR		0xffe06004	/*  register 32 bit */
+#define TBUFSTAT		WORD_REF(TBUFSTAT_ADDR)
+#define TBUF_ADDR		0xffe06100	/*  register 32 bit */
+#define TBUF			WORD_REF(TBUF_ADDR)
+
+/****************************
+ *
+ *  WATCHPOINT & PATCH UNIT REGISTERS  (0XFFC07000 - 0XFFC07200)
+ *
+ ****************************/
+
+#define WPIACTL_ADDR		0xffe07000	/*  register 32 bit */
+#define WPIACTL			WORD_REF(WPIACTL_ADDR)
+		/* TOTAL OF 6  */
+#define WPIA_ADDR		0xffe07040	/*  register 32 bit */
+#define WPIA			WORD_REF(WPIA_ADDR)
+		/* TOTAL OF 6  */
+#define WPIACNT_ADDR		0xffe07080	/*  register 32 bit */
+#define WPIACNT			WORD_REF(WPIACNT_ADDR)
+
+#define WPDACTL_ADDR		0xffe07100	/*  register 32 bit */
+#define WPDACTL			WORD_REF(WPDACTL_ADDR)
+		/* TOTAL OF 2 */
+#define WPDA_ADDR		0xffe07140	/*  register 32 bit */
+#define WPDA			WORD_REF(WPDA_ADDR)
+		/* TOTAL OF 2 */
+#define WPDACNT_ADDR		0xffe07180	/*  register 32 bit */
+#define WPDACNT			WORD_REF(WPDACNT_ADDR)
+
+#define WPSTAT_ADDR		0xffe07200	/*  register 32 bit */
+#define WPSTAT			WORD_REF(WPSTAT_ADDR)
+
+/****************************
+ *
+ *  PERFORMANCE MONITOR REGISTERS  (0XFFC08000 - 0XFFC08104)
+ *
+ ****************************/
+
+#define PFCTL_ADDR		0xffe08000	/*  register 32 bit */
+#define PFCTL			WORD_REF(PFCTL_ADDR)
+		/* TOTAL OF 2 */
+#define PFCNTR_ADDR		0xffe08100	/*  register 32 bit */
+#define PFCNTR			WORD_REF(PFCNTR_ADDR)
+
+/***************************
+ *
+ * SYSTEM INTERRUPT CONTROLLER REGISTERS
+ *
+ ***************************/
+#define SIC_ISR_ADDR		0xffc00c14	/*  register 32 bit */
+#define SIC_ISR			WORD_REF(SIC_ISR_ADDR)
+
+#define SIC_IWR_ADDR		0xffc00c18	/*  register 32 bit */
+#define SIC_IWR			WORD_REF(SIC_IWR_ADDR)
+
+#define SIC_MASK_ADDR		0xffc00c10	/*  register 32 bit */
+#define SIC_MASK		WORD_REF(SIC_MASK_ADDR)
+
+#define SIC_RVECT_ADDR		0xffc00c00	/*  register 16 bit */
+#define SIC_RVECT		HALFWORD_REF(SIC_RVECT_ADDR)
+
+#define SIC_MASK_ALL		0x80000000
+
+#endif				/* _BLKFin_H_  */
Index: git/linux-2.6/include/asm-blackfin/mach-bf535/bf535_serial.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf535/bf535_serial.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,109 @@
+
+ /*
+  * File:         include/asm-blackfin/mach-bf535/bf535_serial.h
+  * Based on:
+  * Author:
+  *
+  * Created:
+  * Description:
+  *
+  * Rev:
+  *
+  * Modified:
+  *
+  *
+  * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.
+  * If not, write to the Free Software Foundation,
+  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+  */
+
+#ifndef _BF535_SERIAL_H_
+#define _BF535_SERIAL_H_
+
+#define UART0_THR_ADDR		0xffc01800	/* UART 0 Transmit holding register
+						   16 bit */
+#define UART_THR(idx)		HALFWORD_REF((UART0_THR_ADDR | (idx << 10)))
+
+#define UART0_RBR_ADDR		0xffc01800	/* UART 0 Receive buffer register
+						   16 bit */
+#define UART_RBR(idx)		HALFWORD_REF((UART0_RBR_ADDR | (idx << 10)))
+
+#define UART0_DLL_ADDR		0xffc01800	/* UART 0 Divisor latch (low byte)
+						   register  16 bit */
+#define UART_DLL(idx)		HALFWORD_REF((UART0_DLL_ADDR | (idx << 10)))
+
+#define UART0_IER_ADDR		0xffc01802	/* UART 0 Interrupt enable register  16 bit */
+#define UART_IER(idx)		HALFWORD_REF((UART0_IER_ADDR | (idx << 10)))
+#define UART_IER_ERBFI		0x01	/* Enable Receive Buffer Full Interrupt
+					   (DR bit) */
+#define UART_IER_ETBEI		0x02	/* Enable Transmit Buffer Empty
+					   Interrupt(THRE bit) */
+#define UART_IER_ELSI		0x04	/* Enable RX Status Interrupt
+					   (gen if any of LSR[4:1] set) */
+#define UART_IER_EDDSI		0x08	/* Enable Modem Status Interrupt(gen if any UARTx_MSR[3:0] set) */
+
+#define UART0_DLH_ADDR		0xffc01802	/* UART 0 Divisor latch (high byte) register  16 bit */
+#define UART_DLH(idx)		HALFWORD_REF((UART0_DLH_ADDR | (idx << 10)))
+#define UART0_IIR_ADDR		0xffc01804	/* UART 0 Interrupt identification register  16 bit */
+#define UART_IIR(idx)		HALFWORD_REF((UART0_IIR_ADDR | (idx << 10)))
+#define UART_IIR_NOINT		0x01	/* Bit0: cleared when no interrupt */
+#define UART_IIR_STATUS		0x06	/* mask bit for the status: bit2-1 */
+#define UART_IIR_LSR		0x06	/* Receive line status */
+#define UART_IIR_RBR		0x04	/* Receive data ready */
+#define UART_IIR_THR		0x02	/* Ready to transmit  */
+#define UART_IIR_MSR		0x00	/* Modem status       */
+
+#define UART0_LCR_ADDR          0xffc01806	/* UART 0 Line control register  16 bit */
+#define UART_LCR(idx)           HALFWORD_REF((UART0_LCR_ADDR | (idx << 10)))
+#define UART_LCR_WLS5           0	/* word length 5 bits */
+#define UART_LCR_WLS6           0x01	/* word length 6 bits */
+#define UART_LCR_WLS7           0x02	/* word length 7 bits */
+#define UART_LCR_WLS8           0x03	/* word length 8 bits */
+#define UART_LCR_STB            0x04	/* StopBit: 1: 2 stop bits for
+					   non-5-bit word length 1/2 stop bits
+					   for 5-bit word length 0:
+					   1 stop bit */
+#define UART_LCR_PEN            0x08	/* Parity Enable 1: for enable */
+#define UART_LCR_EPS            0x10	/* Parity Selection:
+					   1: for even pariety
+					   0: odd parity when PEN =1 & SP =0 */
+#define UART_LCR_SP             0x20	/* Sticky Parity: */
+#define UART_LCR_SB             0x40	/* Set Break: force TX pin to 0 */
+#define UART_LCR_DLAB           0x80	/* Divisor Latch Access */
+
+#define UART0_MCR_ADDR          0xffc01808	/* UART 0 Module Control register
+						   16 bit */
+#define UART_MCR(idx)           HALFWORD_REF((UART0_MCR_ADDR | (idx << 10)))
+
+#define UART0_LSR_ADDR          0xffc0180a	/* UART 0 Line status register
+						   16 bit */
+#define UART_LSR(idx)           HALFWORD_REF((UART0_LSR_ADDR | (idx << 10)))
+#define UART_LSR_DR             0x01	/* Data Ready */
+#define UART_LSR_OE             0x02	/* Overrun Error */
+#define UART_LSR_PE             0x04	/* Parity Error  */
+#define UART_LSR_FE             0x08	/* Frame Error   */
+#define UART_LSR_BI             0x10	/* Break Interrupt */
+#define UART_LSR_THRE           0x20	/* THR empty, REady to accept */
+#define UART_LSR_TEMT           0x40	/* TSR and UARTx_thr both empty */
+
+#define UART0_MSR_ADDR          0xffc0180c	/* UART 0 Modem status register  16 bit */
+#define UART_MSR(idx)           HALFWORD_REF((UART0_MSR_ADDR | (idx << 10)))
+#define UART0_SCR_ADDR          0xffc0180e	/* UART 0 Scratch register  16 bit */
+#define UART_SCR(idx)           HALFWORD_REF((UART0_SCR_ADDR | (idx << 10)))
+#define UART0_IRCR_ADDR         0xffc01810	/* UART 0 IrDA Control register  16 bit */
+#define UART_IRCR(idx)          HALFWORD_REF((UART0_IRCR_ADDR | (idx << 10)))
+
+#endif				/* _BF535_SERIAL_H_ */
Index: git/linux-2.6/include/asm-blackfin/mach-bf535/blackfin.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf535/blackfin.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,44 @@
+
+/*
+ * File:         include/asm-blackfin/mach-bf535/blackfin.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *	Common header file for blackfin family of processors
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MACH_BLACKFIN_H_
+#define _MACH_BLACKFIN_H_
+
+#include "bf535.h"
+#include "mem_map.h"
+#include "defBF535.h"
+
+#if !(defined(__ASSEMBLY__) || defined(ASSEMBLY))
+#include "cdefBF535.h"
+#endif
+
+#endif				/* _MACH_BLACKFIN_H_ */
Index: git/linux-2.6/include/asm-blackfin/mach-bf535/cdefBF535.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf535/cdefBF535.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,475 @@
+/*
+ * File:         include/asm-blackfin/mach-bf535/cdefBF535.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *	include all Core registers and bit definition
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _CDEF_BF535_H
+#define _CDEF_BF535_H
+
+//
+/*
+#if defined(__ADSPLPBLACKFIN__)
+#warning cdefBF535.h should only be included for 535 compatible chips.
+#endif
+*/
+#include "defBF535.h"
+
+// include core specific register pointer definitions
+#include "cdefblackfin.h"
+
+// Clock and System Control (0xFFC0 0400-0xFFC0 07FF)
+#define pPLL_CTL ((volatile unsigned long *)PLL_CTL)
+#define pPLL_STAT ((volatile unsigned short *)PLL_STAT)
+#define pPLL_LOCKCNT ((volatile unsigned short *)PLL_LOCKCNT)
+#define pSWRST ((volatile unsigned short *)SWRST)
+#define pSYSCR ((volatile unsigned short *)SYSCR)
+#define pPLL_IOCKR ((volatile unsigned short *)PLL_IOCKR)
+
+// JTAG/Debug Communication Channel (0xFFC0 0800-0xFFC0 0BFF)
+#define pCHIPID ((volatile unsigned long *)CHIPID)
+
+// System Interrupt Controller (0xFFC0 0C00-0xFFC0 0FFF)
+/*
+#define SIC_RVECT              0xFFC00C00  // Reset Vector Register
+*/
+#define pSIC_IAR0 ((volatile unsigned long *)SIC_IAR0)
+#define pSIC_IAR1 ((volatile unsigned long *)SIC_IAR1)
+#define pSIC_IAR2 ((volatile unsigned long *)SIC_IAR2)
+#define pSIC_IMASK ((volatile unsigned long *)SIC_IMASK)
+#define pSIC_ISR ((volatile unsigned long *)SIC_ISR)
+#define pSIC_IWR ((volatile unsigned long *)SIC_IWR)
+
+// Watchdog Timer (0xFFC0 1000-0xFFC0 13FF)
+#define pWDOG_CTL ((volatile unsigned short *)WDOG_CTL)
+#define pWDOG_CNT ((volatile unsigned long *)WDOG_CNT)
+#define pWDOG_STAT ((volatile unsigned long *)WDOG_STAT)
+
+// Real Time Clock (0xFFC0 1400-0xFFC0 17FF)
+#define pRTC_STAT ((volatile unsigned long *)RTC_STAT)
+#define pRTC_ICTL ((volatile unsigned short *)RTC_ICTL)
+#define pRTC_ISTAT ((volatile unsigned short *)RTC_ISTAT)
+#define pRTC_SWCNT ((volatile unsigned short *)RTC_SWCNT)
+#define pRTC_ALARM ((volatile unsigned long *)RTC_ALARM)
+#define pRTC_FAST ((volatile unsigned short *)RTC_FAST)
+
+// General Purpose IO (0xFFC0 2400-0xFFC0 27FF)
+#define pFIO_DIR ((volatile unsigned short *)FIO_DIR)
+#define pFIO_FLAG_C ((volatile unsigned short *)FIO_FLAG_C)
+#define pFIO_FLAG_S ((volatile unsigned short *)FIO_FLAG_S)
+#define pFIO_MASKA_C ((volatile unsigned short *)FIO_MASKA_C)
+#define pFIO_MASKA_S ((volatile unsigned short *)FIO_MASKA_S)
+#define pFIO_MASKB_C ((volatile unsigned short *)FIO_MASKB_C)
+#define pFIO_MASKB_S ((volatile unsigned short *)FIO_MASKB_S)
+#define pFIO_POLAR ((volatile unsigned short *)FIO_POLAR)
+#define pFIO_EDGE ((volatile unsigned short *)FIO_EDGE)
+#define pFIO_BOTH ((volatile unsigned short *)FIO_BOTH)
+
+// Aysnchronous Memory Controller - External Bus Interface Unit (0xFFC0 3C00-0xFFC0 3FFF)
+#define pEBIU_AMGCTL ((volatile unsigned short *)EBIU_AMGCTL)
+#define pEBIU_AMBCTL0 ((volatile unsigned long *)EBIU_AMBCTL0)
+#define pEBIU_AMBCTL1 ((volatile unsigned long *)EBIU_AMBCTL1)
+
+// USB Registers (0xFFC0 4400 - 0xFFC0 47FF)
+#define pUSBD_ID ((volatile unsigned short *)USBD_ID)
+#define pUSBD_FRM ((volatile unsigned short *)USBD_FRM)
+#define pUSBD_FRMAT ((volatile unsigned short *)USBD_FRMAT)
+#define pUSBD_EPBUF ((volatile unsigned short *)USBD_EPBUF)
+#define pUSBD_STAT ((volatile unsigned short *)USBD_STAT)
+#define pUSBD_CTRL ((volatile unsigned short *)USBD_CTRL)
+#define pUSBD_GINTR ((volatile unsigned short *)USBD_GINTR)
+#define pUSBD_GMASK ((volatile unsigned short *)USBD_GMASK)
+#define pUSBD_DMACFG ((volatile unsigned short *)USBD_DMACFG)
+#define pUSBD_DMABL ((volatile unsigned short *)USBD_DMABL)
+#define pUSBD_DMABH ((volatile unsigned short *)USBD_DMABH)
+#define pUSBD_DMACT ((volatile unsigned short *)USBD_DMACT)
+#define pUSBD_DMAIRQ ((volatile unsigned short *)USBD_DMAIRQ)
+#define pUSBD_INTR0 ((volatile unsigned short *)USBD_INTR0)
+#define pUSBD_MASK0 ((volatile unsigned short *)USBD_MASK0)
+#define pUSBD_EPCFG0 ((volatile unsigned short *)USBD_EPCFG0)
+#define pUSBD_EPADR0 ((volatile unsigned short *)USBD_EPADR0)
+#define pUSBD_EPLEN0 ((volatile unsigned short *)USBD_EPLEN0)
+#define pUSBD_INTR1 ((volatile unsigned short *)USBD_INTR1)
+#define pUSBD_MASK1 ((volatile unsigned short *)USBD_MASK1)
+#define pUSBD_EPCFG1 ((volatile unsigned short *)USBD_EPCFG1)
+#define pUSBD_EPADR1 ((volatile unsigned short *)USBD_EPADR1)
+#define pUSBD_EPLEN1 ((volatile unsigned short *)USBD_EPLEN1)
+#define pUSBD_INTR2 ((volatile unsigned short *)USBD_INTR2)
+#define pUSBD_MASK2 ((volatile unsigned short *)USBD_MASK2)
+#define pUSBD_EPCFG2 ((volatile unsigned short *)USBD_EPCFG2)
+#define pUSBD_EPADR2 ((volatile unsigned short *)USBD_EPADR2)
+#define pUSBD_EPLEN2 ((volatile unsigned short *)USBD_EPLEN2)
+#define pUSBD_INTR3 ((volatile unsigned short *)USBD_INTR3)
+#define pUSBD_MASK3 ((volatile unsigned short *)USBD_MASK3)
+#define pUSBD_EPCFG3 ((volatile unsigned short *)USBD_EPCFG3)
+#define pUSBD_EPADR3 ((volatile unsigned short *)USBD_EPADR3)
+#define pUSBD_EPLEN3 ((volatile unsigned short *)USBD_EPLEN3)
+#define pUSBD_INTR4 ((volatile unsigned short *)USBD_INTR4)
+#define pUSBD_MASK4 ((volatile unsigned short *)USBD_MASK4)
+#define pUSBD_EPCFG4 ((volatile unsigned short *)USBD_EPCFG4)
+#define pUSBD_EPADR4 ((volatile unsigned short *)USBD_EPADR4)
+#define pUSBD_EPLEN4 ((volatile unsigned short *)USBD_EPLEN4)
+#define pUSBD_INTR5 ((volatile unsigned short *)USBD_INTR5)
+#define pUSBD_MASK5 ((volatile unsigned short *)USBD_MASK5)
+#define pUSBD_EPCFG5 ((volatile unsigned short *)USBD_EPCFG5)
+#define pUSBD_EPADR5 ((volatile unsigned short *)USBD_EPADR5)
+#define pUSBD_EPLEN5 ((volatile unsigned short *)USBD_EPLEN5)
+#define pUSBD_INTR6 ((volatile unsigned short *)USBD_INTR6)
+#define pUSBD_MASK6 ((volatile unsigned short *)USBD_MASK6)
+#define pUSBD_EPCFG6 ((volatile unsigned short *)USBD_EPCFG6)
+#define pUSBD_EPADR6 ((volatile unsigned short *)USBD_EPADR6)
+#define pUSBD_EPLEN6 ((volatile unsigned short *)USBD_EPLEN6)
+#define pUSBD_INTR7 ((volatile unsigned short *)USBD_INTR7)
+#define pUSBD_MASK7 ((volatile unsigned short *)USBD_MASK7)
+#define pUSBD_EPCFG7 ((volatile unsigned short *)USBD_EPCFG7)
+#define pUSBD_EPADR7 ((volatile unsigned short *)USBD_EPADR7)
+#define pUSBD_EPLEN7 ((volatile unsigned short *)USBD_EPLEN7)
+
+// SDRAM Controller External Bus Interface Unit (0xFFC0 4C00-0xFFC0 4FFF)
+#define pEBIU_SDGCTL ((volatile unsigned long *)EBIU_SDGCTL)
+#define pEBIU_SDRRC ((volatile unsigned short *)EBIU_SDRRC)
+#define pEBIU_SDSTAT ((volatile unsigned short *)EBIU_SDSTAT)
+#define pEBIU_SDBCTL ((volatile unsigned long *)EBIU_SDBCTL)
+
+// Memory Map
+
+// Core MMRs
+#define pCOREMMR_BASE ((volatile void *)COREMMR_BASE)
+
+// System MMRs
+#define pSYSMMR_BASE ((volatile void *)SYSMMR_BASE)
+
+// L1 cache/SRAM internal memory
+#define pL1_DATA_A ((void *)L1_DATA_A)
+#define pL1_DATA_B ((void *)L1_DATA_B)
+#define pL1_CODE ((void *)L1_CODE)
+#define pL1_SCRATCH ((void *)L1_SCRATCH)
+
+// L2 SRAM external memory
+#define pL2_BASE ((void *)L2_BASE)
+
+// PCI Spaces
+#define pPCI_CONFIG_SPACE_PORT ((volatile void *)PCI_CONFIG_SPACE_PORT)
+#define pPCI_CONFIG_BASE ((volatile void *)PCI_CONFIG_BASE)
+#define pPCI_IO_BASE ((volatile void *)PCI_IO_BASE)
+#define pPCI_MEM_BASE ((volatile void *)PCI_MEM_BASE)
+
+// Async Memory Banks
+#define pASYNC_BANK3_BASE ((void *)ASYNC_BANK3_BASE)
+#define pASYNC_BANK2_BASE ((void *)ASYNC_BANK2_BASE)
+#define pASYNC_BANK1_BASE ((void *)ASYNC_BANK1_BASE)
+#define pASYNC_BANK0_BASE ((void *)ASYNC_BANK0_BASE)
+
+// Sync DRAM Banks
+#define pSDRAM_BANK3_BASE ((void *)SDRAM_BANK3_BASE)
+#define pSDRAM_BANK2_BASE ((void *)SDRAM_BANK2_BASE)
+#define pSDRAM_BANK1_BASE ((void *)SDRAM_BANK1_BASE)
+#define pSDRAM_BANK0_BASE ((void *)SDRAM_BANK0_BASE)
+
+// System MMR Register Map
+/*
+// L2 MISR MMRs (0xFFC0 0000-0xFFC0 03FF)
+#define MISR_CTL               0xFFC00000     // Control Register
+#define MISR_RMISR0            0xFFC00004     // coreL2[31:0] read bus
+#define MISR_RMISR1            0xFFC00008     // coreL2[63:32] read bus
+#define MISR_RMISR2            0xFFC0000C     // sysL2[31:0] read bus
+#define MISR_WMISR0            0xFFC00010     // coreL2[31:0] write bus
+#define MISR_WMISR1            0xFFC00014     // coreL2[63:32] write bus
+#define MISR_WMISR2            0xFFC00018     // sysL2[31:0] write bus
+*/
+
+// UART 0 Controller (0xFFC0 1800-0xFFC0 1BFF)
+#define pUART0_THR ((volatile unsigned short *)UART0_THR)
+#define pUART0_RBR ((volatile unsigned short *)UART0_RBR)
+#define pUART0_DLL ((volatile unsigned short *)UART0_DLL)
+#define pUART0_IER ((volatile unsigned short *)UART0_IER)
+#define pUART0_DLH ((volatile unsigned short *)UART0_DLH)
+#define pUART0_IIR ((volatile unsigned short *)UART0_IIR)
+#define pUART0_LCR ((volatile unsigned short *)UART0_LCR)
+#define pUART0_MCR ((volatile unsigned short *)UART0_MCR)
+#define pUART0_LSR ((volatile unsigned short *)UART0_LSR)
+#define pUART0_MSR ((volatile unsigned short *)UART0_MSR)
+#define pUART0_SCR ((volatile unsigned short *)UART0_SCR)
+#define pUART0_IRCR ((volatile unsigned short *)UART0_IRCR)
+#define pUART0_CURR_PTR_RX ((volatile unsigned short *)UART0_CURR_PTR_RX)
+#define pUART0_CONFIG_RX ((volatile unsigned short *)UART0_CONFIG_RX)
+#define pUART0_START_ADDR_HI_RX ((volatile unsigned short *)UART0_START_ADDR_HI_RX)
+#define pUART0_START_ADDR_LO_RX ((volatile unsigned short *)UART0_START_ADDR_LO_RX)
+#define pUART0_COUNT_RX ((volatile unsigned short *)UART0_COUNT_RX)
+#define pUART0_NEXT_DESCR_RX ((volatile unsigned short *)UART0_NEXT_DESCR_RX)
+#define pUART0_DESCR_RDY_RX ((volatile unsigned short *)UART0_DESCR_RDY_RX)
+#define pUART0_IRQSTAT_RX ((volatile unsigned short *)UART0_IRQSTAT_RX)
+#define pUART0_CURR_PTR_TX ((volatile unsigned short *)UART0_CURR_PTR_TX)
+#define pUART0_CONFIG_TX ((volatile unsigned short *)UART0_CONFIG_TX)
+#define pUART0_START_ADDR_HI_TX ((volatile unsigned short *)UART0_START_ADDR_HI_TX)
+#define pUART0_START_ADDR_LO_TX ((volatile unsigned short *)UART0_START_ADDR_LO_TX)
+#define pUART0_COUNT_TX ((volatile unsigned short *)UART0_COUNT_TX)
+#define pUART0_NEXT_DESCR_TX ((volatile unsigned short *)UART0_NEXT_DESCR_TX)
+#define pUART0_DESCR_RDY_TX ((volatile unsigned short *)UART0_DESCR_RDY_TX)
+#define pUART0_IRQSTAT_TX ((volatile unsigned short *)UART0_IRQSTAT_TX)
+
+// UART 1 Controller (0xFFC0 1C00-0xFFC0 1FFF)
+#define pUART1_THR ((volatile unsigned short *)UART1_THR)
+#define pUART1_RBR ((volatile unsigned short *)UART1_RBR)
+#define pUART1_DLL ((volatile unsigned short *)UART1_DLL)
+#define pUART1_IER ((volatile unsigned short *)UART1_IER)
+#define pUART1_DLH ((volatile unsigned short *)UART1_DLH)
+#define pUART1_IIR ((volatile unsigned short *)UART1_IIR)
+#define pUART1_LCR ((volatile unsigned short *)UART1_LCR)
+#define pUART1_MCR ((volatile unsigned short *)UART1_MCR)
+#define pUART1_LSR ((volatile unsigned short *)UART1_LSR)
+#define pUART1_MSR ((volatile unsigned short *)UART1_MSR)
+#define pUART1_SCR ((volatile unsigned short *)UART1_SCR)
+#define pUART1_CURR_PTR_RX ((volatile unsigned short *)UART1_CURR_PTR_RX)
+#define pUART1_CONFIG_RX ((volatile unsigned short *)UART1_CONFIG_RX)
+#define pUART1_START_ADDR_HI_RX ((volatile unsigned short *)UART1_START_ADDR_HI_RX)
+#define pUART1_START_ADDR_LO_RX ((volatile unsigned short *)UART1_START_ADDR_LO_RX)
+#define pUART1_COUNT_RX ((volatile unsigned short *)UART1_COUNT_RX)
+#define pUART1_NEXT_DESCR_RX ((volatile unsigned short *)UART1_NEXT_DESCR_RX)
+#define pUART1_DESCR_RDY_RX ((volatile unsigned short *)UART1_DESCR_RDY_RX)
+#define pUART1_IRQSTAT_RX ((volatile unsigned short *)UART1_IRQSTAT_RX)
+#define pUART1_CURR_PTR_TX ((volatile unsigned short *)UART1_CURR_PTR_TX)
+#define pUART1_CONFIG_TX ((volatile unsigned short *)UART1_CONFIG_TX)
+#define pUART1_START_ADDR_HI_TX ((volatile unsigned short *)UART1_START_ADDR_HI_TX)
+#define pUART1_START_ADDR_LO_TX ((volatile unsigned short *)UART1_START_ADDR_LO_TX)
+#define pUART1_COUNT_TX ((volatile unsigned short *)UART1_COUNT_TX)
+#define pUART1_NEXT_DESCR_TX ((volatile unsigned short *)UART1_NEXT_DESCR_TX)
+#define pUART1_DESCR_RDY_TX ((volatile unsigned short *)UART1_DESCR_RDY_TX)
+#define pUART1_IRQSTAT_TX ((volatile unsigned short *)UART1_IRQSTAT_TX)
+
+// TIMER 0, 1, 2 Registers (0xFFC0 2000-0xFFC0 23FF)
+#define pTIMER0_STATUS ((volatile unsigned short *)TIMER0_STATUS)
+#define pTIMER0_CONFIG ((volatile unsigned short *)TIMER0_CONFIG)
+#define pTIMER0_COUNTER_LO ((volatile unsigned short *)TIMER0_COUNTER_LO)
+#define pTIMER0_COUNTER_HI ((volatile unsigned short *)TIMER0_COUNTER_HI)
+#define pTIMER0_PERIOD_LO ((volatile unsigned short *)TIMER0_PERIOD_LO)
+#define pTIMER0_PERIOD_HI ((volatile unsigned short *)TIMER0_PERIOD_HI)
+#define pTIMER0_WIDTH_LO ((volatile unsigned short *)TIMER0_WIDTH_LO)
+#define pTIMER0_WIDTH_HI ((volatile unsigned short *)TIMER0_WIDTH_HI)
+#define pTIMER1_STATUS ((volatile unsigned short *)TIMER1_STATUS)
+#define pTIMER1_CONFIG ((volatile unsigned short *)TIMER1_CONFIG)
+#define pTIMER1_COUNTER_LO ((volatile unsigned short *)TIMER1_COUNTER_LO)
+#define pTIMER1_COUNTER_HI ((volatile unsigned short *)TIMER1_COUNTER_HI)
+#define pTIMER1_PERIOD_LO ((volatile unsigned short *)TIMER1_PERIOD_LO)
+#define pTIMER1_PERIOD_HI ((volatile unsigned short *)TIMER1_PERIOD_HI)
+#define pTIMER1_WIDTH_LO ((volatile unsigned short *)TIMER1_WIDTH_LO)
+#define pTIMER1_WIDTH_HI ((volatile unsigned short *)TIMER1_WIDTH_HI)
+#define pTIMER2_STATUS ((volatile unsigned short *)TIMER2_STATUS)
+#define pTIMER2_CONFIG ((volatile unsigned short *)TIMER2_CONFIG)
+#define pTIMER2_COUNTER_LO ((volatile unsigned short *)TIMER2_COUNTER_LO)
+#define pTIMER2_COUNTER_HI ((volatile unsigned short *)TIMER2_COUNTER_HI)
+#define pTIMER2_PERIOD_LO ((volatile unsigned short *)TIMER2_PERIOD_LO)
+#define pTIMER2_PERIOD_HI ((volatile unsigned short *)TIMER2_PERIOD_HI)
+#define pTIMER2_WIDTH_LO ((volatile unsigned short *)TIMER2_WIDTH_LO)
+#define pTIMER2_WIDTH_HI ((volatile unsigned short *)TIMER2_WIDTH_HI)
+
+// SPORT0 Controller (0xFFC0 2800-0xFFC0 2BFF)
+#define pSPORT0_TX_CONFIG ((volatile unsigned short *)SPORT0_TX_CONFIG)
+#define pSPORT0_RX_CONFIG ((volatile unsigned short *)SPORT0_RX_CONFIG)
+#define pSPORT0_TX ((volatile short *)SPORT0_TX)
+#define pSPORT0_RX ((volatile short *)SPORT0_RX)
+#define pSPORT0_TSCLKDIV ((volatile unsigned short *)SPORT0_TSCLKDIV)
+#define pSPORT0_RSCLKDIV ((volatile unsigned short *)SPORT0_RSCLKDIV)
+#define pSPORT0_TFSDIV ((volatile unsigned short *)SPORT0_TFSDIV)
+#define pSPORT0_RFSDIV ((volatile unsigned short *)SPORT0_RFSDIV)
+#define pSPORT0_STAT ((volatile unsigned short *)SPORT0_STAT)
+#define pSPORT0_MTCS0 ((volatile unsigned short *)SPORT0_MTCS0)
+#define pSPORT0_MTCS1 ((volatile unsigned short *)SPORT0_MTCS1)
+#define pSPORT0_MTCS2 ((volatile unsigned short *)SPORT0_MTCS2)
+#define pSPORT0_MTCS3 ((volatile unsigned short *)SPORT0_MTCS3)
+#define pSPORT0_MTCS4 ((volatile unsigned short *)SPORT0_MTCS4)
+#define pSPORT0_MTCS5 ((volatile unsigned short *)SPORT0_MTCS5)
+#define pSPORT0_MTCS6 ((volatile unsigned short *)SPORT0_MTCS6)
+#define pSPORT0_MTCS7 ((volatile unsigned short *)SPORT0_MTCS7)
+#define pSPORT0_MRCS0 ((volatile unsigned short *)SPORT0_MRCS0)
+#define pSPORT0_MRCS1 ((volatile unsigned short *)SPORT0_MRCS1)
+#define pSPORT0_MRCS2 ((volatile unsigned short *)SPORT0_MRCS2)
+#define pSPORT0_MRCS3 ((volatile unsigned short *)SPORT0_MRCS3)
+#define pSPORT0_MRCS4 ((volatile unsigned short *)SPORT0_MRCS4)
+#define pSPORT0_MRCS5 ((volatile unsigned short *)SPORT0_MRCS5)
+#define pSPORT0_MRCS6 ((volatile unsigned short *)SPORT0_MRCS6)
+#define pSPORT0_MRCS7 ((volatile unsigned short *)SPORT0_MRCS7)
+#define pSPORT0_MCMC1 ((volatile unsigned short *)SPORT0_MCMC1)
+#define pSPORT0_MCMC2 ((volatile unsigned short *)SPORT0_MCMC2)
+#define pSPORT0_CURR_PTR_RX ((volatile unsigned short *)SPORT0_CURR_PTR_RX)
+#define pSPORT0_CONFIG_DMA_RX ((volatile unsigned short *)SPORT0_CONFIG_DMA_RX)
+#define pSPORT0_START_ADDR_HI_RX ((volatile unsigned short *)SPORT0_START_ADDR_HI_RX)
+#define pSPORT0_START_ADDR_LO_RX ((volatile unsigned short *)SPORT0_START_ADDR_LO_RX)
+#define pSPORT0_COUNT_RX ((volatile unsigned short *)SPORT0_COUNT_RX)
+#define pSPORT0_NEXT_DESCR_RX ((volatile unsigned short *)SPORT0_NEXT_DESCR_RX)
+#define pSPORT0_DESCR_RDY_RX ((volatile unsigned short *)SPORT0_DESCR_RDY_RX)
+#define pSPORT0_IRQSTAT_RX ((volatile unsigned short *)SPORT0_IRQSTAT_RX)
+#define pSPORT0_CURR_PTR_TX ((volatile unsigned short *)SPORT0_CURR_PTR_TX)
+#define pSPORT0_CONFIG_DMA_TX ((volatile unsigned short *)SPORT0_CONFIG_DMA_TX)
+#define pSPORT0_START_ADDR_HI_TX ((volatile unsigned short *)SPORT0_START_ADDR_HI_TX)
+#define pSPORT0_START_ADDR_LO_TX ((volatile unsigned short *)SPORT0_START_ADDR_LO_TX)
+#define pSPORT0_COUNT_TX ((volatile unsigned short *)SPORT0_COUNT_TX)
+#define pSPORT0_NEXT_DESCR_TX ((volatile unsigned short *)SPORT0_NEXT_DESCR_TX)
+#define pSPORT0_DESCR_RDY_TX ((volatile unsigned short *)SPORT0_DESCR_RDY_TX)
+#define pSPORT0_IRQSTAT_TX ((volatile unsigned short *)SPORT0_IRQSTAT_TX)
+
+// SPORT1 Controller (0xFFC0 2C00-0xFFC0 2FFF)
+#define pSPORT1_TX_CONFIG ((volatile unsigned short *)SPORT1_TX_CONFIG)
+#define pSPORT1_RX_CONFIG ((volatile unsigned short *)SPORT1_RX_CONFIG)
+#define pSPORT1_TX ((volatile short *)SPORT1_TX)
+#define pSPORT1_RX ((volatile short *)SPORT1_RX)
+#define pSPORT1_TSCLKDIV ((volatile unsigned short *)SPORT1_TSCLKDIV)
+#define pSPORT1_RSCLKDIV ((volatile unsigned short *)SPORT1_RSCLKDIV)
+#define pSPORT1_TFSDIV ((volatile unsigned short *)SPORT1_TFSDIV)
+#define pSPORT1_RFSDIV ((volatile unsigned short *)SPORT1_RFSDIV)
+#define pSPORT1_STAT ((volatile unsigned short *)SPORT1_STAT)
+#define pSPORT1_MTCS0 ((volatile unsigned short *)SPORT1_MTCS0)
+#define pSPORT1_MTCS1 ((volatile unsigned short *)SPORT1_MTCS1)
+#define pSPORT1_MTCS2 ((volatile unsigned short *)SPORT1_MTCS2)
+#define pSPORT1_MTCS3 ((volatile unsigned short *)SPORT1_MTCS3)
+#define pSPORT1_MTCS4 ((volatile unsigned short *)SPORT1_MTCS4)
+#define pSPORT1_MTCS5 ((volatile unsigned short *)SPORT1_MTCS5)
+#define pSPORT1_MTCS6 ((volatile unsigned short *)SPORT1_MTCS6)
+#define pSPORT1_MTCS7 ((volatile unsigned short *)SPORT1_MTCS7)
+#define pSPORT1_MRCS0 ((volatile unsigned short *)SPORT1_MRCS0)
+#define pSPORT1_MRCS1 ((volatile unsigned short *)SPORT1_MRCS1)
+#define pSPORT1_MRCS2 ((volatile unsigned short *)SPORT1_MRCS2)
+#define pSPORT1_MRCS3 ((volatile unsigned short *)SPORT1_MRCS3)
+#define pSPORT1_MRCS4 ((volatile unsigned short *)SPORT1_MRCS4)
+#define pSPORT1_MRCS5 ((volatile unsigned short *)SPORT1_MRCS5)
+#define pSPORT1_MRCS6 ((volatile unsigned short *)SPORT1_MRCS6)
+#define pSPORT1_MRCS7 ((volatile unsigned short *)SPORT1_MRCS7)
+#define pSPORT1_MCMC1 ((volatile unsigned short *)SPORT1_MCMC1)
+#define pSPORT1_MCMC2 ((volatile unsigned short *)SPORT1_MCMC2)
+#define pSPORT1_CURR_PTR_RX ((volatile unsigned short *)SPORT1_CURR_PTR_RX)
+#define pSPORT1_CONFIG_DMA_RX ((volatile unsigned short *)SPORT1_CONFIG_DMA_RX)
+#define pSPORT1_START_ADDR_HI_RX ((volatile unsigned short *)SPORT1_START_ADDR_HI_RX)
+#define pSPORT1_START_ADDR_LO_RX ((volatile unsigned short *)SPORT1_START_ADDR_LO_RX)
+#define pSPORT1_COUNT_RX ((volatile unsigned short *)SPORT1_COUNT_RX)
+#define pSPORT1_NEXT_DESCR_RX ((volatile unsigned short *)SPORT1_NEXT_DESCR_RX)
+#define pSPORT1_DESCR_RDY_RX ((volatile unsigned short *)SPORT1_DESCR_RDY_RX)
+#define pSPORT1_IRQSTAT_RX ((volatile unsigned short *)SPORT1_IRQSTAT_RX)
+#define pSPORT1_CURR_PTR_TX ((volatile unsigned short *)SPORT1_CURR_PTR_TX)
+#define pSPORT1_CONFIG_DMA_TX ((volatile unsigned short *)SPORT1_CONFIG_DMA_TX)
+#define pSPORT1_START_ADDR_HI_TX ((volatile unsigned short *)SPORT1_START_ADDR_HI_TX)
+#define pSPORT1_START_ADDR_LO_TX ((volatile unsigned short *)SPORT1_START_ADDR_LO_TX)
+#define pSPORT1_COUNT_TX ((volatile unsigned short *)SPORT1_COUNT_TX)
+#define pSPORT1_NEXT_DESCR_TX ((volatile unsigned short *)SPORT1_NEXT_DESCR_TX)
+#define pSPORT1_DESCR_RDY_TX ((volatile unsigned short *)SPORT1_DESCR_RDY_TX)
+#define pSPORT1_IRQSTAT_TX ((volatile unsigned short *)SPORT1_IRQSTAT_TX)
+
+// SPI 0 Controller (0xFFC0 3000-0xFFC0 33FF)
+#define pSPI0_CTL ((volatile unsigned short *)SPI0_CTL)
+#define pSPI0_FLG ((volatile unsigned short *)SPI0_FLG)
+#define pSPI0_ST ((volatile unsigned short *)SPI0_ST)
+#define pSPI0_TDBR ((volatile unsigned short *)SPI0_TDBR)
+#define pSPI0_RDBR ((volatile unsigned short *)SPI0_RDBR)
+#define pSPI0_BAUD ((volatile unsigned short *)SPI0_BAUD)
+#define pSPI0_SHADOW ((volatile unsigned short *)SPI0_SHADOW)
+#define pSPI0_CURR_PTR ((volatile unsigned short *)SPI0_CURR_PTR)
+#define pSPI0_CONFIG ((volatile unsigned short *)SPI0_CONFIG)
+#define pSPI0_START_ADDR_HI ((volatile unsigned short *)SPI0_START_ADDR_HI)
+#define pSPI0_START_ADDR_LO ((volatile unsigned short *)SPI0_START_ADDR_LO)
+#define pSPI0_COUNT ((volatile unsigned short *)SPI0_COUNT)
+#define pSPI0_NEXT_DESCR ((volatile unsigned short *)SPI0_NEXT_DESCR)
+#define pSPI0_DESCR_RDY ((volatile unsigned short *)SPI0_DESCR_RDY)
+#define pSPI0_DMA_INT ((volatile unsigned short *)SPI0_DMA_INT)
+
+// SPI 1 Controller (0xFFC0 3400-0xFFC0 37FF)
+#define pSPI1_CTL ((volatile unsigned short *)SPI1_CTL)
+#define pSPI1_FLG ((volatile unsigned short *)SPI1_FLG)
+#define pSPI1_ST ((volatile unsigned short *)SPI1_ST)
+#define pSPI1_TDBR ((volatile unsigned short *)SPI1_TDBR)
+#define pSPI1_RDBR ((volatile unsigned short *)SPI1_RDBR)
+#define pSPI1_BAUD ((volatile unsigned short *)SPI1_BAUD)
+#define pSPI1_SHADOW ((volatile unsigned short *)SPI1_SHADOW)
+#define pSPI1_CURR_PTR ((volatile unsigned short *)SPI1_CURR_PTR)
+#define pSPI1_CONFIG ((volatile unsigned short *)SPI1_CONFIG)
+#define pSPI1_START_ADDR_HI ((volatile unsigned short *)SPI1_START_ADDR_HI)
+#define pSPI1_START_ADDR_LO ((volatile unsigned short *)SPI1_START_ADDR_LO)
+#define pSPI1_COUNT ((volatile unsigned short *)SPI1_COUNT)
+#define pSPI1_NEXT_DESCR ((volatile unsigned short *)SPI1_NEXT_DESCR)
+#define pSPI1_DESCR_RDY ((volatile unsigned short *)SPI1_DESCR_RDY)
+#define pSPI1_DMA_INT ((volatile unsigned short *)SPI1_DMA_INT)
+
+// Memory DMA Controller (0xFFC0 3800-0xFFC0 3BFF)
+#define pMDD_DCP ((volatile unsigned short *)MDD_DCP)
+#define pMDD_DCFG ((volatile unsigned short *)MDD_DCFG)
+#define pMDD_DSAH ((volatile unsigned short *)MDD_DSAH)
+#define pMDD_DSAL ((volatile unsigned short *)MDD_DSAL)
+#define pMDD_DCT ((volatile unsigned short *)MDD_DCT)
+#define pMDD_DND ((volatile unsigned short *)MDD_DND)
+#define pMDD_DDR ((volatile unsigned short *)MDD_DDR)
+#define pMDD_DI ((volatile unsigned short *)MDD_DI)
+#define pMDS_DCP ((volatile unsigned short *)MDS_DCP)
+#define pMDS_DCFG ((volatile unsigned short *)MDS_DCFG)
+#define pMDS_DSAH ((volatile unsigned short *)MDS_DSAH)
+#define pMDS_DSAL ((volatile unsigned short *)MDS_DSAL)
+#define pMDS_DCT ((volatile unsigned short *)MDS_DCT)
+#define pMDS_DND ((volatile unsigned short *)MDS_DND)
+#define pMDS_DDR ((volatile unsigned short *)MDS_DDR)
+#define pMDS_DI ((volatile unsigned short *)MDS_DI)
+
+// PCI Bridge PAB Registers (0xFFC0 4000-0xFFC0 43FF)
+#define pPCI_CTL ((volatile unsigned short *)PCI_CTL)
+#define pPCI_STAT ((volatile unsigned long *)PCI_STAT)
+#define pPCI_ICTL ((volatile unsigned long *)PCI_ICTL)
+#define pPCI_MBAP ((volatile void **)PCI_MBAP)
+#define pPCI_IBAP ((volatile void **)PCI_IBAP)
+#define pPCI_CBAP ((volatile void **)PCI_CBAP)
+#define pPCI_TMBAP ((volatile void **)PCI_TMBAP)
+#define pPCI_TIBAP ((volatile void **)PCI_TIBAP)
+
+// PCI Bridge External Access Bus Registers (0xEEFF FF00-0xEEFF FFFF)
+#define pPCI_DMBARM ((volatile unsigned long *)PCI_DMBARM)
+#define pPCI_DIBARM ((volatile unsigned long *)PCI_DIBARM)
+#define pPCI_CFG_DIC ((volatile unsigned long *)PCI_CFG_DIC)
+#define pPCI_CFG_VIC ((volatile unsigned long *)PCI_CFG_VIC)
+#define pPCI_CFG_STAT ((volatile unsigned long *)PCI_CFG_STAT)
+#define pPCI_CFG_CMD ((volatile unsigned long *)PCI_CFG_CMD)
+#define pPCI_CFG_CC ((volatile unsigned long *)PCI_CFG_CC)
+#define pPCI_CFG_RID ((volatile unsigned long *)PCI_CFG_RID)
+#define pPCI_CFG_BIST ((volatile unsigned long *)PCI_CFG_BIST)
+#define pPCI_CFG_HT ((volatile unsigned long *)PCI_CFG_HT)
+#define pPCI_CFG_MLT ((volatile unsigned long *)PCI_CFG_MLT)
+#define pPCI_CFG_CLS ((volatile unsigned long *)PCI_CFG_CLS)
+#define pPCI_CFG_MBAR ((volatile unsigned long *)PCI_CFG_MBAR)
+#define pPCI_CFG_IBAR ((volatile unsigned long *)PCI_CFG_IBAR)
+#define pPCI_CFG_SID ((volatile unsigned long *)PCI_CFG_SID)
+#define pPCI_CFG_SVID ((volatile unsigned long *)PCI_CFG_SVID)
+#define pPCI_CFG_MAXL ((volatile unsigned long *)PCI_CFG_MAXL)
+#define pPCI_CFG_MING ((volatile unsigned long *)PCI_CFG_MING)
+#define pPCI_CFG_IP ((volatile unsigned long *)PCI_CFG_IP)
+#define pPCI_CFG_IL ((volatile unsigned long *)PCI_CFG_IL)
+#define pPCI_HMCTL ((volatile unsigned long *)PCI_HMCTL)
+
+// System Bus Interface Unit (0xFFC0 4800-0xFFC0 4FFF)
+/*
+#define L1SBAR                 0xFFC04840  // L1 SRAM Base Address Register
+#define L1CSR                  0xFFC04844  // L1 SRAM Control Initialization Register
+*/
+#define pDMA_DBP ((volatile unsigned short *)DMA_DBP)
+#define pDB_ACOMP ((volatile void **)DB_ACOMP)
+#define pDB_CCOMP ((volatile unsigned long *)DB_CCOMP)
+
+#endif				/* _CDEF_BF535_H */
Index: git/linux-2.6/include/asm-blackfin/mach-bf535/cdefblackfin.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf535/cdefblackfin.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,198 @@
+
+/*
+ * File:         include/asm-blackfin/mach-bf535/cdefblackfin.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *	Common header file for blackfin family of processors
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _CDEF_BLACKFIN_H
+#define _CDEF_BLACKFIN_H
+/*
+#if defined(__ADSPLPBLACKFIN__)
+#warning cdefblackfin.h should only be included for 535 compatible chips.
+#endif
+*/
+#include "defblackfin.h"
+
+// Cache & SRAM Memory
+#define pSRAM_BASE_ADDRESS ((volatile void **)SRAM_BASE_ADDRESS)
+#define pDMEM_CONTROL ((volatile unsigned long *)DMEM_CONTROL)
+#define pDCPLB_STATUS ((volatile unsigned long *)DCPLB_STATUS)
+#define pDCPLB_FAULT_ADDR ((volatile void **)DCPLB_FAULT_ADDR)
+/*
+#define MMR_TIMEOUT            0xFFE00010  // Memory-Mapped Register Timeout Register
+*/
+#define pDCPLB_ADDR0 ((volatile void **)DCPLB_ADDR0)
+#define pDCPLB_ADDR1 ((volatile void **)DCPLB_ADDR1)
+#define pDCPLB_ADDR2 ((volatile void **)DCPLB_ADDR2)
+#define pDCPLB_ADDR3 ((volatile void **)DCPLB_ADDR3)
+#define pDCPLB_ADDR4 ((volatile void **)DCPLB_ADDR4)
+#define pDCPLB_ADDR5 ((volatile void **)DCPLB_ADDR5)
+#define pDCPLB_ADDR6 ((volatile void **)DCPLB_ADDR6)
+#define pDCPLB_ADDR7 ((volatile void **)DCPLB_ADDR7)
+#define pDCPLB_ADDR8 ((volatile void **)DCPLB_ADDR8)
+#define pDCPLB_ADDR9 ((volatile void **)DCPLB_ADDR9)
+#define pDCPLB_ADDR10 ((volatile void **)DCPLB_ADDR10)
+#define pDCPLB_ADDR11 ((volatile void **)DCPLB_ADDR11)
+#define pDCPLB_ADDR12 ((volatile void **)DCPLB_ADDR12)
+#define pDCPLB_ADDR13 ((volatile void **)DCPLB_ADDR13)
+#define pDCPLB_ADDR14 ((volatile void **)DCPLB_ADDR14)
+#define pDCPLB_ADDR15 ((volatile void **)DCPLB_ADDR15)
+#define pDCPLB_DATA0 ((volatile unsigned long *)DCPLB_DATA0)
+#define pDCPLB_DATA1 ((volatile unsigned long *)DCPLB_DATA1)
+#define pDCPLB_DATA2 ((volatile unsigned long *)DCPLB_DATA2)
+#define pDCPLB_DATA3 ((volatile unsigned long *)DCPLB_DATA3)
+#define pDCPLB_DATA4 ((volatile unsigned long *)DCPLB_DATA4)
+#define pDCPLB_DATA5 ((volatile unsigned long *)DCPLB_DATA5)
+#define pDCPLB_DATA6 ((volatile unsigned long *)DCPLB_DATA6)
+#define pDCPLB_DATA7 ((volatile unsigned long *)DCPLB_DATA7)
+#define pDCPLB_DATA8 ((volatile unsigned long *)DCPLB_DATA8)
+#define pDCPLB_DATA9 ((volatile unsigned long *)DCPLB_DATA9)
+#define pDCPLB_DATA10 ((volatile unsigned long *)DCPLB_DATA10)
+#define pDCPLB_DATA11 ((volatile unsigned long *)DCPLB_DATA11)
+#define pDCPLB_DATA12 ((volatile unsigned long *)DCPLB_DATA12)
+#define pDCPLB_DATA13 ((volatile unsigned long *)DCPLB_DATA13)
+#define pDCPLB_DATA14 ((volatile unsigned long *)DCPLB_DATA14)
+#define pDCPLB_DATA15 ((volatile unsigned long *)DCPLB_DATA15)
+#define pDTEST_COMMAND ((volatile unsigned long *)DTEST_COMMAND)
+/*
+#define DTEST_INDEX            0xFFE00304  // Data Test Index Register
+*/
+#define pDTEST_DATA0 ((volatile unsigned long *)DTEST_DATA0)
+#define pDTEST_DATA1 ((volatile unsigned long *)DTEST_DATA1)
+/*
+#define DTEST_DATA2            0xFFE00408  // Data Test Data Register
+#define DTEST_DATA3            0xFFE0040C  // Data Test Data Register
+*/
+#define pIMEM_CONTROL ((volatile unsigned long *)IMEM_CONTROL)
+#define pICPLB_STATUS ((volatile unsigned long *)ICPLB_STATUS)
+#define pICPLB_FAULT_ADDR ((volatile void **)ICPLB_FAULT_ADDR)
+#define pICPLB_ADDR0 ((volatile void **)ICPLB_ADDR0)
+#define pICPLB_ADDR1 ((volatile void **)ICPLB_ADDR1)
+#define pICPLB_ADDR2 ((volatile void **)ICPLB_ADDR2)
+#define pICPLB_ADDR3 ((volatile void **)ICPLB_ADDR3)
+#define pICPLB_ADDR4 ((volatile void **)ICPLB_ADDR4)
+#define pICPLB_ADDR5 ((volatile void **)ICPLB_ADDR5)
+#define pICPLB_ADDR6 ((volatile void **)ICPLB_ADDR6)
+#define pICPLB_ADDR7 ((volatile void **)ICPLB_ADDR7)
+#define pICPLB_ADDR8 ((volatile void **)ICPLB_ADDR8)
+#define pICPLB_ADDR9 ((volatile void **)ICPLB_ADDR9)
+#define pICPLB_ADDR10 ((volatile void **)ICPLB_ADDR10)
+#define pICPLB_ADDR11 ((volatile void **)ICPLB_ADDR11)
+#define pICPLB_ADDR12 ((volatile void **)ICPLB_ADDR12)
+#define pICPLB_ADDR13 ((volatile void **)ICPLB_ADDR13)
+#define pICPLB_ADDR14 ((volatile void **)ICPLB_ADDR14)
+#define pICPLB_ADDR15 ((volatile void **)ICPLB_ADDR15)
+#define pICPLB_DATA0 ((volatile unsigned long *)ICPLB_DATA0)
+#define pICPLB_DATA1 ((volatile unsigned long *)ICPLB_DATA1)
+#define pICPLB_DATA2 ((volatile unsigned long *)ICPLB_DATA2)
+#define pICPLB_DATA3 ((volatile unsigned long *)ICPLB_DATA3)
+#define pICPLB_DATA4 ((volatile unsigned long *)ICPLB_DATA4)
+#define pICPLB_DATA5 ((volatile unsigned long *)ICPLB_DATA5)
+#define pICPLB_DATA6 ((volatile unsigned long *)ICPLB_DATA6)
+#define pICPLB_DATA7 ((volatile unsigned long *)ICPLB_DATA7)
+#define pICPLB_DATA8 ((volatile unsigned long *)ICPLB_DATA8)
+#define pICPLB_DATA9 ((volatile unsigned long *)ICPLB_DATA9)
+#define pICPLB_DATA10 ((volatile unsigned long *)ICPLB_DATA10)
+#define pICPLB_DATA11 ((volatile unsigned long *)ICPLB_DATA11)
+#define pICPLB_DATA12 ((volatile unsigned long *)ICPLB_DATA12)
+#define pICPLB_DATA13 ((volatile unsigned long *)ICPLB_DATA13)
+#define pICPLB_DATA14 ((volatile unsigned long *)ICPLB_DATA14)
+#define pICPLB_DATA15 ((volatile unsigned long *)ICPLB_DATA15)
+#define pITEST_COMMAND ((volatile unsigned long *)ITEST_COMMAND)
+/*
+#define ITEST_INDEX            0xFFE01304  // Instruction Test Index Register
+*/
+#define pITEST_DATA0 ((volatile unsigned long *)ITEST_DATA0)
+#define pITEST_DATA1 ((volatile unsigned long *)ITEST_DATA1)
+
+// Event/Interrupt Registers
+#define pEVT0 ((volatile void **)EVT0)
+#define pEVT1 ((volatile void **)EVT1)
+#define pEVT2 ((volatile void **)EVT2)
+#define pEVT3 ((volatile void **)EVT3)
+#define pEVT4 ((volatile void **)EVT4)
+#define pEVT5 ((volatile void **)EVT5)
+#define pEVT6 ((volatile void **)EVT6)
+#define pEVT7 ((volatile void **)EVT7)
+#define pEVT8 ((volatile void **)EVT8)
+#define pEVT9 ((volatile void **)EVT9)
+#define pEVT10 ((volatile void **)EVT10)
+#define pEVT11 ((volatile void **)EVT11)
+#define pEVT12 ((volatile void **)EVT12)
+#define pEVT13 ((volatile void **)EVT13)
+#define pEVT14 ((volatile void **)EVT14)
+#define pEVT15 ((volatile void **)EVT15)
+#define pIMASK ((volatile unsigned short *)IMASK)
+#define pIPEND ((volatile unsigned short *)IPEND)
+#define pILAT ((volatile unsigned short *)ILAT)
+
+// Core Timer Registers
+#define pTCNTL ((volatile unsigned long *)TCNTL)
+#define pTPERIOD ((volatile unsigned long *)TPERIOD)
+#define pTSCALE ((volatile unsigned long *)TSCALE)
+#define pTCOUNT ((volatile unsigned long *)TCOUNT)
+
+// Debug/MP/Emulation Registers
+#define pDSPID ((volatile unsigned long *)DSPID)
+#define pDBGCTL ((volatile unsigned long *)DBGCTL)
+#define pDBGSTAT ((volatile unsigned long *)DBGSTAT)
+#define pEMUDAT ((volatile unsigned long *)EMUDAT)
+
+// Trace Buffer Registers
+#define pTBUFCTL ((volatile unsigned long *)TBUFCTL)
+#define pTBUFSTAT ((volatile unsigned long *)TBUFSTAT)
+#define pTBUF ((volatile void **)TBUF)
+
+// Watch Point Control Registers
+#define pWPIACTL ((volatile unsigned long *)WPIACTL)
+#define pWPIA0 ((volatile void **)WPIA0)
+#define pWPIA1 ((volatile void **)WPIA1)
+#define pWPIA2 ((volatile void **)WPIA2)
+#define pWPIA3 ((volatile void **)WPIA3)
+#define pWPIA4 ((volatile void **)WPIA4)
+#define pWPIA5 ((volatile void **)WPIA5)
+#define pWPIACNT0 ((volatile unsigned long *)WPIACNT0)
+#define pWPIACNT1 ((volatile unsigned long *)WPIACNT1)
+#define pWPIACNT2 ((volatile unsigned long *)WPIACNT2)
+#define pWPIACNT3 ((volatile unsigned long *)WPIACNT3)
+#define pWPIACNT4 ((volatile unsigned long *)WPIACNT4)
+#define pWPIACNT5 ((volatile unsigned long *)WPIACNT5)
+#define pWPDACTL ((volatile unsigned long *)WPDACTL)
+#define pWPDA0 ((volatile void **)WPDA0)
+#define pWPDA1 ((volatile void **)WPDA1)
+#define pWPDACNT0 ((volatile unsigned long *)WPDACNT0)
+#define pWPDACNT1 ((volatile unsigned long *)WPDACNT1)
+#define pWPSTAT ((volatile unsigned long *)WPSTAT)
+
+// Performance Monitor Registers
+#define pPFCTL ((volatile unsigned long *)PFCTL)
+#define pPFCNTR0 ((volatile unsigned long *)PFCNTR0)
+#define pPFCNTR1 ((volatile unsigned long *)PFCNTR1)
+
+#endif				/* _CDEF_BLACKFIN_H */
Index: git/linux-2.6/include/asm-blackfin/mach-bf535/defBF535.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf535/defBF535.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,1154 @@
+/*
+ * File:         include/asm-blackfin/mach-bf535/defBF535.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *	Common header file for blackfin family of processors
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* SYSTEM & MM REGISTER BIT & ADDRESS DEFINITIONS FOR ADSP-BF535 */
+
+#ifndef _DEF_BF535_H
+#define _DEF_BF535_H
+
+#if defined(__ADSPLPBLACKFIN__)
+#warning defBF535.h should only be included for 535 compatible chips.
+#endif
+// include all Core registers and bit definitions
+#include <defBlackfin.h>
+
+//**********************************************************************************
+// Memory Map
+//**********************************************************************************
+
+// Core MMRs
+#define COREMMR_BASE           0xFFE00000	// Core MMRs
+#define COREMMR_SIZE           0x200000	// 2MB
+
+// System MMRs
+#define SYSMMR_BASE            0xFFC00000	// System MMRs
+#define SYSMMR_SIZE            0x200000	// 2MB
+
+// L1 cache/SRAM internal memory
+#define L1_DATA_A		0xFF800000	// L1 Data Bank A
+#define L1_DATA_B		0xFF900000	// L1 Data Bank B
+#define L1_DATA_SIZE		0x4000	//  16K
+#define L1_CODE			0xFFA00000	// L1 Code SRAM
+#define L1_CODE_SIZE		0x4000	//  16K
+#define L1_SCRATCH		0xFFB00000	// L1 Scratch SRAM
+#define L1_SCRATCH_SIZE		0x1000	//  4K
+
+// L2 SRAM external memory
+#define L2_BASE			0xF0000000	// L2 SRAM
+#define L2_SIZE			0x40000	//  256K
+
+// PCI Spaces
+#define PCI_CONFIG_SPACE_PORT	0xEEFFFFFC	// PCI config space reg
+#define PCI_CONFIG_BASE		0xEEFFFF00	// PCI config region
+#define PCI_CONFIG_SIZE		0x10000	//  64K
+#define PCI_IO_BASE		0xEEFE0000	// PCI I/O space
+#define PCI_IO_SIZE		0x10000	//  64K
+#define PCI_MEM_BASE		0xE0000000	// PCI Mem space
+#define PCI_MEM_SIZE		0x8000000	//  64K
+
+// Async Memory Banks
+#define ASYNC_BANK3_BASE	0x2C000000	// Async Bank 3
+#define ASYNC_BANK3_SIZE	0x4000000	//  64 MB
+#define ASYNC_BANK2_BASE	0x28000000	// Async Bank 2
+#define ASYNC_BANK2_SIZE	0x4000000	//  64 MB
+#define ASYNC_BANK1_BASE	0x24000000	// Async Bank 1
+#define ASYNC_BANK1_SIZE	0x4000000	//  64 MB
+#define ASYNC_BANK0_BASE	0x20000000	// Async Bank 0
+#define ASYNC_BANK0_SIZE	0x4000000	//  64 MB
+
+// Sync DRAM Banks
+#define SDRAM_BANK3_BASE	0x18000000	// Sync Bank 3
+#define SDRAM_BANK2_BASE	0x10000000	// Sync Bank 2
+#define SDRAM_BANK1_BASE	0x08000000	// Sync Bank 1
+#define SDRAM_BANK0_BASE	0x00000000	// Sync Bank 0
+
+//**********************************************************************************
+// System MMR Register Map
+//**********************************************************************************
+
+// L2 MISR MMRs (0xFFC0 0000-0xFFC0 03FF)
+#define MISR_CTL               0xFFC00000	// Control Register
+#define MISR_RMISR0            0xFFC00004	// coreL2[31:0] read bus
+#define MISR_RMISR1            0xFFC00008	// coreL2[63:32] read bus
+#define MISR_RMISR2            0xFFC0000C	// sysL2[31:0] read bus
+#define MISR_WMISR0            0xFFC00010	// coreL2[31:0] write bus
+#define MISR_WMISR1            0xFFC00014	// coreL2[63:32] write bus
+#define MISR_WMISR2            0xFFC00018	// sysL2[31:0] write bus
+
+// Clock and System Control (0xFFC0 0400-0xFFC0 07FF)
+#define PLL_CTL                0xFFC00400	// PLL Control register (32-bit)
+#define PLL_STAT               0xFFC00404	// PLL Status register
+#define PLL_LOCKCNT            0xFFC00406	// PLL Lock Counter register
+#define PLL_IOCKR              0xFFC00408	// Peripheral Clock Enable register (32-bit)
+#define SWRST                  0xFFC00410	// Software Reset Register
+
+#define PLLCTL			PLL_CTL
+#define PLLSTAT			PLL_STAT
+#define LOCKCNT			PLL_LOCKCNT
+#define IOCKR			PLL_IOCKR
+
+#define SYSCR                  0xFFC00414	// System Configuration register (RCSR)
+
+// JTAG/Debug Communication Channel (0xFFC0 0800-0xFFC0 0BFF)
+#define CHIPID                 0xFFC048C0	// Device ID Register
+
+// System Interrupt Controller (0xFFC0 0C00-0xFFC0 0FFF)
+#define SIC_RVECT              0xFFC00C00	// Reset Vector Register
+#define SIC_IAR0               0xFFC00C04	// Interrupt Assignment Register 0
+#define SIC_IAR1               0xFFC00C08	// Interrupt Assignment Register 1
+#define SIC_IAR2               0xFFC00C0C	// Interrupt Assignment Register 2
+#define SIC_IMASK              0xFFC00C10	// Interrupt Mask Register
+#define SIC_ISR                0xFFC00C14	// Interrupt Status Register
+#define SIC_IWR                0xFFC00C18	// Interrupt Wakeup Register
+
+// Watchdog Timer (0xFFC0 1000-0xFFC0 13FF)
+#define WDOGCTL                0xFFC01000	// Watchdog Control Register
+#define WDOGCNT                0xFFC01004	// Watchdog Count Register
+#define WDOGSTAT               0xFFC01008	// Watchdog Status Register
+
+#define WDOG_CTL		WDOGCTL
+#define WDOG_CNT		WDOGCNT
+#define WDOG_STAT		WDOGSTAT
+
+// Real Time Clock (0xFFC0 1400-0xFFC0 17FF)
+#define RTCSTAT                0xFFC01400	// RTC Status Register
+#define RTCICTL                0xFFC01404	// RTC Interrupt Control Register
+#define RTCISTAT               0xFFC01408	// RTC Interrupt Status Register
+#define RTCSWCNT               0xFFC0140C	// RTC Stopwatch Count Register
+#define RTCALARM               0xFFC01410	// RTC Alarm Time Register
+#define RTCFAST                0xFFC01414	// RTC Prescaler Control Register
+
+#define RTC_STAT		RTCSTAT
+#define RTC_ICTL		RTCICTL
+#define RTC_ISTAT		RTCISTAT
+#define RTC_SWCNT		RTCSWCNT
+#define RTC_ALARM		RTCALARM
+#define RTC_FAST		RTCFAST
+
+// UART 0 Controller (0xFFC0 1800-0xFFC0 1BFF)
+#define UART0_THR              0xFFC01800	// Transmit Holding register
+#define UART0_RBR              0xFFC01800	// Receive Buffer register
+#define UART0_DLL              0xFFC01800	// Divisor Latch (Low-Byte)
+#define UART0_IER              0xFFC01802	// Interrupt Enable Register
+#define UART0_DLH              0xFFC01802	// Divisor Latch (High-Byte)
+#define UART0_IIR              0xFFC01804	// Interrupt Identification Register
+#define UART0_LCR              0xFFC01806	// Line Control Register
+#define UART0_MCR              0xFFC01808	// Module Control Register
+#define UART0_LSR              0xFFC0180A	// Line Status Register
+#define UART0_MSR              0xFFC0180C	// MSR Modem Status Register
+#define UART0_SCR              0xFFC0180E	// SCR Scratch Register
+#define UART0_IRCR             0xFFC01810	// IRCR IrDA Control Register
+#define UART0_CURR_PTR_RX      0xFFC01A00	// UART -DMA RCV Current Pointer register
+#define UART0_CONFIG_RX        0xFFC01A02	// UART -RCV DMA Configuration register
+#define UART0_START_ADDR_HI_RX 0xFFC01A04	// UART -RCV DMA Start Page register
+#define UART0_START_ADDR_LO_RX 0xFFC01A06	// UART -RCV DMA Start Address register
+#define UART0_COUNT_RX         0xFFC01A08	// UART -RCV DMA Count register
+#define UART0_NEXT_DESCR_RX    0xFFC01A0A	// UART -RCV DMA Next Descriptor Pointer register
+#define UART0_DESCR_RDY_RX     0xFFC01A0C	// UART -RCV DMA Descriptor Ready
+#define UART0_IRQSTAT_RX       0xFFC01A0E	// UART -RCV DMA Interrupt Register
+#define UART0_CURR_PTR_TX      0xFFC01B00	// UART -XMT DMA Current Pointer register
+#define UART0_CONFIG_TX        0xFFC01B02	// UART -XMT DMA Configuration register
+#define UART0_START_ADDR_HI_TX 0xFFC01B04	// UART -XMT DMA Start Page register
+#define UART0_START_ADDR_LO_TX 0xFFC01B06	// UART -XMT DMA Start Address register
+#define UART0_COUNT_TX         0xFFC01B08	// UART -XMT DMA Count register
+#define UART0_NEXT_DESCR_TX    0xFFC01B0A	// UART -XMT DMA Next Descriptor Pointer register
+#define UART0_DESCR_RDY_TX     0xFFC01B0C	// UART -XMT DMA Descriptor Ready
+#define UART0_IRQSTAT_TX       0xFFC01B0E	// UART -XMT DMA Interrupt register
+
+// UART 1 Controller (0xFFC0 1C00-0xFFC0 1FFF)
+#define UART1_THR              0xFFC01C00	// Transmit Holding register
+#define UART1_RBR              0xFFC01C00	// Receive Buffer register
+#define UART1_DLL              0xFFC01C00	// Divisor Latch (Low-Byte)
+#define UART1_IER              0xFFC01C02	// Interrupt Enable Register
+#define UART1_DLH              0xFFC01C02	// Divisor Latch (High-Byte)
+#define UART1_IIR              0xFFC01C04	// Interrupt Identification Register
+#define UART1_LCR              0xFFC01C06	// Line Control Register
+#define UART1_MCR              0xFFC01C08	// Module Control Register
+#define UART1_LSR              0xFFC01C0A	// Line Status Register
+#define UART1_MSR              0xFFC01C0C	// MSR Modem Status Register
+#define UART1_SCR              0xFFC01C0E	// SCR Scratch Register
+#define UART1_CURR_PTR_RX      0xFFC01E00	// UART -DMA RCV Current Pointer register
+#define UART1_CONFIG_RX        0xFFC01E02	// UART -RCV DMA Configuration register
+#define UART1_START_ADDR_HI_RX 0xFFC01E04	// UART -RCV DMA Start Page register
+#define UART1_START_ADDR_LO_RX 0xFFC01E06	// UART -RCV DMA Start Address register
+#define UART1_COUNT_RX         0xFFC01E08	// UART -RCV DMA Count register
+#define UART1_NEXT_DESCR_RX    0xFFC01E0A	// UART -RCV DMA Next Descriptor Pointer register
+#define UART1_DESCR_RDY_RX     0xFFC01E0C	// UART -RCV DMA Descriptor Ready
+#define UART1_IRQSTAT_RX       0xFFC01E0E	// UART -RCV DMA Interrupt Register
+#define UART1_CURR_PTR_TX      0xFFC01F00	// UART -XMT DMA Current Pointer register
+#define UART1_CONFIG_TX        0xFFC01F02	// UART -XMT DMA Configuration register
+#define UART1_START_ADDR_HI_TX 0xFFC01F04	// UART -XMT DMA Start Page register
+#define UART1_START_ADDR_LO_TX 0xFFC01F06	// UART -XMT DMA Start Address register
+#define UART1_COUNT_TX         0xFFC01F08	// UART -XMT DMA Count register
+#define UART1_NEXT_DESCR_TX    0xFFC01F0A	// UART -XMT DMA Next Descriptor Pointer register
+#define UART1_DESCR_RDY_TX     0xFFC01F0C	// UART -XMT DMA Descriptor Ready
+#define UART1_IRQSTAT_TX       0xFFC01F0E	// UART -XMT DMA Interrupt register
+
+// TIMER 0, 1, 2 Registers (0xFFC0 2000-0xFFC0 23FF)
+#define TIMER0_STATUS          0xFFC02000	// Timer 0 Global Status and Sticky Register
+#define TIMER0_CONFIG          0xFFC02002	// Timer 0 configuration Register
+#define TIMER0_COUNTER_LO      0xFFC02004	// Timer 0 Counter Register (low word)
+#define TIMER0_COUNTER_HI      0xFFC02006	// Timer 0 Counter Register (high word)
+#define TIMER0_PERIOD_LO       0xFFC02008	// Timer 0 Period Register (low word)
+#define TIMER0_PERIOD_HI       0xFFC0200A	// Timer 0 Period Register (high word)
+#define TIMER0_WIDTH_LO        0xFFC0200C	// Timer 0 Width Register (low word)
+#define TIMER0_WIDTH_HI        0xFFC0200E	// Timer 0 Width Register (high word)
+#define TIMER1_STATUS          0xFFC02010	// Timer 1 Global Status and Sticky Register
+#define TIMER1_CONFIG          0xFFC02012	// Timer 1 configuration register
+#define TIMER1_COUNTER_LO      0xFFC02014	// Timer 1 Counter Register (low word)
+#define TIMER1_COUNTER_HI      0xFFC02016	// Timer 1 Counter Register (high word)
+#define TIMER1_PERIOD_LO       0xFFC02018	// Timer 1 Period Register (low word)
+#define TIMER1_PERIOD_HI       0xFFC0201A	// Timer 1 Period Register (high word)
+#define TIMER1_WIDTH_LO        0xFFC0201C	// Timer 1 Width Register (low word)
+#define TIMER1_WIDTH_HI        0xFFC0201E	// Timer 1 Width Register (high word)
+#define TIMER2_STATUS          0xFFC02020	// Timer 2 Global Status and Sticky Register
+#define TIMER2_CONFIG          0xFFC02022	// Timer 2 configuration register
+#define TIMER2_COUNTER_LO      0xFFC02024	// Timer 2 Counter Register (low word)
+#define TIMER2_COUNTER_HI      0xFFC02026	// Timer 2 Counter Register (high word)
+#define TIMER2_PERIOD_LO       0xFFC02028	// Timer 2 Period Register (low word)
+#define TIMER2_PERIOD_HI       0xFFC0202A	// Timer 2 Period Register (high word)
+#define TIMER2_WIDTH_LO        0xFFC0202C	// Timer 2 Width Register (low word)
+#define TIMER2_WIDTH_HI        0xFFC0202E	// Timer 2 Width Register (high word)
+
+// General Purpose IO (0xFFC0 2400-0xFFC0 27FF)
+#define FIO_DIR                0xFFC02400	// Peripheral Flag Direction Register
+#define FIO_FLAG_C             0xFFC02404	// Peripheral Interrupt Flag Register (clear)
+#define FIO_FLAG_S             0xFFC02406	// Peripheral Interrupt Flag Register (set)
+#define FIO_MASKA_C            0xFFC02408	// Flag Mask Interrupt A Register (clear)
+#define FIO_MASKA_S            0xFFC0240A	// Flag Mask Interrupt A Register (set)
+#define FIO_MASKB_C            0xFFC0240C	// Flag Mask Interrupt B Register (clear)
+#define FIO_MASKB_S            0xFFC0240E	// Flag Mask Interrupt B Register (set)
+#define FIO_POLAR              0xFFC02410	// Flag Source Polarity Register
+#define FIO_EDGE               0xFFC02414	// Flag Source Sensitivity Register
+#define FIO_BOTH               0xFFC02418	// Flag Set on BOTH Edges Register
+
+// SPORT0 Controller (0xFFC0 2800-0xFFC0 2BFF)
+#define SPORT0_TX_CONFIG       0xFFC02800	// SPORT0 Transmit Configuration Register
+#define SPORT0_RX_CONFIG       0xFFC02802	// SPORT0 Receive Configuration Register
+#define SPORT0_TX              0xFFC02804	// SPORT0 TX transmit Register
+#define SPORT0_RX              0xFFC02806	// SPORT0 RX Receive register
+#define SPORT0_TSCLKDIV        0xFFC02808	// SPORT0 Transmit Serial Clock Divider
+#define SPORT0_RSCLKDIV        0xFFC0280A	// SPORT0 Receive Serial Clock Divider
+#define SPORT0_TFSDIV          0xFFC0280C	// SPORT0 Transmit Frame Sync Divider
+#define SPORT0_RFSDIV          0xFFC0280E	// SPORT0 Receive Frame Sync Divider
+#define SPORT0_STAT            0xFFC02810	// SPORT0 Status Register
+#define SPORT0_MTCS0           0xFFC02812	// SPORT0 Multi-Channel Transmit Select Register
+#define SPORT0_MTCS1           0xFFC02814	// SPORT0 Multi-Channel Transmit Select Register
+#define SPORT0_MTCS2           0xFFC02816	// SPORT0 Multi-Channel Transmit Select Register
+#define SPORT0_MTCS3           0xFFC02818	// SPORT0 Multi-Channel Transmit Select Register
+#define SPORT0_MTCS4           0xFFC0281A	// SPORT0 Multi-Channel Transmit Select Register
+#define SPORT0_MTCS5           0xFFC0281C	// SPORT0 Multi-Channel Transmit Select Register
+#define SPORT0_MTCS6           0xFFC0281E	// SPORT0 Multi-Channel Transmit Select Register
+#define SPORT0_MTCS7           0xFFC02820	// SPORT0 Multi-Channel Transmit Select Register
+#define SPORT0_MRCS0           0xFFC02822	// SPORT0 Multi-Channel Receive Select Register
+#define SPORT0_MRCS1           0xFFC02824	// SPORT0 Multi-Channel Receive Select Register
+#define SPORT0_MRCS2           0xFFC02826	// SPORT0 Multi-Channel Receive Select Register
+#define SPORT0_MRCS3           0xFFC02828	// SPORT0 Multi-Channel Receive Select Register
+#define SPORT0_MRCS4           0xFFC0282A	// SPORT0 Multi-Channel Receive Select Register
+#define SPORT0_MRCS5           0xFFC0282C	// SPORT0 Multi-Channel Receive Select Register
+#define SPORT0_MRCS6           0xFFC0282E	// SPORT0 Multi-Channel Receive Select Register
+#define SPORT0_MRCS7           0xFFC02830	// SPORT0 Multi-Channel Receive Select Register
+#define SPORT0_MCMC1           0xFFC02832	// SPORT0 Multi-Channel Configuration Register 1
+#define SPORT0_MCMC2           0xFFC02834	// SPORT0 Multi-Channel Configuration Register 2
+#define SPORT0_CURR_PTR_RX     0xFFC02A00	// SPORT0 -RCV DMA Current Pointer
+#define SPORT0_CONFIG_DMA_RX   0xFFC02A02	// SPORT0 -RCV DMA Configuration
+#define SPORT0_START_ADDR_HI_RX 0xFFC02A04	// SPORT0 -RCV DMA Start Page
+#define SPORT0_START_ADDR_LO_RX 0xFFC02A06	// SPORT0 -RCV DMA Start Address
+#define SPORT0_COUNT_RX        0xFFC02A08	// SPORT0 -RCV DMA Count
+#define SPORT0_NEXT_DESCR_RX   0xFFC02A0A	// SPORT0 -RCV DMA Next Descriptor Pointer
+#define SPORT0_DESCR_RDY_RX    0xFFC02A0C	// SPORT0 -RCV DMA Descriptor Ready
+#define SPORT0_IRQSTAT_RX      0xFFC02A0E	// SPORT0 -RCV DMA Interrupt Register
+#define SPORT0_CURR_PTR_TX     0xFFC02B00	// SPORT0 -XMT DMA Current Pointer
+#define SPORT0_CONFIG_DMA_TX   0xFFC02B02	// SPORT0 -XMT DMA Configuration
+#define SPORT0_START_ADDR_HI_TX 0xFFC02B04	// SPORT0 -XMT DMA Start Page
+#define SPORT0_START_ADDR_LO_TX 0xFFC02B06	// SPORT0 -XMT DMA Start Address
+#define SPORT0_COUNT_TX        0xFFC02B08	// SPORT0 -XMT DMA Count
+#define SPORT0_NEXT_DESCR_TX   0xFFC02B0A	// SPORT0 -XMT DMA Next Descriptor Pointer
+#define SPORT0_DESCR_RDY_TX    0xFFC02B0C	// SPORT0 -XMT DMA Descriptor Ready
+#define SPORT0_IRQSTAT_TX      0xFFC02B0E	// SPORT0 -XMT DMA Interrupt Register
+
+// SPORT1 Controller (0xFFC0 2C00-0xFFC0 2FFF)
+#define SPORT1_TX_CONFIG       0xFFC02C00	// SPORT1 Transmit Configuration Register
+#define SPORT1_RX_CONFIG       0xFFC02C02	// SPORT1 Receive Configuration Register
+#define SPORT1_TX              0xFFC02C04	// SPORT1 TX transmit Register
+#define SPORT1_RX              0xFFC02C06	// SPORT1 RX Receive register
+#define SPORT1_TSCLKDIV        0xFFC02C08	// SPORT1 Transmit Serial Clock Divider
+#define SPORT1_RSCLKDIV        0xFFC02C0A	// SPORT1 Receive Serial Clock Divider
+#define SPORT1_TFSDIV          0xFFC02C0C	// SPORT1 Transmit Frame Sync Divider
+#define SPORT1_RFSDIV          0xFFC02C0E	// SPORT1 Receive Frame Sync Divider
+#define SPORT1_STAT            0xFFC02C10	// SPORT1 Status Register
+#define SPORT1_MTCS0           0xFFC02C12	// SPORT1 Multi-Channel Transmit Select Register
+#define SPORT1_MTCS1           0xFFC02C14	// SPORT1 Multi-Channel Transmit Select Register
+#define SPORT1_MTCS2           0xFFC02C16	// SPORT1 Multi-Channel Transmit Select Register
+#define SPORT1_MTCS3           0xFFC02C18	// SPORT1 Multi-Channel Transmit Select Register
+#define SPORT1_MTCS4           0xFFC02C1A	// SPORT1 Multi-Channel Transmit Select Register
+#define SPORT1_MTCS5           0xFFC02C1C	// SPORT1 Multi-Channel Transmit Select Register
+#define SPORT1_MTCS6           0xFFC02C1E	// SPORT1 Multi-Channel Transmit Select Register
+#define SPORT1_MTCS7           0xFFC02C20	// SPORT1 Multi-Channel Transmit Select Register
+#define SPORT1_MRCS0           0xFFC02C22	// SPORT1 Multi-Channel Receive Select Register
+#define SPORT1_MRCS1           0xFFC02C24	// SPORT1 Multi-Channel Receive Select Register
+#define SPORT1_MRCS2           0xFFC02C26	// SPORT1 Multi-Channel Receive Select Register
+#define SPORT1_MRCS3           0xFFC02C28	// SPORT1 Multi-Channel Receive Select Register
+#define SPORT1_MRCS4           0xFFC02C2A	// SPORT1 Multi-Channel Receive Select Register
+#define SPORT1_MRCS5           0xFFC02C2C	// SPORT1 Multi-Channel Receive Select Register
+#define SPORT1_MRCS6           0xFFC02C2E	// SPORT1 Multi-Channel Receive Select Register
+#define SPORT1_MRCS7           0xFFC02C30	// SPORT1 Multi-Channel Receive Select Register
+#define SPORT1_MCMC1           0xFFC02C32	// SPORT1 Multi-Channel Configuration Register 1
+#define SPORT1_MCMC2           0xFFC02C34	// SPORT1 Multi-Channel Configuration Register 2
+#define SPORT1_CURR_PTR_RX     0xFFC02E00	// SPORT1 -RCV DMA Current Pointer
+#define SPORT1_CONFIG_DMA_RX   0xFFC02E02	// SPORT1 -RCV DMA Configuration
+#define SPORT1_START_ADDR_HI_RX 0xFFC02E04	// SPORT1 -RCV DMA Start Page
+#define SPORT1_START_ADDR_LO_RX 0xFFC02E06	// SPORT1 -RCV DMA Start Address
+#define SPORT1_COUNT_RX        0xFFC02E08	// SPORT1 -RCV DMA Count
+#define SPORT1_NEXT_DESCR_RX   0xFFC02E0A	// SPORT1 -RCV DMA Next Descriptor Pointer
+#define SPORT1_DESCR_RDY_RX    0xFFC02E0C	// SPORT1 -RCV DMA Descriptor Ready
+#define SPORT1_IRQSTAT_RX      0xFFC02E0E	// SPORT1 -RCV DMA Interrupt Register
+#define SPORT1_CURR_PTR_TX     0xFFC02F00	// SPORT1 -XMT DMA Current Pointer
+#define SPORT1_CONFIG_DMA_TX   0xFFC02F02	// SPORT1 -XMT DMA Configuration
+#define SPORT1_START_ADDR_HI_TX 0xFFC02F04	// SPORT1 -XMT DMA Start Page
+#define SPORT1_START_ADDR_LO_TX 0xFFC02F06	// SPORT1 -XMT DMA Start Address
+#define SPORT1_COUNT_TX        0xFFC02F08	// SPORT1 -XMT DMA Count
+#define SPORT1_NEXT_DESCR_TX   0xFFC02F0A	// SPORT1 -XMT DMA Next Descriptor Pointer
+#define SPORT1_DESCR_RDY_TX    0xFFC02F0C	// SPORT1 -XMT DMA Descriptor Ready
+#define SPORT1_IRQSTAT_TX      0xFFC02F0E	// SPORT1 -XMT DMA Interrupt Register
+
+// SPI 0 Controller (0xFFC0 3000-0xFFC0 33FF)
+#define SPI0_CTL               0xFFC03000	// SPI0 Control Register
+#define SPI0_FLG               0xFFC03002	// SPI0 Flag register
+#define SPI0_ST                0xFFC03004	// SPI0 Status register
+#define SPI0_TDBR              0xFFC03006	// SPI0 Transmit Data Buffer Register
+#define SPI0_RDBR              0xFFC03008	// SPI0 Receive Data Buffer Register
+#define SPI0_BAUD              0xFFC0300A	// SPI0 Baud rate Register
+#define SPI0_SHADOW            0xFFC0300C
+#define SPI0_CURR_PTR          0xFFC03200	// SPI0 -DMA Current Pointer register
+#define SPI0_CONFIG            0xFFC03202	// SPI0 -DMA Configuration register
+#define SPI0_START_ADDR_HI     0xFFC03204	// SPI0 -DMA Start Page register
+#define SPI0_START_ADDR_LO     0xFFC03206	// SPI0 -DMA Start Address register
+#define SPI0_COUNT             0xFFC03208	// SPI0 -DMA Count register
+#define SPI0_NEXT_DESCR        0xFFC0320A	// SPI0 -DMA Next Descriptor Pointer
+#define SPI0_DESCR_RDY         0xFFC0320C	// SPI0 -DMA Descriptor Ready
+#define SPI0_DMA_INT           0xFFC0320E	// SPI0 -DMA Interrupt register
+
+// SPI 1 Controller (0xFFC0 3400-0xFFC0 37FF)
+#define SPI1_CTL               0xFFC03400	// SPI1 Control Register
+#define SPI1_FLG               0xFFC03402	// SPI1 Flag register
+#define SPI1_ST                0xFFC03404	// SPI1 Status register
+#define SPI1_TDBR              0xFFC03406	// SPI1 Transmit Data Buffer Register
+#define SPI1_RDBR              0xFFC03408	// SPI1 Receive Data Buffer Register
+#define SPI1_BAUD              0xFFC0340A	// SPI1 Baud rate Register
+#define SPI1_SHADOW            0xFFC0340C
+#define SPI1_CURR_PTR          0xFFC03600	// SPI1 -DMA Current Pointer register
+#define SPI1_CONFIG            0xFFC03602	// SPI1 -DMA Configuration register
+#define SPI1_START_ADDR_HI     0xFFC03604	// SPI1 -DMA Start Page register
+#define SPI1_START_ADDR_LO     0xFFC03606	// SPI1 -DMA Start Address register
+#define SPI1_COUNT             0xFFC03608	// SPI1 -DMA Count register
+#define SPI1_NEXT_DESCR        0xFFC0360A	// SPI1 -DMA Next Descriptor Pointer
+#define SPI1_DESCR_RDY         0xFFC0360C	// SPI1 -DMA Descriptor Ready
+#define SPI1_DMA_INT           0xFFC0360E	// SPI1 -DMA Interrupt register
+
+// Memory DMA Controller (0xFFC0 3800-0xFFC0 3BFF)
+#define MDD_DCP                0xFFC03800	// Current Pointer - Write Channel
+#define MDD_DCFG               0xFFC03802	// DMA Configuration - Write Channel
+#define MDD_DSAH               0xFFC03804	// Start Address Hi - Write Channel
+#define MDD_DSAL               0xFFC03806	// Start Address Lo - Write Channel
+#define MDD_DCT                0xFFC03808	// DMA Count - Write Channel
+#define MDD_DND                0xFFC0380A	// Next Descriptor Pointer - Write Channel
+#define MDD_DDR                0xFFC0380C	// Descriptor Ready - Write Channel
+#define MDD_DI                 0xFFC0380E	// DMA Interrupt - Write Channel
+#define MDS_DCP                0xFFC03900	// Current Pointer - Read Channel
+#define MDS_DCFG               0xFFC03902	// DMA Configuration - Read Channel
+#define MDS_DSAH               0xFFC03904	// Start Address Hi - Read Channel
+#define MDS_DSAL               0xFFC03906	// Start Address Lo - Read Channel
+#define MDS_DCT                0xFFC03908	// DMA Count - Read Channel
+#define MDS_DND                0xFFC0390A	// Next Descriptor Pointer - Read Channel
+#define MDS_DDR                0xFFC0390C	// Descriptor Ready - Read Channel
+#define MDS_DI                 0xFFC0390E	// DMA Interrupt - Read Channel
+
+// For backwards-compatibility with VDSP++3.0 and earlier code...
+#define MDW_DCP                MDD_DCP
+#define MDW_DCFG               MDD_DCFG
+#define MDW_DSAH               MDD_DSAH
+#define MDW_DSAL               MDD_DSAL
+#define MDW_DCT                MDD_DCT
+#define MDW_DND                MDD_DND
+#define MDW_DDR                MDD_DDR
+#define MDW_DI                 MDD_DI
+#define MDR_DCP                MDS_DCP
+#define MDR_DCFG               MDS_DCFG
+#define MDR_DSAH               MDS_DSAH
+#define MDR_DSAL               MDS_DSAL
+#define MDR_DCT                MDS_DCT
+#define MDR_DND                MDS_DND
+#define MDR_DDR                MDS_DDR
+#define MDR_DI                 MDS_DI
+
+// Aysnchronous Memory Controller - External Bus Interface Unit (0xFFC0 3C00-0xFFC0 3FFF)
+#define EBIU_AMGCTL            0xFFC03C00	// Asynchronous Memory Global Control Register
+#define EBIU_AMBCTL0           0xFFC03C04	// Asynchronous Memory Bank Control Register 0
+#define EBIU_AMBCTL1           0xFFC03C08	// Asynchronous Memory Bank Control Register 1
+
+// PCI Bridge PAB Registers (0xFFC0 4000-0xFFC0 43FF)
+#define PCI_CTL                0xFFC04000	// PCI Bridge Control
+#define  PCI_CTL_HOST	 	 0x01
+#define  PCI_CTL_ENABPCI	 0x02
+#define  PCI_CTL_FASTBCK2BCK	 0x04
+#define  PCI_CTL_ENABINTA	 0x08
+#define  PCI_CTL_OUTPUTINTA	 0x10
+#define  PCI_CTL_ENABRST	 0x20
+#define  PCI_CTL_OUTPUTRST	 0x40
+
+#define PCI_STAT               0xFFC04004	// PCI Bridge Status
+#define   PCI_STAT_INTA	         0x0001
+#define   PCI_STAT_INTB	         0x0002
+#define   PCI_STAT_INTC	         0x0004
+#define   PCI_STAT_INTD	         0x0008
+#define   PCI_STAT_PARERR	 0x0010
+#define   PCI_STAT_FATERR	 0x0020
+#define   PCI_STAT_RESET	 0x0040
+#define   PCI_STAT_TXEMPTY	 0x0080
+#define   PCI_STAT_TXFULL	 0x0100
+#define   PCI_STAT_QUEFULL	 0x0200
+#define   PCI_STAT_MEMWRINV	 0x0400
+#define   PCI_STAT_INRDERR	 0x0800
+#define   PCI_STAT_INWRERR	 0x1000
+#define   PCI_STAT_INVEABACC	 0x2000
+#define   PCI_STAT_SYSERR	 0x4000
+
+#define PCI_ICTL               0xFFC04008	// PCI Bridge Interrupt Control
+#define   PCI_ICTL_INTA	         0x0001
+#define   PCI_ICTL_INTB	         0x0002
+#define   PCI_ICTL_INTC	         0x0004
+#define   PCI_ICTL_INTD	         0x0008
+#define   PCI_ICTL_PARERR	 0x0010
+#define   PCI_ICTL_FATERR	 0x0020
+#define   PCI_ICTL_RESET	 0x0040
+#define   PCI_ICTL_TXFULL	 0x0080
+#define   PCI_ICTL_MEMWRINV	 0x0400
+#define   PCI_ICTL_INRDERR	 0x0800
+#define   PCI_ICTL_INWRERR	 0x1000
+#define   PCI_ICTL_INVEABACC	 0x2000
+#define   PCI_ICTL_SYSERR	 0x4000
+
+#define PCI_MBAP               0xFFC0400C	// PCI Memory Space Base Address Pointer [31:27]
+#define PCI_IBAP               0xFFC04010	// PCI IO Space Base Address Pointer
+#define PCI_CBAP               0xFFC04014	// PCI Config Space Base Address Port
+#define PCI_TMBAP              0xFFC04018	// PCI to BF535 Memory Base Address Pointer
+#define PCI_TIBAP              0xFFC0401C	// PCI to BF535 IO Base Address Pointer
+
+// PCI Bridge External Access Bus Registers (0xEEFF FF00-0xEEFF FFFF)
+#define PCI_DMBARM             0xEEFFFF00	// PCI Device Memory Bar Mask
+#define PCI_DIBARM             0xEEFFFF04	// PCI Device IO Bar Mask
+#define PCI_CFG_DIC            0xEEFFFF08	// PCI Config Device ID
+#define PCI_CFG_VIC            0xEEFFFF0C	// PCI Config Vendor ID
+#define PCI_CFG_STAT           0xEEFFFF10	// PCI Config Status (Read-only)
+#define PCI_CFG_CMD            0xEEFFFF14	// PCI Config Command
+#define PCI_CFG_CC             0xEEFFFF18	// PCI Config Class Code
+#define PCI_CFG_RID            0xEEFFFF1C	// PCI Config Revision ID
+#define PCI_CFG_BIST           0xEEFFFF20	// PCI Config BIST
+#define PCI_CFG_HT             0xEEFFFF24	// PCI Config Header Type
+#define PCI_CFG_MLT            0xEEFFFF28	// PCI Config Memory Latency Timer
+#define PCI_CFG_CLS            0xEEFFFF2C	// PCI Config Cache Line Size
+#define PCI_CFG_MBAR           0xEEFFFF30	// PCI Config Memory Base Address Register
+#define PCI_CFG_IBAR           0xEEFFFF34	// PCI Config IO Base Address Register
+#define PCI_CFG_SID            0xEEFFFF38	// PCI Config Sub-system ID
+#define PCI_CFG_SVID           0xEEFFFF3C	// PCI Config Sub-system Vendor ID
+#define PCI_CFG_MAXL           0xEEFFFF40	// PCI Config Maximum Latency Cycles
+#define PCI_CFG_MING           0xEEFFFF44	// PCI Config Minimum Grant Cycles
+#define PCI_CFG_IP             0xEEFFFF48	// PCI Config Interrupt Pin
+#define PCI_CFG_IL             0xEEFFFF4C	// PCI Config Interrupt Line
+#define PCI_HMCTL              0xEEFFFF50	// PCI Blocking BAR Host Mode Control
+
+#define  PCI_HMCTL_SYSMMRENAB	 0x1
+#define  PCI_HMCTL_L2ENAB	 0x2
+#define  PCI_HMCTL_ASYNCENAB	 0x4
+#define  PCI_HMCTL_ASYNCSIZE	 0x18	/* 00-64MB, 01-128MB, 10-192MB, 11-256MB */
+#define  PCI_HMCTL_SDRAMENAB	 0x20
+#define  PCI_HMCTL_SDRAMSIZE	 0x7C0	/* 0-32MB, 1-64MB, 2-96MB, 128MB, 160MB */
+
+// USB Registers (0xFFC0 4400 - 0xFFC0 47FF)
+#define USBD_ID                0xFFC04400	// USB Device ID Register
+#define USBD_FRM               0xFFC04402	// Current USB Frame Number
+#define USBD_FRMAT             0xFFC04404	// Match value for USB frame number.
+#define USBD_EPBUF             0xFFC04406	// Enables Download of Configuration Into UDC Core
+#define USBD_STAT              0xFFC04408	// Returns USBD Module Status
+#define USBD_CTRL              0xFFC0440A	// Allows Configuration and Control of USBD Module.
+#define USBD_GINTR             0xFFC0440C	// Global Interrupt Register
+#define USBD_GMASK             0xFFC0440E	// Global Interrupt Register Mask
+#define USBD_DMACFG            0xFFC04440	// DMA Master Channel Configuration Register
+#define USBD_DMABL             0xFFC04442	// DMA Master Channel Base Address, Low
+#define USBD_DMABH             0xFFC04444	// DMA Master Channel Base Address, High
+#define USBD_DMACT             0xFFC04446	// DMA Master Channel Count Register
+#define USBD_DMAIRQ            0xFFC04448	// DMA Master Channel DMA Count Register
+#define USBD_INTR0             0xFFC04480	// USB Endpoint 0 Interrupt Register
+#define USBD_MASK0             0xFFC04482	// USB Endpoint 0 Mask Register
+#define USBD_EPCFG0            0xFFC04484	// USB Endpoint 0 Control Register
+#define USBD_EPADR0            0xFFC04486	// USB Endpoint 0 Address Offset Register
+#define USBD_EPLEN0            0xFFC04488	// USB Endpoint 0 Buffer Length Register
+#define USBD_INTR1             0xFFC0448A	// USB Endpoint 1 Interrupt Register
+#define USBD_MASK1             0xFFC0448C	// USB Endpoint 1 Mask Register
+#define USBD_EPCFG1            0xFFC0448E	// USB Endpoint 1 Control Register
+#define USBD_EPADR1            0xFFC04490	// USB Endpoint 1 Address Offset Register
+#define USBD_EPLEN1            0xFFC04492	// USB Endpoint 1 Buffer Length Register
+#define USBD_INTR2             0xFFC04494	// USB Endpoint 2 Interrupt Register
+#define USBD_MASK2             0xFFC04496	// USB Endpoint 2 Mask Register
+#define USBD_EPCFG2            0xFFC04498	// USB Endpoint 2 Control Register
+#define USBD_EPADR2            0xFFC0449A	// USB Endpoint 2 Address Offset Register
+#define USBD_EPLEN2            0xFFC0449C	// USB Endpoint 2 Buffer Length Register
+#define USBD_INTR3             0xFFC0449E	// USB Endpoint 3 Interrupt Register
+#define USBD_MASK3             0xFFC044A0	// USB Endpoint 3 Mask Register
+#define USBD_EPCFG3            0xFFC044A2	// USB Endpoint 3 Control Register
+#define USBD_EPADR3            0xFFC044A4	// USB Endpoint 3 Address Offset Register
+#define USBD_EPLEN3            0xFFC044A6	// USB Endpoint 3 Buffer Length Register
+#define USBD_INTR4             0xFFC044A8	// USB Endpoint 4 Interrupt Register
+#define USBD_MASK4             0xFFC044AA	// USB Endpoint 4 Mask Register
+#define USBD_EPCFG4            0xFFC044AC	// USB Endpoint 4 Control Register
+#define USBD_EPADR4            0xFFC044AE	// USB Endpoint 4 Address Offset Register
+#define USBD_EPLEN4            0xFFC044B0	// USB Endpoint 4 Buffer Length Register
+#define USBD_INTR5             0xFFC044B2	// USB Endpoint 5 Interrupt Register
+#define USBD_MASK5             0xFFC044B4	// USB Endpoint 5 Mask Register
+#define USBD_EPCFG5            0xFFC044B6	// USB Endpoint 5 Control Register
+#define USBD_EPADR5            0xFFC044B8	// USB Endpoint 5 Address Offset Register
+#define USBD_EPLEN5            0xFFC044BA	// USB Endpoint 5 Buffer Length Register
+#define USBD_INTR6             0xFFC044BC	// USB Endpoint 6 Interrupt Register
+#define USBD_MASK6             0xFFC044BE	// USB Endpoint 6 Mask Register
+#define USBD_EPCFG6            0xFFC044C0	// USB Endpoint 6 Control Register
+#define USBD_EPADR6            0xFFC044C2	// USB Endpoint 6 Address Offset Register
+#define USBD_EPLEN6            0xFFC044C4	// USB Endpoint 6 Buffer Length Register
+#define USBD_INTR7             0xFFC044C6	// USB Endpoint 7 Interrupt Register
+#define USBD_MASK7             0xFFC044C8	// USB Endpoint 7 Mask Register
+#define USBD_EPCFG7            0xFFC044CA	// USB Endpoint 7 Control Register
+#define USBD_EPADR7            0xFFC044CC	// USB Endpoint 7 Address Offset Register
+#define USBD_EPLEN7            0xFFC044CE	// USB Endpoint 7 Buffer Length Register
+
+// System Bus Interface Unit (0xFFC0 4800-0xFFC0 4FFF)
+#define L1SBAR                 0xFFC04840	// L1 SRAM Base Address Register
+#define L1CSR                  0xFFC04844	// L1 SRAM Control Initialization Register
+#define DMA_DBP                0xFFC04880	// Next Descriptor Base Pointer
+#define DB_ACOMP               0xFFC04884	// DMA Bus Address Comparator
+#define DB_CCOMP               0xFFC04888	// DMA Bus Control Comparator
+
+#define DB_NDBP                DMA_DBP	// Backward compatibility
+
+#define L1_SBAR			L1SBAR
+#define L1_CSR			L1CSR
+
+// SDRAM Controller External Bus Interface Unit (0xFFC0 4C00-0xFFC0 4FFF)
+#define EBIU_SDGCTL            0xFFC04C00	// SDRAM Global Control Register
+#define EBIU_SDBCTL            0xFFC04C04	// SDRAM Bank Control Register
+#define EBIU_SDRRC             0xFFC04C0A	// SDRAM Refresh Rate Control Register
+#define EBIU_SDSTAT            0xFFC04C0E	// SDRAM Status Register
+
+// PAB Reserved (0xFFC0 5000-0xFFDF FFFF) (**Reserved**)
+
+//**********************************************************************************
+// System MMR Register Bits
+//**********************************************************************************
+
+// PLLCTL Masks
+#define PLL_CLKIN              0x00000000	// Pass CLKIN to PLL
+#define PLL_CLKIN_DIV2         0x00000001	// Pass CLKIN/2 to PLL
+#define PLL_OFF                0x00000002	// Shut off PLL clocks
+#define STOPCK_OFF             0x00000008	// Core clock off
+#define PDWN                   0x00000020	// Put the PLL in a Deep Sleep state
+#define BYPASS                 0x00000100	// Bypass the PLL
+#define CCLK_DIV2              0x00000000	// SCLK = CCLK / 2
+#define CCLK_DIV2_5            0x00010000	// SCLK = CCLK / 2.5
+#define CCLK_DIV3              0x00020000	// SCLK = CCLK / 3
+#define CCLK_DIV4              0x00030000	// SCLK = CCLK / 4
+
+// IOCKR Masks
+#define IOCK_PCI               0x00000001	// Enable PCI peripheral clock
+#define IOCK_L2                0x00000002	// Enable L2 memory peripheral clock
+#define IOCK_EBIU              0x00000004	// Enable EBIU controller peripheral clock
+#define IOCK_GPIO              0x00000008	// Enable GPIO peripheral clock
+#define IOCK_MEMDMA            0x00000010	// Enable MemDMA controller peripheral clock
+#define IOCK_SPORT0            0x00000020	// Enable SPORT0 controller peripheral clock
+#define IOCK_SPORT1            0x00000040	// Enable SPORT1 controller peripheral clock
+#define IOCK_SPI0              0x00000080	// Enable SPI0 controller peripheral clock
+#define IOCK_SPI1              0x00000100	// Enable SPI1 controller peripheral clock
+#define IOCK_UART0             0x00000200	// Enable UART0 controller peripheral clock
+#define IOCK_UART1             0x00000400	// Enable UART1 controller peripheral clock
+#define IOCK_TIMER0            0x00000800	// Enable TIMER0 peripheral clock
+#define IOCK_TIMER1            0x00001000	// Enable TIMER1 peripheral clock
+#define IOCK_TIMER2            0x00002000	// Enable TIMER2 peripheral clock
+#define IOCK_USB               0x00004000	// Enable USB peripheral clock
+
+// SWRST Mask
+#define SYSTEM_RESET           0x00000007	// Initiates a system software reset
+
+// System Interrupt Controller Masks (SIC_IAR0, SIC_IAR1, SIC_IAR2, SIC_IMASK, SIC_IWR)
+// SIC_IAR0 Masks
+
+//
+#define P0_IVG7                0x00000000	// Peripheral #0 assigned IVG7
+#define P0_IVG8                0x00000001	// Peripheral #0 assigned IVG8
+#define P0_IVG9                0x00000002	// Peripheral #0 assigned IVG9
+#define P0_IVG10               0x00000003	// Peripheral #0 assigned IVG10
+#define P0_IVG11               0x00000004	// Peripheral #0 assigned IVG11
+#define P0_IVG12               0x00000005	// Peripheral #0 assigned IVG12
+#define P0_IVG13               0x00000006	// Peripheral #0 assigned IVG13
+#define P0_IVG14               0x00000007	// Peripheral #0 assigned IVG14
+#define P0_IVG15               0x00000008	// Peripheral #0 assigned IVG15
+#define P1_IVG7                0x00000000	// Peripheral #1 assigned IVG7
+#define P1_IVG8                0x00000010	// Peripheral #1 assigned IVG8
+#define P1_IVG9                0x00000020	// Peripheral #1 assigned IVG9
+#define P1_IVG10               0x00000030	// Peripheral #1 assigned IVG10
+#define P1_IVG11               0x00000040	// Peripheral #1 assigned IVG11
+#define P1_IVG12               0x00000050	// Peripheral #1 assigned IVG12
+#define P1_IVG13               0x00000060	// Peripheral #1 assigned IVG13
+#define P1_IVG14               0x00000070	// Peripheral #1 assigned IVG14
+#define P1_IVG15               0x00000080	// Peripheral #1 assigned IVG15
+#define P2_IVG7                0x00000000	// Peripheral #2 assigned IVG7
+#define P2_IVG8                0x00000100	// Peripheral #2 assigned IVG8
+#define P2_IVG9                0x00000200	// Peripheral #2 assigned IVG9
+#define P2_IVG10               0x00000300	// Peripheral #2 assigned IVG10
+#define P2_IVG11               0x00000400	// Peripheral #2 assigned IVG11
+#define P2_IVG12               0x00000500	// Peripheral #2 assigned IVG12
+#define P2_IVG13               0x00000600	// Peripheral #2 assigned IVG13
+#define P2_IVG14               0x00000700	// Peripheral #2 assigned IVG14
+#define P2_IVG15               0x00000800	// Peripheral #2 assigned IVG15
+#define P3_IVG7                0x00000000	// Peripheral #3 assigned IVG7
+#define P3_IVG8                0x00001000	// Peripheral #3 assigned IVG8
+#define P3_IVG9                0x00002000	// Peripheral #3 assigned IVG9
+#define P3_IVG10               0x00003000	// Peripheral #3 assigned IVG10
+#define P3_IVG11               0x00004000	// Peripheral #3 assigned IVG11
+#define P3_IVG12               0x00005000	// Peripheral #3 assigned IVG12
+#define P3_IVG13               0x00006000	// Peripheral #3 assigned IVG13
+#define P3_IVG14               0x00007000	// Peripheral #3 assigned IVG14
+#define P3_IVG15               0x00008000	// Peripheral #3 assigned IVG15
+#define P4_IVG7                0x00000000	// Peripheral #4 assigned IVG7
+#define P4_IVG8                0x00010000	// Peripheral #4 assigned IVG8
+#define P4_IVG9                0x00020000	// Peripheral #4 assigned IVG9
+#define P4_IVG10               0x00030000	// Peripheral #4 assigned IVG10
+#define P4_IVG11               0x00040000	// Peripheral #4 assigned IVG11
+#define P4_IVG12               0x00050000	// Peripheral #4 assigned IVG12
+#define P4_IVG13               0x00060000	// Peripheral #4 assigned IVG13
+#define P4_IVG14               0x00070000	// Peripheral #4 assigned IVG14
+#define P4_IVG15               0x00080000	// Peripheral #4 assigned IVG15
+#define P5_IVG7                0x00000000	// Peripheral #5 assigned IVG7
+#define P5_IVG8                0x00100000	// Peripheral #5 assigned IVG8
+#define P5_IVG9                0x00200000	// Peripheral #5 assigned IVG9
+#define P5_IVG10               0x00300000	// Peripheral #5 assigned IVG10
+#define P5_IVG11               0x00400000	// Peripheral #5 assigned IVG11
+#define P5_IVG12               0x00500000	// Peripheral #5 assigned IVG12
+#define P5_IVG13               0x00600000	// Peripheral #5 assigned IVG13
+#define P5_IVG14               0x00700000	// Peripheral #5 assigned IVG14
+#define P5_IVG15               0x00800000	// Peripheral #5 assigned IVG15
+#define P6_IVG7                0x00000000	// Peripheral #6 assigned IVG7
+#define P6_IVG8                0x01000000	// Peripheral #6 assigned IVG8
+#define P6_IVG9                0x02000000	// Peripheral #6 assigned IVG9
+#define P6_IVG10               0x03000000	// Peripheral #6 assigned IVG10
+#define P6_IVG11               0x04000000	// Peripheral #6 assigned IVG11
+#define P6_IVG12               0x05000000	// Peripheral #6 assigned IVG12
+#define P6_IVG13               0x06000000	// Peripheral #6 assigned IVG13
+#define P6_IVG14               0x07000000	// Peripheral #6 assigned IVG14
+#define P6_IVG15               0x08000000	// Peripheral #6 assigned IVG15
+#define P7_IVG7                0x00000000	// Peripheral #7 assigned IVG7
+#define P7_IVG8                0x10000000	// Peripheral #7 assigned IVG8
+#define P7_IVG9                0x20000000	// Peripheral #7 assigned IVG9
+#define P7_IVG10               0x30000000	// Peripheral #7 assigned IVG10
+#define P7_IVG11               0x40000000	// Peripheral #7 assigned IVG11
+#define P7_IVG12               0x50000000	// Peripheral #7 assigned IVG12
+#define P7_IVG13               0x60000000	// Peripheral #7 assigned IVG13
+#define P7_IVG14               0x70000000	// Peripheral #7 assigned IVG14
+#define P7_IVG15               0x80000000	// Peripheral #7 assigned IVG15
+
+// SIC_IAR1 Masks
+#define P8_IVG7                0x00000000	// Peripheral #8 assigned IVG7
+#define P8_IVG8                0x00000001	// Peripheral #8 assigned IVG8
+#define P8_IVG9                0x00000002	// Peripheral #8 assigned IVG9
+#define P8_IVG10               0x00000003	// Peripheral #8 assigned IVG10
+#define P8_IVG11               0x00000004	// Peripheral #8 assigned IVG11
+#define P8_IVG12               0x00000005	// Peripheral #8 assigned IVG12
+#define P8_IVG13               0x00000006	// Peripheral #8 assigned IVG13
+#define P8_IVG14               0x00000007	// Peripheral #8 assigned IVG14
+#define P8_IVG15               0x00000008	// Peripheral #8 assigned IVG15
+#define P9_IVG7                0x00000000	// Peripheral #9 assigned IVG7
+#define P9_IVG8                0x00000010	// Peripheral #9 assigned IVG8
+#define P9_IVG9                0x00000020	// Peripheral #9 assigned IVG9
+#define P9_IVG10               0x00000030	// Peripheral #9 assigned IVG10
+#define P9_IVG11               0x00000040	// Peripheral #9 assigned IVG11
+#define P9_IVG12               0x00000050	// Peripheral #9 assigned IVG12
+#define P9_IVG13               0x00000060	// Peripheral #9 assigned IVG13
+#define P9_IVG14               0x00000070	// Peripheral #9 assigned IVG14
+#define P9_IVG15               0x00000080	// Peripheral #9 assigned IVG15
+#define P10_IVG7               0x00000000	// Peripheral #10 assigned IVG7
+#define P10_IVG8               0x00000100	// Peripheral #10 assigned IVG8
+#define P10_IVG9               0x00000200	// Peripheral #10 assigned IVG9
+#define P10_IVG10              0x00000300	// Peripheral #10 assigned IVG10
+#define P10_IVG11              0x00000400	// Peripheral #10 assigned IVG11
+#define P10_IVG12              0x00000500	// Peripheral #10 assigned IVG12
+#define P10_IVG13              0x00000600	// Peripheral #10 assigned IVG13
+#define P10_IVG14              0x00000700	// Peripheral #10 assigned IVG14
+#define P10_IVG15              0x00000800	// Peripheral #10 assigned IVG15
+#define P11_IVG7               0x00000000	// Peripheral #11 assigned IVG7
+#define P11_IVG8               0x00001000	// Peripheral #11 assigned IVG8
+#define P11_IVG9               0x00002000	// Peripheral #11 assigned IVG9
+#define P11_IVG10              0x00003000	// Peripheral #11 assigned IVG10
+#define P11_IVG11              0x00004000	// Peripheral #11 assigned IVG11
+#define P11_IVG12              0x00005000	// Peripheral #11 assigned IVG12
+#define P11_IVG13              0x00006000	// Peripheral #11 assigned IVG13
+#define P11_IVG14              0x00007000	// Peripheral #11 assigned IVG14
+#define P11_IVG15              0x00008000	// Peripheral #11 assigned IVG15
+#define P12_IVG7               0x00000000	// Peripheral #12 assigned IVG7
+#define P12_IVG8               0x00010000	// Peripheral #12 assigned IVG8
+#define P12_IVG9               0x00020000	// Peripheral #12 assigned IVG9
+#define P12_IVG10              0x00030000	// Peripheral #12 assigned IVG10
+#define P12_IVG11              0x00040000	// Peripheral #12 assigned IVG11
+#define P12_IVG12              0x00050000	// Peripheral #12 assigned IVG12
+#define P12_IVG13              0x00060000	// Peripheral #12 assigned IVG13
+#define P12_IVG14              0x00070000	// Peripheral #12 assigned IVG14
+#define P12_IVG15              0x00080000	// Peripheral #12 assigned IVG15
+#define P13_IVG7               0x00000000	// Peripheral #13 assigned IVG7
+#define P13_IVG8               0x00100000	// Peripheral #13 assigned IVG8
+#define P13_IVG9               0x00200000	// Peripheral #13 assigned IVG9
+#define P13_IVG10              0x00300000	// Peripheral #13 assigned IVG10
+#define P13_IVG11              0x00400000	// Peripheral #13 assigned IVG11
+#define P13_IVG12              0x00500000	// Peripheral #13 assigned IVG12
+#define P13_IVG13              0x00600000	// Peripheral #13 assigned IVG13
+#define P13_IVG14              0x00700000	// Peripheral #14 assigned IVG14
+#define P13_IVG15              0x00800000	// Peripheral #14 assigned IVG15
+#define P14_IVG7               0x00000000	// Peripheral #14 assigned IVG7
+#define P14_IVG8               0x01000000	// Peripheral #14 assigned IVG8
+#define P14_IVG9               0x02000000	// Peripheral #14 assigned IVG9
+#define P14_IVG10              0x03000000	// Peripheral #14 assigned IVG10
+#define P14_IVG11              0x04000000	// Peripheral #14 assigned IVG11
+#define P14_IVG12              0x05000000	// Peripheral #14 assigned IVG12
+#define P14_IVG13              0x06000000	// Peripheral #14 assigned IVG13
+#define P14_IVG14              0x07000000	// Peripheral #14 assigned IVG14
+#define P14_IVG15              0x08000000	// Peripheral #14 assigned IVG15
+#define P15_IVG7               0x00000000	// Peripheral #15 assigned IVG7
+#define P15_IVG8               0x10000000	// Peripheral #15 assigned IVG8
+#define P15_IVG9               0x20000000	// Peripheral #15 assigned IVG9
+#define P15_IVG10              0x30000000	// Peripheral #15 assigned IVG10
+#define P15_IVG11              0x40000000	// Peripheral #15 assigned IVG11
+#define P15_IVG12              0x50000000	// Peripheral #15 assigned IVG12
+#define P15_IVG13              0x60000000	// Peripheral #15 assigned IVG13
+#define P15_IVG14              0x70000000	// Peripheral #15 assigned IVG14
+#define P15_IVG15              0x80000000	// Peripheral #15 assigned IVG15
+
+// SIC_IAR2 Masks
+#define P16_IVG7               0x00000000	// Peripheral #16 assigned IVG7
+#define P16_IVG8               0x00000001	// Peripheral #16 assigned IVG8
+#define P16_IVG9               0x00000002	// Peripheral #16 assigned IVG9
+#define P16_IVG10              0x00000003	// Peripheral #16 assigned IVG10
+#define P16_IVG11              0x00000004	// Peripheral #16 assigned IVG11
+#define P16_IVG12              0x00000005	// Peripheral #16 assigned IVG12
+#define P16_IVG13              0x00000006	// Peripheral #16 assigned IVG13
+#define P16_IVG14              0x00000007	// Peripheral #16 assigned IVG14
+#define P16_IVG15              0x00000008	// Peripheral #16 assigned IVG15
+#define P17_IVG7               0x00000000	// Peripheral #17 assigned IVG7
+#define P17_IVG8               0x00000010	// Peripheral #17 assigned IVG8
+#define P17_IVG9               0x00000020	// Peripheral #17 assigned IVG9
+#define P17_IVG10              0x00000030	// Peripheral #17 assigned IVG10
+#define P17_IVG11              0x00000040	// Peripheral #17 assigned IVG11
+#define P17_IVG12              0x00000050	// Peripheral #17 assigned IVG12
+#define P17_IVG13              0x00000060	// Peripheral #17 assigned IVG13
+#define P17_IVG14              0x00000070	// Peripheral #17 assigned IVG14
+#define P17_IVG15              0x00000080	// Peripheral #17 assigned IVG15
+#define P18_IVG7               0x00000000	// Peripheral #18 assigned IVG7
+#define P18_IVG8               0x00000100	// Peripheral #18 assigned IVG8
+#define P18_IVG9               0x00000200	// Peripheral #18 assigned IVG9
+#define P18_IVG10              0x00000300	// Peripheral #18 assigned IVG10
+#define P18_IVG11              0x00000400	// Peripheral #18 assigned IVG11
+#define P18_IVG12              0x00000500	// Peripheral #18 assigned IVG12
+#define P18_IVG13              0x00000600	// Peripheral #18 assigned IVG13
+#define P18_IVG14              0x00000700	// Peripheral #18 assigned IVG14
+#define P18_IVG15              0x00000800	// Peripheral #18 assigned IVG15
+#define P19_IVG7               0x00000000	// Peripheral #19 assigned IVG7
+#define P19_IVG8               0x00001000	// Peripheral #19 assigned IVG8
+#define P19_IVG9               0x00002000	// Peripheral #19 assigned IVG9
+#define P19_IVG10              0x00003000	// Peripheral #19 assigned IVG10
+#define P19_IVG11              0x00004000	// Peripheral #19 assigned IVG11
+#define P19_IVG12              0x00005000	// Peripheral #19 assigned IVG12
+#define P19_IVG13              0x00006000	// Peripheral #19 assigned IVG13
+#define P19_IVG14              0x00007000	// Peripheral #19 assigned IVG14
+#define P19_IVG15              0x00008000	// Peripheral #19 assigned IVG15
+#define P20_IVG7               0x00000000	// Peripheral #20 assigned IVG7
+#define P20_IVG8               0x00010000	// Peripheral #20 assigned IVG8
+#define P20_IVG9               0x00020000	// Peripheral #20 assigned IVG9
+#define P20_IVG10              0x00030000	// Peripheral #20 assigned IVG10
+#define P20_IVG11              0x00040000	// Peripheral #20 assigned IVG11
+#define P20_IVG12              0x00050000	// Peripheral #20 assigned IVG12
+#define P20_IVG13              0x00060000	// Peripheral #20 assigned IVG13
+#define P20_IVG14              0x00070000	// Peripheral #20 assigned IVG14
+#define P20_IVG15              0x00080000	// Peripheral #20 assigned IVG15
+//
+// SIC_IMASK Masks
+#define SIC_UNMASK_ALL         0x00000000	// Unmask all peripheral interrupts
+#define SIC_MASK_ALL           0xFFFFFFFF	// Mask all peripheral interrupts
+#define SIC_MASK0              0x00000001	// Mask Peripheral #0 interrupt
+#define SIC_MASK1              0x00000002	// Mask Peripheral #1 interrupt
+#define SIC_MASK2              0x00000004	// Mask Peripheral #2 interrupt
+#define SIC_MASK3              0x00000008	// Mask Peripheral #3 interrupt
+#define SIC_MASK4              0x00000010	// Mask Peripheral #4 interrupt
+#define SIC_MASK5              0x00000020	// Mask Peripheral #5 interrupt
+#define SIC_MASK6              0x00000040	// Mask Peripheral #6 interrupt
+#define SIC_MASK7              0x00000080	// Mask Peripheral #7 interrupt
+#define SIC_MASK8              0x00000100	// Mask Peripheral #8 interrupt
+#define SIC_MASK9              0x00000200	// Mask Peripheral #9 interrupt
+#define SIC_MASK10             0x00000400	// Mask Peripheral #10 interrupt
+#define SIC_MASK11             0x00000800	// Mask Peripheral #11 interrupt
+#define SIC_MASK12             0x00001000	// Mask Peripheral #12 interrupt
+#define SIC_MASK13             0x00002000	// Mask Peripheral #13 interrupt
+#define SIC_MASK14             0x00004000	// Mask Peripheral #14 interrupt
+#define SIC_MASK15             0x00008000	// Mask Peripheral #15 interrupt
+#define SIC_MASK16             0x00010000	// Mask Peripheral #16 interrupt
+#define SIC_MASK17             0x00020000	// Mask Peripheral #17 interrupt
+#define SIC_MASK18             0x00040000	// Mask Peripheral #18 interrupt
+#define SIC_MASK19             0x00080000	// Mask Peripheral #19 interrupt
+#define SIC_MASK20             0x00100000	// Mask Peripheral #20 interrupt
+#define SIC_MASK_DFR           0x80000000	// Mask Core Double Fault Reset
+#define SIC_UNMASK0            0xFFFFFFFE	// Unmask Peripheral #0 interrupt
+#define SIC_UNMASK1            0xFFFFFFFD	// Unmask Peripheral #1 interrupt
+#define SIC_UNMASK2            0xFFFFFFFB	// Unmask Peripheral #2 interrupt
+#define SIC_UNMASK3            0xFFFFFFF7	// Unmask Peripheral #3 interrupt
+#define SIC_UNMASK4            0xFFFFFFEF	// Unmask Peripheral #4 interrupt
+#define SIC_UNMASK5            0xFFFFFFDF	// Unmask Peripheral #5 interrupt
+#define SIC_UNMASK6            0xFFFFFFBF	// Unmask Peripheral #6 interrupt
+#define SIC_UNMASK7            0xFFFFFF7F	// Unmask Peripheral #7 interrupt
+#define SIC_UNMASK8            0xFFFFFEFF	// Unmask Peripheral #8 interrupt
+#define SIC_UNMASK9            0xFFFFFDFF	// Unmask Peripheral #9 interrupt
+#define SIC_UNMASK10           0xFFFFFBFF	// Unmask Peripheral #10 interrupt
+#define SIC_UNMASK11           0xFFFFF7FF	// Unmask Peripheral #11 interrupt
+#define SIC_UNMASK12           0xFFFFEFFF	// Unmask Peripheral #12 interrupt
+#define SIC_UNMASK13           0xFFFFDFFF	// Unmask Peripheral #13 interrupt
+#define SIC_UNMASK14           0xFFFFBFFF	// Unmask Peripheral #14 interrupt
+#define SIC_UNMASK15           0xFFFF7FFF	// Unmask Peripheral #15 interrupt
+#define SIC_UNMASK16           0xFFFEFFFF	// Unmask Peripheral #16 interrupt
+#define SIC_UNMASK17           0xFFFDFFFF	// Unmask Peripheral #17 interrupt
+#define SIC_UNMASK18           0xFFFBFFFF	// Unmask Peripheral #18 interrupt
+#define SIC_UNMASK19           0xFFF7FFFF	// Unmask Peripheral #19 interrupt
+#define SIC_UNMASK20           0xFFEFFFFF	// Unmask Peripheral #20 interrupt
+#define SIC_UNMASK_DFR         0x7FFFFFFF	// Unmask Core Double Fault Reset
+
+// SIC_IWR Masks
+#define IWR_DISABLE_ALL        0x00000000	// Wakeup Disable all peripherals
+#define IWR_ENABLE_ALL         0xFFFFFFFF	// Wakeup Enable all peripherals
+#define IWR_ENABLE0            0x00000001	// Wakeup Enable Peripheral #0
+#define IWR_ENABLE1            0x00000002	// Wakeup Enable Peripheral #1
+#define IWR_ENABLE2            0x00000004	// Wakeup Enable Peripheral #2
+#define IWR_ENABLE3            0x00000008	// Wakeup Enable Peripheral #3
+#define IWR_ENABLE4            0x00000010	// Wakeup Enable Peripheral #4
+#define IWR_ENABLE5            0x00000020	// Wakeup Enable Peripheral #5
+#define IWR_ENABLE6            0x00000040	// Wakeup Enable Peripheral #6
+#define IWR_ENABLE7            0x00000080	// Wakeup Enable Peripheral #7
+#define IWR_ENABLE8            0x00000100	// Wakeup Enable Peripheral #8
+#define IWR_ENABLE9            0x00000200	// Wakeup Enable Peripheral #9
+#define IWR_ENABLE10           0x00000400	// Wakeup Enable Peripheral #10
+#define IWR_ENABLE11           0x00000800	// Wakeup Enable Peripheral #11
+#define IWR_ENABLE12           0x00001000	// Wakeup Enable Peripheral #12
+#define IWR_ENABLE13           0x00002000	// Wakeup Enable Peripheral #13
+#define IWR_ENABLE14           0x00004000	// Wakeup Enable Peripheral #14
+#define IWR_ENABLE15           0x00008000	// Wakeup Enable Peripheral #15
+#define IWR_ENABLE16           0x00010000	// Wakeup Enable Peripheral #16
+#define IWR_ENABLE17           0x00020000	// Wakeup Enable Peripheral #17
+#define IWR_ENABLE18           0x00040000	// Wakeup Enable Peripheral #18
+#define IWR_ENABLE19           0x00080000	// Wakeup Enable Peripheral #19
+#define IWR_ENABLE20           0x00100000	// Wakeup Enable Peripheral #20
+#define IWR_DISABLE0           0xFFFFFFFE	// Wakeup Disable Peripheral #0
+#define IWR_DISABLE1           0xFFFFFFFD	// Wakeup Disable Peripheral #1
+#define IWR_DISABLE2           0xFFFFFFFB	// Wakeup Disable Peripheral #2
+#define IWR_DISABLE3           0xFFFFFFF7	// Wakeup Disable Peripheral #3
+#define IWR_DISABLE4           0xFFFFFFEF	// Wakeup Disable Peripheral #4
+#define IWR_DISABLE5           0xFFFFFFDF	// Wakeup Disable Peripheral #5
+#define IWR_DISABLE6           0xFFFFFFBF	// Wakeup Disable Peripheral #6
+#define IWR_DISABLE7           0xFFFFFF7F	// Wakeup Disable Peripheral #7
+#define IWR_DISABLE8           0xFFFFFEFF	// Wakeup Disable Peripheral #8
+#define IWR_DISABLE9           0xFFFFFDFF	// Wakeup Disable Peripheral #9
+#define IWR_DISABLE10          0xFFFFFBFF	// Wakeup Disable Peripheral #10
+#define IWR_DISABLE11          0xFFFFF7FF	// Wakeup Disable Peripheral #11
+#define IWR_DISABLE12          0xFFFFEFFF	// Wakeup Disable Peripheral #12
+#define IWR_DISABLE13          0xFFFFDFFF	// Wakeup Disable Peripheral #13
+#define IWR_DISABLE14          0xFFFFBFFF	// Wakeup Disable Peripheral #14
+#define IWR_DISABLE15          0xFFFF7FFF	// Wakeup Disable Peripheral #15
+#define IWR_DISABLE16          0xFFFEFFFF	// Wakeup Disable Peripheral #16
+#define IWR_DISABLE17          0xFFFDFFFF	// Wakeup Disable Peripheral #17
+#define IWR_DISABLE18          0xFFFBFFFF	// Wakeup Disable Peripheral #18
+#define IWR_DISABLE19          0xFFF7FFFF	// Wakeup Disable Peripheral #19
+#define IWR_DISABLE20          0xFFEFFFFF	// Wakeup Disable Peripheral #20
+
+// WDOGCTL Masks
+#define ENABLE_RESET           0x00000000	// Set Watchdog Timer to generate reset
+#define ENABLE_NMI             0x00000002	// Set Watchdog Timer to generate non-maskable interrupt
+#define ENABLE_GPI             0x00000004	// Set Watchdog Timer to generate general-purpose interrupt
+#define DISABLE_EVT            0x00000006	// Disable Watchdog Timer interrupts
+
+// RTCFAST Mask
+#define ENABLE_PRESCALE        0x00000001	// Enable prescaler so RTC runs at 1 Hz
+	  // Must be set after power-up for proper operation of RTC
+
+// SPICTLx Masks
+#define TIMOD                  0x00000003	// Transfer initiation mode and interrupt generation
+#define SZ                     0x00000004	// Send Zero (=0) or last (=1) word when TDBR empty.
+#define GM                     0x00000008	// When RDBR full, get more (=1) data or discard (=0) incoming Data
+#define PSSE                   0x00000010	// Enable (=1) Slave-Select input for Master.
+#define EMISO                  0x00000020	// Enable (=1) MISO pin as an output.
+#define SIZE                   0x00000100	// Word length (0 => 8 bits, 1 => 16 bits)
+#define LSBF                   0x00000200	// Data format (0 => MSB sent/received first 1 => LSB sent/received first)
+#define CPHA                   0x00000400	// Clock phase (0 => SPICLK starts toggling in middle of xfer, 1 => SPICLK toggles at the beginning of xfer.
+#define CPOL                   0x00000800	// Clock polarity (0 => active-high, 1 => active-low)
+#define MSTR                   0x00001000	// Configures SPI as master (=1) or slave (=0)
+#define WOM                    0x00002000	// Open drain (=1) data output enable (for MOSI and MISO)
+#define SPE                    0x00004000	// SPI module enable (=1), disable (=0)
+
+// SPIFLGx Masks
+#define FLS1                   0x00000002	// Enables (=1) SPI_FLOUT1 as flag output for SPI Slave-select
+#define FLS2                   0x00000004	// Enables (=1) SPI_FLOUT2 as flag output for SPI Slave-select
+#define FLS3                   0x00000008	// Enables (=1) SPI_FLOUT3 as flag output for SPI Slave-select
+#define FLS4                   0x00000010	// Enables (=1) SPI_FLOUT4 as flag output for SPI Slave-select
+#define FLS5                   0x00000020	// Enables (=1) SPI_FLOUT5 as flag output for SPI Slave-select
+#define FLS6                   0x00000040	// Enables (=1) SPI_FLOUT6 as flag output for SPI Slave-select
+#define FLS7                   0x00000080	// Enables (=1) SPI_FLOUT7 as flag output for SPI Slave-select
+#define FLG1                   0x00000200	// Activates (=0) SPI_FLOUT1 as flag output for SPI Slave-select
+#define FLG2                   0x00000400	// Activates (=0) SPI_FLOUT2 as flag output for SPI Slave-select
+#define FLG3                   0x00000800	// Activates (=0) SPI_FLOUT3 as flag output for SPI Slave-select
+#define FLG4                   0x00001000	// Activates (=0) SPI_FLOUT4 as flag output for SPI Slave-select
+#define FLG5                   0x00002000	// Activates (=0) SPI_FLOUT5 as flag output for SPI Slave-select
+#define FLG6                   0x00004000	// Activates (=0) SPI_FLOUT6 as flag output for SPI Slave-select
+#define FLG7                   0x00008000	// Activates (=0) SPI_FLOUT7 as flag output for SPI Slave-select
+
+// SPIFLGx Bit Positions
+#define FLS1_P                 0x00000001	// Enables (=1) SPI_FLOUT1 as flag output for SPI Slave-select
+#define FLS2_P                 0x00000002	// Enables (=1) SPI_FLOUT2 as flag output for SPI Slave-select
+#define FLS3_P                 0x00000003	// Enables (=1) SPI_FLOUT3 as flag output for SPI Slave-select
+#define FLS4_P                 0x00000004	// Enables (=1) SPI_FLOUT4 as flag output for SPI Slave-select
+#define FLS5_P                 0x00000005	// Enables (=1) SPI_FLOUT5 as flag output for SPI Slave-select
+#define FLS6_P                 0x00000006	// Enables (=1) SPI_FLOUT6 as flag output for SPI Slave-select
+#define FLS7_P                 0x00000007	// Enables (=1) SPI_FLOUT7 as flag output for SPI Slave-select
+#define FLG1_P                 0x00000009	// Activates (=0) SPI_FLOUT1 as flag output for SPI Slave-select
+#define FLG2_P                 0x0000000A	// Activates (=0) SPI_FLOUT2 as flag output for SPI Slave-select
+#define FLG3_P                 0x0000000B	// Activates (=0) SPI_FLOUT3 as flag output for SPI Slave-select
+#define FLG4_P                 0x0000000C	// Activates (=0) SPI_FLOUT4 as flag output for SPI Slave-select
+#define FLG5_P                 0x0000000D	// Activates (=0) SPI_FLOUT5 as flag output for SPI Slave-select
+#define FLG6_P                 0x0000000E	// Activates (=0) SPI_FLOUT6 as flag output for SPI Slave-select
+#define FLG7_P                 0x0000000F	// Activates (=0) SPI_FLOUT7 as flag output for SPI Slave-select
+
+// AMGCTL Masks
+#define AMCKEN                 0x00000001	// Enable CLKOUT
+#define AMBEN_B4               0x00000002	// Enable Asynchronous Memory Bank 6 only
+#define AMBEN_B4_B5            0x00000004	// Enable Asynchronous Memory Banks 4 & 5 only
+#define AMBEN_ALL              0x00000006	// Enable Asynchronous Memory Banks (all) 4, 5, 6, and 7
+#define B4PEN                  0x00000010	// Enable 16-bit packing for Asynchronous Memory Bank 4
+#define B5PEN                  0x00000020	// Enable 16-bit packing for Asynchronous Memory Bank 5
+#define B6PEN                  0x00000040	// Enable 16-bit packing for Asynchronous Memory Bank 6
+#define B7PEN                  0x00000080	// Enable 16-bit packing for Asynchronous Memory Bank 7
+
+// AMGCTL Bit Positions
+#define AMCKEN_P               0x00000000	// Enable CLKOUT
+#define AMBEN_P0               0x00000001	// Asynchronous Memory Enable, 00 - banks 4-7 disabled, 01 - bank 4 enabled
+#define AMBEN_P1               0x00000002	// Asynchronous Memory Enable, 10 - banks 4&5 enabled,  11 - banks 4-7 enabled
+#define B4PEN_P                0x00000004	// Enable 16-bit packing for Asynchronous Memory Bank 4
+#define B5PEN_P                0x00000005	// Enable 16-bit packing for Asynchronous Memory Bank 5
+#define B6PEN_P                0x00000006	// Enable 16-bit packing for Asynchronous Memory Bank 6
+#define B7PEN_P                0x00000007	// Enable 16-bit packing for Asynchronous Memory Bank 7
+
+// AMBCTL0 Masks
+#define B4RDYEN                0x00000001	// Bank 4 RDY Enable, 0=disable, 1=enable
+#define B4RDYPOL               0x00000002	// Bank 4 RDY Active high, 0=active low, 1=active high
+#define B4TT_1                 0x00000004	// Bank 4 Transition Time from Read to Write = 1 cycle
+#define B4TT_2                 0x00000008	// Bank 4 Transition Time from Read to Write = 2 cycles
+#define B4TT_3                 0x0000000C	// Bank 4 Transition Time from Read to Write = 3 cycles
+#define B4TT_4                 0x00000000	// Bank 4 Transition Time from Read to Write = 4 cycles
+#define B4ST_1                 0x00000010	// Bank 4 Setup Time from AOE asserted to Read or Write asserted = 1 cycle
+#define B4ST_2                 0x00000020	// Bank 4 Setup Time from AOE asserted to Read or Write asserted = 2 cycles
+#define B4ST_3                 0x00000030	// Bank 4 Setup Time from AOE asserted to Read or Write asserted = 3 cycles
+#define B4ST_4                 0x00000000	// Bank 4 Setup Time from AOE asserted to Read or Write asserted = 4 cycles
+#define B4HT_1                 0x00000040	// Bank 4 Hold Time from Read or Write deasserted to AOE deasserted = 1 cycle
+#define B4HT_2                 0x00000080	// Bank 4 Hold Time from Read or Write deasserted to AOE deasserted = 2 cycles
+#define B4HT_3                 0x000000C0	// Bank 4 Hold Time from Read or Write deasserted to AOE deasserted = 3 cycles
+#define B4HT_4                 0x00000000	// Bank 4 Hold Time from Read or Write deasserted to AOE deasserted = 4 cycles
+#define B4RAT_1                0x00000100	// Bank 4 Read Access Time = 1 cycle
+#define B4RAT_2                0x00000200	// Bank 4 Read Access Time = 2 cycles
+#define B4RAT_3                0x00000300	// Bank 4 Read Access Time = 3 cycles
+#define B4RAT_4                0x00000400	// Bank 4 Read Access Time = 4 cycles
+#define B4RAT_5                0x00000500	// Bank 4 Read Access Time = 5 cycles
+#define B4RAT_6                0x00000600	// Bank 4 Read Access Time = 6 cycles
+#define B4RAT_7                0x00000700	// Bank 4 Read Access Time = 7 cycles
+#define B4RAT_8                0x00000800	// Bank 4 Read Access Time = 8 cycles
+#define B4RAT_9                0x00000900	// Bank 4 Read Access Time = 9 cycles
+#define B4RAT_10               0x00000A00	// Bank 4 Read Access Time = 10 cycles
+#define B4RAT_11               0x00000B00	// Bank 4 Read Access Time = 11 cycles
+#define B4RAT_12               0x00000C00	// Bank 4 Read Access Time = 12 cycles
+#define B4RAT_13               0x00000D00	// Bank 4 Read Access Time = 13 cycles
+#define B4RAT_14               0x00000E00	// Bank 4 Read Access Time = 14 cycles
+#define B4RAT_15               0x00000F00	// Bank 4 Read Access Time = 15 cycles
+#define B4WAT_1                0x00001000	// Bank 4 Write Access Time = 1 cycle
+#define B4WAT_2                0x00002000	// Bank 4 Write Access Time = 2 cycles
+#define B4WAT_3                0x00003000	// Bank 4 Write Access Time = 3 cycles
+#define B4WAT_4                0x00004000	// Bank 4 Write Access Time = 4 cycles
+#define B4WAT_5                0x00005000	// Bank 4 Write Access Time = 5 cycles
+#define B4WAT_6                0x00006000	// Bank 4 Write Access Time = 6 cycles
+#define B4WAT_7                0x00007000	// Bank 4 Write Access Time = 7 cycles
+#define B4WAT_8                0x00008000	// Bank 4 Write Access Time = 8 cycles
+#define B4WAT_9                0x00009000	// Bank 4 Write Access Time = 9 cycles
+#define B4WAT_10               0x0000A000	// Bank 4 Write Access Time = 10 cycles
+#define B4WAT_11               0x0000B000	// Bank 4 Write Access Time = 11 cycles
+#define B4WAT_12               0x0000C000	// Bank 4 Write Access Time = 12 cycles
+#define B4WAT_13               0x0000D000	// Bank 4 Write Access Time = 13 cycles
+#define B4WAT_14               0x0000E000	// Bank 4 Write Access Time = 14 cycles
+#define B4WAT_15               0x0000F000	// Bank 4 Write Access Time = 15 cycles
+#define B5RDYEN                0x00000001	// Bank 5 RDY enable, 0=disable, 1=enable
+#define B5RDYPOL               0x00000002	// Bank 5 RDY Active high, 0=active low, 1=active high
+#define B5TT_1                 0x00000004	// Bank 5 Transition Time from Read to Write = 1 cycle
+#define B5TT_2                 0x00000008	// Bank 5 Transition Time from Read to Write = 2 cycles
+#define B5TT_3                 0x0000000C	// Bank 5 Transition Time from Read to Write = 3 cycles
+#define B5TT_4                 0x00000000	// Bank 5 Transition Time from Read to Write = 4 cycles
+#define B5ST_1                 0x00000010	// Bank 5 Setup Time from AOE asserted to Read or Write asserted = 1 cycle
+#define B5ST_2                 0x00000020	// Bank 5 Setup Time from AOE asserted to Read or Write asserted = 2 cycles
+#define B5ST_3                 0x00000030	// Bank 5 Setup Time from AOE asserted to Read or Write asserted = 3 cycles
+#define B5ST_4                 0x00000000	// Bank 5 Setup Time from AOE asserted to Read or Write asserted = 4 cycles
+#define B5HT_1                 0x00000040	// Bank 5 Hold Time from Read or Write deasserted to AOE deasserted = 1 cycle
+#define B5HT_2                 0x00000080	// Bank 5 Hold Time from Read or Write deasserted to AOE deasserted = 2 cycles
+#define B5HT_3                 0x000000C0	// Bank 5 Hold Time from Read or Write deasserted to AOE deasserted = 3 cycles
+#define B5HT_4                 0x00000000	// Bank 5 Hold Time from Read or Write deasserted to AOE deasserted = 4 cycles
+#define B5RAT_1                0x00000100	// Bank 5 Read Access Time = 1 cycle
+#define B5RAT_2                0x00000200	// Bank 5 Read Access Time = 2 cycles
+#define B5RAT_3                0x00000300	// Bank 5 Read Access Time = 3 cycles
+#define B5RAT_4                0x00000400	// Bank 5 Read Access Time = 4 cycles
+#define B5RAT_5                0x00000500	// Bank 5 Read Access Time = 5 cycles
+#define B5RAT_6                0x00000600	// Bank 5 Read Access Time = 6 cycles
+#define B5RAT_7                0x00000700	// Bank 5 Read Access Time = 7 cycles
+#define B5RAT_8                0x00000800	// Bank 5 Read Access Time = 8 cycles
+#define B5RAT_9                0x00000900	// Bank 5 Read Access Time = 9 cycles
+#define B5RAT_10               0x00000A00	// Bank 5 Read Access Time = 10 cycles
+#define B5RAT_11               0x00000B00	// Bank 5 Read Access Time = 11 cycles
+#define B5RAT_12               0x00000C00	// Bank 5 Read Access Time = 12 cycles
+#define B5RAT_13               0x00000D00	// Bank 5 Read Access Time = 13 cycles
+#define B5RAT_14               0x00000E00	// Bank 5 Read Access Time = 14 cycles
+#define B5RAT_15               0x00000F00	// Bank 5 Read Access Time = 15 cycles
+#define B5WAT_1                0x00001000	// Bank 5 Write Access Time = 1 cycle
+#define B5WAT_2                0x00002000	// Bank 5 Write Access Time = 2 cycles
+#define B5WAT_3                0x00003000	// Bank 5 Write Access Time = 3 cycles
+#define B5WAT_4                0x00004000	// Bank 5 Write Access Time = 4 cycles
+#define B5WAT_5                0x00005000	// Bank 5 Write Access Time = 5 cycles
+#define B5WAT_6                0x00006000	// Bank 5 Write Access Time = 6 cycles
+#define B5WAT_7                0x00007000	// Bank 5 Write Access Time = 7 cycles
+#define B5WAT_8                0x00008000	// Bank 5 Write Access Time = 8 cycles
+#define B5WAT_9                0x00009000	// Bank 5 Write Access Time = 9 cycles
+#define B5WAT_10               0x0000A000	// Bank 5 Write Access Time = 10 cycles
+#define B5WAT_11               0x0000B000	// Bank 5 Write Access Time = 11 cycles
+#define B5WAT_12               0x0000C000	// Bank 5 Write Access Time = 12 cycles
+#define B5WAT_13               0x0000D000	// Bank 5 Write Access Time = 13 cycles
+#define B5WAT_14               0x0000E000	// Bank 5 Write Access Time = 14 cycles
+#define B5WAT_15               0x0000F000	// Bank 5 Write Access Time = 15 cycles
+
+// AMBCTL1 Masks
+#define B6RDYEN                0x00000001	// Bank 6 RDY Enable, 0=disable, 1=enable
+#define B6RDYPOL               0x00000002	// Bank 6 RDY Active high, 0=active low, 1=active high
+#define B6TT_1                 0x00000004	// Bank 6 Transition Time from Read to Write = 1 cycle
+#define B6TT_2                 0x00000008	// Bank 6 Transition Time from Read to Write = 2 cycles
+#define B6TT_3                 0x0000000C	// Bank 6 Transition Time from Read to Write = 3 cycles
+#define B6TT_4                 0x00000000	// Bank 6 Transition Time from Read to Write = 4 cycles
+#define B6ST_1                 0x00000010	// Bank 6 Setup Time from AOE asserted to Read or Write asserted = 1 cycle
+#define B6ST_2                 0x00000020	// Bank 6 Setup Time from AOE asserted to Read or Write asserted = 2 cycles
+#define B6ST_3                 0x00000030	// Bank 6 Setup Time from AOE asserted to Read or Write asserted = 3 cycles
+#define B6ST_4                 0x00000000	// Bank 6 Setup Time from AOE asserted to Read or Write asserted = 4 cycles
+#define B6HT_1                 0x00000040	// Bank 6 Hold Time from Read or Write deasserted to AOE deasserted = 1 cycle
+#define B6HT_2                 0x00000080	// Bank 6 Hold Time from Read or Write deasserted to AOE deasserted = 2 cycles
+#define B6HT_3                 0x000000C0	// Bank 6 Hold Time from Read or Write deasserted to AOE deasserted = 3 cycles
+#define B6HT_4                 0x00000000	// Bank 6 Hold Time from Read or Write deasserted to AOE deasserted = 4 cycles
+#define B6RAT_1                0x00000100	// Bank 6 Read Access Time = 1 cycle
+#define B6RAT_2                0x00000200	// Bank 6 Read Access Time = 2 cycles
+#define B6RAT_3                0x00000300	// Bank 6 Read Access Time = 3 cycles
+#define B6RAT_4                0x00000400	// Bank 6 Read Access Time = 4 cycles
+#define B6RAT_5                0x00000500	// Bank 6 Read Access Time = 5 cycles
+#define B6RAT_6                0x00000600	// Bank 6 Read Access Time = 6 cycles
+#define B6RAT_7                0x00000700	// Bank 6 Read Access Time = 7 cycles
+#define B6RAT_8                0x00000800	// Bank 6 Read Access Time = 8 cycles
+#define B6RAT_9                0x00000900	// Bank 6 Read Access Time = 9 cycles
+#define B6RAT_10               0x00000A00	// Bank 6 Read Access Time = 10 cycles
+#define B6RAT_11               0x00000B00	// Bank 6 Read Access Time = 11 cycles
+#define B6RAT_12               0x00000C00	// Bank 6 Read Access Time = 12 cycles
+#define B6RAT_13               0x00000D00	// Bank 6 Read Access Time = 13 cycles
+#define B6RAT_14               0x00000E00	// Bank 6 Read Access Time = 14 cycles
+#define B6RAT_15               0x00000F00	// Bank 6 Read Access Time = 15 cycles
+#define B6WAT_1                0x00001000	// Bank 6 Write Access Time = 1 cycle
+#define B6WAT_2                0x00002000	// Bank 6 Write Access Time = 2 cycles
+#define B6WAT_3                0x00003000	// Bank 6 Write Access Time = 3 cycles
+#define B6WAT_4                0x00004000	// Bank 6 Write Access Time = 4 cycles
+#define B6WAT_5                0x00005000	// Bank 6 Write Access Time = 5 cycles
+#define B6WAT_6                0x00006000	// Bank 6 Write Access Time = 6 cycles
+#define B6WAT_7                0x00007000	// Bank 6 Write Access Time = 7 cycles
+#define B6WAT_8                0x00008000	// Bank 6 Write Access Time = 8 cycles
+#define B6WAT_9                0x00009000	// Bank 6 Write Access Time = 9 cycles
+#define B6WAT_10               0x0000A000	// Bank 6 Write Access Time = 10 cycles
+#define B6WAT_11               0x0000B000	// Bank 6 Write Access Time = 11 cycles
+#define B6WAT_12               0x0000C000	// Bank 6 Write Access Time = 12 cycles
+#define B6WAT_13               0x0000D000	// Bank 6 Write Access Time = 13 cycles
+#define B6WAT_14               0x0000E000	// Bank 6 Write Access Time = 14 cycles
+#define B6WAT_15               0x0000F000	// Bank 6 Write Access Time = 15 cycles
+#define B7RDYEN                0x00000001	// Bank 7 RDY enable, 0=disable, 1=enable
+#define B7RDYPOL               0x00000002	// Bank 7 RDY Active high, 0=active low, 1=active high
+#define B7TT_1                 0x00000004	// Bank 7 Transition Time from Read to Write = 1 cycle
+#define B7TT_2                 0x00000008	// Bank 7 Transition Time from Read to Write = 2 cycles
+#define B7TT_3                 0x0000000C	// Bank 7 Transition Time from Read to Write = 3 cycles
+#define B7TT_4                 0x00000000	// Bank 7 Transition Time from Read to Write = 4 cycles
+#define B7ST_1                 0x00000010	// Bank 7 Setup Time from AOE asserted to Read or Write asserted = 1 cycle
+#define B7ST_2                 0x00000020	// Bank 7 Setup Time from AOE asserted to Read or Write asserted = 2 cycles
+#define B7ST_3                 0x00000030	// Bank 7 Setup Time from AOE asserted to Read or Write asserted = 3 cycles
+#define B7ST_4                 0x00000000	// Bank 7 Setup Time from AOE asserted to Read or Write asserted = 4 cycles
+#define B7HT_1                 0x00000040	// Bank 7 Hold Time from Read or Write deasserted to AOE deasserted = 1 cycle
+#define B7HT_2                 0x00000080	// Bank 7 Hold Time from Read or Write deasserted to AOE deasserted = 2 cycles
+#define B7HT_3                 0x000000C0	// Bank 7 Hold Time from Read or Write deasserted to AOE deasserted = 3 cycles
+#define B7HT_4                 0x00000000	// Bank 7 Hold Time from Read or Write deasserted to AOE deasserted = 4 cycles
+#define B7RAT_1                0x00000100	// Bank 7 Read Access Time = 1 cycle
+#define B7RAT_2                0x00000200	// Bank 7 Read Access Time = 2 cycles
+#define B7RAT_3                0x00000300	// Bank 7 Read Access Time = 3 cycles
+#define B7RAT_4                0x00000400	// Bank 7 Read Access Time = 4 cycles
+#define B7RAT_5                0x00000500	// Bank 7 Read Access Time = 5 cycles
+#define B7RAT_6                0x00000600	// Bank 7 Read Access Time = 6 cycles
+#define B7RAT_7                0x00000700	// Bank 7 Read Access Time = 7 cycles
+#define B7RAT_8                0x00000800	// Bank 7 Read Access Time = 8 cycles
+#define B7RAT_9                0x00000900	// Bank 7 Read Access Time = 9 cycles
+#define B7RAT_10               0x00000A00	// Bank 7 Read Access Time = 10 cycles
+#define B7RAT_11               0x00000B00	// Bank 7 Read Access Time = 11 cycles
+#define B7RAT_12               0x00000C00	// Bank 7 Read Access Time = 12 cycles
+#define B7RAT_13               0x00000D00	// Bank 7 Read Access Time = 13 cycles
+#define B7RAT_14               0x00000E00	// Bank 7 Read Access Time = 14 cycles
+#define B7RAT_15               0x00000F00	// Bank 7 Read Access Time = 15 cycles
+#define B7WAT_1                0x00001000	// Bank 7 Write Access Time = 1 cycle
+#define B7WAT_2                0x00002000	// Bank 7 Write Access Time = 2 cycles
+#define B7WAT_3                0x00003000	// Bank 7 Write Access Time = 3 cycles
+#define B7WAT_4                0x00004000	// Bank 7 Write Access Time = 4 cycles
+#define B7WAT_5                0x00005000	// Bank 7 Write Access Time = 5 cycles
+#define B7WAT_6                0x00006000	// Bank 7 Write Access Time = 6 cycles
+#define B7WAT_7                0x00007000	// Bank 7 Write Access Time = 7 cycles
+#define B7WAT_8                0x00008000	// Bank 7 Write Access Time = 8 cycles
+#define B7WAT_9                0x00009000	// Bank 7 Write Access Time = 9 cycles
+#define B7WAT_10               0x0000A000	// Bank 7 Write Access Time = 10 cycles
+#define B7WAT_11               0x0000B000	// Bank 7 Write Access Time = 11 cycles
+#define B7WAT_12               0x0000C000	// Bank 7 Write Access Time = 12 cycles
+#define B7WAT_13               0x0000D000	// Bank 7 Write Access Time = 13 cycles
+#define B7WAT_14               0x0000E000	// Bank 7 Write Access Time = 14 cycles
+#define B7WAT_15               0x0000F000	// Bank 7 Write Access Time = 15 cycles
+
+#endif				/* __DEF_BF535_H */
Index: git/linux-2.6/include/asm-blackfin/mach-bf535/defblackfin.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf535/defblackfin.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,444 @@
+/*
+ * File:         include/asm-blackfin/mach-bf535/defblackfin.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *	Common header file for blackfin family of processors
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* SYSTEM & MM REGISTER BIT & ADDRESS DEFINITIONS FOR ADSP-BF535 */
+
+#ifndef _DEF_BLACKFIN_H
+#define _DEF_BLACKFIN_H
+
+#if defined(__ADSPLPBLACKFIN__)
+#warning defblackfin.h should only be included for 535 compatible chips.
+#endif
+#define MK_BMSK_( x ) (1<<x)	// Make a bit mask from a bit position
+
+//**********************************************************************************
+// System Register Bits
+//**********************************************************************************
+
+//**************************************************
+//   ASTAT register
+//**************************************************
+
+#ifdef __ADSPBF535__
+// ** Bit Positions
+#define ASTAT_AZ_P         0x00000000	// Result of last ALU0 or shifter operation is zero
+#define ASTAT_AN_P         0x00000001	// Result of last ALU0 or shifter operation is negative
+#define ASTAT_AC_P         0x00000002	// Result of last ALU0 operation generated a carry
+#define ASTAT_AV0_P        0x00000003	// Result of last ALU0 or MAC0 operation overflowed, sticky for MAC
+#define ASTAT_AV1_P        0x00000004	// Result of last MAC1 operation overflowed, sticky for MAC
+#define ASTAT_CC_P         0x00000005	// Condition Code, used for holding comparison results
+#define ASTAT_AQ_P         0x00000006	// Quotient Bit
+#define ASTAT_RND_MOD_P    0x00000008	// Rounding mode, set for biased, clear for unbiased
+
+// NOTE: ASTAT_AC_P will be deprecated in future releases
+// To be replaced by ASTAT_AC0_P
+#define ASTAT_AC0_P        ASTAT_AC_P
+
+#else				/* __ADSPBF535__ */
+
+// definitions of ASTAT bit positions for next revision of BLACKFIN
+#define ASTAT_AZ_P         0x00000000	// Result of last ALU0 or shifter operation is zero
+#define ASTAT_AN_P         0x00000001	// Result of last ALU0 or shifter operation is negative
+#define ASTAT_CC_P         0x00000005	// Condition Code, used for holding comparison results
+#define ASTAT_AQ_P         0x00000006	// Quotient Bit
+#define ASTAT_RND_MOD_P    0x00000008	// Rounding mode, set for biased, clear for unbiased
+#define ASTAT_AC0_P        0x0000000C	// Result of last ALU0 operation generated a carry
+#define ASTAT_AC1_P        0x0000000D	// Result of last ALU1 operation generated a carry
+#define ASTAT_AV0_P        0x00000010	// Result of last ALU0 or MAC0 operation overflowed, sticky for MAC
+#define ASTAT_AV0S_P       0x00000011	// Sticky version of ASTAT_AV0_P
+#define ASTAT_AV1_P        0x00000012	// Result of last MAC1 operation overflowed, sticky for MAC
+#define ASTAT_AV1S_P       0x00000013	// Sticky version of ASTAT_AV1_P
+#define ASTAT_V_P          0x00000018	// Result of last op written to data register file.
+#define ASTAT_VS_P         0x00000019	// Sticky version of ASTAT_V_P
+#endif				/* __ADSPBF535__ */
+
+// ** Masks
+#define ASTAT_AZ           MK_BMSK_(ASTAT_AZ_P)	// Result of last ALU0 or shifter operation is zero
+#define ASTAT_AN           MK_BMSK_(ASTAT_AN_P)	// Result of last ALU0 or shifter operation is negative
+#define ASTAT_AV0          MK_BMSK_(ASTAT_AV0_P)	// Result of last ALU0 or MAC0 operation overflowed, sticky for MAC
+#define ASTAT_AV1          MK_BMSK_(ASTAT_AV1_P)	// Result of last MAC1 operation overflowed, sticky for MAC
+#define ASTAT_CC           MK_BMSK_(ASTAT_CC_P)	// Condition Code, used for holding comparison results
+#define ASTAT_AQ           MK_BMSK_(ASTAT_AQ_P)	// Quotient Bit
+#define ASTAT_RND_MOD      MK_BMSK_(ASTAT_RND_MOD_P)	// Rounding mode, set for biased, clear for unbiased
+
+#ifdef __ADSPBF535__
+
+#define ASTAT_AC           MK_BMSK_(ASTAT_AC_P)	// Result of last ALU0 operation generated a carry
+
+#else				/* __ADSPBF535__ */
+
+#define ASTAT_AC0          MK_BMSK_(ASTAT_AC0_P)	// Result of last ALU0 operation generated a carry
+#define ASTAT_AC1          MK_BMSK_(ASTAT_AC1_P)	// Result of last ALU1 operation generated a carry
+#define ASTAT_AV0S         MK_BMSK_(ASTAT_AV0S_P)	// Sticky version of ASTAT_AV0_P
+#define ASTAT_AV1S         MK_BMSK_(ASTAT_AV1S_P)	// Sticky version of ASTAT_AV1_P
+#define ASTAT_V            MK_BMSK_(ASTAT_V_P)	// Result of last op written to data register file.
+#define ASTAT_VS           MK_BMSK_(ASTAT_VS_P)	// Sticky version of ASTAT_V_P
+
+#endif				/* __ADSPBF535__ */
+
+//**************************************************
+//   SEQSTAT register
+//**************************************************
+
+// ** Bit Positions
+#define SEQSTAT_EXCAUSE0_P     0x00000000	// Last exception cause bit 0
+#define SEQSTAT_EXCAUSE1_P     0x00000001	// Last exception cause bit 1
+#define SEQSTAT_EXCAUSE2_P     0x00000002	// Last exception cause bit 2
+#define SEQSTAT_EXCAUSE3_P     0x00000003	// Last exception cause bit 3
+#define SEQSTAT_EXCAUSE4_P     0x00000004	// Last exception cause bit 4
+#define SEQSTAT_EXCAUSE5_P     0x00000005	// Last exception cause bit 5
+#define SEQSTAT_OMODE0_P       0x0000000A	// Operating mode: 00 user, 01 supervisor, 1x debug
+#define SEQSTAT_OMODE1_P       0x0000000B	// Operating mode: 00 user, 01 supervisor, 1x debug
+#define SEQSTAT_IDLE_REQ_P     0x0000000C	// Pending idle mode request, set by IDLE instruction
+#define SEQSTAT_SFTRESET_P     0x0000000D	// Indicates whether the last reset was a software reset (=1)
+#define SEQSTAT_HWERRCAUSE0_P  0x0000000E	// Last hw error cause bit 0
+#define SEQSTAT_HWERRCAUSE1_P  0x0000000F	// Last hw error cause bit 1
+#define SEQSTAT_HWERRCAUSE2_P  0x00000010	// Last hw error cause bit 2
+#define SEQSTAT_HWERRCAUSE3_P  0x00000011	// Last hw error cause bit 3
+#define SEQSTAT_HWERRCAUSE4_P  0x00000012	// Last hw error cause bit 4
+
+// ** Masks
+// Exception cause
+#define SEQSTAT_EXCAUSE        MK_BMSK_(SEQSTAT_EXCAUSE0_P) | \
+                               MK_BMSK_(SEQSTAT_EXCAUSE1_P) | \
+                               MK_BMSK_(SEQSTAT_EXCAUSE2_P) | \
+                               MK_BMSK_(SEQSTAT_EXCAUSE3_P) | \
+                               MK_BMSK_(SEQSTAT_EXCAUSE4_P) | \
+                               MK_BMSK_(SEQSTAT_EXCAUSE5_P) | \
+                               0
+
+// Operating mode: 00 user, 01 supervisor, 1x debug
+#define SEQSTAT_OMODE          MK_BMSK_(SEQSTAT_OMODE0_P) | \
+                               MK_BMSK_(SEQSTAT_OMODE1_P) | \
+                               0
+
+// Pending idle mode request, set by IDLE instruction
+#define SEQSTAT_IDLE_REQ       MK_BMSK_(SEQSTAT_IDLE_REQ_P)
+
+// Indicates whether the last reset was a software reset (=1)
+#define SEQSTAT_SFTRESET       MK_BMSK_(SEQSTAT_SFTRESET_P)
+
+// Last hw error cause
+#define SEQSTAT_HWERRCAUSE     MK_BMSK_(SEQSTAT_HWERRCAUSE0_P) | \
+                               MK_BMSK_(SEQSTAT_HWERRCAUSE1_P) | \
+                               MK_BMSK_(SEQSTAT_HWERRCAUSE2_P) | \
+                               MK_BMSK_(SEQSTAT_HWERRCAUSE3_P) | \
+                               MK_BMSK_(SEQSTAT_HWERRCAUSE4_P) | \
+                               0
+
+//**************************************************
+//   SYSCFG register
+//**************************************************
+
+// ** Bit Positions
+#define SYSCFG_SSSTEP_P        0x00000000	// Supervisor single step, when set it forces an exception for each instruction executed
+#define SYSCFG_CCEN_P          0x00000001	// Enable cycle counter (=1)
+#define SYSCFG_SNEN_P          0x00000002	// Enable self-nesting interrupts (=1)
+
+// ** Masks
+#define SYSCFG_SSSTEP         MK_BMSK_(SYSCFG_SSSTEP_P)	// Supervisor single step, when set it forces an exception for each instruction executed
+#define SYSCFG_CCEN           MK_BMSK_(SYSCFG_CCEN_P)	// Enable cycle counter (=1)
+#define SYSCFG_SNEN           MK_BMSK_(SYSCFG_SNEN_P)	// Enable self-nesting interrupts (=1)
+/* Backward-compatibility for typos in prior releases */
+#define SYSCFG_SSSSTEP         SYSCFG_SSSTEP
+#define SYSCFG_CCCEN           SYSCFG_CCEN
+
+//**********************************************************************************
+// Core MMR Register Map
+//**********************************************************************************
+
+// Cache & SRAM Memory
+#define SRAM_BASE_ADDRESS      0xFFE00000	// SRAM Base Address (Read Only)
+#define DMEM_CONTROL           0xFFE00004	// Data memory control
+#define DCPLB_STATUS           0xFFE00008	// Data Cache Programmable Look-Aside Buffer Status
+#define DCPLB_FAULT_ADDR       0xFFE0000C	// Data Cache Programmable Look-Aside Buffer Fault Address
+#define MMR_TIMEOUT            0xFFE00010	// Memory-Mapped Register Timeout Register
+#define DCPLB_ADDR0            0xFFE00100	// Data Cache Protection Lookaside Buffer 0
+#define DCPLB_ADDR1            0xFFE00104	// Data Cache Protection Lookaside Buffer 1
+#define DCPLB_ADDR2            0xFFE00108	// Data Cache Protection Lookaside Buffer 2
+#define DCPLB_ADDR3            0xFFE0010C	// Data Cache Protection Lookaside Buffer 3
+#define DCPLB_ADDR4            0xFFE00110	// Data Cache Protection Lookaside Buffer 4
+#define DCPLB_ADDR5            0xFFE00114	// Data Cache Protection Lookaside Buffer 5
+#define DCPLB_ADDR6            0xFFE00118	// Data Cache Protection Lookaside Buffer 6
+#define DCPLB_ADDR7            0xFFE0011C	// Data Cache Protection Lookaside Buffer 7
+#define DCPLB_ADDR8            0xFFE00120	// Data Cache Protection Lookaside Buffer 8
+#define DCPLB_ADDR9            0xFFE00124	// Data Cache Protection Lookaside Buffer 9
+#define DCPLB_ADDR10           0xFFE00128	// Data Cache Protection Lookaside Buffer 10
+#define DCPLB_ADDR11           0xFFE0012C	// Data Cache Protection Lookaside Buffer 11
+#define DCPLB_ADDR12           0xFFE00130	// Data Cache Protection Lookaside Buffer 12
+#define DCPLB_ADDR13           0xFFE00134	// Data Cache Protection Lookaside Buffer 13
+#define DCPLB_ADDR14           0xFFE00138	// Data Cache Protection Lookaside Buffer 14
+#define DCPLB_ADDR15           0xFFE0013C	// Data Cache Protection Lookaside Buffer 15
+#define DCPLB_DATA0            0xFFE00200	// Data Cache 0 Status
+#define DCPLB_DATA1            0xFFE00204	// Data Cache 1 Status
+#define DCPLB_DATA2            0xFFE00208	// Data Cache 2 Status
+#define DCPLB_DATA3            0xFFE0020C	// Data Cache 3 Status
+#define DCPLB_DATA4            0xFFE00210	// Data Cache 4 Status
+#define DCPLB_DATA5            0xFFE00214	// Data Cache 5 Status
+#define DCPLB_DATA6            0xFFE00218	// Data Cache 6 Status
+#define DCPLB_DATA7            0xFFE0021C	// Data Cache 7 Status
+#define DCPLB_DATA8            0xFFE00220	// Data Cache 8 Status
+#define DCPLB_DATA9            0xFFE00224	// Data Cache 9 Status
+#define DCPLB_DATA10           0xFFE00228	// Data Cache 10 Status
+#define DCPLB_DATA11           0xFFE0022C	// Data Cache 11 Status
+#define DCPLB_DATA12           0xFFE00230	// Data Cache 12 Status
+#define DCPLB_DATA13           0xFFE00234	// Data Cache 13 Status
+#define DCPLB_DATA14           0xFFE00238	// Data Cache 14 Status
+#define DCPLB_DATA15           0xFFE0023C	// Data Cache 15 Status
+#define DTEST_COMMAND          0xFFE00300	// Data Test Command Register
+#define DTEST_INDEX            0xFFE00304	// Data Test Index Register
+#define DTEST_DATA0            0xFFE00400	// Data Test Data Register
+#define DTEST_DATA1            0xFFE00404	// Data Test Data Register
+#define DTEST_DATA2            0xFFE00408	// Data Test Data Register
+#define DTEST_DATA3            0xFFE0040C	// Data Test Data Register
+#define IMEM_CONTROL           0xFFE01004	// Instruction Memory Control
+#define ICPLB_STATUS           0xFFE01008	// Instruction Cache miss status
+#define ICPLB_FAULT_ADDR       0xFFE0100C	// Instruction Cache miss address
+#define ICPLB_ADDR0            0xFFE01100	// Instruction Cache Protection Lookaside Buffer 0
+#define ICPLB_ADDR1            0xFFE01104	// Instruction Cache Protection Lookaside Buffer 1
+#define ICPLB_ADDR2            0xFFE01108	// Instruction Cache Protection Lookaside Buffer 2
+#define ICPLB_ADDR3            0xFFE0110C	// Instruction Cache Protection Lookaside Buffer 3
+#define ICPLB_ADDR4            0xFFE01110	// Instruction Cache Protection Lookaside Buffer 4
+#define ICPLB_ADDR5            0xFFE01114	// Instruction Cache Protection Lookaside Buffer 5
+#define ICPLB_ADDR6            0xFFE01118	// Instruction Cache Protection Lookaside Buffer 6
+#define ICPLB_ADDR7            0xFFE0111C	// Instruction Cache Protection Lookaside Buffer 7
+#define ICPLB_ADDR8            0xFFE01120	// Instruction Cache Protection Lookaside Buffer 8
+#define ICPLB_ADDR9            0xFFE01124	// Instruction Cache Protection Lookaside Buffer 9
+#define ICPLB_ADDR10           0xFFE01128	// Instruction Cache Protection Lookaside Buffer 10
+#define ICPLB_ADDR11           0xFFE0112C	// Instruction Cache Protection Lookaside Buffer 11
+#define ICPLB_ADDR12           0xFFE01130	// Instruction Cache Protection Lookaside Buffer 12
+#define ICPLB_ADDR13           0xFFE01134	// Instruction Cache Protection Lookaside Buffer 13
+#define ICPLB_ADDR14           0xFFE01138	// Instruction Cache Protection Lookaside Buffer 14
+#define ICPLB_ADDR15           0xFFE0113C	// Instruction Cache Protection Lookaside Buffer 15
+#define ICPLB_DATA0            0xFFE01200	// Instruction Cache 0 Status
+#define ICPLB_DATA1            0xFFE01204	// Instruction Cache 1 Status
+#define ICPLB_DATA2            0xFFE01208	// Instruction Cache 2 Status
+#define ICPLB_DATA3            0xFFE0120C	// Instruction Cache 3 Status
+#define ICPLB_DATA4            0xFFE01210	// Instruction Cache 4 Status
+#define ICPLB_DATA5            0xFFE01214	// Instruction Cache 5 Status
+#define ICPLB_DATA6            0xFFE01218	// Instruction Cache 6 Status
+#define ICPLB_DATA7            0xFFE0121C	// Instruction Cache 7 Status
+#define ICPLB_DATA8            0xFFE01220	// Instruction Cache 8 Status
+#define ICPLB_DATA9            0xFFE01224	// Instruction Cache 9 Status
+#define ICPLB_DATA10           0xFFE01228	// Instruction Cache 10 Status
+#define ICPLB_DATA11           0xFFE0122C	// Instruction Cache 11 Status
+#define ICPLB_DATA12           0xFFE01230	// Instruction Cache 12 Status
+#define ICPLB_DATA13           0xFFE01234	// Instruction Cache 13 Status
+#define ICPLB_DATA14           0xFFE01238	// Instruction Cache 14 Status
+#define ICPLB_DATA15           0xFFE0123C	// Instruction Cache 15 Status
+#define ITEST_COMMAND          0xFFE01300	// Instruction Test Command Register
+#define ITEST_INDEX            0xFFE01304	// Instruction Test Index Register
+#define ITEST_DATA0            0xFFE01400	// Instruction Test Data Register
+#define ITEST_DATA1            0xFFE01404	// Instruction Test Data Register
+
+// Event/Interrupt Registers
+#define EVT0                   0xFFE02000	// Event Vector 0 ESR Address
+#define EVT1                   0xFFE02004	// Event Vector 1 ESR Address
+#define EVT2                   0xFFE02008	// Event Vector 2 ESR Address
+#define EVT3                   0xFFE0200C	// Event Vector 3 ESR Address
+#define EVT4                   0xFFE02010	// Event Vector 4 ESR Address
+#define EVT5                   0xFFE02014	// Event Vector 5 ESR Address
+#define EVT6                   0xFFE02018	// Event Vector 6 ESR Address
+#define EVT7                   0xFFE0201C	// Event Vector 7 ESR Address
+#define EVT8                   0xFFE02020	// Event Vector 8 ESR Address
+#define EVT9                   0xFFE02024	// Event Vector 9 ESR Address
+#define EVT10                  0xFFE02028	// Event Vector 10 ESR Address
+#define EVT11                  0xFFE0202C	// Event Vector 11 ESR Address
+#define EVT12                  0xFFE02030	// Event Vector 12 ESR Address
+#define EVT13                  0xFFE02034	// Event Vector 13 ESR Address
+#define EVT14                  0xFFE02038	// Event Vector 14 ESR Address
+#define EVT15                  0xFFE0203C	// Event Vector 15 ESR Address
+#define IMASK                  0xFFE02104	// Interrupt Mask Register
+#define IPEND                  0xFFE02108	// Interrupt Pending Register
+#define ILAT                   0xFFE0210C	// Interrupt Latch Register
+
+// Core Timer Registers
+#define TCNTL                  0xFFE03000	// Core Timer Control Register
+#define TPERIOD                0xFFE03004	// Core Timer Period Register
+#define TSCALE                 0xFFE03008	// Core Timer Scale Register
+#define TCOUNT                 0xFFE0300C	// Core Timer Count Register
+
+// Debug/MP/Emulation Registers
+#define DSPID                  0xFFE05000	// DSP Processor ID Register for MP implementations
+#define DBGCTL                 0xFFE05004	// Debug Control Register
+#define DBGSTAT                0xFFE05008	// Debug Status Register
+#define EMUDAT                 0xFFE0500C	// Emulator Data Register
+
+// Trace Buffer Registers
+#define TBUFCTL                0xFFE06000	// Trace Buffer Control Register
+#define TBUFSTAT               0xFFE06004	// Trace Buffer Status Register
+#define TBUF                   0xFFE06100	// Trace Buffer
+
+// Watch Point Control Registers
+#define WPIACTL                0xFFE07000	// Instruction Watch Point Control Register
+#define WPIA0                  0xFFE07040	// Instruction Watch Point Address 0
+#define WPIA1                  0xFFE07044	// Instruction Watch Point Address 1
+#define WPIA2                  0xFFE07048	// Instruction Watch Point Address 2
+#define WPIA3                  0xFFE0704C	// Instruction Watch Point Address 3
+#define WPIA4                  0xFFE07050	// Instruction Watch Point Address 4
+#define WPIA5                  0xFFE07054	// Instruction Watch Point Address 5
+#define WPIACNT0               0xFFE07080	// Instruction Watch Point Counter 0
+#define WPIACNT1               0xFFE07084	// Instruction Watch Point Counter 1
+#define WPIACNT2               0xFFE07088	// Instruction Watch Point Counter 2
+#define WPIACNT3               0xFFE0708C	// Instruction Watch Point Counter 3
+#define WPIACNT4               0xFFE07090	// Instruction Watch Point Counter 4
+#define WPIACNT5               0xFFE07094	// Instruction Watch Point Counter 5
+#define WPDACTL                0xFFE07100	// Data Watch Point Control Register
+#define WPDA0                  0xFFE07140	// Data Watch Point Address 0
+#define WPDA1                  0xFFE07144	// Data Watch Point Address 1
+#define WPDACNT0               0xFFE07180	// Data Watch Point Counter 0
+#define WPDACNT1               0xFFE07184	// Data Watch Point Counter 1
+#define WPSTAT                 0xFFE07200	// Watch Point Status Register
+
+// Performance Monitor Registers
+#define PFCTL                  0xFFE08000	// Performance Monitor Control Register
+#define PFCNTR0                0xFFE08100	// Performance Monitor Counter Register 0
+#define PFCNTR1                0xFFE08104	// Performance Monitor Counter Register 1
+
+//**********************************************************************************
+// Core MMR Register Bits
+//**********************************************************************************
+
+//**************************************************
+//   EVT registers (ILAT, IMASK, and IPEND).
+//**************************************************
+
+// ** Bit Positions
+#define EVT_EMU_P            0x00000000	// Emulator interrupt bit position
+#define EVT_RST_P            0x00000001	// Reset interrupt bit position
+#define EVT_NMI_P            0x00000002	// Non Maskable interrupt bit position
+#define EVT_EVX_P            0x00000003	// Exception bit position
+#define EVT_IRPTEN_P         0x00000004	// Global interrupt enable bit position
+#define EVT_IVHW_P           0x00000005	// Hardware Error interrupt bit position
+#define EVT_IVTMR_P          0x00000006	// Timer interrupt bit position
+#define EVT_IVG7_P           0x00000007	// IVG7 interrupt bit position
+#define EVT_IVG8_P           0x00000008	// IVG8 interrupt bit position
+#define EVT_IVG9_P           0x00000009	// IVG9 interrupt bit position
+#define EVT_IVG10_P          0x0000000a	// IVG10 interrupt bit position
+#define EVT_IVG11_P          0x0000000b	// IVG11 interrupt bit position
+#define EVT_IVG12_P          0x0000000c	// IVG12 interrupt bit position
+#define EVT_IVG13_P          0x0000000d	// IVG13 interrupt bit position
+#define EVT_IVG14_P          0x0000000e	// IVG14 interrupt bit position
+#define EVT_IVG15_P          0x0000000f	// IVG15 interrupt bit position
+
+// ** Masks
+#define EVT_EMU              MK_BMSK_(EVT_EMU_P   )	// Emulator interrupt mask
+#define EVT_RST              MK_BMSK_(EVT_RST_P   )	// Reset interrupt mask
+#define EVT_NMI              MK_BMSK_(EVT_NMI_P   )	// Non Maskable interrupt mask
+#define EVT_EVX              MK_BMSK_(EVT_EVX_P   )	// Exception mask
+#define EVT_IRPTEN           MK_BMSK_(EVT_IRPTEN_P)	// Global interrupt enable mask
+#define EVT_IVHW             MK_BMSK_(EVT_IVHW_P  )	// Hardware Error interrupt mask
+#define EVT_IVTMR            MK_BMSK_(EVT_IVTMR_P )	// Timer interrupt mask
+#define EVT_IVG7             MK_BMSK_(EVT_IVG7_P  )	// IVG7 interrupt mask
+#define EVT_IVG8             MK_BMSK_(EVT_IVG8_P  )	// IVG8 interrupt mask
+#define EVT_IVG9             MK_BMSK_(EVT_IVG9_P  )	// IVG9 interrupt mask
+#define EVT_IVG10            MK_BMSK_(EVT_IVG10_P )	// IVG10 interrupt mask
+#define EVT_IVG11            MK_BMSK_(EVT_IVG11_P )	// IVG11 interrupt mask
+#define EVT_IVG12            MK_BMSK_(EVT_IVG12_P )	// IVG12 interrupt mask
+#define EVT_IVG13            MK_BMSK_(EVT_IVG13_P )	// IVG13 interrupt mask
+#define EVT_IVG14            MK_BMSK_(EVT_IVG14_P )	// IVG14 interrupt mask
+#define EVT_IVG15            MK_BMSK_(EVT_IVG15_P )	// IVG15 interrupt mask
+
+//**************************************************
+//   DMEM_CONTROL register
+//**************************************************
+// ** Bit Positions
+#define ENDM_P						 0x00	// Enable Data Memory L1
+#define DMCTL_ENDM_P				 ENDM_P	// "" (older define)
+#define ENDCPLB_P					 0x01	// Enable DCPLBS
+#define DMCTL_ENDCPLB_P			 ENDCPLB_P	// "" (older define)
+#define DMC0_P						 0x02	// L1 Data Memory Configure bit 0
+#define DMCTL_DMC0_P				 DMC0_P	// "" (older define)
+#define DMC1_P						 0x03	// L1 Data Memory Configure bit 1
+#define DMCTL_DMC1_P				 DMC1_P	// "" (older define)
+
+// ** Masks
+#define ENDM                   MK_BMSK_(DMCTL_ENDM_P)	// Enable Data Memory L1
+
+// Bank A set as SRAM, Bank B set as SRAM
+#define ASRAM_BSRAM            0x00000000
+
+// Enable DCPLB
+#define ENDCPLB                MK_BMSK_(DMCTL_ENDCPLB_P) | \
+                               0
+
+// Bank A set as CACHE, Bank B set as SRAM
+#define ACACHE_BSRAM           0x00000008
+// Bank A set as CACHE, Bank B set as CACHE
+#define ACACHE_BCACHE          0x0000000C
+#define DCBS                   0x00000010	// If HIGHBIT is 1, select L1 data memory B
+					   // If HIGHBIT is 0, select L1 data memory A
+					   // If LOWBIT is 1, select L1 memory bank B
+					   // If LOWBIT is 0, select L1 memory bank A
+
+// IMEM_CONTROL Masks
+#define ENIM                   0x00000001	// Enable L1 Code Memory
+#define ENICPLB                0x00000002	// Enable ICPLB
+#define IMC                    0x00000004	// Configure L1 code memory as cache (0=SRAM)
+
+// TCNTL Masks
+#define TMPWR                  0x00000001	// Timer Low Power Control, 0=low power mode, 1=active state
+#define TMREN                  0x00000002	// Timer enable, 0=disable, 1=enable
+#define TAUTORLD               0x00000004	// Timer auto reload
+#define TINT                   0x00000008	// Timer generated interrupt 0=no interrupt has been generated, 1=interrupt has been generated (sticky)
+
+// TCNTL Bit Positions
+#define TMPWR_P                0x00000000	// Timer Low Power Control, 0=low power mode, 1=active state
+#define TMREN_P                0x00000001	// Timer enable, 0=disable, 1=enable
+#define TAUTORLD_P             0x00000002	// Timer auto reload
+#define TINT_P                 0x00000003	// Timer generated interrupt 0=no interrupt has been generated, 1=interrupt has been generated (sticky)
+
+// DCPLB_DATA and ICPLB_DATA Masks
+#define CPLB_VALID             0x00000001	// 0=invalid entry, 1=valid entry
+#define CPLB_LOCK              0x00000002	// 0=entry may be replaced, 1=entry locked
+#define CPLB_USER_RD           0x00000004	// 0=no read access, 1=read access allowed (user mode)
+#define CPLB_USER_WR           0x00000008	// 0=no write access, 0=write access allowed (user mode)
+	 // only applies to L1 data memory
+#define CPLB_SUPV_WR           0x00000010	// 0=no write access, 0=write access allowed (supervisor mode)
+#define CPLB_L1SRAM            0x00000020	// 0=SRAM mapped in L1, 0=SRAM not mapped to L1
+#define CPLB_DA0ACC            0x00000040	// 0=access allowed from either DAG, 1=access from DAG0 only
+	 // only applies in L1 data memory controller
+#define CPLB_DIRTY             0x00000080	// 1=dirty, 0=clean
+	 // only applies in L1 data memory controller
+#define CPLB_L1_CHBL           0x00001000	// 0=non-cacheable in L1, 1=cacheable in L1
+#define CPLB_WT                0x00004000	// 0=write-back, 1=write-through
+	 // only applies in L1 data memory controller in cache mode
+#define PAGE_SIZE_1KB          0x00000000	// 1 KB page size
+#define PAGE_SIZE_4KB          0x00010000	// 4 KB page size
+#define PAGE_SIZE_1MB          0x00020000	// 1 MB page size
+#define PAGE_SIZE_4MB          0x00030000	// 4 MB page size
+
+// DCPLB_DATA and ICPLB_DATA Bit Positions
+#define CPLB_VALID_P           0x00000000	// 0=invalid entry, 1=valid entry
+#define CPLB_LOCK_P            0x00000001	// 0=entry may be replaced, 1=entry locked
+#define CPLB_USER_RD_P         0x00000002	//
+
+#endif				/* _DEF_BLACKFIN_H */
Index: git/linux-2.6/include/asm-blackfin/mach-bf535/irq.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf535/irq.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,125 @@
+/*
+ * File:         include/asm-blackfin/mach-bf535/irq.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *	Common header file for blackfin family of processors
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _BF535_IRQ_H_
+#define _BF535_IRQ_H_
+
+/*
+ * Interrupt source definitions
+             Event Source    Core Event Name
+Core        Emulation               **
+ Events         (highest priority)  EMU         0
+            Reset                   RST         1
+            NMI                     NMI         2
+            Exception               EVX         3
+            Reserved                --          4
+            Hardware Error          IVHW        5
+            Core Timer              IVTMR       6 *
+            System RTC              IVG7        7
+            Interrupts USB Rx/Tx    IVG7        8
+            ** SPARE **             --          9
+            PCI                     IVG7        10
+            SPORT0 RX/TX            IVG8        11
+            ** SPARE **             --          12
+            SPORT1 RX/TX            IVG8        13
+            ** SPARE **             --          14
+            SPI0 RX/TX              IVG9        15
+            ** SPARE **             --          16
+            SPI1 RX/TX              IVG9        17
+            ** SPARE **             --          18
+            UART0 RX/TX             IVG10       19
+            **SPARE **              --          20
+            UART1 RX/TX             IVG10       21
+            ** SPARE **             --          22
+            Timer0                  IVG11       23
+            Timer1                  IVG11       24
+            Timer2                  IVG11       25
+            ** SPARE **                         26
+            Programmable Flags      **
+                    Interrupt A     IVG12       27 (all 8)
+                    Interrupt B     IVG12       28 (all 8)
+            Memory DMA              --          29
+            Watchdog Timer          IVG13       30
+            Software Interrupt 1    IVG14       31
+            Software Interrupt 2    --
+                 (lowest priority)  IVG15       32 *
+ */
+/* The ABSTRACT IRQ definitions */
+/** the first seven of the following are fixed, the rest you change if you need to **/
+#define	IRQ_EMU			0	// Emulation
+#define	IRQ_RST			1	// reset
+#define	IRQ_NMI			2	// Non Maskable
+#define	IRQ_EVX			3	// Exception
+#define	IRQ_UNUSED		4	//  - unused interrupt
+#define	IRQ_HWERR		5	// Hardware Error
+#define	IRQ_CORETMR		6	// Core timer
+#define	IRQ_RTC			7	// Real Time Clock
+#define	IRQ_USB			8	// Universal Serial Bus
+#define	IRQ_SPARE1		9	//  Spare ?? USB
+#define IRQ_PCI_INTA		9	// PCI INTA
+
+// Exchanged with IRQ_UART1. HuTao Apr18 2003
+#define	IRQ_PCI			10	// Personal Computer Interface ??
+#define	IRQ_SPORT0		11	// Synchronous Serial Port 0
+#define	IRQ_SPARE2		12	//  Spare ?? split SPORT0
+#define IRQ_PCI_INTB		12	// PCI INTB
+
+#define	IRQ_SPORT1		13	// Synchronous Serial Port 1
+#define	IRQ_SPARE3		14	//  Spare ?? split SPORT1
+#define IRQ_PCI_INTC		14
+
+#define	IRQ_SPI0		15	// Serial Peripheral Interface 0
+#define	IRQ_SPARE4		16	//  Spare
+#define IRQ_PCI_INTD		16
+
+#define	IRQ_SPI1		17	// Serial Peripheral Interface 1
+#define	IRQ_SPARE5		18	//  Spare
+#define	IRQ_UART0		19	// UART 0
+#define	IRQ_SPARE6		20	//  Spare
+
+// Changed to make UART driver work. HuTao Apr18 2003
+#define	IRQ_UART1		21	// UART 1
+
+#define	IRQ_SPARE7		22	//  Spare
+#define	IRQ_TMR0		23	// Timer 0
+#define	IRQ_TMR1		24	// Timer 1
+#define	IRQ_TMR2		25	// Timer 2
+#define	IRQ_SPARE8		26	//  Spare
+#define	IRQ_PROG_INTA		27	// Programmable Flags A (8)
+#define	IRQ_PROG_INTB		28	// Programmable Flags B (8)
+#define	IRQ_MEM_DMA		29	// Memory DMA Xfer Comp
+#define	IRQ_WATCH	   	30	// Watch Dog Timer
+#define	IRQ_SW_INT1		31	// Software Int 1
+#define	IRQ_SW_INT2		32	// Software Int 2 (reserved for SYSCALL)
+
+#define SYS_IRQS		33	// Number of interrupt levels the kernel sees.
+
+#endif				/* _BF535_IRQ_H_ */
Index: git/linux-2.6/include/asm-blackfin/mach-bf537/bf537.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf537/bf537.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,275 @@
+
+ /*
+  * File:         include/asm-blackfin/mach-bf537/bf537.h
+  * Based on:
+  * Author:
+  *
+  * Created:
+  * Description:
+  *
+  * Rev:
+  *
+  * Modified:
+  *
+  *
+  * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.
+  * If not, write to the Free Software Foundation,
+  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+  */
+
+#ifndef _BLKFin_H_
+#define _BLKFin_H_
+
+#include <linux/config.h>
+
+#define SUPPORTED_DSPID 2
+
+/* Masks for generic ERROR IRQ demultiplexing used in int-priority-sc.c */
+
+#define SPI_ERR_MASK (TXCOL | RBSY | MODF | TXE)	/* SPI_STAT */
+#define SPORT_ERR_MASK (ROVF | RUVF | TOVF | TUVF)	/* SPORTx_STAT */
+#define PPI_ERR_MASK (0xFFFF & ~FLD)	/* PPI_STATUS */
+#define EMAC_ERR_MASK (PHYINT | MMCINT | RXFSINT | TXFSINT | WAKEDET | RXDMAERR | TXDMAERR | STMDONE)	/* EMAC_SYSTAT */
+#define UART_ERR_MASK_STAT1 (0x4)	/* UARTx_IIR */
+#define UART_ERR_MASK_STAT0 (0x2)	/* UARTx_IIR */
+#define CAN_ERR_MASK  (EWTIF | EWRIF | EPIF | BOIF | WUIF | UIAIF | AAIF | RMLIF | UCEIF | EXTIF | ADIF)	/* CAN_GIF */
+
+#define OFFSET_( x ) ((x) & 0x0000FFFF)	/* define macro for offset */
+
+/*some misc defines*/
+#define IMASK_IVG15		0x8000
+#define IMASK_IVG14		0x4000
+#define IMASK_IVG13		0x2000
+#define IMASK_IVG12		0x1000
+
+#define IMASK_IVG11		0x0800
+#define IMASK_IVG10		0x0400
+#define IMASK_IVG9		0x0200
+#define IMASK_IVG8		0x0100
+
+#define IMASK_IVG7		0x0080
+#define IMASK_IVGTMR	0x0040
+#define IMASK_IVGHW		0x0020
+
+/***************************/
+
+#define BLKFIN_ICACHESIZE	(16*1024)
+
+#if defined(CONFIG_BF537) || defined(CONFIG_BF534)
+#define BLKFIN_DCACHESIZE	(32*1024)
+#define BLKFIN_DSUPBANKS	2
+#else
+#define BLKFIN_DCACHESIZE	(16*1024)
+#define BLKFIN_DSUPBANKS	1
+#endif
+
+#define BLKFIN_DSUBBANKS	4
+#define BLKFIN_DWAYS		2
+#define BLKFIN_DLINES		64
+#define BLKFIN_ISUBBANKS	4
+#define BLKFIN_IWAYS		4
+#define BLKFIN_ILINES		32
+
+#define WAY0_L			0x1
+#define WAY1_L			0x2
+#define WAY01_L			0x3
+#define WAY2_L			0x4
+#define WAY02_L			0x5
+#define	WAY12_L			0x6
+#define	WAY012_L		0x7
+
+#define	WAY3_L			0x8
+#define	WAY03_L			0x9
+#define	WAY13_L			0xA
+#define	WAY013_L		0xB
+
+#define	WAY32_L			0xC
+#define	WAY320_L		0xD
+#define	WAY321_L		0xE
+#define	WAYALL_L		0xF
+
+#define DMC_ENABLE (2<<2)	/*yes, 2, not 1 */
+
+#define ZERO		0x0
+
+/********************************* EBIU Settings ************************************/
+#define AMBCTL0VAL	((CONFIG_BANK_1 << 16) | CONFIG_BANK_0)
+#define AMBCTL1VAL	((CONFIG_BANK_3 << 16) | CONFIG_BANK_2)
+
+#ifdef CONFIG_C_AMBEN_ALL
+#define V_AMBEN AMBEN_ALL
+#endif
+#ifdef CONFIG_C_AMBEN
+#define V_AMBEN 0x0
+#endif
+#ifdef CONFIG_C_AMBEN_B0
+#define V_AMBEN AMBEN_B0
+#endif
+#ifdef CONFIG_C_AMBEN_B0_B1
+#define V_AMBEN AMBEN_B0_B1
+#endif
+#ifdef CONFIG_C_AMBEN_B0_B1_B2
+#define V_AMBEN AMBEN_B0_B1_B2
+#endif
+#ifdef CONFIG_C_AMCKEN
+#define V_AMCKEN AMCKEN
+#else
+#define V_AMCKEN 0x0
+#endif
+#ifdef CONFIG_C_CDPRIO
+#define V_CDPRIO 0x100
+#else
+#define V_CDPRIO 0x0
+#endif
+
+#define AMGCTLVAL	(V_AMBEN | V_AMCKEN | V_CDPRIO)
+
+/********************************PLL Settings **************************************/
+#ifdef CONFIG_BFIN_KERNEL_CLOCK
+#if (CONFIG_VCO_MULT < 0)
+#error "VCO Multiplier is less than 0. Please select a different value"
+#endif
+
+#if (CONFIG_VCO_MULT == 0)
+#error "VCO Multiplier should be greater than 0. Please select a different value"
+#endif
+
+#if(CONFIG_VCO_MULT > 64)
+#error "VCO Multiplier is more than 64. Please select a different value"
+#endif
+
+#if(CONFIG_CLKIN_HALF == 0)
+#define CONFIG_VCO_HZ	(CONFIG_CLKIN_HZ * CONFIG_VCO_MULT)
+#else
+#define CONFIG_VCO_HZ	((CONFIG_CLKIN_HZ * CONFIG_VCO_MULT)/2)
+#endif
+
+#if(CONFIG_PLL_BYPASS == 0)
+#define CONFIG_CCLK_HZ	(CONFIG_VCO_HZ/CONFIG_CCLK_DIV)
+#define CONFIG_SCLK_HZ	(CONFIG_VCO_HZ/CONFIG_SCLK_DIV)
+#else
+#define CONFIG_CCLK_HZ	CONFIG_CLKIN_HZ
+#define CONFIG_SCLK_HZ	CONFIG_CLKIN_HZ
+#endif
+
+#if (CONFIG_SCLK_DIV < 1)
+#error "SCLK DIV cannot be less than 1 or more than 15. Please select a proper value"
+#endif
+
+#if (CONFIG_SCLK_DIV > 15)
+#error "SCLK DIV cannot be less than 1 or more than 15. Please select a proper value"
+#endif
+
+#if (CONFIG_CCLK_DIV != 1)
+#if (CONFIG_CCLK_DIV != 2)
+#if (CONFIG_CCLK_DIV != 4)
+#if (CONFIG_CCLK_DIV != 8)
+#error "CCLK DIV can be 1,2,4 or 8 only.Please select a proper value"
+#endif
+#endif
+#endif
+#endif
+
+#define MAX_VC	650000000
+
+#if(CONFIG_VCO_HZ > MAX_VC)
+#error "VCO selected is more than maximum value. Please change the VCO multipler"
+#endif
+
+#if (CONFIG_SCLK_HZ > 133000000)
+#error "Sclk value selected is more than maximum.Please select a proper value for SCLK multiplier"
+#endif
+
+#if (CONFIG_SCLK_HZ < 27000000)
+#error "Sclk value selected is less than minimum.Please select a proper value for SCLK multiplier"
+#endif
+
+#if (CONFIG_SCLK_HZ >= CONFIG_CCLK_HZ)
+#if(CONFIG_SCLK_HZ != CONFIG_CLKIN_HZ)
+#if(CONFIG_CCLK_HZ != CONFIG_CLKIN_HZ)
+#error "Please select sclk less than cclk"
+#endif
+#endif
+#endif
+
+#if (CONFIG_CCLK_DIV == 1)
+#define CONFIG_CCLK_ACT_DIV   CCLK_DIV1
+#endif
+#if (CONFIG_CCLK_DIV == 2)
+#define CONFIG_CCLK_ACT_DIV   CCLK_DIV2
+#endif
+#if (CONFIG_CCLK_DIV == 4)
+#define CONFIG_CCLK_ACT_DIV   CCLK_DIV4
+#endif
+#if (CONFIG_CCLK_DIV == 8)
+#define CONFIG_CCLK_ACT_DIV   CCLK_DIV8
+#endif
+#ifndef CONFIG_CCLK_ACT_DIV
+#define CONFIG_CCLK_ACT_DIV   CONFIG_CCLK_DIV_not_defined_properly
+#endif
+
+#endif /* CONFIG_BFIN_KERNEL_CLOCK */
+
+#ifdef CONFIG_BF537
+#define CPU "BF537"
+#endif
+#ifdef CONFIG_BF536
+#define CPU "BF536"
+#endif
+#ifdef CONFIG_BF534
+#define CPU "BF534"
+#endif
+#ifndef CPU
+#define	CPU "UNKOWN"
+#endif
+
+#if (CONFIG_MEM_SIZE % 4)
+#error "SDRAM mem size must be multible of 4MB"
+#endif
+
+#define SDRAM_IGENERIC    (CPLB_L1_CHBL | CPLB_USER_RD | CPLB_VALID | CPLB_PORTPRIO)
+#define SDRAM_IKERNEL     (SDRAM_IGENERIC | CPLB_LOCK)
+#define L1_IMEMORY        (               CPLB_USER_RD | CPLB_VALID | CPLB_LOCK)
+#define SDRAM_INON_CHBL   (               CPLB_USER_RD | CPLB_VALID)
+
+/*Use the menuconfig cache policy here - CONFIG_BLKFIN_WT/CONFIG_BLKFIN_WB*/
+
+#define ANOMALY_05000158		0x200
+#ifdef CONFIG_BLKFIN_WB		/*Write Back Policy */
+#define SDRAM_DGENERIC   (CPLB_L1_CHBL | CPLB_DIRTY \
+			| CPLB_SUPV_WR | CPLB_USER_WR | CPLB_USER_RD | CPLB_VALID | ANOMALY_05000158)
+#else				/*Write Through */
+#define SDRAM_DGENERIC   (CPLB_L1_CHBL | CPLB_WT | CPLB_L1_AOW \
+			| CPLB_SUPV_WR | CPLB_USER_WR | CPLB_USER_RD | CPLB_VALID | ANOMALY_05000158)
+#endif
+#define SDRAM_DKERNEL    (SDRAM_DGENERIC | CPLB_LOCK)
+
+#define L1_DMEMORY       (CPLB_SUPV_WR | CPLB_USER_WR | CPLB_USER_RD | CPLB_VALID | ANOMALY_05000158)
+#define SDRAM_DNON_CHBL  (CPLB_SUPV_WR | CPLB_USER_WR | CPLB_USER_RD | CPLB_VALID | ANOMALY_05000158)
+#define SDRAM_EBIU       (CPLB_SUPV_WR | CPLB_USER_WR | CPLB_USER_RD | CPLB_VALID | ANOMALY_05000158)
+#define SDRAM_OOPS  	 (CPLB_VALID | ANOMALY_05000158 | CPLB_LOCK)
+
+#define SIZE_1K 0x00000400	/* 1K */
+#define SIZE_4K 0x00001000	/* 4K */
+#define SIZE_1M 0x00100000	/* 1M */
+#define SIZE_4M 0x00400000	/* 4M */
+
+#define BFIN_NAND_BASE	0x20202000
+#define BFIN_NAND_CLE           (1<<2)                  /* A2 -> Command Enable */
+#define BFIN_NAND_ALE           (1<<1)                  /* A1 -> Address Enable */
+#define BFIN_NAND_READY		PF3
+
+#endif				/* _BLKFin_H_  */
Index: git/linux-2.6/include/asm-blackfin/mach-bf537/blackfin.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf537/blackfin.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,197 @@
+
+/*
+ * File:         include/asm-blackfin/mach-bf537/blackfin.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MACH_BLACKFIN_H_
+#define _MACH_BLACKFIN_H_
+
+#include "bf537.h"
+#include "mem_map.h"
+#include "defBF534.h"
+
+#ifdef CONFIG_BF537
+#include "defBF537.h"
+#endif
+
+#if !(defined(__ASSEMBLY__) || defined(ASSEMBLY))
+#include "cdefBF534.h"
+
+/* UART 0*/
+#define pUART_THR pUART0_THR
+#define pUART_RBR pUART0_RBR
+#define pUART_DLL pUART0_DLL
+#define pUART_IER pUART0_IER
+#define pUART_DLH pUART0_DLH
+#define pUART_IIR pUART0_IIR
+#define pUART_LCR pUART0_LCR
+#define pUART_MCR pUART0_MCR
+#define pUART_LSR pUART0_LSR
+#define pUART_SCR  pUART0_SCR
+#define pUART_GCTL pUART0_GCTL
+
+#ifdef CONFIG_BF537
+#include "cdefBF537.h"
+#endif
+#endif
+
+/* MAP used DEFINES from BF533 to BF537 - so we don't need to change them in the driver, kernel, etc. */
+
+/* UART_IIR Register */
+#define STATUS(x)	((x << 1) & 0x06)
+#define STATUS_P1	0x02
+#define STATUS_P0	0x01
+
+/* UART 0*/
+
+/* DMA Channnel */
+#define CH_UART_RX CH_UART0_RX
+#define CH_UART_TX CH_UART0_TX
+
+/* System Interrupt Controller */
+#define IRQ_UART_RX IRQ_UART0_RX
+#define	IRQ_UART_TX IRQ_UART0_TX
+#define	IRQ_UART_ERROR IRQ_UART0_ERROR
+
+/* MMR Registers*/
+#define UART_THR UART0_THR
+#define UART_RBR UART0_RBR
+#define UART_DLL UART0_DLL
+#define UART_IER UART0_IER
+#define UART_DLH UART0_DLH
+#define UART_IIR UART0_IIR
+#define UART_LCR UART0_LCR
+#define UART_MCR UART0_MCR
+#define UART_LSR UART0_LSR
+#define UART_SCR  UART0_SCR
+#define UART_GCTL UART0_GCTL
+
+/* DPMC*/
+#define STOPCK_OFF STOPCK
+
+/* FIO USE PORT F*/
+#ifdef CONFIG_BF537_PORT_F
+#define pPORT_FER		pPORTF_FER
+#define pFIO_FLAG_D		pPORTFIO
+#define pFIO_FLAG_C		pPORTFIO_CLEAR
+#define pFIO_FLAG_S		pPORTFIO_SET
+#define pFIO_FLAG_T		pPORTFIO_TOGGLE
+#define pFIO_MASKA_D	pPORTFIO_MASKA
+#define pFIO_MASKA_C	pPORTFIO_MASKA_CLEAR
+#define pFIO_MASKA_S	pPORTFIO_MASKA_SET
+#define pFIO_MASKA_T	pPORTFIO_MASKA_TOGGLE
+#define pFIO_MASKB_D	pPORTFIO_MASKB
+#define pFIO_MASKB_C	pPORTFIO_MASKB_CLEAR
+#define pFIO_MASKB_S	pPORTFIO_MASKB_SET
+#define pFIO_MASKB_T	pPORTFIO_MASKB_TOGGLE
+#define pFIO_DIR		pPORTFIO_DIR
+#define pFIO_POLAR		pPORTFIO_POLAR
+#define pFIO_EDGE		pPORTFIO_EDGE
+#define pFIO_BOTH		pPORTFIO_BOTH
+#define pFIO_INEN		pPORTFIO_INEN
+
+#define FIO_FLAG_D		PORTFIO
+#define FIO_FLAG_C		PORTFIO_CLEAR
+#define FIO_FLAG_S		PORTFIO_SET
+#define FIO_FLAG_T		PORTFIO_TOGGLE
+#define FIO_MASKA_D	    PORTFIO_MASKA
+#define FIO_MASKA_C     PORTFIO_MASKA_CLEAR
+#define FIO_MASKA_S     PORTFIO_MASKA_SET
+#define FIO_MASKA_T     PORTFIO_MASKA_TOGGLE
+#define FIO_MASKB_D     PORTFIO_MASKB
+#define FIO_MASKB_C     PORTFIO_MASKB_CLEAR
+#define FIO_MASKB_S     PORTFIO_MASKB_SET
+#define FIO_MASKB_T     PORTFIO_MASKB_TOGGLE
+#define FIO_DIR		    PORTFIO_DIR
+#define FIO_POLAR		PORTFIO_POLAR
+#define FIO_EDGE		PORTFIO_EDGE
+#define FIO_BOTH		PORTFIO_BOTH
+#define FIO_INEN		PORTFIO_INEN
+#endif
+
+/* FIO USE PORT G*/
+#ifdef CONFIG_BF537_PORT_G
+#define pPORT_FER		pPORTG_FER
+#define pFIO_FLAG_D		pPORTGIO
+#define pFIO_FLAG_C		pPORTGIO_CLEAR
+#define pFIO_FLAG_S		pPORTGIO_SET
+#define pFIO_FLAG_T		pPORTGIO_TOGGLE
+#define pFIO_MASKA_D	pPORTGIO_MASKA
+#define pFIO_MASKA_C	pPORTGIO_MASKA_CLEAR
+#define pFIO_MASKA_S	pPORTGIO_MASKA_SET
+#define pFIO_MASKA_T	pPORTGIO_MASKA_TOGGLE
+#define pFIO_MASKB_D	pPORTGIO_MASKB
+#define pFIO_MASKB_C	pPORTGIO_MASKB_CLEAR
+#define pFIO_MASKB_S	pPORTGIO_MASKB_SET
+#define pFIO_MASKB_T	pPORTGIO_MASKB_TOGGLE
+#define pFIO_DIR		pPORTGIO_DIR
+#define pFIO_POLAR		pPORTGIO_POLAR
+#define pFIO_EDGE		pPORTGIO_EDGE
+#define pFIO_BOTH		pPORTGIO_BOTH
+#define pFIO_INEN		pPORTGIO_INEN
+
+#define FIO_FLAG_D		PORTGIO
+#define FIO_FLAG_C		PORTGIO_CLEAR
+#define FIO_FLAG_S		PORTGIO_SET
+#define FIO_FLAG_T		PORTGIO_TOGGLE
+#define FIO_MASKA_D	    PORTGIO_MASKA
+#define FIO_MASKA_C	    PORTGIO_MASKA_CLEAR
+#define FIO_MASKA_S	    PORTGIO_MASKA_SET
+#define FIO_MASKA_T	    PORTGIO_MASKA_TOGGLE
+#define FIO_MASKB_D	    PORTGIO_MASKB
+#define FIO_MASKB_C	    PORTGIO_MASKB_CLEAR
+#define FIO_MASKB_S	    PORTGIO_MASKB_SET
+#define FIO_MASKB_T	    PORTGIO_MASKB_TOGGLE
+#define FIO_DIR		    PORTGIO_DIR
+#define FIO_POLAR		PORTGIO_POLAR
+#define FIO_EDGE		PORTGIO_EDGE
+#define FIO_BOTH		PORTGIO_BOTH
+#define FIO_INEN		PORTGIO_INEN
+
+#endif
+
+/* RTC_ICTL and RTC_ISTAT Masks															    */
+#define	SWEF  STOPWATCH		/* Stopwatch Interrupt Enable                                                                 */
+#define	AEF	  ALARM		/* Alarm Interrupt Enable                                                                             */
+#define	SEF	  SECOND	/* Seconds (1 Hz) Interrupt Enable                                                    */
+#define	MEF	  MINUTE	/* Minutes Interrupt Enable                                                                   */
+#define	HEF	  HOUR		/* Hours Interrupt Enable                                                                             */
+#define	DEF	  DAY		/* 24 Hours (Days) Interrupt Enable                                                   */
+#define	DAEF  DAY_ALARM		/* Day Alarm (Day, Hour, Minute, Second) Interrupt Enable             */
+#define	WPS	  WRITE_PENDING	/* Write Pending Status                                                                               */
+#define	WCOM  WRITE_COMPLETE	/* Write Complete Interrupt Enable                                                        */
+
+/* PLL_DIV Masks													*/
+#define CCLK_DIV1 CSEL_DIV1	/*          CCLK = VCO / 1                                  */
+#define CCLK_DIV2 CSEL_DIV2	/*          CCLK = VCO / 2                                  */
+#define CCLK_DIV4 CSEL_DIV4	/*          CCLK = VCO / 4                                  */
+#define CCLK_DIV8 CSEL_DIV8	/*          CCLK = VCO / 8                                  */
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/mach-bf537/cdefBF534.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf537/cdefBF534.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,976 @@
+/*
+ * file:         include/asm-blackfin/mach-bf537/cdefbf534.h
+ * based on:
+ * author:
+ *
+ * created:
+ * description:
+ *	system mmr register map
+ * rev:
+ *
+ * modified:
+ *
+ *
+ * bugs:         enter bugs at http://blackfin.uclinux.org/
+ *
+ * this program is free software; you can redistribute it and/or modify
+ * it under the terms of the gnu general public license as published by
+ * the free software foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * this program is distributed in the hope that it will be useful,
+ * but without any warranty; without even the implied warranty of
+ * merchantability or fitness for a particular purpose.  see the
+ * gnu general public license for more details.
+ *
+ * you should have received a copy of the gnu general public license
+ * along with this program; see the file copying.
+ * if not, write to the free software foundation,
+ * 59 temple place - suite 330, boston, ma 02111-1307, usa.
+ */
+
+#ifndef _CDEF_BF534_H
+#define _CDEF_BF534_H
+
+/* Include all Core registers and bit definitions 									*/
+#include "defBF534.h"
+
+/* Include core specific register pointer definitions 								*/
+#include <asm/mach-common/cdef_LPBlackfin.h>
+
+/* Clock and System Control	(0xFFC00000 - 0xFFC000FF)								*/
+#define pPLL_CTL 			((volatile unsigned short *)PLL_CTL)
+#define pPLL_DIV 			((volatile unsigned short *)PLL_DIV)
+#define pVR_CTL 			((volatile unsigned short *)VR_CTL)
+#define pPLL_STAT 			((volatile unsigned short *)PLL_STAT)
+#define pPLL_LOCKCNT 		((volatile unsigned short *)PLL_LOCKCNT)
+
+/* System Interrupt Controller (0xFFC00100 - 0xFFC001FF)							*/
+#define pSWRST 				((volatile unsigned short *)SWRST)
+#define pSYSCR 				((volatile unsigned short *)SYSCR)
+#define	pSIC_RVECT			((void * volatile *)SIC_RVECT)
+#define pSIC_IMASK 			((volatile unsigned long  *)SIC_IMASK)
+#define pSIC_IAR0 			((volatile unsigned long  *)SIC_IAR0)
+#define pSIC_IAR1 			((volatile unsigned long  *)SIC_IAR1)
+#define pSIC_IAR2 			((volatile unsigned long  *)SIC_IAR2)
+#define pSIC_IAR3 			((volatile unsigned long  *)SIC_IAR3)
+#define pSIC_ISR 			((volatile unsigned long  *)SIC_ISR)
+#define pSIC_IWR 			((volatile unsigned long  *)SIC_IWR)
+
+/* Watchdog Timer		(0xFFC00200 - 0xFFC002FF)									*/
+#define pWDOG_CTL 			((volatile unsigned short *)WDOG_CTL)
+#define pWDOG_CNT 			((volatile unsigned long  *)WDOG_CNT)
+#define pWDOG_STAT 			((volatile unsigned long  *)WDOG_STAT)
+
+/* Real Time Clock		(0xFFC00300 - 0xFFC003FF)									*/
+#define pRTC_STAT 			((volatile unsigned long  *)RTC_STAT)
+#define pRTC_ICTL 			((volatile unsigned short *)RTC_ICTL)
+#define pRTC_ISTAT 			((volatile unsigned short *)RTC_ISTAT)
+#define pRTC_SWCNT 			((volatile unsigned short *)RTC_SWCNT)
+#define pRTC_ALARM 			((volatile unsigned long  *)RTC_ALARM)
+#define pRTC_FAST 			((volatile unsigned short *)RTC_FAST)
+#define pRTC_PREN 			((volatile unsigned short *)RTC_PREN)
+
+/* UART0 Controller		(0xFFC00400 - 0xFFC004FF)									*/
+#define pUART0_THR 			((volatile unsigned short *)UART0_THR)
+#define pUART0_RBR 			((volatile unsigned short *)UART0_RBR)
+#define pUART0_DLL 			((volatile unsigned short *)UART0_DLL)
+#define pUART0_IER 			((volatile unsigned short *)UART0_IER)
+#define pUART0_DLH 			((volatile unsigned short *)UART0_DLH)
+#define pUART0_IIR 			((volatile unsigned short *)UART0_IIR)
+#define pUART0_LCR 			((volatile unsigned short *)UART0_LCR)
+#define pUART0_MCR 			((volatile unsigned short *)UART0_MCR)
+#define pUART0_LSR 			((volatile unsigned short *)UART0_LSR)
+#define pUART0_MSR			((volatile unsigned short *)UART0_LSR)
+#define pUART0_SCR 			((volatile unsigned short *)UART0_SCR)
+#define pUART0_GCTL 		((volatile unsigned short *)UART0_GCTL)
+
+/* SPI Controller		(0xFFC00500 - 0xFFC005FF)									*/
+#define pSPI_CTL 			((volatile unsigned short *)SPI_CTL)
+#define pSPI_FLG 			((volatile unsigned short *)SPI_FLG)
+#define pSPI_STAT 			((volatile unsigned short *)SPI_STAT)
+#define pSPI_TDBR 			((volatile unsigned short *)SPI_TDBR)
+#define pSPI_RDBR 			((volatile unsigned short *)SPI_RDBR)
+#define pSPI_BAUD 			((volatile unsigned short *)SPI_BAUD)
+#define pSPI_SHADOW 		((volatile unsigned short *)SPI_SHADOW)
+
+/* TIMER0-7 Registers		(0xFFC00600 - 0xFFC006FF)								*/
+#define pTIMER0_CONFIG 		((volatile unsigned short *)TIMER0_CONFIG)
+#define pTIMER0_COUNTER 	((volatile unsigned long  *)TIMER0_COUNTER)
+#define pTIMER0_PERIOD 		((volatile unsigned long  *)TIMER0_PERIOD)
+#define pTIMER0_WIDTH 		((volatile unsigned long  *)TIMER0_WIDTH)
+
+#define pTIMER1_CONFIG 		((volatile unsigned short *)TIMER1_CONFIG)
+#define pTIMER1_COUNTER 	((volatile unsigned long  *)TIMER1_COUNTER)
+#define pTIMER1_PERIOD 		((volatile unsigned long  *)TIMER1_PERIOD)
+#define pTIMER1_WIDTH 		((volatile unsigned long  *)TIMER1_WIDTH)
+
+#define pTIMER2_CONFIG 		((volatile unsigned short *)TIMER2_CONFIG)
+#define pTIMER2_COUNTER 	((volatile unsigned long  *)TIMER2_COUNTER)
+#define pTIMER2_PERIOD 		((volatile unsigned long  *)TIMER2_PERIOD)
+#define pTIMER2_WIDTH 		((volatile unsigned long  *)TIMER2_WIDTH)
+
+#define pTIMER3_CONFIG 		((volatile unsigned short *)TIMER3_CONFIG)
+#define pTIMER3_COUNTER 	((volatile unsigned long  *)TIMER3_COUNTER)
+#define pTIMER3_PERIOD 		((volatile unsigned long  *)TIMER3_PERIOD)
+#define pTIMER3_WIDTH 		((volatile unsigned long  *)TIMER3_WIDTH)
+
+#define pTIMER4_CONFIG 		((volatile unsigned short *)TIMER4_CONFIG)
+#define pTIMER4_COUNTER 	((volatile unsigned long  *)TIMER4_COUNTER)
+#define pTIMER4_PERIOD 		((volatile unsigned long  *)TIMER4_PERIOD)
+#define pTIMER4_WIDTH 		((volatile unsigned long  *)TIMER4_WIDTH)
+
+#define pTIMER5_CONFIG 		((volatile unsigned short *)TIMER5_CONFIG)
+#define pTIMER5_COUNTER 	((volatile unsigned long  *)TIMER5_COUNTER)
+#define pTIMER5_PERIOD 		((volatile unsigned long  *)TIMER5_PERIOD)
+#define pTIMER5_WIDTH 		((volatile unsigned long  *)TIMER5_WIDTH)
+
+#define pTIMER6_CONFIG 		((volatile unsigned short *)TIMER6_CONFIG)
+#define pTIMER6_COUNTER 	((volatile unsigned long  *)TIMER6_COUNTER)
+#define pTIMER6_PERIOD 		((volatile unsigned long  *)TIMER6_PERIOD)
+#define pTIMER6_WIDTH 		((volatile unsigned long  *)TIMER6_WIDTH)
+
+#define pTIMER7_CONFIG 		((volatile unsigned short *)TIMER7_CONFIG)
+#define pTIMER7_COUNTER 	((volatile unsigned long  *)TIMER7_COUNTER)
+#define pTIMER7_PERIOD 		((volatile unsigned long  *)TIMER7_PERIOD)
+#define pTIMER7_WIDTH 		((volatile unsigned long  *)TIMER7_WIDTH)
+
+#define pTIMER_ENABLE 		((volatile unsigned short *)TIMER_ENABLE)
+#define pTIMER_DISABLE 		((volatile unsigned short *)TIMER_DISABLE)
+#define pTIMER_STATUS		((volatile unsigned long  *)TIMER_STATUS)
+
+/* General Purpose I/O Port F (0xFFC00700 - 0xFFC007FF)								*/
+#define pPORTFIO	 			((volatile unsigned short *)PORTFIO)
+#define pPORTFIO_CLEAR	 		((volatile unsigned short *)PORTFIO_CLEAR)
+#define pPORTFIO_SET	 		((volatile unsigned short *)PORTFIO_SET)
+#define pPORTFIO_TOGGLE 		((volatile unsigned short *)PORTFIO_TOGGLE)
+#define pPORTFIO_MASKA 			((volatile unsigned short *)PORTFIO_MASKA)
+#define pPORTFIO_MASKA_CLEAR 	((volatile unsigned short *)PORTFIO_MASKA_CLEAR)
+#define pPORTFIO_MASKA_SET 		((volatile unsigned short *)PORTFIO_MASKA_SET)
+#define pPORTFIO_MASKA_TOGGLE 	((volatile unsigned short *)PORTFIO_MASKA_TOGGLE)
+#define pPORTFIO_MASKB	 		((volatile unsigned short *)PORTFIO_MASKB)
+#define pPORTFIO_MASKB_CLEAR 	((volatile unsigned short *)PORTFIO_MASKB_CLEAR)
+#define pPORTFIO_MASKB_SET 		((volatile unsigned short *)PORTFIO_MASKB_SET)
+#define pPORTFIO_MASKB_TOGGLE 	((volatile unsigned short *)PORTFIO_MASKB_TOGGLE)
+#define pPORTFIO_DIR 			((volatile unsigned short *)PORTFIO_DIR)
+#define pPORTFIO_POLAR 			((volatile unsigned short *)PORTFIO_POLAR)
+#define pPORTFIO_EDGE 			((volatile unsigned short *)PORTFIO_EDGE)
+#define pPORTFIO_BOTH 			((volatile unsigned short *)PORTFIO_BOTH)
+#define pPORTFIO_INEN 			((volatile unsigned short *)PORTFIO_INEN)
+
+/* SPORT0 Controller		(0xFFC00800 - 0xFFC008FF)								*/
+#define pSPORT0_TCR1 		((volatile unsigned short *)SPORT0_TCR1)
+#define pSPORT0_TCR2 		((volatile unsigned short *)SPORT0_TCR2)
+#define pSPORT0_TCLKDIV 	((volatile unsigned short *)SPORT0_TCLKDIV)
+#define pSPORT0_TFSDIV 		((volatile unsigned short *)SPORT0_TFSDIV)
+#define pSPORT0_TX 			((volatile unsigned long  *)SPORT0_TX)
+#define pSPORT0_RX 			((volatile unsigned long  *)SPORT0_RX)
+#define pSPORT0_TX32 		((volatile unsigned long  *)SPORT0_TX)
+#define pSPORT0_RX32 		((volatile unsigned long  *)SPORT0_RX)
+#define pSPORT0_TX16 		((volatile unsigned short *)SPORT0_TX)
+#define pSPORT0_RX16 		((volatile unsigned short *)SPORT0_RX)
+#define pSPORT0_RCR1 		((volatile unsigned short *)SPORT0_RCR1)
+#define pSPORT0_RCR2 		((volatile unsigned short *)SPORT0_RCR2)
+#define pSPORT0_RCLKDIV 	((volatile unsigned short *)SPORT0_RCLKDIV)
+#define pSPORT0_RFSDIV 		((volatile unsigned short *)SPORT0_RFSDIV)
+#define pSPORT0_STAT 		((volatile unsigned short *)SPORT0_STAT)
+#define pSPORT0_CHNL 		((volatile unsigned short *)SPORT0_CHNL)
+#define pSPORT0_MCMC1 		((volatile unsigned short *)SPORT0_MCMC1)
+#define pSPORT0_MCMC2 		((volatile unsigned short *)SPORT0_MCMC2)
+#define pSPORT0_MTCS0 		((volatile unsigned long  *)SPORT0_MTCS0)
+#define pSPORT0_MTCS1 		((volatile unsigned long  *)SPORT0_MTCS1)
+#define pSPORT0_MTCS2 		((volatile unsigned long  *)SPORT0_MTCS2)
+#define pSPORT0_MTCS3 		((volatile unsigned long  *)SPORT0_MTCS3)
+#define pSPORT0_MRCS0 		((volatile unsigned long  *)SPORT0_MRCS0)
+#define pSPORT0_MRCS1 		((volatile unsigned long  *)SPORT0_MRCS1)
+#define pSPORT0_MRCS2 		((volatile unsigned long  *)SPORT0_MRCS2)
+#define pSPORT0_MRCS3 		((volatile unsigned long  *)SPORT0_MRCS3)
+
+/* SPORT1 Controller		(0xFFC00900 - 0xFFC009FF)								*/
+#define pSPORT1_TCR1 		((volatile unsigned short *)SPORT1_TCR1)
+#define pSPORT1_TCR2 		((volatile unsigned short *)SPORT1_TCR2)
+#define pSPORT1_TCLKDIV 	((volatile unsigned short *)SPORT1_TCLKDIV)
+#define pSPORT1_TFSDIV 		((volatile unsigned short *)SPORT1_TFSDIV)
+#define pSPORT1_TX 			((volatile unsigned long  *)SPORT1_TX)
+#define pSPORT1_RX 			((volatile unsigned long  *)SPORT1_RX)
+#define pSPORT1_TX32 		((volatile unsigned long  *)SPORT1_TX)
+#define pSPORT1_RX32 		((volatile unsigned long  *)SPORT1_RX)
+#define pSPORT1_TX16 		((volatile unsigned short *)SPORT1_TX)
+#define pSPORT1_RX16 		((volatile unsigned short *)SPORT1_RX)
+#define pSPORT1_RCR1 		((volatile unsigned short *)SPORT1_RCR1)
+#define pSPORT1_RCR2 		((volatile unsigned short *)SPORT1_RCR2)
+#define pSPORT1_RCLKDIV 	((volatile unsigned short *)SPORT1_RCLKDIV)
+#define pSPORT1_RFSDIV 		((volatile unsigned short *)SPORT1_RFSDIV)
+#define pSPORT1_STAT 		((volatile unsigned short *)SPORT1_STAT)
+#define pSPORT1_CHNL 		((volatile unsigned short *)SPORT1_CHNL)
+#define pSPORT1_MCMC1 		((volatile unsigned short *)SPORT1_MCMC1)
+#define pSPORT1_MCMC2 		((volatile unsigned short *)SPORT1_MCMC2)
+#define pSPORT1_MTCS0 		((volatile unsigned long  *)SPORT1_MTCS0)
+#define pSPORT1_MTCS1 		((volatile unsigned long  *)SPORT1_MTCS1)
+#define pSPORT1_MTCS2 		((volatile unsigned long  *)SPORT1_MTCS2)
+#define pSPORT1_MTCS3 		((volatile unsigned long  *)SPORT1_MTCS3)
+#define pSPORT1_MRCS0 		((volatile unsigned long  *)SPORT1_MRCS0)
+#define pSPORT1_MRCS1 		((volatile unsigned long  *)SPORT1_MRCS1)
+#define pSPORT1_MRCS2 		((volatile unsigned long  *)SPORT1_MRCS2)
+#define pSPORT1_MRCS3 		((volatile unsigned long  *)SPORT1_MRCS3)
+
+/* External Bus Interface Unit (0xFFC00A00 - 0xFFC00AFF)							*/
+#define pEBIU_AMGCTL 		((volatile unsigned short *)EBIU_AMGCTL)
+#define pEBIU_AMBCTL0 		((volatile unsigned long  *)EBIU_AMBCTL0)
+#define pEBIU_AMBCTL1 		((volatile unsigned long  *)EBIU_AMBCTL1)
+#define pEBIU_SDGCTL 		((volatile unsigned long  *)EBIU_SDGCTL)
+#define pEBIU_SDBCTL 		((volatile unsigned short *)EBIU_SDBCTL)
+#define pEBIU_SDRRC 		((volatile unsigned short *)EBIU_SDRRC)
+#define pEBIU_SDSTAT 		((volatile unsigned short *)EBIU_SDSTAT)
+
+/* DMA Traffic Control Registers													*/
+#define	pDMA_TCPER			((volatile unsigned short *)DMA_TCPER)
+#define	pDMA_TCCNT			((volatile unsigned short *)DMA_TCCNT)
+
+/* DMA Controller																	*/
+#define pDMA0_CONFIG 			((volatile unsigned short *)DMA0_CONFIG)
+#define pDMA0_NEXT_DESC_PTR 	((void * volatile *)DMA0_NEXT_DESC_PTR)
+#define pDMA0_START_ADDR 		((void * volatile *)DMA0_START_ADDR)
+#define pDMA0_X_COUNT 			((volatile unsigned short *)DMA0_X_COUNT)
+#define pDMA0_Y_COUNT 			((volatile unsigned short *)DMA0_Y_COUNT)
+#define pDMA0_X_MODIFY 			((volatile signed   short *)DMA0_X_MODIFY)
+#define pDMA0_Y_MODIFY 			((volatile signed   short *)DMA0_Y_MODIFY)
+#define pDMA0_CURR_DESC_PTR 	((void * volatile *)DMA0_CURR_DESC_PTR)
+#define pDMA0_CURR_ADDR 		((void * volatile *)DMA0_CURR_ADDR)
+#define pDMA0_CURR_X_COUNT 		((volatile unsigned short *)DMA0_CURR_X_COUNT)
+#define pDMA0_CURR_Y_COUNT 		((volatile unsigned short *)DMA0_CURR_Y_COUNT)
+#define pDMA0_IRQ_STATUS 		((volatile unsigned short *)DMA0_IRQ_STATUS)
+#define pDMA0_PERIPHERAL_MAP 	((volatile unsigned short *)DMA0_PERIPHERAL_MAP)
+
+#define pDMA1_CONFIG 			((volatile unsigned short *)DMA1_CONFIG)
+#define pDMA1_NEXT_DESC_PTR 	((void * volatile *)DMA1_NEXT_DESC_PTR)
+#define pDMA1_START_ADDR 		((void * volatile *)DMA1_START_ADDR)
+#define pDMA1_X_COUNT 			((volatile unsigned short *)DMA1_X_COUNT)
+#define pDMA1_Y_COUNT 			((volatile unsigned short *)DMA1_Y_COUNT)
+#define pDMA1_X_MODIFY 			((volatile signed   short *)DMA1_X_MODIFY)
+#define pDMA1_Y_MODIFY 			((volatile signed   short *)DMA1_Y_MODIFY)
+#define pDMA1_CURR_DESC_PTR 	((void * volatile *)DMA1_CURR_DESC_PTR)
+#define pDMA1_CURR_ADDR 		((void * volatile *)DMA1_CURR_ADDR)
+#define pDMA1_CURR_X_COUNT 		((volatile unsigned short *)DMA1_CURR_X_COUNT)
+#define pDMA1_CURR_Y_COUNT 		((volatile unsigned short *)DMA1_CURR_Y_COUNT)
+#define pDMA1_IRQ_STATUS 		((volatile unsigned short *)DMA1_IRQ_STATUS)
+#define pDMA1_PERIPHERAL_MAP 	((volatile unsigned short *)DMA1_PERIPHERAL_MAP)
+
+#define pDMA2_CONFIG 			((volatile unsigned short *)DMA2_CONFIG)
+#define pDMA2_NEXT_DESC_PTR 	((void * volatile *)DMA2_NEXT_DESC_PTR)
+#define pDMA2_START_ADDR 		((void * volatile *)DMA2_START_ADDR)
+#define pDMA2_X_COUNT 			((volatile unsigned short *)DMA2_X_COUNT)
+#define pDMA2_Y_COUNT 			((volatile unsigned short *)DMA2_Y_COUNT)
+#define pDMA2_X_MODIFY 			((volatile signed   short *)DMA2_X_MODIFY)
+#define pDMA2_Y_MODIFY 			((volatile signed   short *)DMA2_Y_MODIFY)
+#define pDMA2_CURR_DESC_PTR 	((void * volatile *)DMA2_CURR_DESC_PTR)
+#define pDMA2_CURR_ADDR 		((void * volatile *)DMA2_CURR_ADDR)
+#define pDMA2_CURR_X_COUNT 		((volatile unsigned short *)DMA2_CURR_X_COUNT)
+#define pDMA2_CURR_Y_COUNT 		((volatile unsigned short *)DMA2_CURR_Y_COUNT)
+#define pDMA2_IRQ_STATUS 		((volatile unsigned short *)DMA2_IRQ_STATUS)
+#define pDMA2_PERIPHERAL_MAP 	((volatile unsigned short *)DMA2_PERIPHERAL_MAP)
+
+#define pDMA3_CONFIG 			((volatile unsigned short *)DMA3_CONFIG)
+#define pDMA3_NEXT_DESC_PTR 	((void * volatile *)DMA3_NEXT_DESC_PTR)
+#define pDMA3_START_ADDR 		((void * volatile *)DMA3_START_ADDR)
+#define pDMA3_X_COUNT 			((volatile unsigned short *)DMA3_X_COUNT)
+#define pDMA3_Y_COUNT 			((volatile unsigned short *)DMA3_Y_COUNT)
+#define pDMA3_X_MODIFY 			((volatile signed   short *)DMA3_X_MODIFY)
+#define pDMA3_Y_MODIFY 			((volatile signed   short *)DMA3_Y_MODIFY)
+#define pDMA3_CURR_DESC_PTR 	((void * volatile *)DMA3_CURR_DESC_PTR)
+#define pDMA3_CURR_ADDR 		((void * volatile *)DMA3_CURR_ADDR)
+#define pDMA3_CURR_X_COUNT 		((volatile unsigned short *)DMA3_CURR_X_COUNT)
+#define pDMA3_CURR_Y_COUNT 		((volatile unsigned short *)DMA3_CURR_Y_COUNT)
+#define pDMA3_IRQ_STATUS 		((volatile unsigned short *)DMA3_IRQ_STATUS)
+#define pDMA3_PERIPHERAL_MAP 	((volatile unsigned short *)DMA3_PERIPHERAL_MAP)
+
+#define pDMA4_CONFIG 			((volatile unsigned short *)DMA4_CONFIG)
+#define pDMA4_NEXT_DESC_PTR 	((void * volatile *)DMA4_NEXT_DESC_PTR)
+#define pDMA4_START_ADDR 		((void * volatile *)DMA4_START_ADDR)
+#define pDMA4_X_COUNT 			((volatile unsigned short *)DMA4_X_COUNT)
+#define pDMA4_Y_COUNT 			((volatile unsigned short *)DMA4_Y_COUNT)
+#define pDMA4_X_MODIFY 			((volatile signed   short *)DMA4_X_MODIFY)
+#define pDMA4_Y_MODIFY 			((volatile signed   short *)DMA4_Y_MODIFY)
+#define pDMA4_CURR_DESC_PTR 	((void * volatile *)DMA4_CURR_DESC_PTR)
+#define pDMA4_CURR_ADDR 		((void * volatile *)DMA4_CURR_ADDR)
+#define pDMA4_CURR_X_COUNT 		((volatile unsigned short *)DMA4_CURR_X_COUNT)
+#define pDMA4_CURR_Y_COUNT 		((volatile unsigned short *)DMA4_CURR_Y_COUNT)
+#define pDMA4_IRQ_STATUS 		((volatile unsigned short *)DMA4_IRQ_STATUS)
+#define pDMA4_PERIPHERAL_MAP 	((volatile unsigned short *)DMA4_PERIPHERAL_MAP)
+
+#define pDMA5_CONFIG 			((volatile unsigned short *)DMA5_CONFIG)
+#define pDMA5_NEXT_DESC_PTR 	((void * volatile *)DMA5_NEXT_DESC_PTR)
+#define pDMA5_START_ADDR 		((void * volatile *)DMA5_START_ADDR)
+#define pDMA5_X_COUNT 			((volatile unsigned short *)DMA5_X_COUNT)
+#define pDMA5_Y_COUNT 			((volatile unsigned short *)DMA5_Y_COUNT)
+#define pDMA5_X_MODIFY 			((volatile signed   short *)DMA5_X_MODIFY)
+#define pDMA5_Y_MODIFY 			((volatile signed   short *)DMA5_Y_MODIFY)
+#define pDMA5_CURR_DESC_PTR 	((void * volatile *)DMA5_CURR_DESC_PTR)
+#define pDMA5_CURR_ADDR 		((void * volatile *)DMA5_CURR_ADDR)
+#define pDMA5_CURR_X_COUNT 		((volatile unsigned short *)DMA5_CURR_X_COUNT)
+#define pDMA5_CURR_Y_COUNT 		((volatile unsigned short *)DMA5_CURR_Y_COUNT)
+#define pDMA5_IRQ_STATUS 		((volatile unsigned short *)DMA5_IRQ_STATUS)
+#define pDMA5_PERIPHERAL_MAP 	((volatile unsigned short *)DMA5_PERIPHERAL_MAP)
+
+#define pDMA6_CONFIG 			((volatile unsigned short *)DMA6_CONFIG)
+#define pDMA6_NEXT_DESC_PTR 	((void * volatile *)DMA6_NEXT_DESC_PTR)
+#define pDMA6_START_ADDR 		((void * volatile *)DMA6_START_ADDR)
+#define pDMA6_X_COUNT 			((volatile unsigned short *)DMA6_X_COUNT)
+#define pDMA6_Y_COUNT 			((volatile unsigned short *)DMA6_Y_COUNT)
+#define pDMA6_X_MODIFY 			((volatile signed   short *)DMA6_X_MODIFY)
+#define pDMA6_Y_MODIFY 			((volatile signed   short *)DMA6_Y_MODIFY)
+#define pDMA6_CURR_DESC_PTR 	((void * volatile *)DMA6_CURR_DESC_PTR)
+#define pDMA6_CURR_ADDR 		((void * volatile *)DMA6_CURR_ADDR)
+#define pDMA6_CURR_X_COUNT 		((volatile unsigned short *)DMA6_CURR_X_COUNT)
+#define pDMA6_CURR_Y_COUNT 		((volatile unsigned short *)DMA6_CURR_Y_COUNT)
+#define pDMA6_IRQ_STATUS 		((volatile unsigned short *)DMA6_IRQ_STATUS)
+#define pDMA6_PERIPHERAL_MAP 	((volatile unsigned short *)DMA6_PERIPHERAL_MAP)
+
+#define pDMA7_CONFIG 			((volatile unsigned short *)DMA7_CONFIG)
+#define pDMA7_NEXT_DESC_PTR 	((void * volatile *)DMA7_NEXT_DESC_PTR)
+#define pDMA7_START_ADDR 		((void * volatile *)DMA7_START_ADDR)
+#define pDMA7_X_COUNT 			((volatile unsigned short *)DMA7_X_COUNT)
+#define pDMA7_Y_COUNT 			((volatile unsigned short *)DMA7_Y_COUNT)
+#define pDMA7_X_MODIFY 			((volatile signed   short *)DMA7_X_MODIFY)
+#define pDMA7_Y_MODIFY 			((volatile signed   short *)DMA7_Y_MODIFY)
+#define pDMA7_CURR_DESC_PTR 	((void * volatile *)DMA7_CURR_DESC_PTR)
+#define pDMA7_CURR_ADDR 		((void * volatile *)DMA7_CURR_ADDR)
+#define pDMA7_CURR_X_COUNT 		((volatile unsigned short *)DMA7_CURR_X_COUNT)
+#define pDMA7_CURR_Y_COUNT 		((volatile unsigned short *)DMA7_CURR_Y_COUNT)
+#define pDMA7_IRQ_STATUS 		((volatile unsigned short *)DMA7_IRQ_STATUS)
+#define pDMA7_PERIPHERAL_MAP 	((volatile unsigned short *)DMA7_PERIPHERAL_MAP)
+
+#define pDMA8_CONFIG 			((volatile unsigned short *)DMA8_CONFIG)
+#define pDMA8_NEXT_DESC_PTR 	((void * volatile *)DMA8_NEXT_DESC_PTR)
+#define pDMA8_START_ADDR 		((void * volatile *)DMA8_START_ADDR)
+#define pDMA8_X_COUNT 			((volatile unsigned short *)DMA8_X_COUNT)
+#define pDMA8_Y_COUNT 			((volatile unsigned short *)DMA8_Y_COUNT)
+#define pDMA8_X_MODIFY 			((volatile signed   short *)DMA8_X_MODIFY)
+#define pDMA8_Y_MODIFY 			((volatile signed   short *)DMA8_Y_MODIFY)
+#define pDMA8_CURR_DESC_PTR 	((void * volatile *)DMA8_CURR_DESC_PTR)
+#define pDMA8_CURR_ADDR 		((void * volatile *)DMA8_CURR_ADDR)
+#define pDMA8_CURR_X_COUNT 		((volatile unsigned short *)DMA8_CURR_X_COUNT)
+#define pDMA8_CURR_Y_COUNT 		((volatile unsigned short *)DMA8_CURR_Y_COUNT)
+#define pDMA8_IRQ_STATUS 		((volatile unsigned short *)DMA8_IRQ_STATUS)
+#define pDMA8_PERIPHERAL_MAP 	((volatile unsigned short *)DMA8_PERIPHERAL_MAP)
+
+#define pDMA9_CONFIG 			((volatile unsigned short *)DMA9_CONFIG)
+#define pDMA9_NEXT_DESC_PTR 	((void * volatile *)DMA9_NEXT_DESC_PTR)
+#define pDMA9_START_ADDR 		((void * volatile *)DMA9_START_ADDR)
+#define pDMA9_X_COUNT 			((volatile unsigned short *)DMA9_X_COUNT)
+#define pDMA9_Y_COUNT 			((volatile unsigned short *)DMA9_Y_COUNT)
+#define pDMA9_X_MODIFY 			((volatile signed   short *)DMA9_X_MODIFY)
+#define pDMA9_Y_MODIFY 			((volatile signed   short *)DMA9_Y_MODIFY)
+#define pDMA9_CURR_DESC_PTR 	((void * volatile *)DMA9_CURR_DESC_PTR)
+#define pDMA9_CURR_ADDR 		((void * volatile *)DMA9_CURR_ADDR)
+#define pDMA9_CURR_X_COUNT 		((volatile unsigned short *)DMA9_CURR_X_COUNT)
+#define pDMA9_CURR_Y_COUNT 		((volatile unsigned short *)DMA9_CURR_Y_COUNT)
+#define pDMA9_IRQ_STATUS 		((volatile unsigned short *)DMA9_IRQ_STATUS)
+#define pDMA9_PERIPHERAL_MAP 	((volatile unsigned short *)DMA9_PERIPHERAL_MAP)
+
+#define pDMA10_CONFIG 			((volatile unsigned short *)DMA10_CONFIG)
+#define pDMA10_NEXT_DESC_PTR 	((void * volatile *)DMA10_NEXT_DESC_PTR)
+#define pDMA10_START_ADDR 		((void * volatile *)DMA10_START_ADDR)
+#define pDMA10_X_COUNT 			((volatile unsigned short *)DMA10_X_COUNT)
+#define pDMA10_Y_COUNT 			((volatile unsigned short *)DMA10_Y_COUNT)
+#define pDMA10_X_MODIFY 		((volatile signed   short *)DMA10_X_MODIFY)
+#define pDMA10_Y_MODIFY 		((volatile signed   short *)DMA10_Y_MODIFY)
+#define pDMA10_CURR_DESC_PTR 	((void * volatile *)DMA10_CURR_DESC_PTR)
+#define pDMA10_CURR_ADDR 		((void * volatile *)DMA10_CURR_ADDR)
+#define pDMA10_CURR_X_COUNT 	((volatile unsigned short *)DMA10_CURR_X_COUNT)
+#define pDMA10_CURR_Y_COUNT 	((volatile unsigned short *)DMA10_CURR_Y_COUNT)
+#define pDMA10_IRQ_STATUS 		((volatile unsigned short *)DMA10_IRQ_STATUS)
+#define pDMA10_PERIPHERAL_MAP 	((volatile unsigned short *)DMA10_PERIPHERAL_MAP)
+
+#define pDMA11_CONFIG 			((volatile unsigned short *)DMA11_CONFIG)
+#define pDMA11_NEXT_DESC_PTR 	((void * volatile *)DMA11_NEXT_DESC_PTR)
+#define pDMA11_START_ADDR 		((void * volatile *)DMA11_START_ADDR)
+#define pDMA11_X_COUNT 			((volatile unsigned short *)DMA11_X_COUNT)
+#define pDMA11_Y_COUNT 			((volatile unsigned short *)DMA11_Y_COUNT)
+#define pDMA11_X_MODIFY 		((volatile signed   short *)DMA11_X_MODIFY)
+#define pDMA11_Y_MODIFY 		((volatile signed   short *)DMA11_Y_MODIFY)
+#define pDMA11_CURR_DESC_PTR 	((void * volatile *)DMA11_CURR_DESC_PTR)
+#define pDMA11_CURR_ADDR 		((void * volatile *)DMA11_CURR_ADDR)
+#define pDMA11_CURR_X_COUNT 	((volatile unsigned short *)DMA11_CURR_X_COUNT)
+#define pDMA11_CURR_Y_COUNT 	((volatile unsigned short *)DMA11_CURR_Y_COUNT)
+#define pDMA11_IRQ_STATUS 		((volatile unsigned short *)DMA11_IRQ_STATUS)
+#define pDMA11_PERIPHERAL_MAP 	((volatile unsigned short *)DMA11_PERIPHERAL_MAP)
+
+#define pMDMA_D0_CONFIG 		((volatile unsigned short *)MDMA_D0_CONFIG)
+#define pMDMA_D0_NEXT_DESC_PTR 	((void * volatile *)MDMA_D0_NEXT_DESC_PTR)
+#define pMDMA_D0_START_ADDR 	((void * volatile *)MDMA_D0_START_ADDR)
+#define pMDMA_D0_X_COUNT 		((volatile unsigned short *)MDMA_D0_X_COUNT)
+#define pMDMA_D0_Y_COUNT 		((volatile unsigned short *)MDMA_D0_Y_COUNT)
+#define pMDMA_D0_X_MODIFY 		((volatile signed   short *)MDMA_D0_X_MODIFY)
+#define pMDMA_D0_Y_MODIFY 		((volatile signed   short *)MDMA_D0_Y_MODIFY)
+#define pMDMA_D0_CURR_DESC_PTR 	((void * volatile *)MDMA_D0_CURR_DESC_PTR)
+#define pMDMA_D0_CURR_ADDR 		((void * volatile *)MDMA_D0_CURR_ADDR)
+#define pMDMA_D0_CURR_X_COUNT 	((volatile unsigned short *)MDMA_D0_CURR_X_COUNT)
+#define pMDMA_D0_CURR_Y_COUNT 	((volatile unsigned short *)MDMA_D0_CURR_Y_COUNT)
+#define pMDMA_D0_IRQ_STATUS 	((volatile unsigned short *)MDMA_D0_IRQ_STATUS)
+#define pMDMA_D0_PERIPHERAL_MAP ((volatile unsigned short *)MDMA_D0_PERIPHERAL_MAP)
+
+#define pMDMA_S0_CONFIG 		((volatile unsigned short *)MDMA_S0_CONFIG)
+#define pMDMA_S0_NEXT_DESC_PTR 	((void * volatile *)MDMA_S0_NEXT_DESC_PTR)
+#define pMDMA_S0_START_ADDR 	((void * volatile *)MDMA_S0_START_ADDR)
+#define pMDMA_S0_X_COUNT 		((volatile unsigned short *)MDMA_S0_X_COUNT)
+#define pMDMA_S0_Y_COUNT 		((volatile unsigned short *)MDMA_S0_Y_COUNT)
+#define pMDMA_S0_X_MODIFY 		((volatile signed   short *)MDMA_S0_X_MODIFY)
+#define pMDMA_S0_Y_MODIFY 		((volatile signed   short *)MDMA_S0_Y_MODIFY)
+#define pMDMA_S0_CURR_DESC_PTR 	((void * volatile *)MDMA_S0_CURR_DESC_PTR)
+#define pMDMA_S0_CURR_ADDR 		((void * volatile *)MDMA_S0_CURR_ADDR)
+#define pMDMA_S0_CURR_X_COUNT 	((volatile unsigned short *)MDMA_S0_CURR_X_COUNT)
+#define pMDMA_S0_CURR_Y_COUNT 	((volatile unsigned short *)MDMA_S0_CURR_Y_COUNT)
+#define pMDMA_S0_IRQ_STATUS 	((volatile unsigned short *)MDMA_S0_IRQ_STATUS)
+#define pMDMA_S0_PERIPHERAL_MAP	((volatile unsigned short *)MDMA_S0_PERIPHERAL_MAP)
+
+#define pMDMA_D1_CONFIG 		((volatile unsigned short *)MDMA_D1_CONFIG)
+#define pMDMA_D1_NEXT_DESC_PTR 	((void * volatile *)MDMA_D1_NEXT_DESC_PTR)
+#define pMDMA_D1_START_ADDR 	((void * volatile *)MDMA_D1_START_ADDR)
+#define pMDMA_D1_X_COUNT 		((volatile unsigned short *)MDMA_D1_X_COUNT)
+#define pMDMA_D1_Y_COUNT 		((volatile unsigned short *)MDMA_D1_Y_COUNT)
+#define pMDMA_D1_X_MODIFY 		((volatile signed   short *)MDMA_D1_X_MODIFY)
+#define pMDMA_D1_Y_MODIFY 		((volatile signed   short *)MDMA_D1_Y_MODIFY)
+#define pMDMA_D1_CURR_DESC_PTR 	((void * volatile *)MDMA_D1_CURR_DESC_PTR)
+#define pMDMA_D1_CURR_ADDR 		((void * volatile *)MDMA_D1_CURR_ADDR)
+#define pMDMA_D1_CURR_X_COUNT 	((volatile unsigned short *)MDMA_D1_CURR_X_COUNT)
+#define pMDMA_D1_CURR_Y_COUNT 	((volatile unsigned short *)MDMA_D1_CURR_Y_COUNT)
+#define pMDMA_D1_IRQ_STATUS 	((volatile unsigned short *)MDMA_D1_IRQ_STATUS)
+#define pMDMA_D1_PERIPHERAL_MAP ((volatile unsigned short *)MDMA_D1_PERIPHERAL_MAP)
+
+#define pMDMA_S1_CONFIG 		((volatile unsigned short *)MDMA_S1_CONFIG)
+#define pMDMA_S1_NEXT_DESC_PTR 	((void * volatile *)MDMA_S1_NEXT_DESC_PTR)
+#define pMDMA_S1_START_ADDR 	((void * volatile *)MDMA_S1_START_ADDR)
+#define pMDMA_S1_X_COUNT 		((volatile unsigned short *)MDMA_S1_X_COUNT)
+#define pMDMA_S1_Y_COUNT 		((volatile unsigned short *)MDMA_S1_Y_COUNT)
+#define pMDMA_S1_X_MODIFY 		((volatile signed   short *)MDMA_S1_X_MODIFY)
+#define pMDMA_S1_Y_MODIFY 		((volatile signed   short *)MDMA_S1_Y_MODIFY)
+#define pMDMA_S1_CURR_DESC_PTR 	((void * volatile *)MDMA_S1_CURR_DESC_PTR)
+#define pMDMA_S1_CURR_ADDR 		((void * volatile *)MDMA_S1_CURR_ADDR)
+#define pMDMA_S1_CURR_X_COUNT 	((volatile unsigned short *)MDMA_S1_CURR_X_COUNT)
+#define pMDMA_S1_CURR_Y_COUNT 	((volatile unsigned short *)MDMA_S1_CURR_Y_COUNT)
+#define pMDMA_S1_IRQ_STATUS 	((volatile unsigned short *)MDMA_S1_IRQ_STATUS)
+#define pMDMA_S1_PERIPHERAL_MAP ((volatile unsigned short *)MDMA_S1_PERIPHERAL_MAP)
+
+/* Parallel Peripheral Interface (0xFFC01000 - 0xFFC010FF)							*/
+#define pPPI_CONTROL 		((volatile unsigned short *)PPI_CONTROL)
+#define pPPI_STATUS 		((volatile unsigned short *)PPI_STATUS)
+#define pPPI_DELAY 			((volatile unsigned short *)PPI_DELAY)
+#define pPPI_COUNT 			((volatile unsigned short *)PPI_COUNT)
+#define pPPI_FRAME 			((volatile unsigned short *)PPI_FRAME)
+
+/* Two-Wire Interface		(0xFFC01400 - 0xFFC014FF)								*/
+#define pTWI_CLKDIV			((volatile unsigned short *)TWI_CLKDIV)
+#define pTWI_CONTROL		((volatile unsigned short *)TWI_CONTROL)
+#define pTWI_SLAVE_CTL		((volatile unsigned short *)TWI_SLAVE_CTL)
+#define pTWI_SLAVE_STAT		((volatile unsigned short *)TWI_SLAVE_STAT)
+#define pTWI_SLAVE_ADDR		((volatile unsigned short *)TWI_SLAVE_ADDR)
+#define pTWI_MASTER_CTL		((volatile unsigned short *)TWI_MASTER_CTL)
+#define pTWI_MASTER_STAT	((volatile unsigned short *)TWI_MASTER_STAT)
+#define pTWI_MASTER_ADDR	((volatile unsigned short *)TWI_MASTER_ADDR)
+#define pTWI_INT_STAT		((volatile unsigned short *)TWI_INT_STAT)
+#define pTWI_INT_MASK		((volatile unsigned short *)TWI_INT_MASK)
+#define pTWI_FIFO_CTL		((volatile unsigned short *)TWI_FIFO_CTL)
+#define pTWI_FIFO_STAT		((volatile unsigned short *)TWI_FIFO_STAT)
+#define pTWI_XMT_DATA8		((volatile unsigned short *)TWI_XMT_DATA8)
+#define pTWI_XMT_DATA16		((volatile unsigned short *)TWI_XMT_DATA16)
+#define pTWI_RCV_DATA8		((volatile unsigned short *)TWI_RCV_DATA8)
+#define pTWI_RCV_DATA16		((volatile unsigned short *)TWI_RCV_DATA16)
+
+/* General Purpose I/O Port G (0xFFC01500 - 0xFFC015FF)								*/
+#define pPORTGIO	 			((volatile unsigned short *)PORTGIO)
+#define pPORTGIO_CLEAR	 		((volatile unsigned short *)PORTGIO_CLEAR)
+#define pPORTGIO_SET	 		((volatile unsigned short *)PORTGIO_SET)
+#define pPORTGIO_TOGGLE 		((volatile unsigned short *)PORTGIO_TOGGLE)
+#define pPORTGIO_MASKA			((volatile unsigned short *)PORTGIO_MASKA)
+#define pPORTGIO_MASKA_CLEAR	((volatile unsigned short *)PORTGIO_MASKA_CLEAR)
+#define pPORTGIO_MASKA_SET		((volatile unsigned short *)PORTGIO_MASKA_SET)
+#define pPORTGIO_MASKA_TOGGLE	((volatile unsigned short *)PORTGIO_MASKA_TOGGLE)
+#define pPORTGIO_MASKB			((volatile unsigned short *)PORTGIO_MASKB)
+#define pPORTGIO_MASKB_CLEAR	((volatile unsigned short *)PORTGIO_MASKB_CLEAR)
+#define pPORTGIO_MASKB_SET		((volatile unsigned short *)PORTGIO_MASKB_SET)
+#define pPORTGIO_MASKB_TOGGLE	((volatile unsigned short *)PORTGIO_MASKB_TOGGLE)
+#define pPORTGIO_DIR 			((volatile unsigned short *)PORTGIO_DIR)
+#define pPORTGIO_POLAR 			((volatile unsigned short *)PORTGIO_POLAR)
+#define pPORTGIO_EDGE 			((volatile unsigned short *)PORTGIO_EDGE)
+#define pPORTGIO_BOTH 			((volatile unsigned short *)PORTGIO_BOTH)
+#define pPORTGIO_INEN 			((volatile unsigned short *)PORTGIO_INEN)
+
+/* General Purpose I/O Port H (0xFFC01700 - 0xFFC017FF)								*/
+#define pPORTHIO	 			((volatile unsigned short *)PORTHIO)
+#define pPORTHIO_CLEAR	 		((volatile unsigned short *)PORTHIO_CLEAR)
+#define pPORTHIO_SET	 		((volatile unsigned short *)PORTHIO_SET)
+#define pPORTHIO_TOGGLE 		((volatile unsigned short *)PORTHIO_TOGGLE)
+#define pPORTHIO_MASKA			((volatile unsigned short *)PORTHIO_MASKA)
+#define pPORTHIO_MASKA_CLEAR	((volatile unsigned short *)PORTHIO_MASKA_CLEAR)
+#define pPORTHIO_MASKA_SET		((volatile unsigned short *)PORTHIO_MASKA_SET)
+#define pPORTHIO_MASKA_TOGGLE	((volatile unsigned short *)PORTHIO_MASKA_TOGGLE)
+#define pPORTHIO_MASKB			((volatile unsigned short *)PORTHIO_MASKB)
+#define pPORTHIO_MASKB_CLEAR	((volatile unsigned short *)PORTHIO_MASKB_CLEAR)
+#define pPORTHIO_MASKB_SET		((volatile unsigned short *)PORTHIO_MASKB_SET)
+#define pPORTHIO_MASKB_TOGGLE	((volatile unsigned short *)PORTHIO_MASKB_TOGGLE)
+#define pPORTHIO_DIR 			((volatile unsigned short *)PORTHIO_DIR)
+#define pPORTHIO_POLAR 			((volatile unsigned short *)PORTHIO_POLAR)
+#define pPORTHIO_EDGE 			((volatile unsigned short *)PORTHIO_EDGE)
+#define pPORTHIO_BOTH 			((volatile unsigned short *)PORTHIO_BOTH)
+#define pPORTHIO_INEN 			((volatile unsigned short *)PORTHIO_INEN)
+
+/* UART1 Controller		(0xFFC02000 - 0xFFC020FF)								*/
+#define pUART1_THR 			((volatile unsigned short *)UART1_THR)
+#define pUART1_RBR 			((volatile unsigned short *)UART1_RBR)
+#define pUART1_DLL 			((volatile unsigned short *)UART1_DLL)
+#define pUART1_IER 			((volatile unsigned short *)UART1_IER)
+#define pUART1_DLH 			((volatile unsigned short *)UART1_DLH)
+#define pUART1_IIR 			((volatile unsigned short *)UART1_IIR)
+#define pUART1_LCR 			((volatile unsigned short *)UART1_LCR)
+#define pUART1_MCR 			((volatile unsigned short *)UART1_MCR)
+#define pUART1_LSR 			((volatile unsigned short *)UART1_LSR)
+#define pUART1_MSR			((volatile unsigned short *)UART1_LSR)
+#define pUART1_SCR 			((volatile unsigned short *)UART1_SCR)
+#define pUART1_GCTL 		((volatile unsigned short *)UART1_GCTL)
+
+/* CAN Controller		(0xFFC02A00 - 0xFFC02FFF)								*/
+/* For Mailboxes 0-15 */
+#define pCAN_MC1			((volatile unsigned short *)CAN_MC1)
+#define pCAN_MD1			((volatile unsigned short *)CAN_MD1)
+#define pCAN_TRS1			((volatile unsigned short *)CAN_TRS1)
+#define pCAN_TRR1			((volatile unsigned short *)CAN_TRR1)
+#define pCAN_TA1			((volatile unsigned short *)CAN_TA1)
+#define pCAN_AA1			((volatile unsigned short *)CAN_AA1)
+#define pCAN_RMP1			((volatile unsigned short *)CAN_RMP1)
+#define pCAN_RML1			((volatile unsigned short *)CAN_RML1)
+#define pCAN_MBTIF1			((volatile unsigned short *)CAN_MBTIF1)
+#define pCAN_MBRIF1			((volatile unsigned short *)CAN_MBRIF1)
+#define pCAN_MBIM1			((volatile unsigned short *)CAN_MBIM1)
+#define pCAN_RFH1			((volatile unsigned short *)CAN_RFH1)
+#define pCAN_OPSS1			((volatile unsigned short *)CAN_OPSS1)
+
+/* For Mailboxes 16-31 */
+#define pCAN_MC2			((volatile unsigned short *)CAN_MC2)
+#define pCAN_MD2			((volatile unsigned short *)CAN_MD2)
+#define pCAN_TRS2			((volatile unsigned short *)CAN_TRS2)
+#define pCAN_TRR2			((volatile unsigned short *)CAN_TRR2)
+#define pCAN_TA2			((volatile unsigned short *)CAN_TA2)
+#define pCAN_AA2			((volatile unsigned short *)CAN_AA2)
+#define pCAN_RMP2			((volatile unsigned short *)CAN_RMP2)
+#define pCAN_RML2			((volatile unsigned short *)CAN_RML2)
+#define pCAN_MBTIF2			((volatile unsigned short *)CAN_MBTIF2)
+#define pCAN_MBRIF2			((volatile unsigned short *)CAN_MBRIF2)
+#define pCAN_MBIM2			((volatile unsigned short *)CAN_MBIM2)
+#define pCAN_RFH2			((volatile unsigned short *)CAN_RFH2)
+#define pCAN_OPSS2			((volatile unsigned short *)CAN_OPSS2)
+
+#define pCAN_CLOCK			((volatile unsigned short *)CAN_CLOCK)
+#define pCAN_TIMING			((volatile unsigned short *)CAN_TIMING)
+#define pCAN_DEBUG			((volatile unsigned short *)CAN_DEBUG)
+#define pCAN_STATUS			((volatile unsigned short *)CAN_STATUS)
+#define pCAN_CEC			((volatile unsigned short *)CAN_CEC)
+#define pCAN_GIS			((volatile unsigned short *)CAN_GIS)
+#define pCAN_GIM			((volatile unsigned short *)CAN_GIM)
+#define pCAN_GIF			((volatile unsigned short *)CAN_GIF)
+#define pCAN_CONTROL		((volatile unsigned short *)CAN_CONTROL)
+#define pCAN_INTR			((volatile unsigned short *)CAN_INTR)
+#define pCAN_SFCMVER		((volatile unsigned short *)CAN_SFCMVER)
+#define pCAN_MBTD			((volatile unsigned short *)CAN_MBTD)
+#define pCAN_EWR			((volatile unsigned short *)CAN_EWR)
+#define pCAN_ESR			((volatile unsigned short *)CAN_ESR)
+#define pCAN_UCREG			((volatile unsigned short *)CAN_UCREG)
+#define pCAN_UCCNT			((volatile unsigned short *)CAN_UCCNT)
+#define pCAN_UCRC			((volatile unsigned short *)CAN_UCRC)
+#define pCAN_UCCNF			((volatile unsigned short *)CAN_UCCNF)
+#define pCAN_SFCMVER2		((volatile unsigned short *)CAN_SFCMVER2)
+
+/* Mailbox Acceptance Masks */
+#define pCAN_AM00L			((volatile unsigned short *)CAN_AM00L)
+#define pCAN_AM00H			((volatile unsigned short *)CAN_AM00H)
+#define pCAN_AM01L			((volatile unsigned short *)CAN_AM01L)
+#define pCAN_AM01H			((volatile unsigned short *)CAN_AM01H)
+#define pCAN_AM02L			((volatile unsigned short *)CAN_AM02L)
+#define pCAN_AM02H			((volatile unsigned short *)CAN_AM02H)
+#define pCAN_AM03L			((volatile unsigned short *)CAN_AM03L)
+#define pCAN_AM03H			((volatile unsigned short *)CAN_AM03H)
+#define pCAN_AM04L			((volatile unsigned short *)CAN_AM04L)
+#define pCAN_AM04H			((volatile unsigned short *)CAN_AM04H)
+#define pCAN_AM05L			((volatile unsigned short *)CAN_AM05L)
+#define pCAN_AM05H			((volatile unsigned short *)CAN_AM05H)
+#define pCAN_AM06L			((volatile unsigned short *)CAN_AM06L)
+#define pCAN_AM06H			((volatile unsigned short *)CAN_AM06H)
+#define pCAN_AM07L			((volatile unsigned short *)CAN_AM07L)
+#define pCAN_AM07H			((volatile unsigned short *)CAN_AM07H)
+#define pCAN_AM08L			((volatile unsigned short *)CAN_AM08L)
+#define pCAN_AM08H			((volatile unsigned short *)CAN_AM08H)
+#define pCAN_AM09L			((volatile unsigned short *)CAN_AM09L)
+#define pCAN_AM09H			((volatile unsigned short *)CAN_AM09H)
+#define pCAN_AM10L			((volatile unsigned short *)CAN_AM10L)
+#define pCAN_AM10H			((volatile unsigned short *)CAN_AM10H)
+#define pCAN_AM11L			((volatile unsigned short *)CAN_AM11L)
+#define pCAN_AM11H			((volatile unsigned short *)CAN_AM11H)
+#define pCAN_AM12L			((volatile unsigned short *)CAN_AM12L)
+#define pCAN_AM12H			((volatile unsigned short *)CAN_AM12H)
+#define pCAN_AM13L			((volatile unsigned short *)CAN_AM13L)
+#define pCAN_AM13H			((volatile unsigned short *)CAN_AM13H)
+#define pCAN_AM14L			((volatile unsigned short *)CAN_AM14L)
+#define pCAN_AM14H			((volatile unsigned short *)CAN_AM14H)
+#define pCAN_AM15L			((volatile unsigned short *)CAN_AM15L)
+#define pCAN_AM15H			((volatile unsigned short *)CAN_AM15H)
+
+#define pCAN_AM16L			((volatile unsigned short *)CAN_AM16L)
+#define pCAN_AM16H			((volatile unsigned short *)CAN_AM16H)
+#define pCAN_AM17L			((volatile unsigned short *)CAN_AM17L)
+#define pCAN_AM17H			((volatile unsigned short *)CAN_AM17H)
+#define pCAN_AM18L			((volatile unsigned short *)CAN_AM18L)
+#define pCAN_AM18H			((volatile unsigned short *)CAN_AM18H)
+#define pCAN_AM19L			((volatile unsigned short *)CAN_AM19L)
+#define pCAN_AM19H			((volatile unsigned short *)CAN_AM19H)
+#define pCAN_AM20L			((volatile unsigned short *)CAN_AM20L)
+#define pCAN_AM20H			((volatile unsigned short *)CAN_AM20H)
+#define pCAN_AM21L			((volatile unsigned short *)CAN_AM21L)
+#define pCAN_AM21H			((volatile unsigned short *)CAN_AM21H)
+#define pCAN_AM22L			((volatile unsigned short *)CAN_AM22L)
+#define pCAN_AM22H			((volatile unsigned short *)CAN_AM22H)
+#define pCAN_AM23L			((volatile unsigned short *)CAN_AM23L)
+#define pCAN_AM23H			((volatile unsigned short *)CAN_AM23H)
+#define pCAN_AM24L			((volatile unsigned short *)CAN_AM24L)
+#define pCAN_AM24H			((volatile unsigned short *)CAN_AM24H)
+#define pCAN_AM25L			((volatile unsigned short *)CAN_AM25L)
+#define pCAN_AM25H			((volatile unsigned short *)CAN_AM25H)
+#define pCAN_AM26L			((volatile unsigned short *)CAN_AM26L)
+#define pCAN_AM26H			((volatile unsigned short *)CAN_AM26H)
+#define pCAN_AM27L			((volatile unsigned short *)CAN_AM27L)
+#define pCAN_AM27H			((volatile unsigned short *)CAN_AM27H)
+#define pCAN_AM28L			((volatile unsigned short *)CAN_AM28L)
+#define pCAN_AM28H			((volatile unsigned short *)CAN_AM28H)
+#define pCAN_AM29L			((volatile unsigned short *)CAN_AM29L)
+#define pCAN_AM29H			((volatile unsigned short *)CAN_AM29H)
+#define pCAN_AM30L			((volatile unsigned short *)CAN_AM30L)
+#define pCAN_AM30H			((volatile unsigned short *)CAN_AM30H)
+#define pCAN_AM31L			((volatile unsigned short *)CAN_AM31L)
+#define pCAN_AM31H			((volatile unsigned short *)CAN_AM31H)
+
+/* CAN Acceptance Mask Area Macros	*/
+#define pCAN_AM_L(x)			((volatile unsigned short *)CAN_AM_L(x))
+#define pCAN_AM_H(x)			((volatile unsigned short *)CAN_AM_H(x))
+
+/* Mailbox Registers */
+#define pCAN_MB00_ID1		((volatile unsigned short *)CAN_MB00_ID1)
+#define pCAN_MB00_ID0		((volatile unsigned short *)CAN_MB00_ID0)
+#define pCAN_MB00_TIMESTAMP	((volatile unsigned short *)CAN_MB00_TIMESTAMP)
+#define pCAN_MB00_LENGTH	((volatile unsigned short *)CAN_MB00_LENGTH)
+#define pCAN_MB00_DATA3		((volatile unsigned short *)CAN_MB00_DATA3)
+#define pCAN_MB00_DATA2		((volatile unsigned short *)CAN_MB00_DATA2)
+#define pCAN_MB00_DATA1		((volatile unsigned short *)CAN_MB00_DATA1)
+#define pCAN_MB00_DATA0		((volatile unsigned short *)CAN_MB00_DATA0)
+
+#define pCAN_MB01_ID1		((volatile unsigned short *)CAN_MB01_ID1)
+#define pCAN_MB01_ID0		((volatile unsigned short *)CAN_MB01_ID0)
+#define pCAN_MB01_TIMESTAMP	((volatile unsigned short *)CAN_MB01_TIMESTAMP)
+#define pCAN_MB01_LENGTH	((volatile unsigned short *)CAN_MB01_LENGTH)
+#define pCAN_MB01_DATA3		((volatile unsigned short *)CAN_MB01_DATA3)
+#define pCAN_MB01_DATA2		((volatile unsigned short *)CAN_MB01_DATA2)
+#define pCAN_MB01_DATA1		((volatile unsigned short *)CAN_MB01_DATA1)
+#define pCAN_MB01_DATA0		((volatile unsigned short *)CAN_MB01_DATA0)
+
+#define pCAN_MB02_ID1		((volatile unsigned short *)CAN_MB02_ID1)
+#define pCAN_MB02_ID0		((volatile unsigned short *)CAN_MB02_ID0)
+#define pCAN_MB02_TIMESTAMP	((volatile unsigned short *)CAN_MB02_TIMESTAMP)
+#define pCAN_MB02_LENGTH	((volatile unsigned short *)CAN_MB02_LENGTH)
+#define pCAN_MB02_DATA3		((volatile unsigned short *)CAN_MB02_DATA3)
+#define pCAN_MB02_DATA2		((volatile unsigned short *)CAN_MB02_DATA2)
+#define pCAN_MB02_DATA1		((volatile unsigned short *)CAN_MB02_DATA1)
+#define pCAN_MB02_DATA0		((volatile unsigned short *)CAN_MB02_DATA0)
+
+#define pCAN_MB03_ID1		((volatile unsigned short *)CAN_MB03_ID1)
+#define pCAN_MB03_ID0		((volatile unsigned short *)CAN_MB03_ID0)
+#define pCAN_MB03_TIMESTAMP	((volatile unsigned short *)CAN_MB03_TIMESTAMP)
+#define pCAN_MB03_LENGTH	((volatile unsigned short *)CAN_MB03_LENGTH)
+#define pCAN_MB03_DATA3		((volatile unsigned short *)CAN_MB03_DATA3)
+#define pCAN_MB03_DATA2		((volatile unsigned short *)CAN_MB03_DATA2)
+#define pCAN_MB03_DATA1		((volatile unsigned short *)CAN_MB03_DATA1)
+#define pCAN_MB03_DATA0		((volatile unsigned short *)CAN_MB03_DATA0)
+
+#define pCAN_MB04_ID1		((volatile unsigned short *)CAN_MB04_ID1)
+#define pCAN_MB04_ID0		((volatile unsigned short *)CAN_MB04_ID0)
+#define pCAN_MB04_TIMESTAMP	((volatile unsigned short *)CAN_MB04_TIMESTAMP)
+#define pCAN_MB04_LENGTH	((volatile unsigned short *)CAN_MB04_LENGTH)
+#define pCAN_MB04_DATA3		((volatile unsigned short *)CAN_MB04_DATA3)
+#define pCAN_MB04_DATA2		((volatile unsigned short *)CAN_MB04_DATA2)
+#define pCAN_MB04_DATA1		((volatile unsigned short *)CAN_MB04_DATA1)
+#define pCAN_MB04_DATA0		((volatile unsigned short *)CAN_MB04_DATA0)
+
+#define pCAN_MB05_ID1		((volatile unsigned short *)CAN_MB05_ID1)
+#define pCAN_MB05_ID0		((volatile unsigned short *)CAN_MB05_ID0)
+#define pCAN_MB05_TIMESTAMP	((volatile unsigned short *)CAN_MB05_TIMESTAMP)
+#define pCAN_MB05_LENGTH	((volatile unsigned short *)CAN_MB05_LENGTH)
+#define pCAN_MB05_DATA3		((volatile unsigned short *)CAN_MB05_DATA3)
+#define pCAN_MB05_DATA2		((volatile unsigned short *)CAN_MB05_DATA2)
+#define pCAN_MB05_DATA1		((volatile unsigned short *)CAN_MB05_DATA1)
+#define pCAN_MB05_DATA0		((volatile unsigned short *)CAN_MB05_DATA0)
+
+#define pCAN_MB06_ID1		((volatile unsigned short *)CAN_MB06_ID1)
+#define pCAN_MB06_ID0		((volatile unsigned short *)CAN_MB06_ID0)
+#define pCAN_MB06_TIMESTAMP	((volatile unsigned short *)CAN_MB06_TIMESTAMP)
+#define pCAN_MB06_LENGTH	((volatile unsigned short *)CAN_MB06_LENGTH)
+#define pCAN_MB06_DATA3		((volatile unsigned short *)CAN_MB06_DATA3)
+#define pCAN_MB06_DATA2		((volatile unsigned short *)CAN_MB06_DATA2)
+#define pCAN_MB06_DATA1		((volatile unsigned short *)CAN_MB06_DATA1)
+#define pCAN_MB06_DATA0		((volatile unsigned short *)CAN_MB06_DATA0)
+
+#define pCAN_MB07_ID1		((volatile unsigned short *)CAN_MB07_ID1)
+#define pCAN_MB07_ID0		((volatile unsigned short *)CAN_MB07_ID0)
+#define pCAN_MB07_TIMESTAMP	((volatile unsigned short *)CAN_MB07_TIMESTAMP)
+#define pCAN_MB07_LENGTH	((volatile unsigned short *)CAN_MB07_LENGTH)
+#define pCAN_MB07_DATA3		((volatile unsigned short *)CAN_MB07_DATA3)
+#define pCAN_MB07_DATA2		((volatile unsigned short *)CAN_MB07_DATA2)
+#define pCAN_MB07_DATA1		((volatile unsigned short *)CAN_MB07_DATA1)
+#define pCAN_MB07_DATA0		((volatile unsigned short *)CAN_MB07_DATA0)
+
+#define pCAN_MB08_ID1		((volatile unsigned short *)CAN_MB08_ID1)
+#define pCAN_MB08_ID0		((volatile unsigned short *)CAN_MB08_ID0)
+#define pCAN_MB08_TIMESTAMP	((volatile unsigned short *)CAN_MB08_TIMESTAMP)
+#define pCAN_MB08_LENGTH	((volatile unsigned short *)CAN_MB08_LENGTH)
+#define pCAN_MB08_DATA3		((volatile unsigned short *)CAN_MB08_DATA3)
+#define pCAN_MB08_DATA2		((volatile unsigned short *)CAN_MB08_DATA2)
+#define pCAN_MB08_DATA1		((volatile unsigned short *)CAN_MB08_DATA1)
+#define pCAN_MB08_DATA0		((volatile unsigned short *)CAN_MB08_DATA0)
+
+#define pCAN_MB09_ID1		((volatile unsigned short *)CAN_MB09_ID1)
+#define pCAN_MB09_ID0		((volatile unsigned short *)CAN_MB09_ID0)
+#define pCAN_MB09_TIMESTAMP	((volatile unsigned short *)CAN_MB09_TIMESTAMP)
+#define pCAN_MB09_LENGTH	((volatile unsigned short *)CAN_MB09_LENGTH)
+#define pCAN_MB09_DATA3		((volatile unsigned short *)CAN_MB09_DATA3)
+#define pCAN_MB09_DATA2		((volatile unsigned short *)CAN_MB09_DATA2)
+#define pCAN_MB09_DATA1		((volatile unsigned short *)CAN_MB09_DATA1)
+#define pCAN_MB09_DATA0		((volatile unsigned short *)CAN_MB09_DATA0)
+
+#define pCAN_MB10_ID1		((volatile unsigned short *)CAN_MB10_ID1)
+#define pCAN_MB10_ID0		((volatile unsigned short *)CAN_MB10_ID0)
+#define pCAN_MB10_TIMESTAMP	((volatile unsigned short *)CAN_MB10_TIMESTAMP)
+#define pCAN_MB10_LENGTH	((volatile unsigned short *)CAN_MB10_LENGTH)
+#define pCAN_MB10_DATA3		((volatile unsigned short *)CAN_MB10_DATA3)
+#define pCAN_MB10_DATA2		((volatile unsigned short *)CAN_MB10_DATA2)
+#define pCAN_MB10_DATA1		((volatile unsigned short *)CAN_MB10_DATA1)
+#define pCAN_MB10_DATA0		((volatile unsigned short *)CAN_MB10_DATA0)
+
+#define pCAN_MB11_ID1		((volatile unsigned short *)CAN_MB11_ID1)
+#define pCAN_MB11_ID0		((volatile unsigned short *)CAN_MB11_ID0)
+#define pCAN_MB11_TIMESTAMP	((volatile unsigned short *)CAN_MB11_TIMESTAMP)
+#define pCAN_MB11_LENGTH	((volatile unsigned short *)CAN_MB11_LENGTH)
+#define pCAN_MB11_DATA3		((volatile unsigned short *)CAN_MB11_DATA3)
+#define pCAN_MB11_DATA2		((volatile unsigned short *)CAN_MB11_DATA2)
+#define pCAN_MB11_DATA1		((volatile unsigned short *)CAN_MB11_DATA1)
+#define pCAN_MB11_DATA0		((volatile unsigned short *)CAN_MB11_DATA0)
+
+#define pCAN_MB12_ID1		((volatile unsigned short *)CAN_MB12_ID1)
+#define pCAN_MB12_ID0		((volatile unsigned short *)CAN_MB12_ID0)
+#define pCAN_MB12_TIMESTAMP	((volatile unsigned short *)CAN_MB12_TIMESTAMP)
+#define pCAN_MB12_LENGTH	((volatile unsigned short *)CAN_MB12_LENGTH)
+#define pCAN_MB12_DATA3		((volatile unsigned short *)CAN_MB12_DATA3)
+#define pCAN_MB12_DATA2		((volatile unsigned short *)CAN_MB12_DATA2)
+#define pCAN_MB12_DATA1		((volatile unsigned short *)CAN_MB12_DATA1)
+#define pCAN_MB12_DATA0		((volatile unsigned short *)CAN_MB12_DATA0)
+
+#define pCAN_MB13_ID1		((volatile unsigned short *)CAN_MB13_ID1)
+#define pCAN_MB13_ID0		((volatile unsigned short *)CAN_MB13_ID0)
+#define pCAN_MB13_TIMESTAMP	((volatile unsigned short *)CAN_MB13_TIMESTAMP)
+#define pCAN_MB13_LENGTH	((volatile unsigned short *)CAN_MB13_LENGTH)
+#define pCAN_MB13_DATA3		((volatile unsigned short *)CAN_MB13_DATA3)
+#define pCAN_MB13_DATA2		((volatile unsigned short *)CAN_MB13_DATA2)
+#define pCAN_MB13_DATA1		((volatile unsigned short *)CAN_MB13_DATA1)
+#define pCAN_MB13_DATA0		((volatile unsigned short *)CAN_MB13_DATA0)
+
+#define pCAN_MB14_ID1		((volatile unsigned short *)CAN_MB14_ID1)
+#define pCAN_MB14_ID0		((volatile unsigned short *)CAN_MB14_ID0)
+#define pCAN_MB14_TIMESTAMP	((volatile unsigned short *)CAN_MB14_TIMESTAMP)
+#define pCAN_MB14_LENGTH	((volatile unsigned short *)CAN_MB14_LENGTH)
+#define pCAN_MB14_DATA3		((volatile unsigned short *)CAN_MB14_DATA3)
+#define pCAN_MB14_DATA2		((volatile unsigned short *)CAN_MB14_DATA2)
+#define pCAN_MB14_DATA1		((volatile unsigned short *)CAN_MB14_DATA1)
+#define pCAN_MB14_DATA0		((volatile unsigned short *)CAN_MB14_DATA0)
+
+#define pCAN_MB15_ID1		((volatile unsigned short *)CAN_MB15_ID1)
+#define pCAN_MB15_ID0		((volatile unsigned short *)CAN_MB15_ID0)
+#define pCAN_MB15_TIMESTAMP	((volatile unsigned short *)CAN_MB15_TIMESTAMP)
+#define pCAN_MB15_LENGTH	((volatile unsigned short *)CAN_MB15_LENGTH)
+#define pCAN_MB15_DATA3		((volatile unsigned short *)CAN_MB15_DATA3)
+#define pCAN_MB15_DATA2		((volatile unsigned short *)CAN_MB15_DATA2)
+#define pCAN_MB15_DATA1		((volatile unsigned short *)CAN_MB15_DATA1)
+#define pCAN_MB15_DATA0		((volatile unsigned short *)CAN_MB15_DATA0)
+
+#define pCAN_MB16_ID1		((volatile unsigned short *)CAN_MB16_ID1)
+#define pCAN_MB16_ID0		((volatile unsigned short *)CAN_MB16_ID0)
+#define pCAN_MB16_TIMESTAMP	((volatile unsigned short *)CAN_MB16_TIMESTAMP)
+#define pCAN_MB16_LENGTH	((volatile unsigned short *)CAN_MB16_LENGTH)
+#define pCAN_MB16_DATA3		((volatile unsigned short *)CAN_MB16_DATA3)
+#define pCAN_MB16_DATA2		((volatile unsigned short *)CAN_MB16_DATA2)
+#define pCAN_MB16_DATA1		((volatile unsigned short *)CAN_MB16_DATA1)
+#define pCAN_MB16_DATA0		((volatile unsigned short *)CAN_MB16_DATA0)
+
+#define pCAN_MB17_ID1		((volatile unsigned short *)CAN_MB17_ID1)
+#define pCAN_MB17_ID0		((volatile unsigned short *)CAN_MB17_ID0)
+#define pCAN_MB17_TIMESTAMP	((volatile unsigned short *)CAN_MB17_TIMESTAMP)
+#define pCAN_MB17_LENGTH	((volatile unsigned short *)CAN_MB17_LENGTH)
+#define pCAN_MB17_DATA3		((volatile unsigned short *)CAN_MB17_DATA3)
+#define pCAN_MB17_DATA2		((volatile unsigned short *)CAN_MB17_DATA2)
+#define pCAN_MB17_DATA1		((volatile unsigned short *)CAN_MB17_DATA1)
+#define pCAN_MB17_DATA0		((volatile unsigned short *)CAN_MB17_DATA0)
+
+#define pCAN_MB18_ID1		((volatile unsigned short *)CAN_MB18_ID1)
+#define pCAN_MB18_ID0		((volatile unsigned short *)CAN_MB18_ID0)
+#define pCAN_MB18_TIMESTAMP	((volatile unsigned short *)CAN_MB18_TIMESTAMP)
+#define pCAN_MB18_LENGTH	((volatile unsigned short *)CAN_MB18_LENGTH)
+#define pCAN_MB18_DATA3		((volatile unsigned short *)CAN_MB18_DATA3)
+#define pCAN_MB18_DATA2		((volatile unsigned short *)CAN_MB18_DATA2)
+#define pCAN_MB18_DATA1		((volatile unsigned short *)CAN_MB18_DATA1)
+#define pCAN_MB18_DATA0		((volatile unsigned short *)CAN_MB18_DATA0)
+
+#define pCAN_MB19_ID1		((volatile unsigned short *)CAN_MB19_ID1)
+#define pCAN_MB19_ID0		((volatile unsigned short *)CAN_MB19_ID0)
+#define pCAN_MB19_TIMESTAMP	((volatile unsigned short *)CAN_MB19_TIMESTAMP)
+#define pCAN_MB19_LENGTH	((volatile unsigned short *)CAN_MB19_LENGTH)
+#define pCAN_MB19_DATA3		((volatile unsigned short *)CAN_MB19_DATA3)
+#define pCAN_MB19_DATA2		((volatile unsigned short *)CAN_MB19_DATA2)
+#define pCAN_MB19_DATA1		((volatile unsigned short *)CAN_MB19_DATA1)
+#define pCAN_MB19_DATA0		((volatile unsigned short *)CAN_MB19_DATA0)
+
+#define pCAN_MB20_ID1		((volatile unsigned short *)CAN_MB20_ID1)
+#define pCAN_MB20_ID0		((volatile unsigned short *)CAN_MB20_ID0)
+#define pCAN_MB20_TIMESTAMP	((volatile unsigned short *)CAN_MB20_TIMESTAMP)
+#define pCAN_MB20_LENGTH	((volatile unsigned short *)CAN_MB20_LENGTH)
+#define pCAN_MB20_DATA3		((volatile unsigned short *)CAN_MB20_DATA3)
+#define pCAN_MB20_DATA2		((volatile unsigned short *)CAN_MB20_DATA2)
+#define pCAN_MB20_DATA1		((volatile unsigned short *)CAN_MB20_DATA1)
+#define pCAN_MB20_DATA0		((volatile unsigned short *)CAN_MB20_DATA0)
+
+#define pCAN_MB21_ID1		((volatile unsigned short *)CAN_MB21_ID1)
+#define pCAN_MB21_ID0		((volatile unsigned short *)CAN_MB21_ID0)
+#define pCAN_MB21_TIMESTAMP	((volatile unsigned short *)CAN_MB21_TIMESTAMP)
+#define pCAN_MB21_LENGTH	((volatile unsigned short *)CAN_MB21_LENGTH)
+#define pCAN_MB21_DATA3		((volatile unsigned short *)CAN_MB21_DATA3)
+#define pCAN_MB21_DATA2		((volatile unsigned short *)CAN_MB21_DATA2)
+#define pCAN_MB21_DATA1		((volatile unsigned short *)CAN_MB21_DATA1)
+#define pCAN_MB21_DATA0		((volatile unsigned short *)CAN_MB21_DATA0)
+
+#define pCAN_MB22_ID1		((volatile unsigned short *)CAN_MB22_ID1)
+#define pCAN_MB22_ID0		((volatile unsigned short *)CAN_MB22_ID0)
+#define pCAN_MB22_TIMESTAMP	((volatile unsigned short *)CAN_MB22_TIMESTAMP)
+#define pCAN_MB22_LENGTH	((volatile unsigned short *)CAN_MB22_LENGTH)
+#define pCAN_MB22_DATA3		((volatile unsigned short *)CAN_MB22_DATA3)
+#define pCAN_MB22_DATA2		((volatile unsigned short *)CAN_MB22_DATA2)
+#define pCAN_MB22_DATA1		((volatile unsigned short *)CAN_MB22_DATA1)
+#define pCAN_MB22_DATA0		((volatile unsigned short *)CAN_MB22_DATA0)
+
+#define pCAN_MB23_ID1		((volatile unsigned short *)CAN_MB23_ID1)
+#define pCAN_MB23_ID0		((volatile unsigned short *)CAN_MB23_ID0)
+#define pCAN_MB23_TIMESTAMP	((volatile unsigned short *)CAN_MB23_TIMESTAMP)
+#define pCAN_MB23_LENGTH	((volatile unsigned short *)CAN_MB23_LENGTH)
+#define pCAN_MB23_DATA3		((volatile unsigned short *)CAN_MB23_DATA3)
+#define pCAN_MB23_DATA2		((volatile unsigned short *)CAN_MB23_DATA2)
+#define pCAN_MB23_DATA1		((volatile unsigned short *)CAN_MB23_DATA1)
+#define pCAN_MB23_DATA0		((volatile unsigned short *)CAN_MB23_DATA0)
+
+#define pCAN_MB24_ID1		((volatile unsigned short *)CAN_MB24_ID1)
+#define pCAN_MB24_ID0		((volatile unsigned short *)CAN_MB24_ID0)
+#define pCAN_MB24_TIMESTAMP	((volatile unsigned short *)CAN_MB24_TIMESTAMP)
+#define pCAN_MB24_LENGTH	((volatile unsigned short *)CAN_MB24_LENGTH)
+#define pCAN_MB24_DATA3		((volatile unsigned short *)CAN_MB24_DATA3)
+#define pCAN_MB24_DATA2		((volatile unsigned short *)CAN_MB24_DATA2)
+#define pCAN_MB24_DATA1		((volatile unsigned short *)CAN_MB24_DATA1)
+#define pCAN_MB24_DATA0		((volatile unsigned short *)CAN_MB24_DATA0)
+
+#define pCAN_MB25_ID1		((volatile unsigned short *)CAN_MB25_ID1)
+#define pCAN_MB25_ID0		((volatile unsigned short *)CAN_MB25_ID0)
+#define pCAN_MB25_TIMESTAMP	((volatile unsigned short *)CAN_MB25_TIMESTAMP)
+#define pCAN_MB25_LENGTH	((volatile unsigned short *)CAN_MB25_LENGTH)
+#define pCAN_MB25_DATA3		((volatile unsigned short *)CAN_MB25_DATA3)
+#define pCAN_MB25_DATA2		((volatile unsigned short *)CAN_MB25_DATA2)
+#define pCAN_MB25_DATA1		((volatile unsigned short *)CAN_MB25_DATA1)
+#define pCAN_MB25_DATA0		((volatile unsigned short *)CAN_MB25_DATA0)
+
+#define pCAN_MB26_ID1		((volatile unsigned short *)CAN_MB26_ID1)
+#define pCAN_MB26_ID0		((volatile unsigned short *)CAN_MB26_ID0)
+#define pCAN_MB26_TIMESTAMP	((volatile unsigned short *)CAN_MB26_TIMESTAMP)
+#define pCAN_MB26_LENGTH	((volatile unsigned short *)CAN_MB26_LENGTH)
+#define pCAN_MB26_DATA3		((volatile unsigned short *)CAN_MB26_DATA3)
+#define pCAN_MB26_DATA2		((volatile unsigned short *)CAN_MB26_DATA2)
+#define pCAN_MB26_DATA1		((volatile unsigned short *)CAN_MB26_DATA1)
+#define pCAN_MB26_DATA0		((volatile unsigned short *)CAN_MB26_DATA0)
+
+#define pCAN_MB27_ID1		((volatile unsigned short *)CAN_MB27_ID1)
+#define pCAN_MB27_ID0		((volatile unsigned short *)CAN_MB27_ID0)
+#define pCAN_MB27_TIMESTAMP	((volatile unsigned short *)CAN_MB27_TIMESTAMP)
+#define pCAN_MB27_LENGTH	((volatile unsigned short *)CAN_MB27_LENGTH)
+#define pCAN_MB27_DATA3		((volatile unsigned short *)CAN_MB27_DATA3)
+#define pCAN_MB27_DATA2		((volatile unsigned short *)CAN_MB27_DATA2)
+#define pCAN_MB27_DATA1		((volatile unsigned short *)CAN_MB27_DATA1)
+#define pCAN_MB27_DATA0		((volatile unsigned short *)CAN_MB27_DATA0)
+
+#define pCAN_MB28_ID1		((volatile unsigned short *)CAN_MB28_ID1)
+#define pCAN_MB28_ID0		((volatile unsigned short *)CAN_MB28_ID0)
+#define pCAN_MB28_TIMESTAMP	((volatile unsigned short *)CAN_MB28_TIMESTAMP)
+#define pCAN_MB28_LENGTH	((volatile unsigned short *)CAN_MB28_LENGTH)
+#define pCAN_MB28_DATA3		((volatile unsigned short *)CAN_MB28_DATA3)
+#define pCAN_MB28_DATA2		((volatile unsigned short *)CAN_MB28_DATA2)
+#define pCAN_MB28_DATA1		((volatile unsigned short *)CAN_MB28_DATA1)
+#define pCAN_MB28_DATA0		((volatile unsigned short *)CAN_MB28_DATA0)
+
+#define pCAN_MB29_ID1		((volatile unsigned short *)CAN_MB29_ID1)
+#define pCAN_MB29_ID0		((volatile unsigned short *)CAN_MB29_ID0)
+#define pCAN_MB29_TIMESTAMP	((volatile unsigned short *)CAN_MB29_TIMESTAMP)
+#define pCAN_MB29_LENGTH	((volatile unsigned short *)CAN_MB29_LENGTH)
+#define pCAN_MB29_DATA3		((volatile unsigned short *)CAN_MB29_DATA3)
+#define pCAN_MB29_DATA2		((volatile unsigned short *)CAN_MB29_DATA2)
+#define pCAN_MB29_DATA1		((volatile unsigned short *)CAN_MB29_DATA1)
+#define pCAN_MB29_DATA0		((volatile unsigned short *)CAN_MB29_DATA0)
+
+#define pCAN_MB30_ID1		((volatile unsigned short *)CAN_MB30_ID1)
+#define pCAN_MB30_ID0		((volatile unsigned short *)CAN_MB30_ID0)
+#define pCAN_MB30_TIMESTAMP	((volatile unsigned short *)CAN_MB30_TIMESTAMP)
+#define pCAN_MB30_LENGTH	((volatile unsigned short *)CAN_MB30_LENGTH)
+#define pCAN_MB30_DATA3		((volatile unsigned short *)CAN_MB30_DATA3)
+#define pCAN_MB30_DATA2		((volatile unsigned short *)CAN_MB30_DATA2)
+#define pCAN_MB30_DATA1		((volatile unsigned short *)CAN_MB30_DATA1)
+#define pCAN_MB30_DATA0		((volatile unsigned short *)CAN_MB30_DATA0)
+
+#define pCAN_MB31_ID1		((volatile unsigned short *)CAN_MB31_ID1)
+#define pCAN_MB31_ID0		((volatile unsigned short *)CAN_MB31_ID0)
+#define pCAN_MB31_TIMESTAMP	((volatile unsigned short *)CAN_MB31_TIMESTAMP)
+#define pCAN_MB31_LENGTH	((volatile unsigned short *)CAN_MB31_LENGTH)
+#define pCAN_MB31_DATA3		((volatile unsigned short *)CAN_MB31_DATA3)
+#define pCAN_MB31_DATA2		((volatile unsigned short *)CAN_MB31_DATA2)
+#define pCAN_MB31_DATA1		((volatile unsigned short *)CAN_MB31_DATA1)
+#define pCAN_MB31_DATA0		((volatile unsigned short *)CAN_MB31_DATA0)
+
+/* CAN Mailbox Area Macros		*/
+#define pCAN_MB_ID1(x)			((volatile unsigned short *)CAN_MB_ID1(x))
+#define pCAN_MB_ID0(x)			((volatile unsigned short *)CAN_MB_ID0(x))
+#define pCAN_MB_TIMESTAMP(x)	((volatile unsigned short *)CAN_MB_TIMESTAMP(x))
+#define pCAN_MB_LENGTH(x)		((volatile unsigned short *)CAN_MB_LENGTH(x))
+#define pCAN_MB_DATA3(x)		((volatile unsigned short *)CAN_MB_DATA3(x))
+#define pCAN_MB_DATA2(x)		((volatile unsigned short *)CAN_MB_DATA2(x))
+#define pCAN_MB_DATA1(x)		((volatile unsigned short *)CAN_MB_DATA1(x))
+#define pCAN_MB_DATA0(x)		((volatile unsigned short *)CAN_MB_DATA0(x))
+
+/* Pin Control Registers	(0xFFC03200 - 0xFFC032FF)								*/
+#define pPORTF_FER			((volatile unsigned short *)PORTF_FER)
+#define pPORTG_FER			((volatile unsigned short *)PORTG_FER)
+#define pPORTH_FER			((volatile unsigned short *)PORTH_FER)
+#define pPORT_MUX			((volatile unsigned short *)PORT_MUX)
+
+/* Handshake MDMA Registers	(0xFFC03300 - 0xFFC033FF)								*/
+#define pHMDMA0_CONTROL		((volatile unsigned short *)HMDMA0_CONTROL)
+#define pHMDMA0_ECINIT		((volatile unsigned short *)HMDMA0_ECINIT)
+#define pHMDMA0_BCINIT		((volatile unsigned short *)HMDMA0_BCINIT)
+#define pHMDMA0_ECURGENT	((volatile unsigned short *)HMDMA0_ECURGENT)
+#define pHMDMA0_ECOVERFLOW	((volatile unsigned short *)HMDMA0_ECOVERFLOW)
+#define pHMDMA0_ECOUNT		((volatile unsigned short *)HMDMA0_ECOUNT)
+#define pHMDMA0_BCOUNT		((volatile unsigned short *)HMDMA0_BCOUNT)
+
+#define pHMDMA1_CONTROL		((volatile unsigned short *)HMDMA1_CONTROL)
+#define pHMDMA1_ECINIT		((volatile unsigned short *)HMDMA1_ECINIT)
+#define pHMDMA1_BCINIT		((volatile unsigned short *)HMDMA1_BCINIT)
+#define pHMDMA1_ECURGENT	((volatile unsigned short *)HMDMA1_ECURGENT)
+#define pHMDMA1_ECOVERFLOW	((volatile unsigned short *)HMDMA1_ECOVERFLOW)
+#define pHMDMA1_ECOUNT		((volatile unsigned short *)HMDMA1_ECOUNT)
+#define pHMDMA1_BCOUNT		((volatile unsigned short *)HMDMA1_BCOUNT)
+
+#endif				/* _CDEF_BF534_H */
Index: git/linux-2.6/include/asm-blackfin/mach-bf537/cdefBF537.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf537/cdefBF537.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,127 @@
+/*
+ * File:         include/asm-blackfin/mach-bf537/cdefBF537.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *	System MMR Register Map
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _CDEF_BF537_H
+#define _CDEF_BF537_H
+
+/* Include MMRs Common to BF534 								*/
+#include "cdefBF534.h"
+
+/* Include all Core registers and bit definitions 									*/
+#include "defBF537.h"
+
+/* Include Macro "Defines" For EMAC (Unique to BF536/BF537		*/
+/* 10/100 Ethernet Controller	(0xFFC03000 - 0xFFC031FF) 						*/
+#define	pEMAC_OPMODE		((volatile unsigned long  *)EMAC_OPMODE)
+#define pEMAC_ADDRLO		((volatile unsigned long  *)EMAC_ADDRLO)
+#define pEMAC_ADDRHI		((volatile unsigned long  *)EMAC_ADDRHI)
+#define pEMAC_HASHLO		((volatile unsigned long  *)EMAC_HASHLO)
+#define pEMAC_HASHHI		((volatile unsigned long  *)EMAC_HASHHI)
+#define pEMAC_STAADD		((volatile unsigned long  *)EMAC_STAADD)
+#define pEMAC_STADAT		((volatile unsigned long  *)EMAC_STADAT)
+#define pEMAC_FLC			((volatile unsigned long  *)EMAC_FLC)
+#define pEMAC_VLAN1			((volatile unsigned long  *)EMAC_VLAN1)
+#define pEMAC_VLAN2			((volatile unsigned long  *)EMAC_VLAN2)
+#define pEMAC_WKUP_CTL		((volatile unsigned long  *)EMAC_WKUP_CTL)
+#define pEMAC_WKUP_FFMSK0	((volatile unsigned long  *)EMAC_WKUP_FFMSK0)
+#define pEMAC_WKUP_FFMSK1	((volatile unsigned long  *)EMAC_WKUP_FFMSK1)
+#define pEMAC_WKUP_FFMSK2	((volatile unsigned long  *)EMAC_WKUP_FFMSK2)
+#define pEMAC_WKUP_FFMSK3	((volatile unsigned long  *)EMAC_WKUP_FFMSK3)
+#define pEMAC_WKUP_FFCMD	((volatile unsigned long  *)EMAC_WKUP_FFCMD)
+#define pEMAC_WKUP_FFOFF	((volatile unsigned long  *)EMAC_WKUP_FFOFF)
+#define pEMAC_WKUP_FFCRC0	((volatile unsigned long  *)EMAC_WKUP_FFCRC0)
+#define pEMAC_WKUP_FFCRC1	((volatile unsigned long  *)EMAC_WKUP_FFCRC1)
+
+#define	pEMAC_SYSCTL		((volatile unsigned long  *)EMAC_SYSCTL)
+#define pEMAC_SYSTAT		((volatile unsigned long  *)EMAC_SYSTAT)
+#define pEMAC_RX_STAT		((volatile unsigned long  *)EMAC_RX_STAT)
+#define pEMAC_RX_STKY		((volatile unsigned long  *)EMAC_RX_STKY)
+#define pEMAC_RX_IRQE		((volatile unsigned long  *)EMAC_RX_IRQE)
+#define pEMAC_TX_STAT		((volatile unsigned long  *)EMAC_TX_STAT)
+#define pEMAC_TX_STKY		((volatile unsigned long  *)EMAC_TX_STKY)
+#define pEMAC_TX_IRQE		((volatile unsigned long  *)EMAC_TX_IRQE)
+
+#define pEMAC_MMC_CTL		((volatile unsigned long  *)EMAC_MMC_CTL)
+#define pEMAC_MMC_RIRQS		((volatile unsigned long  *)EMAC_MMC_RIRQS)
+#define pEMAC_MMC_RIRQE		((volatile unsigned long  *)EMAC_MMC_RIRQE)
+#define pEMAC_MMC_TIRQS		((volatile unsigned long  *)EMAC_MMC_TIRQS)
+#define pEMAC_MMC_TIRQE		((volatile unsigned long  *)EMAC_MMC_TIRQE)
+
+#define pEMAC_RXC_OK		((volatile unsigned long  *)EMAC_RXC_OK)
+#define pEMAC_RXC_FCS		((volatile unsigned long  *)EMAC_RXC_FCS)
+#define pEMAC_RXC_ALIGN		((volatile unsigned long  *)EMAC_RXC_ALIGN)
+#define pEMAC_RXC_OCTET		((volatile unsigned long  *)EMAC_RXC_OCTET)
+#define pEMAC_RXC_DMAOVF	((volatile unsigned long  *)EMAC_RXC_DMAOVF)
+#define pEMAC_RXC_UNICST	((volatile unsigned long  *)EMAC_RXC_UNICST)
+#define pEMAC_RXC_MULTI		((volatile unsigned long  *)EMAC_RXC_MULTI)
+#define pEMAC_RXC_BROAD		((volatile unsigned long  *)EMAC_RXC_BROAD)
+#define pEMAC_RXC_LNERRI	((volatile unsigned long  *)EMAC_RXC_LNERRI)
+#define pEMAC_RXC_LNERRO	((volatile unsigned long  *)EMAC_RXC_LNERRO)
+#define pEMAC_RXC_LONG		((volatile unsigned long  *)EMAC_RXC_LONG)
+#define pEMAC_RXC_MACCTL	((volatile unsigned long  *)EMAC_RXC_MACCTL)
+#define pEMAC_RXC_OPCODE	((volatile unsigned long  *)EMAC_RXC_OPCODE)
+#define pEMAC_RXC_PAUSE		((volatile unsigned long  *)EMAC_RXC_PAUSE)
+#define pEMAC_RXC_ALLFRM	((volatile unsigned long  *)EMAC_RXC_ALLFRM)
+#define pEMAC_RXC_ALLOCT	((volatile unsigned long  *)EMAC_RXC_ALLOCT)
+#define pEMAC_RXC_TYPED		((volatile unsigned long  *)EMAC_RXC_TYPED)
+#define pEMAC_RXC_SHORT		((volatile unsigned long  *)EMAC_RXC_SHORT)
+#define pEMAC_RXC_EQ64		((volatile unsigned long  *)EMAC_RXC_EQ64)
+#define	pEMAC_RXC_LT128		((volatile unsigned long  *)EMAC_RXC_LT128)
+#define pEMAC_RXC_LT256		((volatile unsigned long  *)EMAC_RXC_LT256)
+#define pEMAC_RXC_LT512		((volatile unsigned long  *)EMAC_RXC_LT512)
+#define pEMAC_RXC_LT1024	((volatile unsigned long  *)EMAC_RXC_LT1024)
+#define pEMAC_RXC_GE1024	((volatile unsigned long  *)EMAC_RXC_GE1024)
+
+#define pEMAC_TXC_OK		((volatile unsigned long  *)EMAC_TXC_OK)
+#define pEMAC_TXC_1COL		((volatile unsigned long  *)EMAC_TXC_1COL)
+#define pEMAC_TXC_GT1COL	((volatile unsigned long  *)EMAC_TXC_GT1COL)
+#define pEMAC_TXC_OCTET		((volatile unsigned long  *)EMAC_TXC_OCTET)
+#define pEMAC_TXC_DEFER		((volatile unsigned long  *)EMAC_TXC_DEFER)
+#define pEMAC_TXC_LATECL	((volatile unsigned long  *)EMAC_TXC_LATECL)
+#define pEMAC_TXC_XS_COL	((volatile unsigned long  *)EMAC_TXC_XS_COL)
+#define pEMAC_TXC_DMAUND	((volatile unsigned long  *)EMAC_TXC_DMAUND)
+#define pEMAC_TXC_CRSERR	((volatile unsigned long  *)EMAC_TXC_CRSERR)
+#define pEMAC_TXC_UNICST	((volatile unsigned long  *)EMAC_TXC_UNICST)
+#define pEMAC_TXC_MULTI		((volatile unsigned long  *)EMAC_TXC_MULTI)
+#define pEMAC_TXC_BROAD		((volatile unsigned long  *)EMAC_TXC_BROAD)
+#define pEMAC_TXC_XS_DFR	((volatile unsigned long  *)EMAC_TXC_XS_DFR)
+#define pEMAC_TXC_MACCTL	((volatile unsigned long  *)EMAC_TXC_MACCTL)
+#define pEMAC_TXC_ALLFRM	((volatile unsigned long  *)EMAC_TXC_ALLFRM)
+#define pEMAC_TXC_ALLOCT	((volatile unsigned long  *)EMAC_TXC_ALLOCT)
+#define pEMAC_TXC_EQ64		((volatile unsigned long  *)EMAC_TXC_EQ64)
+#define pEMAC_TXC_LT128		((volatile unsigned long  *)EMAC_TXC_LT128)
+#define pEMAC_TXC_LT256		((volatile unsigned long  *)EMAC_TXC_LT256)
+#define pEMAC_TXC_LT512		((volatile unsigned long  *)EMAC_TXC_LT512)
+#define pEMAC_TXC_LT1024	((volatile unsigned long  *)EMAC_TXC_LT1024)
+#define pEMAC_TXC_GE1024	((volatile unsigned long  *)EMAC_TXC_GE1024)
+#define pEMAC_TXC_ABORT		((volatile unsigned long  *)EMAC_TXC_ABORT)
+
+#endif				/* _CDEF_BF537_H */
Index: git/linux-2.6/include/asm-blackfin/mach-bf537/defBF534.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf537/defBF534.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,2515 @@
+/*
+ * File:         include/asm-blackfin/mach-bf537/cdefBF537.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DEF_BF534_H
+#define _DEF_BF534_H
+
+/* Include all Core registers and bit definitions */
+#include <asm/mach-common/def_LPBlackfin.h>
+
+/************************************************************************************
+** System MMR Register Map
+*************************************************************************************/
+/* Clock and System Control	(0xFFC00000 - 0xFFC000FF)								*/
+#define PLL_CTL				0xFFC00000	/* PLL Control Register						*/
+#define PLL_DIV				0xFFC00004	/* PLL Divide Register						*/
+#define VR_CTL				0xFFC00008	/* Voltage Regulator Control Register		*/
+#define PLL_STAT			0xFFC0000C	/* PLL Status Register						*/
+#define PLL_LOCKCNT			0xFFC00010	/* PLL Lock Count Register					*/
+
+/* System Interrupt Controller (0xFFC00100 - 0xFFC001FF)							*/
+#define SWRST				0xFFC00100	/* Software Reset Register					*/
+#define SYSCR				0xFFC00104	/* System Configuration Register			*/
+#define SIC_RVECT			0xFFC00108	/* Interrupt Reset Vector Address Register	*/
+#define SIC_IMASK			0xFFC0010C	/* Interrupt Mask Register					*/
+#define SIC_IAR0			0xFFC00110	/* Interrupt Assignment Register 0			*/
+#define SIC_IAR1			0xFFC00114	/* Interrupt Assignment Register 1			*/
+#define SIC_IAR2			0xFFC00118	/* Interrupt Assignment Register 2			*/
+#define SIC_IAR3			0xFFC0011C	/* Interrupt Assignment Register 3			*/
+#define SIC_ISR				0xFFC00120	/* Interrupt Status Register				*/
+#define SIC_IWR				0xFFC00124	/* Interrupt Wakeup Register				*/
+
+/* Watchdog Timer			(0xFFC00200 - 0xFFC002FF)								*/
+#define WDOG_CTL			0xFFC00200	/* Watchdog Control Register				*/
+#define WDOG_CNT			0xFFC00204	/* Watchdog Count Register					*/
+#define WDOG_STAT			0xFFC00208	/* Watchdog Status Register					*/
+
+/* Real Time Clock		(0xFFC00300 - 0xFFC003FF)									*/
+#define RTC_STAT			0xFFC00300	/* RTC Status Register						*/
+#define RTC_ICTL			0xFFC00304	/* RTC Interrupt Control Register			*/
+#define RTC_ISTAT			0xFFC00308	/* RTC Interrupt Status Register			*/
+#define RTC_SWCNT			0xFFC0030C	/* RTC Stopwatch Count Register				*/
+#define RTC_ALARM			0xFFC00310	/* RTC Alarm Time Register					*/
+#define RTC_FAST			0xFFC00314	/* RTC Prescaler Enable Register			*/
+#define RTC_PREN			0xFFC00314	/* RTC Prescaler Enable Alternate Macro		*/
+
+/* UART0 Controller		(0xFFC00400 - 0xFFC004FF)									*/
+#define UART0_THR			0xFFC00400	/* Transmit Holding register				*/
+#define UART0_RBR			0xFFC00400	/* Receive Buffer register					*/
+#define UART0_DLL			0xFFC00400	/* Divisor Latch (Low-Byte)					*/
+#define UART0_IER			0xFFC00404	/* Interrupt Enable Register				*/
+#define UART0_DLH			0xFFC00404	/* Divisor Latch (High-Byte)				*/
+#define UART0_IIR			0xFFC00408	/* Interrupt Identification Register		*/
+#define UART0_LCR			0xFFC0040C	/* Line Control Register					*/
+#define UART0_MCR			0xFFC00410	/* Modem Control Register					*/
+#define UART0_LSR			0xFFC00414	/* Line Status Register						*/
+#define UART0_MSR			0xFFC00418	/* Modem Status Register					*/
+#define UART0_SCR			0xFFC0041C	/* SCR Scratch Register						*/
+#define UART0_GCTL			0xFFC00424	/* Global Control Register					*/
+
+/* SPI Controller			(0xFFC00500 - 0xFFC005FF)								*/
+#define SPI_CTL				0xFFC00500	/* SPI Control Register						*/
+#define SPI_FLG				0xFFC00504	/* SPI Flag register						*/
+#define SPI_STAT			0xFFC00508	/* SPI Status register						*/
+#define SPI_TDBR			0xFFC0050C	/* SPI Transmit Data Buffer Register		*/
+#define SPI_RDBR			0xFFC00510	/* SPI Receive Data Buffer Register			*/
+#define SPI_BAUD			0xFFC00514	/* SPI Baud rate Register					*/
+#define SPI_SHADOW			0xFFC00518	/* SPI_RDBR Shadow Register					*/
+
+/* TIMER0-7 Registers		(0xFFC00600 - 0xFFC006FF)								*/
+#define TIMER0_CONFIG		0xFFC00600	/* Timer 0 Configuration Register			*/
+#define TIMER0_COUNTER		0xFFC00604	/* Timer 0 Counter Register					*/
+#define TIMER0_PERIOD		0xFFC00608	/* Timer 0 Period Register					*/
+#define TIMER0_WIDTH		0xFFC0060C	/* Timer 0 Width Register					*/
+
+#define TIMER1_CONFIG		0xFFC00610	/* Timer 1 Configuration Register  			*/
+#define TIMER1_COUNTER		0xFFC00614	/* Timer 1 Counter Register        			*/
+#define TIMER1_PERIOD		0xFFC00618	/* Timer 1 Period Register         			*/
+#define TIMER1_WIDTH		0xFFC0061C	/* Timer 1 Width Register          			*/
+
+#define TIMER2_CONFIG		0xFFC00620	/* Timer 2 Configuration Register  			*/
+#define TIMER2_COUNTER		0xFFC00624	/* Timer 2 Counter Register        			*/
+#define TIMER2_PERIOD		0xFFC00628	/* Timer 2 Period Register         			*/
+#define TIMER2_WIDTH		0xFFC0062C	/* Timer 2 Width Register          			*/
+
+#define TIMER3_CONFIG		0xFFC00630	/* Timer 3 Configuration Register			*/
+#define TIMER3_COUNTER		0xFFC00634	/* Timer 3 Counter Register					*/
+#define TIMER3_PERIOD		0xFFC00638	/* Timer 3 Period Register					*/
+#define TIMER3_WIDTH		0xFFC0063C	/* Timer 3 Width Register					*/
+
+#define TIMER4_CONFIG		0xFFC00640	/* Timer 4 Configuration Register  			*/
+#define TIMER4_COUNTER		0xFFC00644	/* Timer 4 Counter Register        			*/
+#define TIMER4_PERIOD		0xFFC00648	/* Timer 4 Period Register         			*/
+#define TIMER4_WIDTH		0xFFC0064C	/* Timer 4 Width Register          			*/
+
+#define TIMER5_CONFIG		0xFFC00650	/* Timer 5 Configuration Register  			*/
+#define TIMER5_COUNTER		0xFFC00654	/* Timer 5 Counter Register        			*/
+#define TIMER5_PERIOD		0xFFC00658	/* Timer 5 Period Register         			*/
+#define TIMER5_WIDTH		0xFFC0065C	/* Timer 5 Width Register          			*/
+
+#define TIMER6_CONFIG		0xFFC00660	/* Timer 6 Configuration Register  			*/
+#define TIMER6_COUNTER		0xFFC00664	/* Timer 6 Counter Register        			*/
+#define TIMER6_PERIOD		0xFFC00668	/* Timer 6 Period Register         			*/
+#define TIMER6_WIDTH		0xFFC0066C	/* Timer 6 Width Register          			*/
+
+#define TIMER7_CONFIG		0xFFC00670	/* Timer 7 Configuration Register  			*/
+#define TIMER7_COUNTER		0xFFC00674	/* Timer 7 Counter Register        			*/
+#define TIMER7_PERIOD		0xFFC00678	/* Timer 7 Period Register         			*/
+#define TIMER7_WIDTH		0xFFC0067C	/* Timer 7 Width Register       			*/
+
+#define TIMER_ENABLE		0xFFC00680	/* Timer Enable Register					*/
+#define TIMER_DISABLE		0xFFC00684	/* Timer Disable Register					*/
+#define TIMER_STATUS		0xFFC00688	/* Timer Status Register					*/
+
+/* General Purpose I/O Port F (0xFFC00700 - 0xFFC007FF)												*/
+#define PORTFIO					0xFFC00700	/* Port F I/O Pin State Specify Register				*/
+#define PORTFIO_CLEAR			0xFFC00704	/* Port F I/O Peripheral Interrupt Clear Register		*/
+#define PORTFIO_SET				0xFFC00708	/* Port F I/O Peripheral Interrupt Set Register			*/
+#define PORTFIO_TOGGLE			0xFFC0070C	/* Port F I/O Pin State Toggle Register					*/
+#define PORTFIO_MASKA			0xFFC00710	/* Port F I/O Mask State Specify Interrupt A Register	*/
+#define PORTFIO_MASKA_CLEAR		0xFFC00714	/* Port F I/O Mask Disable Interrupt A Register			*/
+#define PORTFIO_MASKA_SET		0xFFC00718	/* Port F I/O Mask Enable Interrupt A Register			*/
+#define PORTFIO_MASKA_TOGGLE	0xFFC0071C	/* Port F I/O Mask Toggle Enable Interrupt A Register	*/
+#define PORTFIO_MASKB			0xFFC00720	/* Port F I/O Mask State Specify Interrupt B Register	*/
+#define PORTFIO_MASKB_CLEAR		0xFFC00724	/* Port F I/O Mask Disable Interrupt B Register			*/
+#define PORTFIO_MASKB_SET		0xFFC00728	/* Port F I/O Mask Enable Interrupt B Register			*/
+#define PORTFIO_MASKB_TOGGLE	0xFFC0072C	/* Port F I/O Mask Toggle Enable Interrupt B Register	*/
+#define PORTFIO_DIR				0xFFC00730	/* Port F I/O Direction Register						*/
+#define PORTFIO_POLAR			0xFFC00734	/* Port F I/O Source Polarity Register					*/
+#define PORTFIO_EDGE			0xFFC00738	/* Port F I/O Source Sensitivity Register				*/
+#define PORTFIO_BOTH			0xFFC0073C	/* Port F I/O Set on BOTH Edges Register				*/
+#define PORTFIO_INEN			0xFFC00740	/* Port F I/O Input Enable Register 					*/
+
+/* SPORT0 Controller		(0xFFC00800 - 0xFFC008FF)										*/
+#define SPORT0_TCR1			0xFFC00800	/* SPORT0 Transmit Configuration 1 Register			*/
+#define SPORT0_TCR2			0xFFC00804	/* SPORT0 Transmit Configuration 2 Register			*/
+#define SPORT0_TCLKDIV		0xFFC00808	/* SPORT0 Transmit Clock Divider					*/
+#define SPORT0_TFSDIV		0xFFC0080C	/* SPORT0 Transmit Frame Sync Divider				*/
+#define SPORT0_TX			0xFFC00810	/* SPORT0 TX Data Register							*/
+#define SPORT0_RX			0xFFC00818	/* SPORT0 RX Data Register							*/
+#define SPORT0_RCR1			0xFFC00820	/* SPORT0 Transmit Configuration 1 Register			*/
+#define SPORT0_RCR2			0xFFC00824	/* SPORT0 Transmit Configuration 2 Register			*/
+#define SPORT0_RCLKDIV		0xFFC00828	/* SPORT0 Receive Clock Divider						*/
+#define SPORT0_RFSDIV		0xFFC0082C	/* SPORT0 Receive Frame Sync Divider				*/
+#define SPORT0_STAT			0xFFC00830	/* SPORT0 Status Register							*/
+#define SPORT0_CHNL			0xFFC00834	/* SPORT0 Current Channel Register					*/
+#define SPORT0_MCMC1		0xFFC00838	/* SPORT0 Multi-Channel Configuration Register 1	*/
+#define SPORT0_MCMC2		0xFFC0083C	/* SPORT0 Multi-Channel Configuration Register 2	*/
+#define SPORT0_MTCS0		0xFFC00840	/* SPORT0 Multi-Channel Transmit Select Register 0	*/
+#define SPORT0_MTCS1		0xFFC00844	/* SPORT0 Multi-Channel Transmit Select Register 1	*/
+#define SPORT0_MTCS2		0xFFC00848	/* SPORT0 Multi-Channel Transmit Select Register 2	*/
+#define SPORT0_MTCS3		0xFFC0084C	/* SPORT0 Multi-Channel Transmit Select Register 3	*/
+#define SPORT0_MRCS0		0xFFC00850	/* SPORT0 Multi-Channel Receive Select Register 0	*/
+#define SPORT0_MRCS1		0xFFC00854	/* SPORT0 Multi-Channel Receive Select Register 1	*/
+#define SPORT0_MRCS2		0xFFC00858	/* SPORT0 Multi-Channel Receive Select Register 2	*/
+#define SPORT0_MRCS3		0xFFC0085C	/* SPORT0 Multi-Channel Receive Select Register 3	*/
+
+/* SPORT1 Controller		(0xFFC00900 - 0xFFC009FF)										*/
+#define SPORT1_TCR1			0xFFC00900	/* SPORT1 Transmit Configuration 1 Register			*/
+#define SPORT1_TCR2			0xFFC00904	/* SPORT1 Transmit Configuration 2 Register			*/
+#define SPORT1_TCLKDIV		0xFFC00908	/* SPORT1 Transmit Clock Divider					*/
+#define SPORT1_TFSDIV		0xFFC0090C	/* SPORT1 Transmit Frame Sync Divider				*/
+#define SPORT1_TX			0xFFC00910	/* SPORT1 TX Data Register							*/
+#define SPORT1_RX			0xFFC00918	/* SPORT1 RX Data Register							*/
+#define SPORT1_RCR1			0xFFC00920	/* SPORT1 Transmit Configuration 1 Register			*/
+#define SPORT1_RCR2			0xFFC00924	/* SPORT1 Transmit Configuration 2 Register			*/
+#define SPORT1_RCLKDIV		0xFFC00928	/* SPORT1 Receive Clock Divider						*/
+#define SPORT1_RFSDIV		0xFFC0092C	/* SPORT1 Receive Frame Sync Divider				*/
+#define SPORT1_STAT			0xFFC00930	/* SPORT1 Status Register							*/
+#define SPORT1_CHNL			0xFFC00934	/* SPORT1 Current Channel Register					*/
+#define SPORT1_MCMC1		0xFFC00938	/* SPORT1 Multi-Channel Configuration Register 1	*/
+#define SPORT1_MCMC2		0xFFC0093C	/* SPORT1 Multi-Channel Configuration Register 2	*/
+#define SPORT1_MTCS0		0xFFC00940	/* SPORT1 Multi-Channel Transmit Select Register 0	*/
+#define SPORT1_MTCS1		0xFFC00944	/* SPORT1 Multi-Channel Transmit Select Register 1	*/
+#define SPORT1_MTCS2		0xFFC00948	/* SPORT1 Multi-Channel Transmit Select Register 2	*/
+#define SPORT1_MTCS3		0xFFC0094C	/* SPORT1 Multi-Channel Transmit Select Register 3	*/
+#define SPORT1_MRCS0		0xFFC00950	/* SPORT1 Multi-Channel Receive Select Register 0	*/
+#define SPORT1_MRCS1		0xFFC00954	/* SPORT1 Multi-Channel Receive Select Register 1	*/
+#define SPORT1_MRCS2		0xFFC00958	/* SPORT1 Multi-Channel Receive Select Register 2	*/
+#define SPORT1_MRCS3		0xFFC0095C	/* SPORT1 Multi-Channel Receive Select Register 3	*/
+
+/* External Bus Interface Unit (0xFFC00A00 - 0xFFC00AFF)								*/
+#define EBIU_AMGCTL			0xFFC00A00	/* Asynchronous Memory Global Control Register	*/
+#define EBIU_AMBCTL0		0xFFC00A04	/* Asynchronous Memory Bank Control Register 0	*/
+#define EBIU_AMBCTL1		0xFFC00A08	/* Asynchronous Memory Bank Control Register 1	*/
+#define EBIU_SDGCTL			0xFFC00A10	/* SDRAM Global Control Register				*/
+#define EBIU_SDBCTL			0xFFC00A14	/* SDRAM Bank Control Register					*/
+#define EBIU_SDRRC			0xFFC00A18	/* SDRAM Refresh Rate Control Register			*/
+#define EBIU_SDSTAT			0xFFC00A1C	/* SDRAM Status Register						*/
+
+/* DMA Traffic Control Registers													*/
+#define DMA_TCPER			0xFFC00B0C	/* Traffic Control Periods Register			*/
+#define DMA_TCCNT			0xFFC00B10	/* Traffic Control Current Counts Register	*/
+
+/* DMA Controller (0xFFC00C00 - 0xFFC00FFF)															*/
+#define DMA0_NEXT_DESC_PTR		0xFFC00C00	/* DMA Channel 0 Next Descriptor Pointer Register		*/
+#define DMA0_START_ADDR			0xFFC00C04	/* DMA Channel 0 Start Address Register					*/
+#define DMA0_CONFIG				0xFFC00C08	/* DMA Channel 0 Configuration Register					*/
+#define DMA0_X_COUNT			0xFFC00C10	/* DMA Channel 0 X Count Register						*/
+#define DMA0_X_MODIFY			0xFFC00C14	/* DMA Channel 0 X Modify Register						*/
+#define DMA0_Y_COUNT			0xFFC00C18	/* DMA Channel 0 Y Count Register						*/
+#define DMA0_Y_MODIFY			0xFFC00C1C	/* DMA Channel 0 Y Modify Register						*/
+#define DMA0_CURR_DESC_PTR		0xFFC00C20	/* DMA Channel 0 Current Descriptor Pointer Register	*/
+#define DMA0_CURR_ADDR			0xFFC00C24	/* DMA Channel 0 Current Address Register				*/
+#define DMA0_IRQ_STATUS			0xFFC00C28	/* DMA Channel 0 Interrupt/Status Register				*/
+#define DMA0_PERIPHERAL_MAP		0xFFC00C2C	/* DMA Channel 0 Peripheral Map Register				*/
+#define DMA0_CURR_X_COUNT		0xFFC00C30	/* DMA Channel 0 Current X Count Register				*/
+#define DMA0_CURR_Y_COUNT		0xFFC00C38	/* DMA Channel 0 Current Y Count Register				*/
+
+#define DMA1_NEXT_DESC_PTR		0xFFC00C40	/* DMA Channel 1 Next Descriptor Pointer Register		*/
+#define DMA1_START_ADDR			0xFFC00C44	/* DMA Channel 1 Start Address Register					*/
+#define DMA1_CONFIG				0xFFC00C48	/* DMA Channel 1 Configuration Register					*/
+#define DMA1_X_COUNT			0xFFC00C50	/* DMA Channel 1 X Count Register						*/
+#define DMA1_X_MODIFY			0xFFC00C54	/* DMA Channel 1 X Modify Register						*/
+#define DMA1_Y_COUNT			0xFFC00C58	/* DMA Channel 1 Y Count Register						*/
+#define DMA1_Y_MODIFY			0xFFC00C5C	/* DMA Channel 1 Y Modify Register						*/
+#define DMA1_CURR_DESC_PTR		0xFFC00C60	/* DMA Channel 1 Current Descriptor Pointer Register	*/
+#define DMA1_CURR_ADDR			0xFFC00C64	/* DMA Channel 1 Current Address Register				*/
+#define DMA1_IRQ_STATUS			0xFFC00C68	/* DMA Channel 1 Interrupt/Status Register				*/
+#define DMA1_PERIPHERAL_MAP		0xFFC00C6C	/* DMA Channel 1 Peripheral Map Register				*/
+#define DMA1_CURR_X_COUNT		0xFFC00C70	/* DMA Channel 1 Current X Count Register				*/
+#define DMA1_CURR_Y_COUNT		0xFFC00C78	/* DMA Channel 1 Current Y Count Register				*/
+
+#define DMA2_NEXT_DESC_PTR		0xFFC00C80	/* DMA Channel 2 Next Descriptor Pointer Register		*/
+#define DMA2_START_ADDR			0xFFC00C84	/* DMA Channel 2 Start Address Register					*/
+#define DMA2_CONFIG				0xFFC00C88	/* DMA Channel 2 Configuration Register					*/
+#define DMA2_X_COUNT			0xFFC00C90	/* DMA Channel 2 X Count Register						*/
+#define DMA2_X_MODIFY			0xFFC00C94	/* DMA Channel 2 X Modify Register						*/
+#define DMA2_Y_COUNT			0xFFC00C98	/* DMA Channel 2 Y Count Register						*/
+#define DMA2_Y_MODIFY			0xFFC00C9C	/* DMA Channel 2 Y Modify Register						*/
+#define DMA2_CURR_DESC_PTR		0xFFC00CA0	/* DMA Channel 2 Current Descriptor Pointer Register	*/
+#define DMA2_CURR_ADDR			0xFFC00CA4	/* DMA Channel 2 Current Address Register				*/
+#define DMA2_IRQ_STATUS			0xFFC00CA8	/* DMA Channel 2 Interrupt/Status Register				*/
+#define DMA2_PERIPHERAL_MAP		0xFFC00CAC	/* DMA Channel 2 Peripheral Map Register				*/
+#define DMA2_CURR_X_COUNT		0xFFC00CB0	/* DMA Channel 2 Current X Count Register				*/
+#define DMA2_CURR_Y_COUNT		0xFFC00CB8	/* DMA Channel 2 Current Y Count Register				*/
+
+#define DMA3_NEXT_DESC_PTR		0xFFC00CC0	/* DMA Channel 3 Next Descriptor Pointer Register		*/
+#define DMA3_START_ADDR			0xFFC00CC4	/* DMA Channel 3 Start Address Register					*/
+#define DMA3_CONFIG				0xFFC00CC8	/* DMA Channel 3 Configuration Register					*/
+#define DMA3_X_COUNT			0xFFC00CD0	/* DMA Channel 3 X Count Register						*/
+#define DMA3_X_MODIFY			0xFFC00CD4	/* DMA Channel 3 X Modify Register						*/
+#define DMA3_Y_COUNT			0xFFC00CD8	/* DMA Channel 3 Y Count Register						*/
+#define DMA3_Y_MODIFY			0xFFC00CDC	/* DMA Channel 3 Y Modify Register						*/
+#define DMA3_CURR_DESC_PTR		0xFFC00CE0	/* DMA Channel 3 Current Descriptor Pointer Register	*/
+#define DMA3_CURR_ADDR			0xFFC00CE4	/* DMA Channel 3 Current Address Register				*/
+#define DMA3_IRQ_STATUS			0xFFC00CE8	/* DMA Channel 3 Interrupt/Status Register				*/
+#define DMA3_PERIPHERAL_MAP		0xFFC00CEC	/* DMA Channel 3 Peripheral Map Register				*/
+#define DMA3_CURR_X_COUNT		0xFFC00CF0	/* DMA Channel 3 Current X Count Register				*/
+#define DMA3_CURR_Y_COUNT		0xFFC00CF8	/* DMA Channel 3 Current Y Count Register				*/
+
+#define DMA4_NEXT_DESC_PTR		0xFFC00D00	/* DMA Channel 4 Next Descriptor Pointer Register		*/
+#define DMA4_START_ADDR			0xFFC00D04	/* DMA Channel 4 Start Address Register					*/
+#define DMA4_CONFIG				0xFFC00D08	/* DMA Channel 4 Configuration Register					*/
+#define DMA4_X_COUNT			0xFFC00D10	/* DMA Channel 4 X Count Register						*/
+#define DMA4_X_MODIFY			0xFFC00D14	/* DMA Channel 4 X Modify Register						*/
+#define DMA4_Y_COUNT			0xFFC00D18	/* DMA Channel 4 Y Count Register						*/
+#define DMA4_Y_MODIFY			0xFFC00D1C	/* DMA Channel 4 Y Modify Register						*/
+#define DMA4_CURR_DESC_PTR		0xFFC00D20	/* DMA Channel 4 Current Descriptor Pointer Register	*/
+#define DMA4_CURR_ADDR			0xFFC00D24	/* DMA Channel 4 Current Address Register				*/
+#define DMA4_IRQ_STATUS			0xFFC00D28	/* DMA Channel 4 Interrupt/Status Register				*/
+#define DMA4_PERIPHERAL_MAP		0xFFC00D2C	/* DMA Channel 4 Peripheral Map Register				*/
+#define DMA4_CURR_X_COUNT		0xFFC00D30	/* DMA Channel 4 Current X Count Register				*/
+#define DMA4_CURR_Y_COUNT		0xFFC00D38	/* DMA Channel 4 Current Y Count Register				*/
+
+#define DMA5_NEXT_DESC_PTR		0xFFC00D40	/* DMA Channel 5 Next Descriptor Pointer Register		*/
+#define DMA5_START_ADDR			0xFFC00D44	/* DMA Channel 5 Start Address Register					*/
+#define DMA5_CONFIG				0xFFC00D48	/* DMA Channel 5 Configuration Register					*/
+#define DMA5_X_COUNT			0xFFC00D50	/* DMA Channel 5 X Count Register						*/
+#define DMA5_X_MODIFY			0xFFC00D54	/* DMA Channel 5 X Modify Register						*/
+#define DMA5_Y_COUNT			0xFFC00D58	/* DMA Channel 5 Y Count Register						*/
+#define DMA5_Y_MODIFY			0xFFC00D5C	/* DMA Channel 5 Y Modify Register						*/
+#define DMA5_CURR_DESC_PTR		0xFFC00D60	/* DMA Channel 5 Current Descriptor Pointer Register	*/
+#define DMA5_CURR_ADDR			0xFFC00D64	/* DMA Channel 5 Current Address Register				*/
+#define DMA5_IRQ_STATUS			0xFFC00D68	/* DMA Channel 5 Interrupt/Status Register				*/
+#define DMA5_PERIPHERAL_MAP		0xFFC00D6C	/* DMA Channel 5 Peripheral Map Register				*/
+#define DMA5_CURR_X_COUNT		0xFFC00D70	/* DMA Channel 5 Current X Count Register				*/
+#define DMA5_CURR_Y_COUNT		0xFFC00D78	/* DMA Channel 5 Current Y Count Register				*/
+
+#define DMA6_NEXT_DESC_PTR		0xFFC00D80	/* DMA Channel 6 Next Descriptor Pointer Register		*/
+#define DMA6_START_ADDR			0xFFC00D84	/* DMA Channel 6 Start Address Register					*/
+#define DMA6_CONFIG				0xFFC00D88	/* DMA Channel 6 Configuration Register					*/
+#define DMA6_X_COUNT			0xFFC00D90	/* DMA Channel 6 X Count Register						*/
+#define DMA6_X_MODIFY			0xFFC00D94	/* DMA Channel 6 X Modify Register						*/
+#define DMA6_Y_COUNT			0xFFC00D98	/* DMA Channel 6 Y Count Register						*/
+#define DMA6_Y_MODIFY			0xFFC00D9C	/* DMA Channel 6 Y Modify Register						*/
+#define DMA6_CURR_DESC_PTR		0xFFC00DA0	/* DMA Channel 6 Current Descriptor Pointer Register	*/
+#define DMA6_CURR_ADDR			0xFFC00DA4	/* DMA Channel 6 Current Address Register				*/
+#define DMA6_IRQ_STATUS			0xFFC00DA8	/* DMA Channel 6 Interrupt/Status Register				*/
+#define DMA6_PERIPHERAL_MAP		0xFFC00DAC	/* DMA Channel 6 Peripheral Map Register				*/
+#define DMA6_CURR_X_COUNT		0xFFC00DB0	/* DMA Channel 6 Current X Count Register				*/
+#define DMA6_CURR_Y_COUNT		0xFFC00DB8	/* DMA Channel 6 Current Y Count Register				*/
+
+#define DMA7_NEXT_DESC_PTR		0xFFC00DC0	/* DMA Channel 7 Next Descriptor Pointer Register		*/
+#define DMA7_START_ADDR			0xFFC00DC4	/* DMA Channel 7 Start Address Register					*/
+#define DMA7_CONFIG				0xFFC00DC8	/* DMA Channel 7 Configuration Register					*/
+#define DMA7_X_COUNT			0xFFC00DD0	/* DMA Channel 7 X Count Register						*/
+#define DMA7_X_MODIFY			0xFFC00DD4	/* DMA Channel 7 X Modify Register						*/
+#define DMA7_Y_COUNT			0xFFC00DD8	/* DMA Channel 7 Y Count Register						*/
+#define DMA7_Y_MODIFY			0xFFC00DDC	/* DMA Channel 7 Y Modify Register						*/
+#define DMA7_CURR_DESC_PTR		0xFFC00DE0	/* DMA Channel 7 Current Descriptor Pointer Register	*/
+#define DMA7_CURR_ADDR			0xFFC00DE4	/* DMA Channel 7 Current Address Register				*/
+#define DMA7_IRQ_STATUS			0xFFC00DE8	/* DMA Channel 7 Interrupt/Status Register				*/
+#define DMA7_PERIPHERAL_MAP		0xFFC00DEC	/* DMA Channel 7 Peripheral Map Register				*/
+#define DMA7_CURR_X_COUNT		0xFFC00DF0	/* DMA Channel 7 Current X Count Register				*/
+#define DMA7_CURR_Y_COUNT		0xFFC00DF8	/* DMA Channel 7 Current Y Count Register				*/
+
+#define DMA8_NEXT_DESC_PTR		0xFFC00E00	/* DMA Channel 8 Next Descriptor Pointer Register		*/
+#define DMA8_START_ADDR			0xFFC00E04	/* DMA Channel 8 Start Address Register					*/
+#define DMA8_CONFIG				0xFFC00E08	/* DMA Channel 8 Configuration Register					*/
+#define DMA8_X_COUNT			0xFFC00E10	/* DMA Channel 8 X Count Register						*/
+#define DMA8_X_MODIFY			0xFFC00E14	/* DMA Channel 8 X Modify Register						*/
+#define DMA8_Y_COUNT			0xFFC00E18	/* DMA Channel 8 Y Count Register						*/
+#define DMA8_Y_MODIFY			0xFFC00E1C	/* DMA Channel 8 Y Modify Register						*/
+#define DMA8_CURR_DESC_PTR		0xFFC00E20	/* DMA Channel 8 Current Descriptor Pointer Register	*/
+#define DMA8_CURR_ADDR			0xFFC00E24	/* DMA Channel 8 Current Address Register				*/
+#define DMA8_IRQ_STATUS			0xFFC00E28	/* DMA Channel 8 Interrupt/Status Register				*/
+#define DMA8_PERIPHERAL_MAP		0xFFC00E2C	/* DMA Channel 8 Peripheral Map Register				*/
+#define DMA8_CURR_X_COUNT		0xFFC00E30	/* DMA Channel 8 Current X Count Register				*/
+#define DMA8_CURR_Y_COUNT		0xFFC00E38	/* DMA Channel 8 Current Y Count Register				*/
+
+#define DMA9_NEXT_DESC_PTR		0xFFC00E40	/* DMA Channel 9 Next Descriptor Pointer Register		*/
+#define DMA9_START_ADDR			0xFFC00E44	/* DMA Channel 9 Start Address Register					*/
+#define DMA9_CONFIG				0xFFC00E48	/* DMA Channel 9 Configuration Register					*/
+#define DMA9_X_COUNT			0xFFC00E50	/* DMA Channel 9 X Count Register						*/
+#define DMA9_X_MODIFY			0xFFC00E54	/* DMA Channel 9 X Modify Register						*/
+#define DMA9_Y_COUNT			0xFFC00E58	/* DMA Channel 9 Y Count Register						*/
+#define DMA9_Y_MODIFY			0xFFC00E5C	/* DMA Channel 9 Y Modify Register						*/
+#define DMA9_CURR_DESC_PTR		0xFFC00E60	/* DMA Channel 9 Current Descriptor Pointer Register	*/
+#define DMA9_CURR_ADDR			0xFFC00E64	/* DMA Channel 9 Current Address Register				*/
+#define DMA9_IRQ_STATUS			0xFFC00E68	/* DMA Channel 9 Interrupt/Status Register				*/
+#define DMA9_PERIPHERAL_MAP		0xFFC00E6C	/* DMA Channel 9 Peripheral Map Register				*/
+#define DMA9_CURR_X_COUNT		0xFFC00E70	/* DMA Channel 9 Current X Count Register				*/
+#define DMA9_CURR_Y_COUNT		0xFFC00E78	/* DMA Channel 9 Current Y Count Register				*/
+
+#define DMA10_NEXT_DESC_PTR		0xFFC00E80	/* DMA Channel 10 Next Descriptor Pointer Register		*/
+#define DMA10_START_ADDR		0xFFC00E84	/* DMA Channel 10 Start Address Register				*/
+#define DMA10_CONFIG			0xFFC00E88	/* DMA Channel 10 Configuration Register				*/
+#define DMA10_X_COUNT			0xFFC00E90	/* DMA Channel 10 X Count Register						*/
+#define DMA10_X_MODIFY			0xFFC00E94	/* DMA Channel 10 X Modify Register						*/
+#define DMA10_Y_COUNT			0xFFC00E98	/* DMA Channel 10 Y Count Register						*/
+#define DMA10_Y_MODIFY			0xFFC00E9C	/* DMA Channel 10 Y Modify Register						*/
+#define DMA10_CURR_DESC_PTR		0xFFC00EA0	/* DMA Channel 10 Current Descriptor Pointer Register	*/
+#define DMA10_CURR_ADDR			0xFFC00EA4	/* DMA Channel 10 Current Address Register				*/
+#define DMA10_IRQ_STATUS		0xFFC00EA8	/* DMA Channel 10 Interrupt/Status Register				*/
+#define DMA10_PERIPHERAL_MAP	0xFFC00EAC	/* DMA Channel 10 Peripheral Map Register				*/
+#define DMA10_CURR_X_COUNT		0xFFC00EB0	/* DMA Channel 10 Current X Count Register				*/
+#define DMA10_CURR_Y_COUNT		0xFFC00EB8	/* DMA Channel 10 Current Y Count Register				*/
+
+#define DMA11_NEXT_DESC_PTR		0xFFC00EC0	/* DMA Channel 11 Next Descriptor Pointer Register		*/
+#define DMA11_START_ADDR		0xFFC00EC4	/* DMA Channel 11 Start Address Register				*/
+#define DMA11_CONFIG			0xFFC00EC8	/* DMA Channel 11 Configuration Register				*/
+#define DMA11_X_COUNT			0xFFC00ED0	/* DMA Channel 11 X Count Register						*/
+#define DMA11_X_MODIFY			0xFFC00ED4	/* DMA Channel 11 X Modify Register						*/
+#define DMA11_Y_COUNT			0xFFC00ED8	/* DMA Channel 11 Y Count Register						*/
+#define DMA11_Y_MODIFY			0xFFC00EDC	/* DMA Channel 11 Y Modify Register						*/
+#define DMA11_CURR_DESC_PTR		0xFFC00EE0	/* DMA Channel 11 Current Descriptor Pointer Register	*/
+#define DMA11_CURR_ADDR			0xFFC00EE4	/* DMA Channel 11 Current Address Register				*/
+#define DMA11_IRQ_STATUS		0xFFC00EE8	/* DMA Channel 11 Interrupt/Status Register				*/
+#define DMA11_PERIPHERAL_MAP	0xFFC00EEC	/* DMA Channel 11 Peripheral Map Register				*/
+#define DMA11_CURR_X_COUNT		0xFFC00EF0	/* DMA Channel 11 Current X Count Register				*/
+#define DMA11_CURR_Y_COUNT		0xFFC00EF8	/* DMA Channel 11 Current Y Count Register				*/
+
+#define MDMA_D0_NEXT_DESC_PTR	0xFFC00F00	/* MemDMA Stream 0 Destination Next Descriptor Pointer Register		*/
+#define MDMA_D0_START_ADDR		0xFFC00F04	/* MemDMA Stream 0 Destination Start Address Register				*/
+#define MDMA_D0_CONFIG			0xFFC00F08	/* MemDMA Stream 0 Destination Configuration Register				*/
+#define MDMA_D0_X_COUNT			0xFFC00F10	/* MemDMA Stream 0 Destination X Count Register						*/
+#define MDMA_D0_X_MODIFY		0xFFC00F14	/* MemDMA Stream 0 Destination X Modify Register					*/
+#define MDMA_D0_Y_COUNT			0xFFC00F18	/* MemDMA Stream 0 Destination Y Count Register						*/
+#define MDMA_D0_Y_MODIFY		0xFFC00F1C	/* MemDMA Stream 0 Destination Y Modify Register					*/
+#define MDMA_D0_CURR_DESC_PTR	0xFFC00F20	/* MemDMA Stream 0 Destination Current Descriptor Pointer Register	*/
+#define MDMA_D0_CURR_ADDR		0xFFC00F24	/* MemDMA Stream 0 Destination Current Address Register				*/
+#define MDMA_D0_IRQ_STATUS		0xFFC00F28	/* MemDMA Stream 0 Destination Interrupt/Status Register			*/
+#define MDMA_D0_PERIPHERAL_MAP	0xFFC00F2C	/* MemDMA Stream 0 Destination Peripheral Map Register				*/
+#define MDMA_D0_CURR_X_COUNT	0xFFC00F30	/* MemDMA Stream 0 Destination Current X Count Register				*/
+#define MDMA_D0_CURR_Y_COUNT	0xFFC00F38	/* MemDMA Stream 0 Destination Current Y Count Register				*/
+
+#define MDMA_S0_NEXT_DESC_PTR	0xFFC00F40	/* MemDMA Stream 0 Source Next Descriptor Pointer Register			*/
+#define MDMA_S0_START_ADDR		0xFFC00F44	/* MemDMA Stream 0 Source Start Address Register					*/
+#define MDMA_S0_CONFIG			0xFFC00F48	/* MemDMA Stream 0 Source Configuration Register					*/
+#define MDMA_S0_X_COUNT			0xFFC00F50	/* MemDMA Stream 0 Source X Count Register							*/
+#define MDMA_S0_X_MODIFY		0xFFC00F54	/* MemDMA Stream 0 Source X Modify Register							*/
+#define MDMA_S0_Y_COUNT			0xFFC00F58	/* MemDMA Stream 0 Source Y Count Register							*/
+#define MDMA_S0_Y_MODIFY		0xFFC00F5C	/* MemDMA Stream 0 Source Y Modify Register							*/
+#define MDMA_S0_CURR_DESC_PTR	0xFFC00F60	/* MemDMA Stream 0 Source Current Descriptor Pointer Register		*/
+#define MDMA_S0_CURR_ADDR		0xFFC00F64	/* MemDMA Stream 0 Source Current Address Register					*/
+#define MDMA_S0_IRQ_STATUS		0xFFC00F68	/* MemDMA Stream 0 Source Interrupt/Status Register					*/
+#define MDMA_S0_PERIPHERAL_MAP	0xFFC00F6C	/* MemDMA Stream 0 Source Peripheral Map Register					*/
+#define MDMA_S0_CURR_X_COUNT	0xFFC00F70	/* MemDMA Stream 0 Source Current X Count Register					*/
+#define MDMA_S0_CURR_Y_COUNT	0xFFC00F78	/* MemDMA Stream 0 Source Current Y Count Register					*/
+
+#define MDMA_D1_NEXT_DESC_PTR	0xFFC00F80	/* MemDMA Stream 1 Destination Next Descriptor Pointer Register		*/
+#define MDMA_D1_START_ADDR		0xFFC00F84	/* MemDMA Stream 1 Destination Start Address Register				*/
+#define MDMA_D1_CONFIG			0xFFC00F88	/* MemDMA Stream 1 Destination Configuration Register				*/
+#define MDMA_D1_X_COUNT			0xFFC00F90	/* MemDMA Stream 1 Destination X Count Register						*/
+#define MDMA_D1_X_MODIFY		0xFFC00F94	/* MemDMA Stream 1 Destination X Modify Register					*/
+#define MDMA_D1_Y_COUNT			0xFFC00F98	/* MemDMA Stream 1 Destination Y Count Register						*/
+#define MDMA_D1_Y_MODIFY		0xFFC00F9C	/* MemDMA Stream 1 Destination Y Modify Register					*/
+#define MDMA_D1_CURR_DESC_PTR	0xFFC00FA0	/* MemDMA Stream 1 Destination Current Descriptor Pointer Register	*/
+#define MDMA_D1_CURR_ADDR		0xFFC00FA4	/* MemDMA Stream 1 Destination Current Address Register				*/
+#define MDMA_D1_IRQ_STATUS		0xFFC00FA8	/* MemDMA Stream 1 Destination Interrupt/Status Register			*/
+#define MDMA_D1_PERIPHERAL_MAP	0xFFC00FAC	/* MemDMA Stream 1 Destination Peripheral Map Register				*/
+#define MDMA_D1_CURR_X_COUNT	0xFFC00FB0	/* MemDMA Stream 1 Destination Current X Count Register				*/
+#define MDMA_D1_CURR_Y_COUNT	0xFFC00FB8	/* MemDMA Stream 1 Destination Current Y Count Register				*/
+
+#define MDMA_S1_NEXT_DESC_PTR	0xFFC00FC0	/* MemDMA Stream 1 Source Next Descriptor Pointer Register			*/
+#define MDMA_S1_START_ADDR		0xFFC00FC4	/* MemDMA Stream 1 Source Start Address Register					*/
+#define MDMA_S1_CONFIG			0xFFC00FC8	/* MemDMA Stream 1 Source Configuration Register					*/
+#define MDMA_S1_X_COUNT			0xFFC00FD0	/* MemDMA Stream 1 Source X Count Register							*/
+#define MDMA_S1_X_MODIFY		0xFFC00FD4	/* MemDMA Stream 1 Source X Modify Register							*/
+#define MDMA_S1_Y_COUNT			0xFFC00FD8	/* MemDMA Stream 1 Source Y Count Register							*/
+#define MDMA_S1_Y_MODIFY		0xFFC00FDC	/* MemDMA Stream 1 Source Y Modify Register							*/
+#define MDMA_S1_CURR_DESC_PTR	0xFFC00FE0	/* MemDMA Stream 1 Source Current Descriptor Pointer Register		*/
+#define MDMA_S1_CURR_ADDR		0xFFC00FE4	/* MemDMA Stream 1 Source Current Address Register					*/
+#define MDMA_S1_IRQ_STATUS		0xFFC00FE8	/* MemDMA Stream 1 Source Interrupt/Status Register					*/
+#define MDMA_S1_PERIPHERAL_MAP	0xFFC00FEC	/* MemDMA Stream 1 Source Peripheral Map Register					*/
+#define MDMA_S1_CURR_X_COUNT	0xFFC00FF0	/* MemDMA Stream 1 Source Current X Count Register					*/
+#define MDMA_S1_CURR_Y_COUNT	0xFFC00FF8	/* MemDMA Stream 1 Source Current Y Count Register					*/
+
+/* Parallel Peripheral Interface (0xFFC01000 - 0xFFC010FF)				*/
+#define PPI_CONTROL			0xFFC01000	/* PPI Control Register			*/
+#define PPI_STATUS			0xFFC01004	/* PPI Status Register			*/
+#define PPI_COUNT			0xFFC01008	/* PPI Transfer Count Register	*/
+#define PPI_DELAY			0xFFC0100C	/* PPI Delay Count Register		*/
+#define PPI_FRAME			0xFFC01010	/* PPI Frame Length Register	*/
+
+/* Two-Wire Interface		(0xFFC01400 - 0xFFC014FF)								*/
+#define TWI_CLKDIV			0xFFC01400	/* Serial Clock Divider Register			*/
+#define TWI_CONTROL			0xFFC01404	/* TWI Control Register						*/
+#define TWI_SLAVE_CTL		0xFFC01408	/* Slave Mode Control Register				*/
+#define TWI_SLAVE_STAT		0xFFC0140C	/* Slave Mode Status Register				*/
+#define TWI_SLAVE_ADDR		0xFFC01410	/* Slave Mode Address Register				*/
+#define TWI_MASTER_CTL		0xFFC01414	/* Master Mode Control Register				*/
+#define TWI_MASTER_STAT		0xFFC01418	/* Master Mode Status Register				*/
+#define TWI_MASTER_ADDR		0xFFC0141C	/* Master Mode Address Register				*/
+#define TWI_INT_STAT		0xFFC01420	/* TWI Interrupt Status Register			*/
+#define TWI_INT_MASK		0xFFC01424	/* TWI Master Interrupt Mask Register		*/
+#define TWI_FIFO_CTL		0xFFC01428	/* FIFO Control Register					*/
+#define TWI_FIFO_STAT		0xFFC0142C	/* FIFO Status Register						*/
+#define TWI_XMT_DATA8		0xFFC01480	/* FIFO Transmit Data Single Byte Register	*/
+#define TWI_XMT_DATA16		0xFFC01484	/* FIFO Transmit Data Double Byte Register	*/
+#define TWI_RCV_DATA8		0xFFC01488	/* FIFO Receive Data Single Byte Register	*/
+#define TWI_RCV_DATA16		0xFFC0148C	/* FIFO Receive Data Double Byte Register	*/
+
+/* General Purpose I/O Port G (0xFFC01500 - 0xFFC015FF)												*/
+#define PORTGIO					0xFFC01500	/* Port G I/O Pin State Specify Register				*/
+#define PORTGIO_CLEAR			0xFFC01504	/* Port G I/O Peripheral Interrupt Clear Register		*/
+#define PORTGIO_SET				0xFFC01508	/* Port G I/O Peripheral Interrupt Set Register			*/
+#define PORTGIO_TOGGLE			0xFFC0150C	/* Port G I/O Pin State Toggle Register					*/
+#define PORTGIO_MASKA			0xFFC01510	/* Port G I/O Mask State Specify Interrupt A Register	*/
+#define PORTGIO_MASKA_CLEAR		0xFFC01514	/* Port G I/O Mask Disable Interrupt A Register			*/
+#define PORTGIO_MASKA_SET		0xFFC01518	/* Port G I/O Mask Enable Interrupt A Register			*/
+#define PORTGIO_MASKA_TOGGLE	0xFFC0151C	/* Port G I/O Mask Toggle Enable Interrupt A Register	*/
+#define PORTGIO_MASKB			0xFFC01520	/* Port G I/O Mask State Specify Interrupt B Register	*/
+#define PORTGIO_MASKB_CLEAR		0xFFC01524	/* Port G I/O Mask Disable Interrupt B Register			*/
+#define PORTGIO_MASKB_SET		0xFFC01528	/* Port G I/O Mask Enable Interrupt B Register			*/
+#define PORTGIO_MASKB_TOGGLE	0xFFC0152C	/* Port G I/O Mask Toggle Enable Interrupt B Register	*/
+#define PORTGIO_DIR				0xFFC01530	/* Port G I/O Direction Register						*/
+#define PORTGIO_POLAR			0xFFC01534	/* Port G I/O Source Polarity Register					*/
+#define PORTGIO_EDGE			0xFFC01538	/* Port G I/O Source Sensitivity Register				*/
+#define PORTGIO_BOTH			0xFFC0153C	/* Port G I/O Set on BOTH Edges Register				*/
+#define PORTGIO_INEN			0xFFC01540	/* Port G I/O Input Enable Register						*/
+
+/* General Purpose I/O Port H (0xFFC01700 - 0xFFC017FF)												*/
+#define PORTHIO					0xFFC01700	/* Port H I/O Pin State Specify Register				*/
+#define PORTHIO_CLEAR			0xFFC01704	/* Port H I/O Peripheral Interrupt Clear Register		*/
+#define PORTHIO_SET				0xFFC01708	/* Port H I/O Peripheral Interrupt Set Register			*/
+#define PORTHIO_TOGGLE			0xFFC0170C	/* Port H I/O Pin State Toggle Register					*/
+#define PORTHIO_MASKA			0xFFC01710	/* Port H I/O Mask State Specify Interrupt A Register	*/
+#define PORTHIO_MASKA_CLEAR		0xFFC01714	/* Port H I/O Mask Disable Interrupt A Register			*/
+#define PORTHIO_MASKA_SET		0xFFC01718	/* Port H I/O Mask Enable Interrupt A Register			*/
+#define PORTHIO_MASKA_TOGGLE	0xFFC0171C	/* Port H I/O Mask Toggle Enable Interrupt A Register	*/
+#define PORTHIO_MASKB			0xFFC01720	/* Port H I/O Mask State Specify Interrupt B Register	*/
+#define PORTHIO_MASKB_CLEAR		0xFFC01724	/* Port H I/O Mask Disable Interrupt B Register			*/
+#define PORTHIO_MASKB_SET		0xFFC01728	/* Port H I/O Mask Enable Interrupt B Register			*/
+#define PORTHIO_MASKB_TOGGLE	0xFFC0172C	/* Port H I/O Mask Toggle Enable Interrupt B Register	*/
+#define PORTHIO_DIR				0xFFC01730	/* Port H I/O Direction Register						*/
+#define PORTHIO_POLAR			0xFFC01734	/* Port H I/O Source Polarity Register					*/
+#define PORTHIO_EDGE			0xFFC01738	/* Port H I/O Source Sensitivity Register				*/
+#define PORTHIO_BOTH			0xFFC0173C	/* Port H I/O Set on BOTH Edges Register				*/
+#define PORTHIO_INEN			0xFFC01740	/* Port H I/O Input Enable Register						*/
+
+/* UART1 Controller		(0xFFC02000 - 0xFFC020FF)								*/
+#define UART1_THR			0xFFC02000	/* Transmit Holding register			*/
+#define UART1_RBR			0xFFC02000	/* Receive Buffer register				*/
+#define UART1_DLL			0xFFC02000	/* Divisor Latch (Low-Byte)				*/
+#define UART1_IER			0xFFC02004	/* Interrupt Enable Register			*/
+#define UART1_DLH			0xFFC02004	/* Divisor Latch (High-Byte)			*/
+#define UART1_IIR			0xFFC02008	/* Interrupt Identification Register	*/
+#define UART1_LCR			0xFFC0200C	/* Line Control Register				*/
+#define UART1_MCR			0xFFC02010	/* Modem Control Register				*/
+#define UART1_LSR			0xFFC02014	/* Line Status Register					*/
+#define UART1_MSR			0xFFC02018	/* Modem Status Register				*/
+#define UART1_SCR			0xFFC0201C	/* SCR Scratch Register					*/
+#define UART1_GCTL			0xFFC02024	/* Global Control Register				*/
+
+/* CAN Controller		(0xFFC02A00 - 0xFFC02FFF)										*/
+/* For Mailboxes 0-15																	*/
+#define CAN_MC1				0xFFC02A00	/* Mailbox config reg 1							*/
+#define CAN_MD1				0xFFC02A04	/* Mailbox direction reg 1						*/
+#define CAN_TRS1			0xFFC02A08	/* Transmit Request Set reg 1					*/
+#define CAN_TRR1			0xFFC02A0C	/* Transmit Request Reset reg 1					*/
+#define CAN_TA1				0xFFC02A10	/* Transmit Acknowledge reg 1					*/
+#define CAN_AA1				0xFFC02A14	/* Transmit Abort Acknowledge reg 1				*/
+#define CAN_RMP1			0xFFC02A18	/* Receive Message Pending reg 1				*/
+#define CAN_RML1			0xFFC02A1C	/* Receive Message Lost reg 1					*/
+#define CAN_MBTIF1			0xFFC02A20	/* Mailbox Transmit Interrupt Flag reg 1		*/
+#define CAN_MBRIF1			0xFFC02A24	/* Mailbox Receive  Interrupt Flag reg 1		*/
+#define CAN_MBIM1			0xFFC02A28	/* Mailbox Interrupt Mask reg 1					*/
+#define CAN_RFH1			0xFFC02A2C	/* Remote Frame Handling reg 1					*/
+#define CAN_OPSS1			0xFFC02A30	/* Overwrite Protection Single Shot Xmit reg 1	*/
+
+/* For Mailboxes 16-31   																*/
+#define CAN_MC2				0xFFC02A40	/* Mailbox config reg 2							*/
+#define CAN_MD2				0xFFC02A44	/* Mailbox direction reg 2						*/
+#define CAN_TRS2			0xFFC02A48	/* Transmit Request Set reg 2					*/
+#define CAN_TRR2			0xFFC02A4C	/* Transmit Request Reset reg 2					*/
+#define CAN_TA2				0xFFC02A50	/* Transmit Acknowledge reg 2					*/
+#define CAN_AA2				0xFFC02A54	/* Transmit Abort Acknowledge reg 2				*/
+#define CAN_RMP2			0xFFC02A58	/* Receive Message Pending reg 2				*/
+#define CAN_RML2			0xFFC02A5C	/* Receive Message Lost reg 2					*/
+#define CAN_MBTIF2			0xFFC02A60	/* Mailbox Transmit Interrupt Flag reg 2		*/
+#define CAN_MBRIF2			0xFFC02A64	/* Mailbox Receive  Interrupt Flag reg 2		*/
+#define CAN_MBIM2			0xFFC02A68	/* Mailbox Interrupt Mask reg 2					*/
+#define CAN_RFH2			0xFFC02A6C	/* Remote Frame Handling reg 2					*/
+#define CAN_OPSS2			0xFFC02A70	/* Overwrite Protection Single Shot Xmit reg 2	*/
+
+/* CAN Configuration, Control, and Status Registers										*/
+#define CAN_CLOCK			0xFFC02A80	/* Bit Timing Configuration register 0			*/
+#define CAN_TIMING			0xFFC02A84	/* Bit Timing Configuration register 1			*/
+#define CAN_DEBUG			0xFFC02A88	/* Debug Register								*/
+#define CAN_STATUS			0xFFC02A8C	/* Global Status Register						*/
+#define CAN_CEC				0xFFC02A90	/* Error Counter Register						*/
+#define CAN_GIS				0xFFC02A94	/* Global Interrupt Status Register				*/
+#define CAN_GIM				0xFFC02A98	/* Global Interrupt Mask Register				*/
+#define CAN_GIF				0xFFC02A9C	/* Global Interrupt Flag Register				*/
+#define CAN_CONTROL			0xFFC02AA0	/* Master Control Register						*/
+#define CAN_INTR			0xFFC02AA4	/* Interrupt Pending Register					*/
+#define CAN_SFCMVER			0xFFC02AA8	/* Version Code Register						*/
+#define CAN_MBTD			0xFFC02AAC	/* Mailbox Temporary Disable Feature			*/
+#define CAN_EWR				0xFFC02AB0	/* Programmable Warning Level					*/
+#define CAN_ESR				0xFFC02AB4	/* Error Status Register						*/
+#define CAN_UCREG			0xFFC02AC0	/* Universal Counter Register/Capture Register	*/
+#define CAN_UCCNT			0xFFC02AC4	/* Universal Counter							*/
+#define CAN_UCRC			0xFFC02AC8	/* Universal Counter Force Reload Register		*/
+#define CAN_UCCNF			0xFFC02ACC	/* Universal Counter Configuration Register		*/
+
+/* Mailbox Acceptance Masks 												*/
+#define CAN_AM00L			0xFFC02B00	/* Mailbox 0 Low Acceptance Mask	*/
+#define CAN_AM00H			0xFFC02B04	/* Mailbox 0 High Acceptance Mask	*/
+#define CAN_AM01L			0xFFC02B08	/* Mailbox 1 Low Acceptance Mask 	*/
+#define CAN_AM01H			0xFFC02B0C	/* Mailbox 1 High Acceptance Mask	*/
+#define CAN_AM02L			0xFFC02B10	/* Mailbox 2 Low Acceptance Mask 	*/
+#define CAN_AM02H			0xFFC02B14	/* Mailbox 2 High Acceptance Mask	*/
+#define CAN_AM03L			0xFFC02B18	/* Mailbox 3 Low Acceptance Mask 	*/
+#define CAN_AM03H			0xFFC02B1C	/* Mailbox 3 High Acceptance Mask	*/
+#define CAN_AM04L			0xFFC02B20	/* Mailbox 4 Low Acceptance Mask 	*/
+#define CAN_AM04H			0xFFC02B24	/* Mailbox 4 High Acceptance Mask	*/
+#define CAN_AM05L			0xFFC02B28	/* Mailbox 5 Low Acceptance Mask 	*/
+#define CAN_AM05H			0xFFC02B2C	/* Mailbox 5 High Acceptance Mask	*/
+#define CAN_AM06L			0xFFC02B30	/* Mailbox 6 Low Acceptance Mask 	*/
+#define CAN_AM06H			0xFFC02B34	/* Mailbox 6 High Acceptance Mask	*/
+#define CAN_AM07L			0xFFC02B38	/* Mailbox 7 Low Acceptance Mask 	*/
+#define CAN_AM07H			0xFFC02B3C	/* Mailbox 7 High Acceptance Mask	*/
+#define CAN_AM08L			0xFFC02B40	/* Mailbox 8 Low Acceptance Mask 	*/
+#define CAN_AM08H			0xFFC02B44	/* Mailbox 8 High Acceptance Mask	*/
+#define CAN_AM09L			0xFFC02B48	/* Mailbox 9 Low Acceptance Mask 	*/
+#define CAN_AM09H			0xFFC02B4C	/* Mailbox 9 High Acceptance Mask	*/
+#define CAN_AM10L			0xFFC02B50	/* Mailbox 10 Low Acceptance Mask 	*/
+#define CAN_AM10H			0xFFC02B54	/* Mailbox 10 High Acceptance Mask	*/
+#define CAN_AM11L			0xFFC02B58	/* Mailbox 11 Low Acceptance Mask 	*/
+#define CAN_AM11H			0xFFC02B5C	/* Mailbox 11 High Acceptance Mask	*/
+#define CAN_AM12L			0xFFC02B60	/* Mailbox 12 Low Acceptance Mask 	*/
+#define CAN_AM12H			0xFFC02B64	/* Mailbox 12 High Acceptance Mask	*/
+#define CAN_AM13L			0xFFC02B68	/* Mailbox 13 Low Acceptance Mask 	*/
+#define CAN_AM13H			0xFFC02B6C	/* Mailbox 13 High Acceptance Mask	*/
+#define CAN_AM14L			0xFFC02B70	/* Mailbox 14 Low Acceptance Mask 	*/
+#define CAN_AM14H			0xFFC02B74	/* Mailbox 14 High Acceptance Mask	*/
+#define CAN_AM15L			0xFFC02B78	/* Mailbox 15 Low Acceptance Mask 	*/
+#define CAN_AM15H			0xFFC02B7C	/* Mailbox 15 High Acceptance Mask	*/
+
+#define CAN_AM16L			0xFFC02B80	/* Mailbox 16 Low Acceptance Mask 	*/
+#define CAN_AM16H			0xFFC02B84	/* Mailbox 16 High Acceptance Mask	*/
+#define CAN_AM17L			0xFFC02B88	/* Mailbox 17 Low Acceptance Mask 	*/
+#define CAN_AM17H			0xFFC02B8C	/* Mailbox 17 High Acceptance Mask	*/
+#define CAN_AM18L			0xFFC02B90	/* Mailbox 18 Low Acceptance Mask 	*/
+#define CAN_AM18H			0xFFC02B94	/* Mailbox 18 High Acceptance Mask	*/
+#define CAN_AM19L			0xFFC02B98	/* Mailbox 19 Low Acceptance Mask 	*/
+#define CAN_AM19H			0xFFC02B9C	/* Mailbox 19 High Acceptance Mask	*/
+#define CAN_AM20L			0xFFC02BA0	/* Mailbox 20 Low Acceptance Mask 	*/
+#define CAN_AM20H			0xFFC02BA4	/* Mailbox 20 High Acceptance Mask	*/
+#define CAN_AM21L			0xFFC02BA8	/* Mailbox 21 Low Acceptance Mask 	*/
+#define CAN_AM21H			0xFFC02BAC	/* Mailbox 21 High Acceptance Mask	*/
+#define CAN_AM22L			0xFFC02BB0	/* Mailbox 22 Low Acceptance Mask 	*/
+#define CAN_AM22H			0xFFC02BB4	/* Mailbox 22 High Acceptance Mask	*/
+#define CAN_AM23L			0xFFC02BB8	/* Mailbox 23 Low Acceptance Mask 	*/
+#define CAN_AM23H			0xFFC02BBC	/* Mailbox 23 High Acceptance Mask	*/
+#define CAN_AM24L			0xFFC02BC0	/* Mailbox 24 Low Acceptance Mask 	*/
+#define CAN_AM24H			0xFFC02BC4	/* Mailbox 24 High Acceptance Mask	*/
+#define CAN_AM25L			0xFFC02BC8	/* Mailbox 25 Low Acceptance Mask 	*/
+#define CAN_AM25H			0xFFC02BCC	/* Mailbox 25 High Acceptance Mask	*/
+#define CAN_AM26L			0xFFC02BD0	/* Mailbox 26 Low Acceptance Mask 	*/
+#define CAN_AM26H			0xFFC02BD4	/* Mailbox 26 High Acceptance Mask	*/
+#define CAN_AM27L			0xFFC02BD8	/* Mailbox 27 Low Acceptance Mask 	*/
+#define CAN_AM27H			0xFFC02BDC	/* Mailbox 27 High Acceptance Mask	*/
+#define CAN_AM28L			0xFFC02BE0	/* Mailbox 28 Low Acceptance Mask 	*/
+#define CAN_AM28H			0xFFC02BE4	/* Mailbox 28 High Acceptance Mask	*/
+#define CAN_AM29L			0xFFC02BE8	/* Mailbox 29 Low Acceptance Mask 	*/
+#define CAN_AM29H			0xFFC02BEC	/* Mailbox 29 High Acceptance Mask	*/
+#define CAN_AM30L			0xFFC02BF0	/* Mailbox 30 Low Acceptance Mask 	*/
+#define CAN_AM30H			0xFFC02BF4	/* Mailbox 30 High Acceptance Mask	*/
+#define CAN_AM31L			0xFFC02BF8	/* Mailbox 31 Low Acceptance Mask 	*/
+#define CAN_AM31H			0xFFC02BFC	/* Mailbox 31 High Acceptance Mask	*/
+
+/* CAN Acceptance Mask Macros				*/
+#define CAN_AM_L(x)		(CAN_AM00L+((x)*0x8))
+#define CAN_AM_H(x)		(CAN_AM00H+((x)*0x8))
+
+/* Mailbox Registers																*/
+#define CAN_MB00_DATA0		0xFFC02C00	/* Mailbox 0 Data Word 0 [15:0] Register	*/
+#define CAN_MB00_DATA1		0xFFC02C04	/* Mailbox 0 Data Word 1 [31:16] Register	*/
+#define CAN_MB00_DATA2		0xFFC02C08	/* Mailbox 0 Data Word 2 [47:32] Register	*/
+#define CAN_MB00_DATA3		0xFFC02C0C	/* Mailbox 0 Data Word 3 [63:48] Register	*/
+#define CAN_MB00_LENGTH		0xFFC02C10	/* Mailbox 0 Data Length Code Register		*/
+#define CAN_MB00_TIMESTAMP	0xFFC02C14	/* Mailbox 0 Time Stamp Value Register		*/
+#define CAN_MB00_ID0		0xFFC02C18	/* Mailbox 0 Identifier Low Register		*/
+#define CAN_MB00_ID1		0xFFC02C1C	/* Mailbox 0 Identifier High Register		*/
+
+#define CAN_MB01_DATA0		0xFFC02C20	/* Mailbox 1 Data Word 0 [15:0] Register 	*/
+#define CAN_MB01_DATA1		0xFFC02C24	/* Mailbox 1 Data Word 1 [31:16] Register	*/
+#define CAN_MB01_DATA2		0xFFC02C28	/* Mailbox 1 Data Word 2 [47:32] Register	*/
+#define CAN_MB01_DATA3		0xFFC02C2C	/* Mailbox 1 Data Word 3 [63:48] Register	*/
+#define CAN_MB01_LENGTH		0xFFC02C30	/* Mailbox 1 Data Length Code Register   	*/
+#define CAN_MB01_TIMESTAMP	0xFFC02C34	/* Mailbox 1 Time Stamp Value Register   	*/
+#define CAN_MB01_ID0		0xFFC02C38	/* Mailbox 1 Identifier Low Register    	*/
+#define CAN_MB01_ID1		0xFFC02C3C	/* Mailbox 1 Identifier High Register    	*/
+
+#define CAN_MB02_DATA0		0xFFC02C40	/* Mailbox 2 Data Word 0 [15:0] Register 	*/
+#define CAN_MB02_DATA1		0xFFC02C44	/* Mailbox 2 Data Word 1 [31:16] Register	*/
+#define CAN_MB02_DATA2		0xFFC02C48	/* Mailbox 2 Data Word 2 [47:32] Register	*/
+#define CAN_MB02_DATA3		0xFFC02C4C	/* Mailbox 2 Data Word 3 [63:48] Register	*/
+#define CAN_MB02_LENGTH		0xFFC02C50	/* Mailbox 2 Data Length Code Register   	*/
+#define CAN_MB02_TIMESTAMP	0xFFC02C54	/* Mailbox 2 Time Stamp Value Register   	*/
+#define CAN_MB02_ID0		0xFFC02C58	/* Mailbox 2 Identifier Low Register     	*/
+#define CAN_MB02_ID1		0xFFC02C5C	/* Mailbox 2 Identifier High Register    	*/
+
+#define CAN_MB03_DATA0		0xFFC02C60	/* Mailbox 3 Data Word 0 [15:0] Register 	*/
+#define CAN_MB03_DATA1		0xFFC02C64	/* Mailbox 3 Data Word 1 [31:16] Register	*/
+#define CAN_MB03_DATA2		0xFFC02C68	/* Mailbox 3 Data Word 2 [47:32] Register	*/
+#define CAN_MB03_DATA3		0xFFC02C6C	/* Mailbox 3 Data Word 3 [63:48] Register	*/
+#define CAN_MB03_LENGTH		0xFFC02C70	/* Mailbox 3 Data Length Code Register   	*/
+#define CAN_MB03_TIMESTAMP	0xFFC02C74	/* Mailbox 3 Time Stamp Value Register   	*/
+#define CAN_MB03_ID0		0xFFC02C78	/* Mailbox 3 Identifier Low Register     	*/
+#define CAN_MB03_ID1		0xFFC02C7C	/* Mailbox 3 Identifier High Register    	*/
+
+#define CAN_MB04_DATA0		0xFFC02C80	/* Mailbox 4 Data Word 0 [15:0] Register 	*/
+#define CAN_MB04_DATA1		0xFFC02C84	/* Mailbox 4 Data Word 1 [31:16] Register	*/
+#define CAN_MB04_DATA2		0xFFC02C88	/* Mailbox 4 Data Word 2 [47:32] Register	*/
+#define CAN_MB04_DATA3		0xFFC02C8C	/* Mailbox 4 Data Word 3 [63:48] Register	*/
+#define CAN_MB04_LENGTH		0xFFC02C90	/* Mailbox 4 Data Length Code Register   	*/
+#define CAN_MB04_TIMESTAMP	0xFFC02C94	/* Mailbox 4 Time Stamp Value Register   	*/
+#define CAN_MB04_ID0		0xFFC02C98	/* Mailbox 4 Identifier Low Register     	*/
+#define CAN_MB04_ID1		0xFFC02C9C	/* Mailbox 4 Identifier High Register    	*/
+
+#define CAN_MB05_DATA0		0xFFC02CA0	/* Mailbox 5 Data Word 0 [15:0] Register 	*/
+#define CAN_MB05_DATA1		0xFFC02CA4	/* Mailbox 5 Data Word 1 [31:16] Register	*/
+#define CAN_MB05_DATA2		0xFFC02CA8	/* Mailbox 5 Data Word 2 [47:32] Register	*/
+#define CAN_MB05_DATA3		0xFFC02CAC	/* Mailbox 5 Data Word 3 [63:48] Register	*/
+#define CAN_MB05_LENGTH		0xFFC02CB0	/* Mailbox 5 Data Length Code Register   	*/
+#define CAN_MB05_TIMESTAMP	0xFFC02CB4	/* Mailbox 5 Time Stamp Value Register   	*/
+#define CAN_MB05_ID0		0xFFC02CB8	/* Mailbox 5 Identifier Low Register     	*/
+#define CAN_MB05_ID1		0xFFC02CBC	/* Mailbox 5 Identifier High Register    	*/
+
+#define CAN_MB06_DATA0		0xFFC02CC0	/* Mailbox 6 Data Word 0 [15:0] Register 	*/
+#define CAN_MB06_DATA1		0xFFC02CC4	/* Mailbox 6 Data Word 1 [31:16] Register	*/
+#define CAN_MB06_DATA2		0xFFC02CC8	/* Mailbox 6 Data Word 2 [47:32] Register	*/
+#define CAN_MB06_DATA3		0xFFC02CCC	/* Mailbox 6 Data Word 3 [63:48] Register	*/
+#define CAN_MB06_LENGTH		0xFFC02CD0	/* Mailbox 6 Data Length Code Register   	*/
+#define CAN_MB06_TIMESTAMP	0xFFC02CD4	/* Mailbox 6 Time Stamp Value Register   	*/
+#define CAN_MB06_ID0		0xFFC02CD8	/* Mailbox 6 Identifier Low Register     	*/
+#define CAN_MB06_ID1		0xFFC02CDC	/* Mailbox 6 Identifier High Register    	*/
+
+#define CAN_MB07_DATA0		0xFFC02CE0	/* Mailbox 7 Data Word 0 [15:0] Register 	*/
+#define CAN_MB07_DATA1		0xFFC02CE4	/* Mailbox 7 Data Word 1 [31:16] Register	*/
+#define CAN_MB07_DATA2		0xFFC02CE8	/* Mailbox 7 Data Word 2 [47:32] Register	*/
+#define CAN_MB07_DATA3		0xFFC02CEC	/* Mailbox 7 Data Word 3 [63:48] Register	*/
+#define CAN_MB07_LENGTH		0xFFC02CF0	/* Mailbox 7 Data Length Code Register   	*/
+#define CAN_MB07_TIMESTAMP	0xFFC02CF4	/* Mailbox 7 Time Stamp Value Register   	*/
+#define CAN_MB07_ID0		0xFFC02CF8	/* Mailbox 7 Identifier Low Register     	*/
+#define CAN_MB07_ID1		0xFFC02CFC	/* Mailbox 7 Identifier High Register    	*/
+
+#define CAN_MB08_DATA0		0xFFC02D00	/* Mailbox 8 Data Word 0 [15:0] Register 	*/
+#define CAN_MB08_DATA1		0xFFC02D04	/* Mailbox 8 Data Word 1 [31:16] Register	*/
+#define CAN_MB08_DATA2		0xFFC02D08	/* Mailbox 8 Data Word 2 [47:32] Register	*/
+#define CAN_MB08_DATA3		0xFFC02D0C	/* Mailbox 8 Data Word 3 [63:48] Register	*/
+#define CAN_MB08_LENGTH		0xFFC02D10	/* Mailbox 8 Data Length Code Register   	*/
+#define CAN_MB08_TIMESTAMP	0xFFC02D14	/* Mailbox 8 Time Stamp Value Register   	*/
+#define CAN_MB08_ID0		0xFFC02D18	/* Mailbox 8 Identifier Low Register     	*/
+#define CAN_MB08_ID1		0xFFC02D1C	/* Mailbox 8 Identifier High Register    	*/
+
+#define CAN_MB09_DATA0		0xFFC02D20	/* Mailbox 9 Data Word 0 [15:0] Register 	*/
+#define CAN_MB09_DATA1		0xFFC02D24	/* Mailbox 9 Data Word 1 [31:16] Register	*/
+#define CAN_MB09_DATA2		0xFFC02D28	/* Mailbox 9 Data Word 2 [47:32] Register	*/
+#define CAN_MB09_DATA3		0xFFC02D2C	/* Mailbox 9 Data Word 3 [63:48] Register	*/
+#define CAN_MB09_LENGTH		0xFFC02D30	/* Mailbox 9 Data Length Code Register   	*/
+#define CAN_MB09_TIMESTAMP	0xFFC02D34	/* Mailbox 9 Time Stamp Value Register   	*/
+#define CAN_MB09_ID0		0xFFC02D38	/* Mailbox 9 Identifier Low Register     	*/
+#define CAN_MB09_ID1		0xFFC02D3C	/* Mailbox 9 Identifier High Register    	*/
+
+#define CAN_MB10_DATA0		0xFFC02D40	/* Mailbox 10 Data Word 0 [15:0] Register 	*/
+#define CAN_MB10_DATA1		0xFFC02D44	/* Mailbox 10 Data Word 1 [31:16] Register	*/
+#define CAN_MB10_DATA2		0xFFC02D48	/* Mailbox 10 Data Word 2 [47:32] Register	*/
+#define CAN_MB10_DATA3		0xFFC02D4C	/* Mailbox 10 Data Word 3 [63:48] Register	*/
+#define CAN_MB10_LENGTH		0xFFC02D50	/* Mailbox 10 Data Length Code Register   	*/
+#define CAN_MB10_TIMESTAMP	0xFFC02D54	/* Mailbox 10 Time Stamp Value Register   	*/
+#define CAN_MB10_ID0		0xFFC02D58	/* Mailbox 10 Identifier Low Register     	*/
+#define CAN_MB10_ID1		0xFFC02D5C	/* Mailbox 10 Identifier High Register    	*/
+
+#define CAN_MB11_DATA0		0xFFC02D60	/* Mailbox 11 Data Word 0 [15:0] Register 	*/
+#define CAN_MB11_DATA1		0xFFC02D64	/* Mailbox 11 Data Word 1 [31:16] Register	*/
+#define CAN_MB11_DATA2		0xFFC02D68	/* Mailbox 11 Data Word 2 [47:32] Register	*/
+#define CAN_MB11_DATA3		0xFFC02D6C	/* Mailbox 11 Data Word 3 [63:48] Register	*/
+#define CAN_MB11_LENGTH		0xFFC02D70	/* Mailbox 11 Data Length Code Register   	*/
+#define CAN_MB11_TIMESTAMP	0xFFC02D74	/* Mailbox 11 Time Stamp Value Register   	*/
+#define CAN_MB11_ID0		0xFFC02D78	/* Mailbox 11 Identifier Low Register     	*/
+#define CAN_MB11_ID1		0xFFC02D7C	/* Mailbox 11 Identifier High Register    	*/
+
+#define CAN_MB12_DATA0		0xFFC02D80	/* Mailbox 12 Data Word 0 [15:0] Register 	*/
+#define CAN_MB12_DATA1		0xFFC02D84	/* Mailbox 12 Data Word 1 [31:16] Register	*/
+#define CAN_MB12_DATA2		0xFFC02D88	/* Mailbox 12 Data Word 2 [47:32] Register	*/
+#define CAN_MB12_DATA3		0xFFC02D8C	/* Mailbox 12 Data Word 3 [63:48] Register	*/
+#define CAN_MB12_LENGTH		0xFFC02D90	/* Mailbox 12 Data Length Code Register   	*/
+#define CAN_MB12_TIMESTAMP	0xFFC02D94	/* Mailbox 12 Time Stamp Value Register   	*/
+#define CAN_MB12_ID0		0xFFC02D98	/* Mailbox 12 Identifier Low Register     	*/
+#define CAN_MB12_ID1		0xFFC02D9C	/* Mailbox 12 Identifier High Register    	*/
+
+#define CAN_MB13_DATA0		0xFFC02DA0	/* Mailbox 13 Data Word 0 [15:0] Register 	*/
+#define CAN_MB13_DATA1		0xFFC02DA4	/* Mailbox 13 Data Word 1 [31:16] Register	*/
+#define CAN_MB13_DATA2		0xFFC02DA8	/* Mailbox 13 Data Word 2 [47:32] Register	*/
+#define CAN_MB13_DATA3		0xFFC02DAC	/* Mailbox 13 Data Word 3 [63:48] Register	*/
+#define CAN_MB13_LENGTH		0xFFC02DB0	/* Mailbox 13 Data Length Code Register   	*/
+#define CAN_MB13_TIMESTAMP	0xFFC02DB4	/* Mailbox 13 Time Stamp Value Register   	*/
+#define CAN_MB13_ID0		0xFFC02DB8	/* Mailbox 13 Identifier Low Register     	*/
+#define CAN_MB13_ID1		0xFFC02DBC	/* Mailbox 13 Identifier High Register    	*/
+
+#define CAN_MB14_DATA0		0xFFC02DC0	/* Mailbox 14 Data Word 0 [15:0] Register 	*/
+#define CAN_MB14_DATA1		0xFFC02DC4	/* Mailbox 14 Data Word 1 [31:16] Register	*/
+#define CAN_MB14_DATA2		0xFFC02DC8	/* Mailbox 14 Data Word 2 [47:32] Register	*/
+#define CAN_MB14_DATA3		0xFFC02DCC	/* Mailbox 14 Data Word 3 [63:48] Register	*/
+#define CAN_MB14_LENGTH		0xFFC02DD0	/* Mailbox 14 Data Length Code Register   	*/
+#define CAN_MB14_TIMESTAMP	0xFFC02DD4	/* Mailbox 14 Time Stamp Value Register   	*/
+#define CAN_MB14_ID0		0xFFC02DD8	/* Mailbox 14 Identifier Low Register     	*/
+#define CAN_MB14_ID1		0xFFC02DDC	/* Mailbox 14 Identifier High Register    	*/
+
+#define CAN_MB15_DATA0		0xFFC02DE0	/* Mailbox 15 Data Word 0 [15:0] Register 	*/
+#define CAN_MB15_DATA1		0xFFC02DE4	/* Mailbox 15 Data Word 1 [31:16] Register	*/
+#define CAN_MB15_DATA2		0xFFC02DE8	/* Mailbox 15 Data Word 2 [47:32] Register	*/
+#define CAN_MB15_DATA3		0xFFC02DEC	/* Mailbox 15 Data Word 3 [63:48] Register	*/
+#define CAN_MB15_LENGTH		0xFFC02DF0	/* Mailbox 15 Data Length Code Register   	*/
+#define CAN_MB15_TIMESTAMP	0xFFC02DF4	/* Mailbox 15 Time Stamp Value Register   	*/
+#define CAN_MB15_ID0		0xFFC02DF8	/* Mailbox 15 Identifier Low Register     	*/
+#define CAN_MB15_ID1		0xFFC02DFC	/* Mailbox 15 Identifier High Register    	*/
+
+#define CAN_MB16_DATA0		0xFFC02E00	/* Mailbox 16 Data Word 0 [15:0] Register 	*/
+#define CAN_MB16_DATA1		0xFFC02E04	/* Mailbox 16 Data Word 1 [31:16] Register	*/
+#define CAN_MB16_DATA2		0xFFC02E08	/* Mailbox 16 Data Word 2 [47:32] Register	*/
+#define CAN_MB16_DATA3		0xFFC02E0C	/* Mailbox 16 Data Word 3 [63:48] Register	*/
+#define CAN_MB16_LENGTH		0xFFC02E10	/* Mailbox 16 Data Length Code Register   	*/
+#define CAN_MB16_TIMESTAMP	0xFFC02E14	/* Mailbox 16 Time Stamp Value Register   	*/
+#define CAN_MB16_ID0		0xFFC02E18	/* Mailbox 16 Identifier Low Register     	*/
+#define CAN_MB16_ID1		0xFFC02E1C	/* Mailbox 16 Identifier High Register    	*/
+
+#define CAN_MB17_DATA0		0xFFC02E20	/* Mailbox 17 Data Word 0 [15:0] Register 	*/
+#define CAN_MB17_DATA1		0xFFC02E24	/* Mailbox 17 Data Word 1 [31:16] Register	*/
+#define CAN_MB17_DATA2		0xFFC02E28	/* Mailbox 17 Data Word 2 [47:32] Register	*/
+#define CAN_MB17_DATA3		0xFFC02E2C	/* Mailbox 17 Data Word 3 [63:48] Register	*/
+#define CAN_MB17_LENGTH		0xFFC02E30	/* Mailbox 17 Data Length Code Register   	*/
+#define CAN_MB17_TIMESTAMP	0xFFC02E34	/* Mailbox 17 Time Stamp Value Register   	*/
+#define CAN_MB17_ID0		0xFFC02E38	/* Mailbox 17 Identifier Low Register     	*/
+#define CAN_MB17_ID1		0xFFC02E3C	/* Mailbox 17 Identifier High Register    	*/
+
+#define CAN_MB18_DATA0		0xFFC02E40	/* Mailbox 18 Data Word 0 [15:0] Register 	*/
+#define CAN_MB18_DATA1		0xFFC02E44	/* Mailbox 18 Data Word 1 [31:16] Register	*/
+#define CAN_MB18_DATA2		0xFFC02E48	/* Mailbox 18 Data Word 2 [47:32] Register	*/
+#define CAN_MB18_DATA3		0xFFC02E4C	/* Mailbox 18 Data Word 3 [63:48] Register	*/
+#define CAN_MB18_LENGTH		0xFFC02E50	/* Mailbox 18 Data Length Code Register   	*/
+#define CAN_MB18_TIMESTAMP	0xFFC02E54	/* Mailbox 18 Time Stamp Value Register   	*/
+#define CAN_MB18_ID0		0xFFC02E58	/* Mailbox 18 Identifier Low Register     	*/
+#define CAN_MB18_ID1		0xFFC02E5C	/* Mailbox 18 Identifier High Register    	*/
+
+#define CAN_MB19_DATA0		0xFFC02E60	/* Mailbox 19 Data Word 0 [15:0] Register 	*/
+#define CAN_MB19_DATA1		0xFFC02E64	/* Mailbox 19 Data Word 1 [31:16] Register	*/
+#define CAN_MB19_DATA2		0xFFC02E68	/* Mailbox 19 Data Word 2 [47:32] Register	*/
+#define CAN_MB19_DATA3		0xFFC02E6C	/* Mailbox 19 Data Word 3 [63:48] Register	*/
+#define CAN_MB19_LENGTH		0xFFC02E70	/* Mailbox 19 Data Length Code Register   	*/
+#define CAN_MB19_TIMESTAMP	0xFFC02E74	/* Mailbox 19 Time Stamp Value Register   	*/
+#define CAN_MB19_ID0		0xFFC02E78	/* Mailbox 19 Identifier Low Register     	*/
+#define CAN_MB19_ID1		0xFFC02E7C	/* Mailbox 19 Identifier High Register    	*/
+
+#define CAN_MB20_DATA0		0xFFC02E80	/* Mailbox 20 Data Word 0 [15:0] Register 	*/
+#define CAN_MB20_DATA1		0xFFC02E84	/* Mailbox 20 Data Word 1 [31:16] Register	*/
+#define CAN_MB20_DATA2		0xFFC02E88	/* Mailbox 20 Data Word 2 [47:32] Register	*/
+#define CAN_MB20_DATA3		0xFFC02E8C	/* Mailbox 20 Data Word 3 [63:48] Register	*/
+#define CAN_MB20_LENGTH		0xFFC02E90	/* Mailbox 20 Data Length Code Register   	*/
+#define CAN_MB20_TIMESTAMP	0xFFC02E94	/* Mailbox 20 Time Stamp Value Register   	*/
+#define CAN_MB20_ID0		0xFFC02E98	/* Mailbox 20 Identifier Low Register     	*/
+#define CAN_MB20_ID1		0xFFC02E9C	/* Mailbox 20 Identifier High Register    	*/
+
+#define CAN_MB21_DATA0		0xFFC02EA0	/* Mailbox 21 Data Word 0 [15:0] Register 	*/
+#define CAN_MB21_DATA1		0xFFC02EA4	/* Mailbox 21 Data Word 1 [31:16] Register	*/
+#define CAN_MB21_DATA2		0xFFC02EA8	/* Mailbox 21 Data Word 2 [47:32] Register	*/
+#define CAN_MB21_DATA3		0xFFC02EAC	/* Mailbox 21 Data Word 3 [63:48] Register	*/
+#define CAN_MB21_LENGTH		0xFFC02EB0	/* Mailbox 21 Data Length Code Register   	*/
+#define CAN_MB21_TIMESTAMP	0xFFC02EB4	/* Mailbox 21 Time Stamp Value Register   	*/
+#define CAN_MB21_ID0		0xFFC02EB8	/* Mailbox 21 Identifier Low Register     	*/
+#define CAN_MB21_ID1		0xFFC02EBC	/* Mailbox 21 Identifier High Register    	*/
+
+#define CAN_MB22_DATA0		0xFFC02EC0	/* Mailbox 22 Data Word 0 [15:0] Register 	*/
+#define CAN_MB22_DATA1		0xFFC02EC4	/* Mailbox 22 Data Word 1 [31:16] Register	*/
+#define CAN_MB22_DATA2		0xFFC02EC8	/* Mailbox 22 Data Word 2 [47:32] Register	*/
+#define CAN_MB22_DATA3		0xFFC02ECC	/* Mailbox 22 Data Word 3 [63:48] Register	*/
+#define CAN_MB22_LENGTH		0xFFC02ED0	/* Mailbox 22 Data Length Code Register   	*/
+#define CAN_MB22_TIMESTAMP	0xFFC02ED4	/* Mailbox 22 Time Stamp Value Register   	*/
+#define CAN_MB22_ID0		0xFFC02ED8	/* Mailbox 22 Identifier Low Register     	*/
+#define CAN_MB22_ID1		0xFFC02EDC	/* Mailbox 22 Identifier High Register    	*/
+
+#define CAN_MB23_DATA0		0xFFC02EE0	/* Mailbox 23 Data Word 0 [15:0] Register 	*/
+#define CAN_MB23_DATA1		0xFFC02EE4	/* Mailbox 23 Data Word 1 [31:16] Register	*/
+#define CAN_MB23_DATA2		0xFFC02EE8	/* Mailbox 23 Data Word 2 [47:32] Register	*/
+#define CAN_MB23_DATA3		0xFFC02EEC	/* Mailbox 23 Data Word 3 [63:48] Register	*/
+#define CAN_MB23_LENGTH		0xFFC02EF0	/* Mailbox 23 Data Length Code Register   	*/
+#define CAN_MB23_TIMESTAMP	0xFFC02EF4	/* Mailbox 23 Time Stamp Value Register   	*/
+#define CAN_MB23_ID0		0xFFC02EF8	/* Mailbox 23 Identifier Low Register     	*/
+#define CAN_MB23_ID1		0xFFC02EFC	/* Mailbox 23 Identifier High Register    	*/
+
+#define CAN_MB24_DATA0		0xFFC02F00	/* Mailbox 24 Data Word 0 [15:0] Register 	*/
+#define CAN_MB24_DATA1		0xFFC02F04	/* Mailbox 24 Data Word 1 [31:16] Register	*/
+#define CAN_MB24_DATA2		0xFFC02F08	/* Mailbox 24 Data Word 2 [47:32] Register	*/
+#define CAN_MB24_DATA3		0xFFC02F0C	/* Mailbox 24 Data Word 3 [63:48] Register	*/
+#define CAN_MB24_LENGTH		0xFFC02F10	/* Mailbox 24 Data Length Code Register   	*/
+#define CAN_MB24_TIMESTAMP	0xFFC02F14	/* Mailbox 24 Time Stamp Value Register   	*/
+#define CAN_MB24_ID0		0xFFC02F18	/* Mailbox 24 Identifier Low Register     	*/
+#define CAN_MB24_ID1		0xFFC02F1C	/* Mailbox 24 Identifier High Register    	*/
+
+#define CAN_MB25_DATA0		0xFFC02F20	/* Mailbox 25 Data Word 0 [15:0] Register 	*/
+#define CAN_MB25_DATA1		0xFFC02F24	/* Mailbox 25 Data Word 1 [31:16] Register	*/
+#define CAN_MB25_DATA2		0xFFC02F28	/* Mailbox 25 Data Word 2 [47:32] Register	*/
+#define CAN_MB25_DATA3		0xFFC02F2C	/* Mailbox 25 Data Word 3 [63:48] Register	*/
+#define CAN_MB25_LENGTH		0xFFC02F30	/* Mailbox 25 Data Length Code Register   	*/
+#define CAN_MB25_TIMESTAMP	0xFFC02F34	/* Mailbox 25 Time Stamp Value Register   	*/
+#define CAN_MB25_ID0		0xFFC02F38	/* Mailbox 25 Identifier Low Register     	*/
+#define CAN_MB25_ID1		0xFFC02F3C	/* Mailbox 25 Identifier High Register    	*/
+
+#define CAN_MB26_DATA0		0xFFC02F40	/* Mailbox 26 Data Word 0 [15:0] Register 	*/
+#define CAN_MB26_DATA1		0xFFC02F44	/* Mailbox 26 Data Word 1 [31:16] Register	*/
+#define CAN_MB26_DATA2		0xFFC02F48	/* Mailbox 26 Data Word 2 [47:32] Register	*/
+#define CAN_MB26_DATA3		0xFFC02F4C	/* Mailbox 26 Data Word 3 [63:48] Register	*/
+#define CAN_MB26_LENGTH		0xFFC02F50	/* Mailbox 26 Data Length Code Register   	*/
+#define CAN_MB26_TIMESTAMP	0xFFC02F54	/* Mailbox 26 Time Stamp Value Register   	*/
+#define CAN_MB26_ID0		0xFFC02F58	/* Mailbox 26 Identifier Low Register     	*/
+#define CAN_MB26_ID1		0xFFC02F5C	/* Mailbox 26 Identifier High Register    	*/
+
+#define CAN_MB27_DATA0		0xFFC02F60	/* Mailbox 27 Data Word 0 [15:0] Register 	*/
+#define CAN_MB27_DATA1		0xFFC02F64	/* Mailbox 27 Data Word 1 [31:16] Register	*/
+#define CAN_MB27_DATA2		0xFFC02F68	/* Mailbox 27 Data Word 2 [47:32] Register	*/
+#define CAN_MB27_DATA3		0xFFC02F6C	/* Mailbox 27 Data Word 3 [63:48] Register	*/
+#define CAN_MB27_LENGTH		0xFFC02F70	/* Mailbox 27 Data Length Code Register   	*/
+#define CAN_MB27_TIMESTAMP	0xFFC02F74	/* Mailbox 27 Time Stamp Value Register   	*/
+#define CAN_MB27_ID0		0xFFC02F78	/* Mailbox 27 Identifier Low Register     	*/
+#define CAN_MB27_ID1		0xFFC02F7C	/* Mailbox 27 Identifier High Register    	*/
+
+#define CAN_MB28_DATA0		0xFFC02F80	/* Mailbox 28 Data Word 0 [15:0] Register 	*/
+#define CAN_MB28_DATA1		0xFFC02F84	/* Mailbox 28 Data Word 1 [31:16] Register	*/
+#define CAN_MB28_DATA2		0xFFC02F88	/* Mailbox 28 Data Word 2 [47:32] Register	*/
+#define CAN_MB28_DATA3		0xFFC02F8C	/* Mailbox 28 Data Word 3 [63:48] Register	*/
+#define CAN_MB28_LENGTH		0xFFC02F90	/* Mailbox 28 Data Length Code Register   	*/
+#define CAN_MB28_TIMESTAMP	0xFFC02F94	/* Mailbox 28 Time Stamp Value Register   	*/
+#define CAN_MB28_ID0		0xFFC02F98	/* Mailbox 28 Identifier Low Register     	*/
+#define CAN_MB28_ID1		0xFFC02F9C	/* Mailbox 28 Identifier High Register    	*/
+
+#define CAN_MB29_DATA0		0xFFC02FA0	/* Mailbox 29 Data Word 0 [15:0] Register 	*/
+#define CAN_MB29_DATA1		0xFFC02FA4	/* Mailbox 29 Data Word 1 [31:16] Register	*/
+#define CAN_MB29_DATA2		0xFFC02FA8	/* Mailbox 29 Data Word 2 [47:32] Register	*/
+#define CAN_MB29_DATA3		0xFFC02FAC	/* Mailbox 29 Data Word 3 [63:48] Register	*/
+#define CAN_MB29_LENGTH		0xFFC02FB0	/* Mailbox 29 Data Length Code Register   	*/
+#define CAN_MB29_TIMESTAMP	0xFFC02FB4	/* Mailbox 29 Time Stamp Value Register   	*/
+#define CAN_MB29_ID0		0xFFC02FB8	/* Mailbox 29 Identifier Low Register     	*/
+#define CAN_MB29_ID1		0xFFC02FBC	/* Mailbox 29 Identifier High Register    	*/
+
+#define CAN_MB30_DATA0		0xFFC02FC0	/* Mailbox 30 Data Word 0 [15:0] Register 	*/
+#define CAN_MB30_DATA1		0xFFC02FC4	/* Mailbox 30 Data Word 1 [31:16] Register	*/
+#define CAN_MB30_DATA2		0xFFC02FC8	/* Mailbox 30 Data Word 2 [47:32] Register	*/
+#define CAN_MB30_DATA3		0xFFC02FCC	/* Mailbox 30 Data Word 3 [63:48] Register	*/
+#define CAN_MB30_LENGTH		0xFFC02FD0	/* Mailbox 30 Data Length Code Register   	*/
+#define CAN_MB30_TIMESTAMP	0xFFC02FD4	/* Mailbox 30 Time Stamp Value Register   	*/
+#define CAN_MB30_ID0		0xFFC02FD8	/* Mailbox 30 Identifier Low Register     	*/
+#define CAN_MB30_ID1		0xFFC02FDC	/* Mailbox 30 Identifier High Register    	*/
+
+#define CAN_MB31_DATA0		0xFFC02FE0	/* Mailbox 31 Data Word 0 [15:0] Register 	*/
+#define CAN_MB31_DATA1		0xFFC02FE4	/* Mailbox 31 Data Word 1 [31:16] Register	*/
+#define CAN_MB31_DATA2		0xFFC02FE8	/* Mailbox 31 Data Word 2 [47:32] Register	*/
+#define CAN_MB31_DATA3		0xFFC02FEC	/* Mailbox 31 Data Word 3 [63:48] Register	*/
+#define CAN_MB31_LENGTH		0xFFC02FF0	/* Mailbox 31 Data Length Code Register   	*/
+#define CAN_MB31_TIMESTAMP	0xFFC02FF4	/* Mailbox 31 Time Stamp Value Register   	*/
+#define CAN_MB31_ID0		0xFFC02FF8	/* Mailbox 31 Identifier Low Register     	*/
+#define CAN_MB31_ID1		0xFFC02FFC	/* Mailbox 31 Identifier High Register    	*/
+
+/* CAN Mailbox Area Macros				*/
+#define CAN_MB_ID1(x)		(CAN_MB00_ID1+((x)*0x20))
+#define CAN_MB_ID0(x)		(CAN_MB00_ID0+((x)*0x20))
+#define CAN_MB_TIMESTAMP(x)	(CAN_MB00_TIMESTAMP+((x)*0x20))
+#define CAN_MB_LENGTH(x)	(CAN_MB00_LENGTH+((x)*0x20))
+#define CAN_MB_DATA3(x)		(CAN_MB00_DATA3+((x)*0x20))
+#define CAN_MB_DATA2(x)		(CAN_MB00_DATA2+((x)*0x20))
+#define CAN_MB_DATA1(x)		(CAN_MB00_DATA1+((x)*0x20))
+#define CAN_MB_DATA0(x)		(CAN_MB00_DATA0+((x)*0x20))
+
+/* Pin Control Registers	(0xFFC03200 - 0xFFC032FF)											*/
+#define PORTF_FER			0xFFC03200	/* Port F Function Enable Register (Alternate/Flag*)	*/
+#define PORTG_FER			0xFFC03204	/* Port G Function Enable Register (Alternate/Flag*)	*/
+#define PORTH_FER			0xFFC03208	/* Port H Function Enable Register (Alternate/Flag*)	*/
+#define PORT_MUX			0xFFC0320C	/* Port Multiplexer Control Register					*/
+
+/* Handshake MDMA Registers	(0xFFC03300 - 0xFFC033FF)										*/
+#define HMDMA0_CONTROL		0xFFC03300	/* Handshake MDMA0 Control Register					*/
+#define HMDMA0_ECINIT		0xFFC03304	/* HMDMA0 Initial Edge Count Register				*/
+#define HMDMA0_BCINIT		0xFFC03308	/* HMDMA0 Initial Block Count Register				*/
+#define HMDMA0_ECURGENT		0xFFC0330C	/* HMDMA0 Urgent Edge Count Threshhold Register		*/
+#define HMDMA0_ECOVERFLOW	0xFFC03310	/* HMDMA0 Edge Count Overflow Interrupt Register	*/
+#define HMDMA0_ECOUNT		0xFFC03314	/* HMDMA0 Current Edge Count Register				*/
+#define HMDMA0_BCOUNT		0xFFC03318	/* HMDMA0 Current Block Count Register				*/
+
+#define HMDMA1_CONTROL		0xFFC03340	/* Handshake MDMA1 Control Register					*/
+#define HMDMA1_ECINIT		0xFFC03344	/* HMDMA1 Initial Edge Count Register				*/
+#define HMDMA1_BCINIT		0xFFC03348	/* HMDMA1 Initial Block Count Register				*/
+#define HMDMA1_ECURGENT		0xFFC0334C	/* HMDMA1 Urgent Edge Count Threshhold Register		*/
+#define HMDMA1_ECOVERFLOW	0xFFC03350	/* HMDMA1 Edge Count Overflow Interrupt Register	*/
+#define HMDMA1_ECOUNT		0xFFC03354	/* HMDMA1 Current Edge Count Register				*/
+#define HMDMA1_BCOUNT		0xFFC03358	/* HMDMA1 Current Block Count Register				*/
+
+/***********************************************************************************
+** System MMR Register Bits And Macros
+**
+** Disclaimer:	All macros are intended to make C and Assembly code more readable.
+**				Use these macros carefully, as any that do left shifts for field
+**				depositing will result in the lower order bits being destroyed.  Any
+**				macro that shifts left to properly position the bit-field should be
+**				used as part of an OR to initialize a register and NOT as a dynamic
+**				modifier UNLESS the lower order bits are saved and ORed back in when
+**				the macro is used.
+*************************************************************************************/
+/*
+** ********************* PLL AND RESET MASKS ****************************************/
+/* PLL_CTL Masks																	*/
+#define DF				0x0001	/* 0: PLL = CLKIN, 1: PLL = CLKIN/2					*/
+#define PLL_OFF			0x0002	/* PLL Not Powered									*/
+#define STOPCK			0x0008	/* Core Clock Off									*/
+#define PDWN			0x0020	/* Enter Deep Sleep Mode							*/
+#define	IN_DELAY		0x0040	/* Add 200ps Delay To EBIU Input Latches			*/
+#define	OUT_DELAY		0x0080	/* Add 200ps Delay To EBIU Output Signals			*/
+#define BYPASS			0x0100	/* Bypass the PLL									*/
+#define	MSEL			0x7E00	/* Multiplier Select For CCLK/VCO Factors			*/
+/* PLL_CTL Macros (Only Use With Logic OR While Setting Lower Order Bits)			*/
+#define	SET_MSEL(x)		(((x)&0x3F) << 0x9)	/* Set MSEL = 0-63 --> VCO = CLKIN*MSEL		*/
+
+/* PLL_DIV Masks														*/
+#define SSEL			0x000F	/* System Select						*/
+#define	CSEL			0x0030	/* Core Select							*/
+#define CSEL_DIV1		0x0000	/* 		CCLK = VCO / 1					*/
+#define CSEL_DIV2		0x0010	/* 		CCLK = VCO / 2					*/
+#define	CSEL_DIV4		0x0020	/* 		CCLK = VCO / 4					*/
+#define	CSEL_DIV8		0x0030	/* 		CCLK = VCO / 8					*/
+/* PLL_DIV Macros														*/
+#define SET_SSEL(x)		((x)&0xF)		/* Set SSEL = 0-15 --> SCLK = VCO/SSEL	*/
+
+/* VR_CTL Masks																	*/
+#define	FREQ			0x0003	/* Switching Oscillator Frequency For Regulator	*/
+#define	HIBERNATE		0x0000	/* 		Powerdown/Bypass On-Board Regulation	*/
+#define	FREQ_333		0x0001	/* 		Switching Frequency Is 333 kHz			*/
+#define	FREQ_667		0x0002	/* 		Switching Frequency Is 667 kHz			*/
+#define	FREQ_1000		0x0003	/* 		Switching Frequency Is 1 MHz			*/
+
+#define GAIN			0x000C	/* Voltage Level Gain	*/
+#define	GAIN_5			0x0000	/* 		GAIN = 5		*/
+#define	GAIN_10			0x0004	/* 		GAIN = 10		*/
+#define	GAIN_20			0x0008	/* 		GAIN = 20		*/
+#define	GAIN_50			0x000C	/* 		GAIN = 50		*/
+
+#define	VLEV			0x00F0	/* Internal Voltage Level					*/
+#define	VLEV_085 		0x0060	/* 		VLEV = 0.85 V (-5% - +10% Accuracy)	*/
+#define	VLEV_090		0x0070	/* 		VLEV = 0.90 V (-5% - +10% Accuracy)	*/
+#define	VLEV_095		0x0080	/* 		VLEV = 0.95 V (-5% - +10% Accuracy)	*/
+#define	VLEV_100		0x0090	/* 		VLEV = 1.00 V (-5% - +10% Accuracy)	*/
+#define	VLEV_105		0x00A0	/* 		VLEV = 1.05 V (-5% - +10% Accuracy)	*/
+#define	VLEV_110		0x00B0	/* 		VLEV = 1.10 V (-5% - +10% Accuracy)	*/
+#define	VLEV_115		0x00C0	/* 		VLEV = 1.15 V (-5% - +10% Accuracy)	*/
+#define	VLEV_120		0x00D0	/* 		VLEV = 1.20 V (-5% - +10% Accuracy)	*/
+#define	VLEV_125		0x00E0	/* 		VLEV = 1.25 V (-5% - +10% Accuracy)	*/
+#define	VLEV_130		0x00F0	/* 		VLEV = 1.30 V (-5% - +10% Accuracy)	*/
+
+#define	WAKE			0x0100	/* Enable RTC/Reset Wakeup From Hibernate	*/
+#define PHYWE			0x0200	/* Enable PHY Wakeup From Hibernate			*/
+#define	CANWE			0x0400	/* Enable CAN Wakeup From Hibernate			*/
+#define	PHYCLKOE		0x4000	/* PHY Clock Output Enable					*/
+#define	CKELOW			0x8000	/* Enable Drive CKE Low During Reset		*/
+
+/* PLL_STAT Masks																	*/
+#define ACTIVE_PLLENABLED	0x0001	/* Processor In Active Mode With PLL Enabled	*/
+#define	FULL_ON				0x0002	/* Processor In Full On Mode					*/
+#define ACTIVE_PLLDISABLED	0x0004	/* Processor In Active Mode With PLL Disabled	*/
+#define	PLL_LOCKED			0x0020	/* PLL_LOCKCNT Has Been Reached					*/
+
+/* SWRST Masks																		*/
+#define SYSTEM_RESET		0x0007	/* Initiates A System Software Reset			*/
+#define	DOUBLE_FAULT		0x0008	/* Core Double Fault Causes Reset				*/
+#define RESET_DOUBLE		0x2000	/* SW Reset Generated By Core Double-Fault		*/
+#define RESET_WDOG			0x4000	/* SW Reset Generated By Watchdog Timer			*/
+#define RESET_SOFTWARE		0x8000	/* SW Reset Occurred Since Last Read Of SWRST	*/
+
+/* SYSCR Masks																				*/
+#define BMODE				0x0006	/* Boot Mode - Latched During HW Reset From Mode Pins	*/
+#define	NOBOOT				0x0010	/* Execute From L1 or ASYNC Bank 0 When BMODE = 0		*/
+
+/* *************  SYSTEM INTERRUPT CONTROLLER MASKS *************************************/
+
+/* SIC_IAR0 Macros															*/
+#define P0_IVG(x)		(((x)&0xF)-7)			/* Peripheral #0 assigned IVG #x 	*/
+#define P1_IVG(x)		(((x)&0xF)-7) << 0x4	/* Peripheral #1 assigned IVG #x 	*/
+#define P2_IVG(x)		(((x)&0xF)-7) << 0x8	/* Peripheral #2 assigned IVG #x 	*/
+#define P3_IVG(x)		(((x)&0xF)-7) << 0xC	/* Peripheral #3 assigned IVG #x	*/
+#define P4_IVG(x)		(((x)&0xF)-7) << 0x10	/* Peripheral #4 assigned IVG #x	*/
+#define P5_IVG(x)		(((x)&0xF)-7) << 0x14	/* Peripheral #5 assigned IVG #x	*/
+#define P6_IVG(x)		(((x)&0xF)-7) << 0x18	/* Peripheral #6 assigned IVG #x	*/
+#define P7_IVG(x)		(((x)&0xF)-7) << 0x1C	/* Peripheral #7 assigned IVG #x	*/
+
+/* SIC_IAR1 Macros															*/
+#define P8_IVG(x)		(((x)&0xF)-7)			/* Peripheral #8 assigned IVG #x 	*/
+#define P9_IVG(x)		(((x)&0xF)-7) << 0x4	/* Peripheral #9 assigned IVG #x 	*/
+#define P10_IVG(x)		(((x)&0xF)-7) << 0x8	/* Peripheral #10 assigned IVG #x	*/
+#define P11_IVG(x)		(((x)&0xF)-7) << 0xC	/* Peripheral #11 assigned IVG #x 	*/
+#define P12_IVG(x)		(((x)&0xF)-7) << 0x10	/* Peripheral #12 assigned IVG #x	*/
+#define P13_IVG(x)		(((x)&0xF)-7) << 0x14	/* Peripheral #13 assigned IVG #x	*/
+#define P14_IVG(x)		(((x)&0xF)-7) << 0x18	/* Peripheral #14 assigned IVG #x	*/
+#define P15_IVG(x)		(((x)&0xF)-7) << 0x1C	/* Peripheral #15 assigned IVG #x	*/
+
+/* SIC_IAR2 Macros															*/
+#define P16_IVG(x)		(((x)&0xF)-7)			/* Peripheral #16 assigned IVG #x	*/
+#define P17_IVG(x)		(((x)&0xF)-7) << 0x4	/* Peripheral #17 assigned IVG #x	*/
+#define P18_IVG(x)		(((x)&0xF)-7) << 0x8	/* Peripheral #18 assigned IVG #x	*/
+#define P19_IVG(x)		(((x)&0xF)-7) << 0xC	/* Peripheral #19 assigned IVG #x	*/
+#define P20_IVG(x)		(((x)&0xF)-7) << 0x10	/* Peripheral #20 assigned IVG #x	*/
+#define P21_IVG(x)		(((x)&0xF)-7) << 0x14	/* Peripheral #21 assigned IVG #x	*/
+#define P22_IVG(x)		(((x)&0xF)-7) << 0x18	/* Peripheral #22 assigned IVG #x	*/
+#define P23_IVG(x)		(((x)&0xF)-7) << 0x1C	/* Peripheral #23 assigned IVG #x	*/
+
+/* SIC_IAR3 Macros															*/
+#define P24_IVG(x)		(((x)&0xF)-7)			/* Peripheral #24 assigned IVG #x	*/
+#define P25_IVG(x)		(((x)&0xF)-7) << 0x4	/* Peripheral #25 assigned IVG #x	*/
+#define P26_IVG(x)		(((x)&0xF)-7) << 0x8	/* Peripheral #26 assigned IVG #x	*/
+#define P27_IVG(x)		(((x)&0xF)-7) << 0xC	/* Peripheral #27 assigned IVG #x	*/
+#define P28_IVG(x)		(((x)&0xF)-7) << 0x10	/* Peripheral #28 assigned IVG #x	*/
+#define P29_IVG(x)		(((x)&0xF)-7) << 0x14	/* Peripheral #29 assigned IVG #x	*/
+#define P30_IVG(x)		(((x)&0xF)-7) << 0x18	/* Peripheral #30 assigned IVG #x	*/
+#define P31_IVG(x)		(((x)&0xF)-7) << 0x1C	/* Peripheral #31 assigned IVG #x	*/
+
+/* SIC_IMASK Masks																		*/
+#define SIC_UNMASK_ALL	0x00000000					/* Unmask all peripheral interrupts	*/
+#define SIC_MASK_ALL	0xFFFFFFFF					/* Mask all peripheral interrupts	*/
+#define SIC_MASK(x)		(1 << ((x)&0x1F))					/* Mask Peripheral #x interrupt		*/
+#define SIC_UNMASK(x)	(0xFFFFFFFF ^ (1 << ((x)&0x1F)))	/* Unmask Peripheral #x interrupt	*/
+
+/* SIC_IWR Masks																		*/
+#define IWR_DISABLE_ALL	0x00000000					/* Wakeup Disable all peripherals	*/
+#define IWR_ENABLE_ALL	0xFFFFFFFF					/* Wakeup Enable all peripherals	*/
+#define IWR_ENABLE(x)	(1 << ((x)&0x1F))					/* Wakeup Enable Peripheral #x		*/
+#define IWR_DISABLE(x)	(0xFFFFFFFF ^ (1 << ((x)&0x1F))) 	/* Wakeup Disable Peripheral #x		*/
+
+/* ***************  WATCHDOG TIMER MASKS  *******************************************/
+/* WDOG_CTL Masks																	*/
+#define WDOG_RESET		0x0000		/* Generate Reset Event							*/
+#define WDOG_NMI		0x0002		/* Generate Non-Maskable Interrupt (NMI) Event	*/
+#define WDOG_GPI		0x0004		/* Generate General Purpose (GP) Interrupt		*/
+#define WDOG_NONE		0x0006		/* Disable Watchdog Timer Interrupts			*/
+#define TMR_EN			0x0FF0		/* Watchdog Counter Enable						*/
+#define	WDOG_DISABLE	0x0AD0		/* Watchdog Counter Disable						*/
+#define TRO				0x8000		/* Watchdog Expired								*/
+
+/* ***************  REAL TIME CLOCK MASKS  **************************/
+/* RTC_STAT and RTC_ALARM Masks										*/
+#define	RTC_SEC				0x0000003F	/* Real-Time Clock Seconds	*/
+#define	RTC_MIN				0x00000FC0	/* Real-Time Clock Minutes	*/
+#define	RTC_HR				0x0001F000	/* Real-Time Clock Hours	*/
+#define	RTC_DAY				0xFFFE0000	/* Real-Time Clock Days		*/
+
+/* RTC_ALARM Macro			z=day		y=hr	x=min	w=sec		*/
+#define SET_ALARM(z,y,x,w)	((((z)&0x7FFF)<<0x11)|(((y)&0x1F)<<0xC)|(((x)&0x3F)<<0x6)|((w)&0x3F))
+
+/* RTC_ICTL and RTC_ISTAT Masks																		*/
+#define	STOPWATCH			0x0001		/* Stopwatch Interrupt Enable								*/
+#define	ALARM				0x0002		/* Alarm Interrupt Enable									*/
+#define	SECOND				0x0004		/* Seconds (1 Hz) Interrupt Enable							*/
+#define	MINUTE				0x0008		/* Minutes Interrupt Enable									*/
+#define	HOUR				0x0010		/* Hours Interrupt Enable									*/
+#define	DAY					0x0020		/* 24 Hours (Days) Interrupt Enable							*/
+#define	DAY_ALARM			0x0040		/* Day Alarm (Day, Hour, Minute, Second) Interrupt Enable	*/
+#define	WRITE_PENDING		0x4000		/* Write Pending Status										*/
+#define	WRITE_COMPLETE		0x8000		/* Write Complete Interrupt Enable							*/
+
+/* RTC_FAST / RTC_PREN Mask												*/
+#define PREN				0x0001	/* Enable Prescaler, RTC Runs @1 Hz	*/
+
+/* ************** UART CONTROLLER MASKS *************************/
+/* UARTx_LCR Masks												*/
+#define WLS(x)		((((x)&0x3)-5) & 0x03)	/* Word Length Select	*/
+#define STB			0x04				/* Stop Bits			*/
+#define PEN			0x08				/* Parity Enable		*/
+#define EPS			0x10				/* Even Parity Select	*/
+#define STP			0x20				/* Stick Parity			*/
+#define SB			0x40				/* Set Break			*/
+#define DLAB		0x80				/* Divisor Latch Access	*/
+
+/* UARTx_MCR Mask										*/
+#define LOOP		0x10	/* Loopback Mode Enable		*/
+
+/* UARTx_LSR Masks										*/
+#define DR			0x01	/* Data Ready				*/
+#define OE			0x02	/* Overrun Error			*/
+#define PE			0x04	/* Parity Error				*/
+#define FE			0x08	/* Framing Error			*/
+#define BI			0x10	/* Break Interrupt			*/
+#define THRE		0x20	/* THR Empty				*/
+#define TEMT		0x40	/* TSR and UART_THR Empty	*/
+
+/* UARTx_IER Masks															*/
+#define ERBFI		0x01		/* Enable Receive Buffer Full Interrupt		*/
+#define ETBEI		0x02		/* Enable Transmit Buffer Empty Interrupt	*/
+#define ELSI		0x04		/* Enable RX Status Interrupt				*/
+
+/* UARTx_IIR Masks														*/
+#define NINT		0x01		/* Pending Interrupt					*/
+/*#define STATUS		0x06		 Highest Priority Pending Interrupt	 Conflicting name  mh */
+
+/* UARTx_GCTL Masks													*/
+#define UCEN		0x01		/* Enable UARTx Clocks				*/
+#define IREN		0x02		/* Enable IrDA Mode					*/
+#define TPOLC		0x04		/* IrDA TX Polarity Change			*/
+#define RPOLC		0x08		/* IrDA RX Polarity Change			*/
+#define FPE			0x10		/* Force Parity Error On Transmit	*/
+#define FFE			0x20		/* Force Framing Error On Transmit	*/
+
+/* ***********  SERIAL PERIPHERAL INTERFACE (SPI) MASKS  ****************************/
+/* SPI_CTL Masks																	*/
+#define	TIMOD		0x0003		/* Transfer Initiate Mode							*/
+#define RDBR_CORE	0x0000		/* 		RDBR Read Initiates, IRQ When RDBR Full		*/
+#define	TDBR_CORE	0x0001		/* 		TDBR Write Initiates, IRQ When TDBR Empty	*/
+#define RDBR_DMA	0x0002		/* 		DMA Read, DMA Until FIFO Empty				*/
+#define TDBR_DMA	0x0003		/* 		DMA Write, DMA Until FIFO Full				*/
+#define SZ			0x0004		/* Send Zero (When TDBR Empty, Send Zero/Last*)		*/
+#define GM			0x0008		/* Get More (When RDBR Full, Overwrite/Discard*)	*/
+#define PSSE		0x0010		/* Slave-Select Input Enable						*/
+#define EMISO		0x0020		/* Enable MISO As Output							*/
+#define SIZE		0x0100		/* Size of Words (16/8* Bits)						*/
+#define LSBF		0x0200		/* LSB First										*/
+#define CPHA		0x0400		/* Clock Phase										*/
+#define CPOL		0x0800		/* Clock Polarity									*/
+#define MSTR		0x1000		/* Master/Slave*									*/
+#define WOM			0x2000		/* Write Open Drain Master							*/
+#define SPE			0x4000		/* SPI Enable										*/
+
+/* SPI_FLG Masks																	*/
+#define FLS1		0x0002		/* Enables SPI_FLOUT1 as SPI Slave-Select Output	*/
+#define FLS2		0x0004		/* Enables SPI_FLOUT2 as SPI Slave-Select Output	*/
+#define FLS3		0x0008		/* Enables SPI_FLOUT3 as SPI Slave-Select Output	*/
+#define FLS4		0x0010		/* Enables SPI_FLOUT4 as SPI Slave-Select Output	*/
+#define FLS5		0x0020		/* Enables SPI_FLOUT5 as SPI Slave-Select Output	*/
+#define FLS6		0x0040		/* Enables SPI_FLOUT6 as SPI Slave-Select Output	*/
+#define FLS7		0x0080		/* Enables SPI_FLOUT7 as SPI Slave-Select Output	*/
+#define FLG1		0xFDFF		/* Activates SPI_FLOUT1 							*/
+#define FLG2		0xFBFF		/* Activates SPI_FLOUT2								*/
+#define FLG3		0xF7FF		/* Activates SPI_FLOUT3								*/
+#define FLG4		0xEFFF		/* Activates SPI_FLOUT4								*/
+#define FLG5		0xDFFF		/* Activates SPI_FLOUT5								*/
+#define FLG6		0xBFFF		/* Activates SPI_FLOUT6								*/
+#define FLG7		0x7FFF		/* Activates SPI_FLOUT7								*/
+
+/* SPI_STAT Masks																				*/
+#define SPIF		0x0001		/* SPI Finished (Single-Word Transfer Complete)					*/
+#define MODF		0x0002		/* Mode Fault Error (Another Device Tried To Become Master)		*/
+#define TXE			0x0004		/* Transmission Error (Data Sent With No New Data In TDBR)		*/
+#define TXS			0x0008		/* SPI_TDBR Data Buffer Status (Full/Empty*)					*/
+#define RBSY		0x0010		/* Receive Error (Data Received With RDBR Full)					*/
+#define RXS			0x0020		/* SPI_RDBR Data Buffer Status (Full/Empty*)					*/
+#define TXCOL		0x0040		/* Transmit Collision Error (Corrupt Data May Have Been Sent)	*/
+
+/*  ****************  GENERAL PURPOSE TIMER MASKS  **********************/
+/* TIMER_ENABLE Masks													*/
+#define TIMEN0			0x0001		/* Enable Timer 0					*/
+#define TIMEN1			0x0002		/* Enable Timer 1					*/
+#define TIMEN2			0x0004		/* Enable Timer 2					*/
+#define TIMEN3			0x0008		/* Enable Timer 3					*/
+#define TIMEN4			0x0010		/* Enable Timer 4					*/
+#define TIMEN5			0x0020		/* Enable Timer 5					*/
+#define TIMEN6			0x0040		/* Enable Timer 6					*/
+#define TIMEN7			0x0080		/* Enable Timer 7					*/
+
+/* TIMER_DISABLE Masks													*/
+#define TIMDIS0			TIMEN0		/* Disable Timer 0					*/
+#define TIMDIS1			TIMEN1		/* Disable Timer 1					*/
+#define TIMDIS2			TIMEN2		/* Disable Timer 2					*/
+#define TIMDIS3			TIMEN3		/* Disable Timer 3					*/
+#define TIMDIS4			TIMEN4		/* Disable Timer 4					*/
+#define TIMDIS5			TIMEN5		/* Disable Timer 5					*/
+#define TIMDIS6			TIMEN6		/* Disable Timer 6					*/
+#define TIMDIS7			TIMEN7		/* Disable Timer 7					*/
+
+/* TIMER_STATUS Masks													*/
+#define TIMIL0			0x00000001	/* Timer 0 Interrupt				*/
+#define TIMIL1			0x00000002	/* Timer 1 Interrupt				*/
+#define TIMIL2			0x00000004	/* Timer 2 Interrupt				*/
+#define TIMIL3			0x00000008	/* Timer 3 Interrupt				*/
+#define TOVL_ERR0		0x00000010	/* Timer 0 Counter Overflow			*/
+#define TOVL_ERR1		0x00000020	/* Timer 1 Counter Overflow			*/
+#define TOVL_ERR2		0x00000040	/* Timer 2 Counter Overflow			*/
+#define TOVL_ERR3		0x00000080	/* Timer 3 Counter Overflow			*/
+#define TRUN0			0x00001000	/* Timer 0 Slave Enable Status		*/
+#define TRUN1			0x00002000	/* Timer 1 Slave Enable Status		*/
+#define TRUN2			0x00004000	/* Timer 2 Slave Enable Status		*/
+#define TRUN3			0x00008000	/* Timer 3 Slave Enable Status		*/
+#define TIMIL4			0x00010000	/* Timer 4 Interrupt				*/
+#define TIMIL5			0x00020000	/* Timer 5 Interrupt				*/
+#define TIMIL6			0x00040000	/* Timer 6 Interrupt				*/
+#define TIMIL7			0x00080000	/* Timer 7 Interrupt				*/
+#define TOVL_ERR4		0x00100000	/* Timer 4 Counter Overflow			*/
+#define TOVL_ERR5		0x00200000	/* Timer 5 Counter Overflow			*/
+#define TOVL_ERR6		0x00400000	/* Timer 6 Counter Overflow			*/
+#define TOVL_ERR7		0x00800000	/* Timer 7 Counter Overflow			*/
+#define TRUN4			0x10000000	/* Timer 4 Slave Enable Status		*/
+#define TRUN5			0x20000000	/* Timer 5 Slave Enable Status		*/
+#define TRUN6			0x40000000	/* Timer 6 Slave Enable Status		*/
+#define TRUN7			0x80000000	/* Timer 7 Slave Enable Status		*/
+
+/* TIMERx_CONFIG Masks													*/
+#define PWM_OUT			0x0001	/* Pulse-Width Modulation Output Mode	*/
+#define WDTH_CAP		0x0002	/* Width Capture Input Mode				*/
+#define EXT_CLK			0x0003	/* External Clock Mode					*/
+#define PULSE_HI		0x0004	/* Action Pulse (Positive/Negative*)	*/
+#define PERIOD_CNT		0x0008	/* Period Count							*/
+#define IRQ_ENA			0x0010	/* Interrupt Request Enable				*/
+#define TIN_SEL			0x0020	/* Timer Input Select					*/
+#define OUT_DIS			0x0040	/* Output Pad Disable					*/
+#define CLK_SEL			0x0080	/* Timer Clock Select					*/
+#define TOGGLE_HI		0x0100	/* PWM_OUT PULSE_HI Toggle Mode			*/
+#define EMU_RUN			0x0200	/* Emulation Behavior Select			*/
+#define ERR_TYP			0xC000	/* Error Type							*/
+
+/* ******************   GPIO PORTS F, G, H MASKS  ***********************/
+/*  General Purpose IO (0xFFC00700 - 0xFFC007FF)  Masks 				*/
+/* Port F Masks 														*/
+#define PF0		0x0001
+#define PF1		0x0002
+#define PF2		0x0004
+#define PF3		0x0008
+#define PF4		0x0010
+#define PF5		0x0020
+#define PF6		0x0040
+#define PF7		0x0080
+#define PF8		0x0100
+#define PF9		0x0200
+#define PF10	0x0400
+#define PF11	0x0800
+#define PF12	0x1000
+#define PF13	0x2000
+#define PF14	0x4000
+#define PF15	0x8000
+
+/* Port G Masks															*/
+#define PG0		0x0001
+#define PG1		0x0002
+#define PG2		0x0004
+#define PG3		0x0008
+#define PG4		0x0010
+#define PG5		0x0020
+#define PG6		0x0040
+#define PG7		0x0080
+#define PG8		0x0100
+#define PG9		0x0200
+#define PG10	0x0400
+#define PG11	0x0800
+#define PG12	0x1000
+#define PG13	0x2000
+#define PG14	0x4000
+#define PG15	0x8000
+
+/* Port H Masks															*/
+#define PH0		0x0001
+#define PH1		0x0002
+#define PH2		0x0004
+#define PH3		0x0008
+#define PH4		0x0010
+#define PH5		0x0020
+#define PH6		0x0040
+#define PH7		0x0080
+#define PH8		0x0100
+#define PH9		0x0200
+#define PH10	0x0400
+#define PH11	0x0800
+#define PH12	0x1000
+#define PH13	0x2000
+#define PH14	0x4000
+#define PH15	0x8000
+
+/* *******************  SERIAL PORT MASKS  **************************************/
+/* SPORTx_TCR1 Masks															*/
+#define TSPEN		0x0001		/* Transmit Enable								*/
+#define ITCLK		0x0002		/* Internal Transmit Clock Select				*/
+#define DTYPE_NORM	0x0004		/* Data Format Normal							*/
+#define DTYPE_ULAW	0x0008		/* Compand Using u-Law							*/
+#define DTYPE_ALAW	0x000C		/* Compand Using A-Law							*/
+#define TLSBIT		0x0010		/* Transmit Bit Order							*/
+#define ITFS		0x0200		/* Internal Transmit Frame Sync Select			*/
+#define TFSR		0x0400		/* Transmit Frame Sync Required Select			*/
+#define DITFS		0x0800		/* Data-Independent Transmit Frame Sync Select	*/
+#define LTFS		0x1000		/* Low Transmit Frame Sync Select				*/
+#define LATFS		0x2000		/* Late Transmit Frame Sync Select				*/
+#define TCKFE		0x4000		/* Clock Falling Edge Select					*/
+
+/* SPORTx_TCR2 Masks and Macro													*/
+#define SLEN(x)		((x)&0x1F)	/* SPORT TX Word Length (2 - 31)				*/
+#define TXSE		0x0100		/* TX Secondary Enable							*/
+#define TSFSE		0x0200		/* Transmit Stereo Frame Sync Enable			*/
+#define TRFST		0x0400		/* Left/Right Order (1 = Right Channel 1st)		*/
+
+/* SPORTx_RCR1 Masks															*/
+#define RSPEN		0x0001		/* Receive Enable 								*/
+#define IRCLK		0x0002		/* Internal Receive Clock Select 				*/
+#define DTYPE_NORM	0x0004		/* Data Format Normal							*/
+#define DTYPE_ULAW	0x0008		/* Compand Using u-Law							*/
+#define DTYPE_ALAW	0x000C		/* Compand Using A-Law							*/
+#define RLSBIT		0x0010		/* Receive Bit Order							*/
+#define IRFS		0x0200		/* Internal Receive Frame Sync Select 			*/
+#define RFSR		0x0400		/* Receive Frame Sync Required Select 			*/
+#define LRFS		0x1000		/* Low Receive Frame Sync Select 				*/
+#define LARFS		0x2000		/* Late Receive Frame Sync Select 				*/
+#define RCKFE		0x4000		/* Clock Falling Edge Select 					*/
+
+/* SPORTx_RCR2 Masks															*/
+#define SLEN(x)		((x)&0x1F)	/* SPORT RX Word Length (2 - 31)				*/
+#define RXSE		0x0100		/* RX Secondary Enable							*/
+#define RSFSE		0x0200		/* RX Stereo Frame Sync Enable					*/
+#define RRFST		0x0400		/* Right-First Data Order 						*/
+
+/* SPORTx_STAT Masks															*/
+#define RXNE		0x0001		/* Receive FIFO Not Empty Status				*/
+#define RUVF		0x0002		/* Sticky Receive Underflow Status				*/
+#define ROVF		0x0004		/* Sticky Receive Overflow Status				*/
+#define TXF			0x0008		/* Transmit FIFO Full Status					*/
+#define TUVF		0x0010		/* Sticky Transmit Underflow Status				*/
+#define TOVF		0x0020		/* Sticky Transmit Overflow Status				*/
+#define TXHRE		0x0040		/* Transmit Hold Register Empty					*/
+
+/* SPORTx_MCMC1 Macros															*/
+#define SP_WOFF(x)		((x) & 0x3FF) 	/* Multichannel Window Offset Field			*/
+
+/* Only use WSIZE Macro With Logic OR While Setting Lower Order Bits						*/
+#define SP_WSIZE(x)	(((((x)>>0x3)-1)&0xF) << 0xC)	/* Multichannel Window Size = (x/8)-1	*/
+
+/* SPORTx_MCMC2 Masks															*/
+#define REC_BYPASS	0x0000		/* Bypass Mode (No Clock Recovery)				*/
+#define REC_2FROM4	0x0002		/* Recover 2 MHz Clock from 4 MHz Clock			*/
+#define REC_8FROM16	0x0003		/* Recover 8 MHz Clock from 16 MHz Clock		*/
+#define MCDTXPE		0x0004 		/* Multichannel DMA Transmit Packing			*/
+#define MCDRXPE		0x0008 		/* Multichannel DMA Receive Packing				*/
+#define MCMEN		0x0010 		/* Multichannel Frame Mode Enable				*/
+#define FSDR		0x0080 		/* Multichannel Frame Sync to Data Relationship	*/
+#define MFD_0		0x0000		/* Multichannel Frame Delay = 0					*/
+#define MFD_1		0x1000		/* Multichannel Frame Delay = 1					*/
+#define MFD_2		0x2000		/* Multichannel Frame Delay = 2					*/
+#define MFD_3		0x3000		/* Multichannel Frame Delay = 3					*/
+#define MFD_4		0x4000		/* Multichannel Frame Delay = 4					*/
+#define MFD_5		0x5000		/* Multichannel Frame Delay = 5					*/
+#define MFD_6		0x6000		/* Multichannel Frame Delay = 6					*/
+#define MFD_7		0x7000		/* Multichannel Frame Delay = 7					*/
+#define MFD_8		0x8000		/* Multichannel Frame Delay = 8					*/
+#define MFD_9		0x9000		/* Multichannel Frame Delay = 9					*/
+#define MFD_10		0xA000		/* Multichannel Frame Delay = 10				*/
+#define MFD_11		0xB000		/* Multichannel Frame Delay = 11				*/
+#define MFD_12		0xC000		/* Multichannel Frame Delay = 12				*/
+#define MFD_13		0xD000		/* Multichannel Frame Delay = 13				*/
+#define MFD_14		0xE000		/* Multichannel Frame Delay = 14				*/
+#define MFD_15		0xF000		/* Multichannel Frame Delay = 15				*/
+
+/* *********************  ASYNCHRONOUS MEMORY CONTROLLER MASKS  *************************/
+/* EBIU_AMGCTL Masks																	*/
+#define AMCKEN			0x0001		/* Enable CLKOUT									*/
+#define	AMBEN_NONE		0x0000		/* All Banks Disabled								*/
+#define AMBEN_B0		0x0002		/* Enable Async Memory Bank 0 only					*/
+#define AMBEN_B0_B1		0x0004		/* Enable Async Memory Banks 0 & 1 only				*/
+#define AMBEN_B0_B1_B2	0x0006		/* Enable Async Memory Banks 0, 1, and 2			*/
+#define AMBEN_ALL		0x0008		/* Enable Async Memory Banks (all) 0, 1, 2, and 3	*/
+
+/* EBIU_AMBCTL0 Masks																	*/
+#define B0RDYEN			0x00000001  /* Bank 0 (B0) RDY Enable							*/
+#define B0RDYPOL		0x00000002  /* B0 RDY Active High								*/
+#define B0TT_1			0x00000004  /* B0 Transition Time (Read to Write) = 1 cycle		*/
+#define B0TT_2			0x00000008  /* B0 Transition Time (Read to Write) = 2 cycles	*/
+#define B0TT_3			0x0000000C  /* B0 Transition Time (Read to Write) = 3 cycles	*/
+#define B0TT_4			0x00000000  /* B0 Transition Time (Read to Write) = 4 cycles	*/
+#define B0ST_1			0x00000010  /* B0 Setup Time (AOE to Read/Write) = 1 cycle		*/
+#define B0ST_2			0x00000020  /* B0 Setup Time (AOE to Read/Write) = 2 cycles		*/
+#define B0ST_3			0x00000030  /* B0 Setup Time (AOE to Read/Write) = 3 cycles		*/
+#define B0ST_4			0x00000000  /* B0 Setup Time (AOE to Read/Write) = 4 cycles		*/
+#define B0HT_1			0x00000040  /* B0 Hold Time (~Read/Write to ~AOE) = 1 cycle		*/
+#define B0HT_2			0x00000080  /* B0 Hold Time (~Read/Write to ~AOE) = 2 cycles	*/
+#define B0HT_3			0x000000C0  /* B0 Hold Time (~Read/Write to ~AOE) = 3 cycles	*/
+#define B0HT_0			0x00000000  /* B0 Hold Time (~Read/Write to ~AOE) = 0 cycles	*/
+#define B0RAT_1			0x00000100  /* B0 Read Access Time = 1 cycle					*/
+#define B0RAT_2			0x00000200  /* B0 Read Access Time = 2 cycles					*/
+#define B0RAT_3			0x00000300  /* B0 Read Access Time = 3 cycles					*/
+#define B0RAT_4			0x00000400  /* B0 Read Access Time = 4 cycles					*/
+#define B0RAT_5			0x00000500  /* B0 Read Access Time = 5 cycles					*/
+#define B0RAT_6			0x00000600  /* B0 Read Access Time = 6 cycles					*/
+#define B0RAT_7			0x00000700  /* B0 Read Access Time = 7 cycles					*/
+#define B0RAT_8			0x00000800  /* B0 Read Access Time = 8 cycles					*/
+#define B0RAT_9			0x00000900  /* B0 Read Access Time = 9 cycles					*/
+#define B0RAT_10		0x00000A00  /* B0 Read Access Time = 10 cycles					*/
+#define B0RAT_11		0x00000B00  /* B0 Read Access Time = 11 cycles					*/
+#define B0RAT_12		0x00000C00  /* B0 Read Access Time = 12 cycles					*/
+#define B0RAT_13		0x00000D00  /* B0 Read Access Time = 13 cycles					*/
+#define B0RAT_14		0x00000E00  /* B0 Read Access Time = 14 cycles					*/
+#define B0RAT_15		0x00000F00  /* B0 Read Access Time = 15 cycles					*/
+#define B0WAT_1			0x00001000  /* B0 Write Access Time = 1 cycle					*/
+#define B0WAT_2			0x00002000  /* B0 Write Access Time = 2 cycles					*/
+#define B0WAT_3			0x00003000  /* B0 Write Access Time = 3 cycles					*/
+#define B0WAT_4			0x00004000  /* B0 Write Access Time = 4 cycles					*/
+#define B0WAT_5			0x00005000  /* B0 Write Access Time = 5 cycles					*/
+#define B0WAT_6			0x00006000  /* B0 Write Access Time = 6 cycles					*/
+#define B0WAT_7			0x00007000  /* B0 Write Access Time = 7 cycles					*/
+#define B0WAT_8			0x00008000  /* B0 Write Access Time = 8 cycles					*/
+#define B0WAT_9			0x00009000  /* B0 Write Access Time = 9 cycles					*/
+#define B0WAT_10		0x0000A000  /* B0 Write Access Time = 10 cycles					*/
+#define B0WAT_11		0x0000B000  /* B0 Write Access Time = 11 cycles					*/
+#define B0WAT_12		0x0000C000  /* B0 Write Access Time = 12 cycles					*/
+#define B0WAT_13		0x0000D000  /* B0 Write Access Time = 13 cycles					*/
+#define B0WAT_14		0x0000E000  /* B0 Write Access Time = 14 cycles					*/
+#define B0WAT_15		0x0000F000  /* B0 Write Access Time = 15 cycles					*/
+
+#define B1RDYEN			0x00010000  /* Bank 1 (B1) RDY Enable                       	*/
+#define B1RDYPOL		0x00020000  /* B1 RDY Active High                           	*/
+#define B1TT_1			0x00040000  /* B1 Transition Time (Read to Write) = 1 cycle 	*/
+#define B1TT_2			0x00080000  /* B1 Transition Time (Read to Write) = 2 cycles	*/
+#define B1TT_3			0x000C0000  /* B1 Transition Time (Read to Write) = 3 cycles	*/
+#define B1TT_4			0x00000000  /* B1 Transition Time (Read to Write) = 4 cycles	*/
+#define B1ST_1			0x00100000  /* B1 Setup Time (AOE to Read/Write) = 1 cycle  	*/
+#define B1ST_2			0x00200000  /* B1 Setup Time (AOE to Read/Write) = 2 cycles 	*/
+#define B1ST_3			0x00300000  /* B1 Setup Time (AOE to Read/Write) = 3 cycles 	*/
+#define B1ST_4			0x00000000  /* B1 Setup Time (AOE to Read/Write) = 4 cycles 	*/
+#define B1HT_1			0x00400000  /* B1 Hold Time (~Read/Write to ~AOE) = 1 cycle 	*/
+#define B1HT_2			0x00800000  /* B1 Hold Time (~Read/Write to ~AOE) = 2 cycles	*/
+#define B1HT_3			0x00C00000  /* B1 Hold Time (~Read/Write to ~AOE) = 3 cycles	*/
+#define B1HT_0			0x00000000  /* B1 Hold Time (~Read/Write to ~AOE) = 0 cycles	*/
+#define B1RAT_1			0x01000000  /* B1 Read Access Time = 1 cycle					*/
+#define B1RAT_2			0x02000000  /* B1 Read Access Time = 2 cycles					*/
+#define B1RAT_3			0x03000000  /* B1 Read Access Time = 3 cycles					*/
+#define B1RAT_4			0x04000000  /* B1 Read Access Time = 4 cycles					*/
+#define B1RAT_5			0x05000000  /* B1 Read Access Time = 5 cycles					*/
+#define B1RAT_6			0x06000000  /* B1 Read Access Time = 6 cycles					*/
+#define B1RAT_7			0x07000000  /* B1 Read Access Time = 7 cycles					*/
+#define B1RAT_8			0x08000000  /* B1 Read Access Time = 8 cycles					*/
+#define B1RAT_9			0x09000000  /* B1 Read Access Time = 9 cycles					*/
+#define B1RAT_10		0x0A000000  /* B1 Read Access Time = 10 cycles					*/
+#define B1RAT_11		0x0B000000  /* B1 Read Access Time = 11 cycles					*/
+#define B1RAT_12		0x0C000000  /* B1 Read Access Time = 12 cycles					*/
+#define B1RAT_13		0x0D000000  /* B1 Read Access Time = 13 cycles					*/
+#define B1RAT_14		0x0E000000  /* B1 Read Access Time = 14 cycles					*/
+#define B1RAT_15		0x0F000000  /* B1 Read Access Time = 15 cycles					*/
+#define B1WAT_1			0x10000000  /* B1 Write Access Time = 1 cycle					*/
+#define B1WAT_2			0x20000000  /* B1 Write Access Time = 2 cycles					*/
+#define B1WAT_3			0x30000000  /* B1 Write Access Time = 3 cycles					*/
+#define B1WAT_4			0x40000000  /* B1 Write Access Time = 4 cycles					*/
+#define B1WAT_5			0x50000000  /* B1 Write Access Time = 5 cycles					*/
+#define B1WAT_6			0x60000000  /* B1 Write Access Time = 6 cycles					*/
+#define B1WAT_7			0x70000000  /* B1 Write Access Time = 7 cycles					*/
+#define B1WAT_8			0x80000000  /* B1 Write Access Time = 8 cycles					*/
+#define B1WAT_9			0x90000000  /* B1 Write Access Time = 9 cycles					*/
+#define B1WAT_10		0xA0000000  /* B1 Write Access Time = 10 cycles					*/
+#define B1WAT_11		0xB0000000  /* B1 Write Access Time = 11 cycles					*/
+#define B1WAT_12		0xC0000000  /* B1 Write Access Time = 12 cycles					*/
+#define B1WAT_13		0xD0000000  /* B1 Write Access Time = 13 cycles					*/
+#define B1WAT_14		0xE0000000  /* B1 Write Access Time = 14 cycles					*/
+#define B1WAT_15		0xF0000000  /* B1 Write Access Time = 15 cycles					*/
+
+/* EBIU_AMBCTL1 Masks																	*/
+#define B2RDYEN			0x00000001  /* Bank 2 (B2) RDY Enable							*/
+#define B2RDYPOL		0x00000002  /* B2 RDY Active High								*/
+#define B2TT_1			0x00000004  /* B2 Transition Time (Read to Write) = 1 cycle		*/
+#define B2TT_2			0x00000008  /* B2 Transition Time (Read to Write) = 2 cycles	*/
+#define B2TT_3			0x0000000C  /* B2 Transition Time (Read to Write) = 3 cycles	*/
+#define B2TT_4			0x00000000  /* B2 Transition Time (Read to Write) = 4 cycles	*/
+#define B2ST_1			0x00000010  /* B2 Setup Time (AOE to Read/Write) = 1 cycle		*/
+#define B2ST_2			0x00000020  /* B2 Setup Time (AOE to Read/Write) = 2 cycles		*/
+#define B2ST_3			0x00000030  /* B2 Setup Time (AOE to Read/Write) = 3 cycles		*/
+#define B2ST_4			0x00000000  /* B2 Setup Time (AOE to Read/Write) = 4 cycles		*/
+#define B2HT_1			0x00000040  /* B2 Hold Time (~Read/Write to ~AOE) = 1 cycle		*/
+#define B2HT_2			0x00000080  /* B2 Hold Time (~Read/Write to ~AOE) = 2 cycles	*/
+#define B2HT_3			0x000000C0  /* B2 Hold Time (~Read/Write to ~AOE) = 3 cycles	*/
+#define B2HT_0			0x00000000  /* B2 Hold Time (~Read/Write to ~AOE) = 0 cycles	*/
+#define B2RAT_1			0x00000100  /* B2 Read Access Time = 1 cycle					*/
+#define B2RAT_2			0x00000200  /* B2 Read Access Time = 2 cycles					*/
+#define B2RAT_3			0x00000300  /* B2 Read Access Time = 3 cycles					*/
+#define B2RAT_4			0x00000400  /* B2 Read Access Time = 4 cycles					*/
+#define B2RAT_5			0x00000500  /* B2 Read Access Time = 5 cycles					*/
+#define B2RAT_6			0x00000600  /* B2 Read Access Time = 6 cycles					*/
+#define B2RAT_7			0x00000700  /* B2 Read Access Time = 7 cycles					*/
+#define B2RAT_8			0x00000800  /* B2 Read Access Time = 8 cycles					*/
+#define B2RAT_9			0x00000900  /* B2 Read Access Time = 9 cycles					*/
+#define B2RAT_10		0x00000A00  /* B2 Read Access Time = 10 cycles					*/
+#define B2RAT_11		0x00000B00  /* B2 Read Access Time = 11 cycles					*/
+#define B2RAT_12		0x00000C00  /* B2 Read Access Time = 12 cycles					*/
+#define B2RAT_13		0x00000D00  /* B2 Read Access Time = 13 cycles					*/
+#define B2RAT_14		0x00000E00  /* B2 Read Access Time = 14 cycles					*/
+#define B2RAT_15		0x00000F00  /* B2 Read Access Time = 15 cycles					*/
+#define B2WAT_1			0x00001000  /* B2 Write Access Time = 1 cycle					*/
+#define B2WAT_2			0x00002000  /* B2 Write Access Time = 2 cycles					*/
+#define B2WAT_3			0x00003000  /* B2 Write Access Time = 3 cycles					*/
+#define B2WAT_4			0x00004000  /* B2 Write Access Time = 4 cycles					*/
+#define B2WAT_5			0x00005000  /* B2 Write Access Time = 5 cycles					*/
+#define B2WAT_6			0x00006000  /* B2 Write Access Time = 6 cycles					*/
+#define B2WAT_7			0x00007000  /* B2 Write Access Time = 7 cycles					*/
+#define B2WAT_8			0x00008000  /* B2 Write Access Time = 8 cycles					*/
+#define B2WAT_9			0x00009000  /* B2 Write Access Time = 9 cycles					*/
+#define B2WAT_10		0x0000A000  /* B2 Write Access Time = 10 cycles					*/
+#define B2WAT_11		0x0000B000  /* B2 Write Access Time = 11 cycles					*/
+#define B2WAT_12		0x0000C000  /* B2 Write Access Time = 12 cycles					*/
+#define B2WAT_13		0x0000D000  /* B2 Write Access Time = 13 cycles					*/
+#define B2WAT_14		0x0000E000  /* B2 Write Access Time = 14 cycles					*/
+#define B2WAT_15		0x0000F000  /* B2 Write Access Time = 15 cycles					*/
+
+#define B3RDYEN			0x00010000  /* Bank 3 (B3) RDY Enable							*/
+#define B3RDYPOL		0x00020000  /* B3 RDY Active High								*/
+#define B3TT_1			0x00040000  /* B3 Transition Time (Read to Write) = 1 cycle		*/
+#define B3TT_2			0x00080000  /* B3 Transition Time (Read to Write) = 2 cycles	*/
+#define B3TT_3			0x000C0000  /* B3 Transition Time (Read to Write) = 3 cycles	*/
+#define B3TT_4			0x00000000  /* B3 Transition Time (Read to Write) = 4 cycles	*/
+#define B3ST_1			0x00100000  /* B3 Setup Time (AOE to Read/Write) = 1 cycle		*/
+#define B3ST_2			0x00200000  /* B3 Setup Time (AOE to Read/Write) = 2 cycles		*/
+#define B3ST_3			0x00300000  /* B3 Setup Time (AOE to Read/Write) = 3 cycles		*/
+#define B3ST_4			0x00000000  /* B3 Setup Time (AOE to Read/Write) = 4 cycles		*/
+#define B3HT_1			0x00400000  /* B3 Hold Time (~Read/Write to ~AOE) = 1 cycle		*/
+#define B3HT_2			0x00800000  /* B3 Hold Time (~Read/Write to ~AOE) = 2 cycles	*/
+#define B3HT_3			0x00C00000  /* B3 Hold Time (~Read/Write to ~AOE) = 3 cycles	*/
+#define B3HT_0			0x00000000  /* B3 Hold Time (~Read/Write to ~AOE) = 0 cycles	*/
+#define B3RAT_1			0x01000000  /* B3 Read Access Time = 1 cycle					*/
+#define B3RAT_2			0x02000000  /* B3 Read Access Time = 2 cycles					*/
+#define B3RAT_3			0x03000000  /* B3 Read Access Time = 3 cycles					*/
+#define B3RAT_4			0x04000000  /* B3 Read Access Time = 4 cycles					*/
+#define B3RAT_5			0x05000000  /* B3 Read Access Time = 5 cycles					*/
+#define B3RAT_6			0x06000000  /* B3 Read Access Time = 6 cycles					*/
+#define B3RAT_7			0x07000000  /* B3 Read Access Time = 7 cycles					*/
+#define B3RAT_8			0x08000000  /* B3 Read Access Time = 8 cycles					*/
+#define B3RAT_9			0x09000000  /* B3 Read Access Time = 9 cycles					*/
+#define B3RAT_10		0x0A000000  /* B3 Read Access Time = 10 cycles					*/
+#define B3RAT_11		0x0B000000  /* B3 Read Access Time = 11 cycles					*/
+#define B3RAT_12		0x0C000000  /* B3 Read Access Time = 12 cycles					*/
+#define B3RAT_13		0x0D000000  /* B3 Read Access Time = 13 cycles					*/
+#define B3RAT_14		0x0E000000  /* B3 Read Access Time = 14 cycles					*/
+#define B3RAT_15		0x0F000000  /* B3 Read Access Time = 15 cycles					*/
+#define B3WAT_1			0x10000000  /* B3 Write Access Time = 1 cycle					*/
+#define B3WAT_2			0x20000000  /* B3 Write Access Time = 2 cycles					*/
+#define B3WAT_3			0x30000000  /* B3 Write Access Time = 3 cycles					*/
+#define B3WAT_4			0x40000000  /* B3 Write Access Time = 4 cycles					*/
+#define B3WAT_5			0x50000000  /* B3 Write Access Time = 5 cycles					*/
+#define B3WAT_6			0x60000000  /* B3 Write Access Time = 6 cycles					*/
+#define B3WAT_7			0x70000000  /* B3 Write Access Time = 7 cycles					*/
+#define B3WAT_8			0x80000000  /* B3 Write Access Time = 8 cycles					*/
+#define B3WAT_9			0x90000000  /* B3 Write Access Time = 9 cycles					*/
+#define B3WAT_10		0xA0000000  /* B3 Write Access Time = 10 cycles					*/
+#define B3WAT_11		0xB0000000  /* B3 Write Access Time = 11 cycles					*/
+#define B3WAT_12		0xC0000000  /* B3 Write Access Time = 12 cycles					*/
+#define B3WAT_13		0xD0000000  /* B3 Write Access Time = 13 cycles					*/
+#define B3WAT_14		0xE0000000  /* B3 Write Access Time = 14 cycles					*/
+#define B3WAT_15		0xF0000000  /* B3 Write Access Time = 15 cycles					*/
+
+/* **********************  SDRAM CONTROLLER MASKS  **********************************************/
+/* EBIU_SDGCTL Masks																			*/
+#define SCTLE			0x00000001	/* Enable SDRAM Signals										*/
+#define CL_2			0x00000008	/* SDRAM CAS Latency = 2 cycles								*/
+#define CL_3			0x0000000C	/* SDRAM CAS Latency = 3 cycles								*/
+#define PASR_ALL		0x00000000	/* All 4 SDRAM Banks Refreshed In Self-Refresh				*/
+#define PASR_B0_B1		0x00000010	/* SDRAM Banks 0 and 1 Are Refreshed In Self-Refresh		*/
+#define PASR_B0			0x00000020	/* Only SDRAM Bank 0 Is Refreshed In Self-Refresh			*/
+#define TRAS_1			0x00000040	/* SDRAM tRAS = 1 cycle										*/
+#define TRAS_2			0x00000080	/* SDRAM tRAS = 2 cycles									*/
+#define TRAS_3			0x000000C0	/* SDRAM tRAS = 3 cycles									*/
+#define TRAS_4			0x00000100	/* SDRAM tRAS = 4 cycles									*/
+#define TRAS_5			0x00000140	/* SDRAM tRAS = 5 cycles									*/
+#define TRAS_6			0x00000180	/* SDRAM tRAS = 6 cycles									*/
+#define TRAS_7			0x000001C0	/* SDRAM tRAS = 7 cycles									*/
+#define TRAS_8			0x00000200	/* SDRAM tRAS = 8 cycles									*/
+#define TRAS_9			0x00000240	/* SDRAM tRAS = 9 cycles									*/
+#define TRAS_10			0x00000280	/* SDRAM tRAS = 10 cycles									*/
+#define TRAS_11			0x000002C0	/* SDRAM tRAS = 11 cycles									*/
+#define TRAS_12			0x00000300	/* SDRAM tRAS = 12 cycles									*/
+#define TRAS_13			0x00000340	/* SDRAM tRAS = 13 cycles									*/
+#define TRAS_14			0x00000380	/* SDRAM tRAS = 14 cycles									*/
+#define TRAS_15			0x000003C0	/* SDRAM tRAS = 15 cycles									*/
+#define TRP_1			0x00000800	/* SDRAM tRP = 1 cycle										*/
+#define TRP_2			0x00001000	/* SDRAM tRP = 2 cycles										*/
+#define TRP_3			0x00001800	/* SDRAM tRP = 3 cycles										*/
+#define TRP_4			0x00002000	/* SDRAM tRP = 4 cycles										*/
+#define TRP_5			0x00002800	/* SDRAM tRP = 5 cycles										*/
+#define TRP_6			0x00003000	/* SDRAM tRP = 6 cycles										*/
+#define TRP_7			0x00003800	/* SDRAM tRP = 7 cycles										*/
+#define TRCD_1			0x00008000	/* SDRAM tRCD = 1 cycle										*/
+#define TRCD_2			0x00010000	/* SDRAM tRCD = 2 cycles									*/
+#define TRCD_3			0x00018000	/* SDRAM tRCD = 3 cycles									*/
+#define TRCD_4			0x00020000	/* SDRAM tRCD = 4 cycles									*/
+#define TRCD_5			0x00028000	/* SDRAM tRCD = 5 cycles									*/
+#define TRCD_6			0x00030000	/* SDRAM tRCD = 6 cycles									*/
+#define TRCD_7			0x00038000	/* SDRAM tRCD = 7 cycles									*/
+#define TWR_1			0x00080000	/* SDRAM tWR = 1 cycle										*/
+#define TWR_2			0x00100000	/* SDRAM tWR = 2 cycles										*/
+#define TWR_3			0x00180000	/* SDRAM tWR = 3 cycles										*/
+#define PUPSD			0x00200000	/* Power-Up Start Delay (15 SCLK Cycles Delay)				*/
+#define PSM				0x00400000	/* Power-Up Sequence (Mode Register Before/After* Refresh)	*/
+#define PSS				0x00800000	/* Enable Power-Up Sequence on Next SDRAM Access			*/
+#define SRFS			0x01000000	/* Enable SDRAM Self-Refresh Mode							*/
+#define EBUFE			0x02000000	/* Enable External Buffering Timing							*/
+#define FBBRW			0x04000000	/* Enable Fast Back-To-Back Read To Write					*/
+#define EMREN			0x10000000	/* Extended Mode Register Enable							*/
+#define TCSR			0x20000000	/* Temp-Compensated Self-Refresh Value (85/45* Deg C)		*/
+#define CDDBG			0x40000000	/* Tristate SDRAM Controls During Bus Grant					*/
+
+/* EBIU_SDBCTL Masks																		*/
+#define EBE				0x0001		/* Enable SDRAM External Bank							*/
+#define EBSZ_16			0x0000		/* SDRAM External Bank Size = 16MB						*/
+#define EBSZ_32			0x0002		/* SDRAM External Bank Size = 32MB						*/
+#define EBSZ_64			0x0004		/* SDRAM External Bank Size = 64MB						*/
+#define EBSZ_128		0x0006		/* SDRAM External Bank Size = 128MB						*/
+#define EBCAW_8			0x0000		/* SDRAM External Bank Column Address Width = 8 Bits	*/
+#define EBCAW_9			0x0010		/* SDRAM External Bank Column Address Width = 9 Bits	*/
+#define EBCAW_10		0x0020		/* SDRAM External Bank Column Address Width = 10 Bits	*/
+#define EBCAW_11		0x0030		/* SDRAM External Bank Column Address Width = 11 Bits	*/
+
+/* EBIU_SDSTAT Masks														*/
+#define SDCI			0x0001		/* SDRAM Controller Idle 				*/
+#define SDSRA			0x0002		/* SDRAM Self-Refresh Active			*/
+#define SDPUA			0x0004		/* SDRAM Power-Up Active 				*/
+#define SDRS			0x0008		/* SDRAM Will Power-Up On Next Access	*/
+#define SDEASE			0x0010		/* SDRAM EAB Sticky Error Status		*/
+#define BGSTAT			0x0020		/* Bus Grant Status						*/
+
+/* **************************  DMA CONTROLLER MASKS  ********************************/
+/* DMAx_CONFIG, MDMA_yy_CONFIG Masks												*/
+#define DMAEN			0x0001		/* DMA Channel Enable							*/
+#define WNR				0x0002		/* Channel Direction (W/R*)						*/
+#define WDSIZE_8		0x0000		/* Transfer Word Size = 8						*/
+#define WDSIZE_16		0x0004		/* Transfer Word Size = 16						*/
+#define WDSIZE_32		0x0008		/* Transfer Word Size = 32						*/
+#define DMA2D			0x0010		/* DMA Mode (2D/1D*)							*/
+#define RESTART			0x0020		/* DMA Buffer Clear								*/
+#define DI_SEL			0x0040		/* Data Interrupt Timing Select					*/
+#define DI_EN			0x0080		/* Data Interrupt Enable						*/
+#define NDSIZE_0		0x0000		/* Next Descriptor Size = 0 (Stop/Autobuffer)	*/
+#define NDSIZE_1		0x0100		/* Next Descriptor Size = 1						*/
+#define NDSIZE_2		0x0200		/* Next Descriptor Size = 2						*/
+#define NDSIZE_3		0x0300		/* Next Descriptor Size = 3						*/
+#define NDSIZE_4		0x0400		/* Next Descriptor Size = 4						*/
+#define NDSIZE_5		0x0500		/* Next Descriptor Size = 5						*/
+#define NDSIZE_6		0x0600		/* Next Descriptor Size = 6						*/
+#define NDSIZE_7		0x0700		/* Next Descriptor Size = 7						*/
+#define NDSIZE_8		0x0800		/* Next Descriptor Size = 8						*/
+#define NDSIZE_9		0x0900		/* Next Descriptor Size = 9						*/
+#define NDSIZE	        	0x0900  	/* Next Descriptor Size */
+#define FLOW	        	0x7000  	/* Flow Control */
+/* #define FLOW_STOP		0x0000		Stop Mode									*/
+/* #define FLOW_AUTO		0x1000		Autobuffer Mode								*/
+/* #define FLOW_ARRAY		0x4000		Descriptor Array Mode						*/
+/* #define FLOW_SMALL		0x6000		Small Model Descriptor List Mode				*/
+/* #define FLOW_LARGE		0x7000		Large Model Descriptor List Mode				*/
+
+/* DMAx_PERIPHERAL_MAP, MDMA_yy_PERIPHERAL_MAP Masks								*/
+#define CTYPE			0x0040	/* DMA Channel Type Indicator (Memory/Peripheral*)	*/
+#define PMAP			0xF000	/* Peripheral Mapped To This Channel				*/
+#define PMAP_PPI		0x0000	/* 		PPI Port DMA								*/
+#define	PMAP_EMACRX		0x1000	/* 		Ethernet Receive DMA						*/
+#define PMAP_EMACTX		0x2000	/* 		Ethernet Transmit DMA						*/
+#define PMAP_SPORT0RX	0x3000	/* 		SPORT0 Receive DMA							*/
+#define PMAP_SPORT0TX	0x4000	/* 		SPORT0 Transmit DMA							*/
+#define PMAP_SPORT1RX	0x5000	/* 		SPORT1 Receive DMA							*/
+#define PMAP_SPORT1TX	0x6000	/* 		SPORT1 Transmit DMA							*/
+#define PMAP_SPI		0x7000	/* 		SPI Port DMA								*/
+#define PMAP_UART0RX	0x8000	/* 		UART0 Port Receive DMA						*/
+#define PMAP_UART0TX	0x9000	/* 		UART0 Port Transmit DMA						*/
+#define	PMAP_UART1RX	0xA000	/* 		UART1 Port Receive DMA						*/
+#define	PMAP_UART1TX	0xB000	/* 		UART1 Port Transmit DMA						*/
+
+/* DMAx_IRQ_STATUS, MDMA_yy_IRQ_STATUS Masks						*/
+#define DMA_DONE		0x0001	/* DMA Completion Interrupt Status	*/
+#define DMA_ERR			0x0002	/* DMA Error Interrupt Status		*/
+#define DFETCH			0x0004	/* DMA Descriptor Fetch Indicator	*/
+#define DMA_RUN			0x0008	/* DMA Channel Running Indicator	*/
+
+/*  ************  PARALLEL PERIPHERAL INTERFACE (PPI) MASKS *************/
+/*  PPI_CONTROL Masks													*/
+#define PORT_EN			0x0001		/* PPI Port Enable					*/
+#define PORT_DIR		0x0002		/* PPI Port Direction				*/
+#define XFR_TYPE		0x000C		/* PPI Transfer Type				*/
+#define PORT_CFG		0x0030		/* PPI Port Configuration			*/
+#define FLD_SEL			0x0040		/* PPI Active Field Select			*/
+#define PACK_EN			0x0080		/* PPI Packing Mode					*/
+#define DMA32			0x0100		/* PPI 32-bit DMA Enable			*/
+#define SKIP_EN			0x0200		/* PPI Skip Element Enable			*/
+#define SKIP_EO			0x0400		/* PPI Skip Even/Odd Elements		*/
+#define DLEN_8			0x0000		/* Data Length = 8 Bits				*/
+#define DLEN_10			0x0800		/* Data Length = 10 Bits			*/
+#define DLEN_11			0x1000		/* Data Length = 11 Bits			*/
+#define DLEN_12			0x1800		/* Data Length = 12 Bits			*/
+#define DLEN_13			0x2000		/* Data Length = 13 Bits			*/
+#define DLEN_14			0x2800		/* Data Length = 14 Bits			*/
+#define DLEN_15			0x3000		/* Data Length = 15 Bits			*/
+#define DLEN_16			0x3800		/* Data Length = 16 Bits			*/
+#define POLC			0x4000		/* PPI Clock Polarity				*/
+#define POLS			0x8000		/* PPI Frame Sync Polarity			*/
+
+/* PPI_STATUS Masks														*/
+#define FLD				0x0400		/* Field Indicator					*/
+#define FT_ERR			0x0800		/* Frame Track Error				*/
+#define OVR				0x1000		/* FIFO Overflow Error				*/
+#define UNDR			0x2000		/* FIFO Underrun Error				*/
+#define ERR_DET			0x4000		/* Error Detected Indicator			*/
+#define ERR_NCOR		0x8000		/* Error Not Corrected Indicator	*/
+
+/*  ********************  TWO-WIRE INTERFACE (TWI) MASKS  ***********************/
+/* TWI_CLKDIV Macros (Use: *pTWI_CLKDIV = CLKLOW(x)|CLKHI(y);  )				*/
+#define	CLKLOW(x)	((x) & 0xFF)		/* Periods Clock Is Held Low			*/
+#define CLKHI(y)	(((y)&0xFF)<<0x8)	/* Periods Before New Clock Low			*/
+
+/* TWI_PRESCALE Masks															*/
+#define	PRESCALE	0x007F		/* SCLKs Per Internal Time Reference (10MHz)	*/
+#define	TWI_ENA		0x0080		/* TWI Enable									*/
+#define	SCCB		0x0200		/* SCCB Compatibility Enable					*/
+
+/* TWI_SLAVE_CTRL Masks															*/
+#define	SEN			0x0001		/* Slave Enable									*/
+#define	SADD_LEN	0x0002		/* Slave Address Length							*/
+#define	STDVAL		0x0004		/* Slave Transmit Data Valid					*/
+#define	NAK			0x0008		/* NAK/ACK* Generated At Conclusion Of Transfer */
+#define	GEN			0x0010		/* General Call Adrress Matching Enabled		*/
+
+/* TWI_SLAVE_STAT Masks															*/
+#define	SDIR		0x0001		/* Slave Transfer Direction (Transmit/Receive*)	*/
+#define GCALL		0x0002		/* General Call Indicator						*/
+
+/* TWI_MASTER_CTRL Masks													*/
+#define	MEN			0x0001		/* Master Mode Enable						*/
+#define	MADD_LEN	0x0002		/* Master Address Length					*/
+#define	MDIR		0x0004		/* Master Transmit Direction (RX/TX*)		*/
+#define	FAST		0x0008		/* Use Fast Mode Timing Specs				*/
+#define	STOP		0x0010		/* Issue Stop Condition						*/
+#define	RSTART		0x0020		/* Repeat Start or Stop* At End Of Transfer	*/
+#define	DCNT		0x3FC0		/* Data Bytes To Transfer					*/
+#define	SDAOVR		0x4000		/* Serial Data Override						*/
+#define	SCLOVR		0x8000		/* Serial Clock Override					*/
+
+/* TWI_MASTER_STAT Masks														*/
+#define	MPROG		0x0001		/* Master Transfer In Progress					*/
+#define	LOSTARB		0x0002		/* Lost Arbitration Indicator (Xfer Aborted)	*/
+#define	ANAK		0x0004		/* Address Not Acknowledged						*/
+#define	DNAK		0x0008		/* Data Not Acknowledged						*/
+#define	BUFRDERR	0x0010		/* Buffer Read Error							*/
+#define	BUFWRERR	0x0020		/* Buffer Write Error							*/
+#define	SDASEN		0x0040		/* Serial Data Sense							*/
+#define	SCLSEN		0x0080		/* Serial Clock Sense							*/
+#define	BUSBUSY		0x0100		/* Bus Busy Indicator							*/
+
+/* TWI_INT_SRC and TWI_INT_ENABLE Masks						*/
+#define	SINIT		0x0001		/* Slave Transfer Initiated	*/
+#define	SCOMP		0x0002		/* Slave Transfer Complete	*/
+#define	SERR		0x0004		/* Slave Transfer Error		*/
+#define	SOVF		0x0008		/* Slave Overflow			*/
+#define	MCOMP		0x0010		/* Master Transfer Complete	*/
+#define	MERR		0x0020		/* Master Transfer Error	*/
+#define	XMTSERV		0x0040		/* Transmit FIFO Service	*/
+#define	RCVSERV		0x0080		/* Receive FIFO Service		*/
+
+/* TWI_FIFO_CTRL Masks												*/
+#define	XMTFLUSH	0x0001		/* Transmit Buffer Flush			*/
+#define	RCVFLUSH	0x0002		/* Receive Buffer Flush				*/
+#define	XMTINTLEN	0x0004		/* Transmit Buffer Interrupt Length	*/
+#define	RCVINTLEN	0x0008		/* Receive Buffer Interrupt Length	*/
+
+/* TWI_FIFO_STAT Masks															*/
+#define	XMTSTAT		0x0003		/* Transmit FIFO Status							*/
+#define	XMT_EMPTY	0x0000		/* 		Transmit FIFO Empty						*/
+#define	XMT_HALF	0x0001		/* 		Transmit FIFO Has 1 Byte To Write		*/
+#define	XMT_FULL	0x0003		/* 		Transmit FIFO Full (2 Bytes To Write)	*/
+
+#define	RCVSTAT		0x000C		/* Receive FIFO Status							*/
+#define	RCV_EMPTY	0x0000		/* 		Receive FIFO Empty						*/
+#define	RCV_HALF	0x0004		/* 		Receive FIFO Has 1 Byte To Read			*/
+#define	RCV_FULL	0x000C		/* 		Receive FIFO Full (2 Bytes To Read)		*/
+
+/* ************  CONTROLLER AREA NETWORK (CAN) MASKS  ***************/
+/* CAN_CONTROL Masks												*/
+#define	SRS			0x0001	/* Software Reset						*/
+#define	DNM			0x0002	/* Device Net Mode						*/
+#define	ABO			0x0004	/* Auto-Bus On Enable					*/
+#define	TXPRIO		0x0008	/* TX Priority (Priority/Mailbox*)		*/
+#define	WBA			0x0010	/* Wake-Up On CAN Bus Activity Enable	*/
+#define	SMR			0x0020	/* Sleep Mode Request					*/
+#define	CSR			0x0040	/* CAN Suspend Mode Request				*/
+#define	CCR			0x0080	/* CAN Configuration Mode Request		*/
+
+/* CAN_STATUS Masks												*/
+#define	WT			0x0001	/* TX Warning Flag					*/
+#define	WR			0x0002	/* RX Warning Flag					*/
+#define	EP			0x0004	/* Error Passive Mode				*/
+#define	EBO			0x0008	/* Error Bus Off Mode				*/
+#define	SMA			0x0020	/* Sleep Mode Acknowledge			*/
+#define	CSA			0x0040	/* Suspend Mode Acknowledge			*/
+#define	CCA			0x0080	/* Configuration Mode Acknowledge	*/
+#define	MBPTR		0x1F00	/* Mailbox Pointer					*/
+#define	TRM			0x4000	/* Transmit Mode					*/
+#define	REC			0x8000	/* Receive Mode						*/
+
+/* CAN_CLOCK Masks									*/
+#define	BRP			0x03FF	/* Bit-Rate Pre-Scaler	*/
+
+/* CAN_TIMING Masks											*/
+#define	TSEG1		0x000F	/* Time Segment 1				*/
+#define	TSEG2		0x0070	/* Time Segment 2				*/
+#define	SAM			0x0080	/* Sampling						*/
+#define	SJW			0x0300	/* Synchronization Jump Width	*/
+
+/* CAN_DEBUG Masks											*/
+#define	DEC			0x0001	/* Disable CAN Error Counters	*/
+#define	DRI			0x0002	/* Disable CAN RX Input			*/
+#define	DTO			0x0004	/* Disable CAN TX Output		*/
+#define	DIL			0x0008	/* Disable CAN Internal Loop	*/
+#define	MAA			0x0010	/* Mode Auto-Acknowledge Enable	*/
+#define	MRB			0x0020	/* Mode Read Back Enable		*/
+#define	CDE			0x8000	/* CAN Debug Enable				*/
+
+/* CAN_CEC Masks										*/
+#define	RXECNT		0x00FF	/* Receive Error Counter	*/
+#define	TXECNT		0xFF00	/* Transmit Error Counter	*/
+
+/* CAN_INTR Masks											*/
+#define	MBRIF		0x0001	/* Mailbox Receive Interrupt	*/
+#define	MBTIF		0x0002	/* Mailbox Transmit Interrupt	*/
+#define	GIRQ		0x0004	/* Global Interrupt				*/
+#define	SMACK		0x0008	/* Sleep Mode Acknowledge		*/
+#define	CANTX		0x0040	/* CAN TX Bus Value				*/
+#define	CANRX		0x0080	/* CAN RX Bus Value				*/
+
+/* CAN_MBxx_ID1 and CAN_MBxx_ID0 Masks										*/
+#define DFC			0xFFFF	/* Data Filtering Code (If Enabled) (ID0)		*/
+#define	EXTID_LO	0xFFFF	/* Lower 16 Bits of Extended Identifier (ID0)	*/
+#define	EXTID_HI	0x0003	/* Upper 2 Bits of Extended Identifier (ID1)	*/
+#define	BASEID		0x1FFC	/* Base Identifier								*/
+#define	IDE			0x2000	/* Identifier Extension							*/
+#define	RTR			0x4000	/* Remote Frame Transmission Request			*/
+#define	AME			0x8000	/* Acceptance Mask Enable						*/
+
+/* CAN_MBxx_TIMESTAMP Masks					*/
+#define TSV			0xFFFF	/* Timestamp	*/
+
+/* CAN_MBxx_LENGTH Masks						*/
+#define DLC			0x000F	/* Data Length Code	*/
+
+/* CAN_AMxxH and CAN_AMxxL Masks												*/
+#define DFM			0xFFFF	/* Data Field Mask (If Enabled) (CAN_AMxxL)			*/
+#define	EXTID_LO	0xFFFF	/* Lower 16 Bits of Extended Identifier (CAN_AMxxL)	*/
+#define	EXTID_HI	0x0003	/* Upper 2 Bits of Extended Identifier (CAN_AMxxH)	*/
+#define	BASEID		0x1FFC	/* Base Identifier									*/
+#define	AMIDE		0x2000	/* Acceptance Mask ID Extension Enable				*/
+#define	FMD			0x4000	/* Full Mask Data Field Enable						*/
+#define	FDF			0x8000	/* Filter On Data Field Enable						*/
+
+/* CAN_MC1 Masks									*/
+#define	MC0			0x0001	/* Enable Mailbox 0		*/
+#define	MC1			0x0002	/* Enable Mailbox 1		*/
+#define	MC2			0x0004	/* Enable Mailbox 2		*/
+#define	MC3			0x0008	/* Enable Mailbox 3		*/
+#define	MC4			0x0010	/* Enable Mailbox 4		*/
+#define	MC5			0x0020	/* Enable Mailbox 5		*/
+#define	MC6			0x0040	/* Enable Mailbox 6		*/
+#define	MC7			0x0080	/* Enable Mailbox 7		*/
+#define	MC8			0x0100	/* Enable Mailbox 8		*/
+#define	MC9			0x0200	/* Enable Mailbox 9		*/
+#define	MC10		0x0400	/* Enable Mailbox 10	*/
+#define	MC11		0x0800	/* Enable Mailbox 11	*/
+#define	MC12		0x1000	/* Enable Mailbox 12	*/
+#define	MC13		0x2000	/* Enable Mailbox 13	*/
+#define	MC14		0x4000	/* Enable Mailbox 14	*/
+#define	MC15		0x8000	/* Enable Mailbox 15	*/
+
+/* CAN_MC2 Masks									*/
+#define	MC16		0x0001	/* Enable Mailbox 16	*/
+#define	MC17		0x0002	/* Enable Mailbox 17	*/
+#define	MC18		0x0004	/* Enable Mailbox 18	*/
+#define	MC19		0x0008	/* Enable Mailbox 19	*/
+#define	MC20		0x0010	/* Enable Mailbox 20	*/
+#define	MC21		0x0020	/* Enable Mailbox 21	*/
+#define	MC22		0x0040	/* Enable Mailbox 22	*/
+#define	MC23		0x0080	/* Enable Mailbox 23	*/
+#define	MC24		0x0100	/* Enable Mailbox 24	*/
+#define	MC25		0x0200	/* Enable Mailbox 25	*/
+#define	MC26		0x0400	/* Enable Mailbox 26	*/
+#define	MC27		0x0800	/* Enable Mailbox 27	*/
+#define	MC28		0x1000	/* Enable Mailbox 28	*/
+#define	MC29		0x2000	/* Enable Mailbox 29	*/
+#define	MC30		0x4000	/* Enable Mailbox 30	*/
+#define	MC31		0x8000	/* Enable Mailbox 31	*/
+
+/* CAN_MD1 Masks												*/
+#define	MD0			0x0001	/* Enable Mailbox 0 For Receive		*/
+#define	MD1			0x0002	/* Enable Mailbox 1 For Receive		*/
+#define	MD2			0x0004	/* Enable Mailbox 2 For Receive		*/
+#define	MD3			0x0008	/* Enable Mailbox 3 For Receive		*/
+#define	MD4			0x0010	/* Enable Mailbox 4 For Receive		*/
+#define	MD5			0x0020	/* Enable Mailbox 5 For Receive		*/
+#define	MD6			0x0040	/* Enable Mailbox 6 For Receive		*/
+#define	MD7			0x0080	/* Enable Mailbox 7 For Receive		*/
+#define	MD8			0x0100	/* Enable Mailbox 8 For Receive		*/
+#define	MD9			0x0200	/* Enable Mailbox 9 For Receive		*/
+#define	MD10		0x0400	/* Enable Mailbox 10 For Receive	*/
+#define	MD11		0x0800	/* Enable Mailbox 11 For Receive	*/
+#define	MD12		0x1000	/* Enable Mailbox 12 For Receive	*/
+#define	MD13		0x2000	/* Enable Mailbox 13 For Receive	*/
+#define	MD14		0x4000	/* Enable Mailbox 14 For Receive	*/
+#define	MD15		0x8000	/* Enable Mailbox 15 For Receive	*/
+
+/* CAN_MD2 Masks												*/
+#define	MD16		0x0001	/* Enable Mailbox 16 For Receive	*/
+#define	MD17		0x0002	/* Enable Mailbox 17 For Receive	*/
+#define	MD18		0x0004	/* Enable Mailbox 18 For Receive	*/
+#define	MD19		0x0008	/* Enable Mailbox 19 For Receive	*/
+#define	MD20		0x0010	/* Enable Mailbox 20 For Receive	*/
+#define	MD21		0x0020	/* Enable Mailbox 21 For Receive	*/
+#define	MD22		0x0040	/* Enable Mailbox 22 For Receive	*/
+#define	MD23		0x0080	/* Enable Mailbox 23 For Receive	*/
+#define	MD24		0x0100	/* Enable Mailbox 24 For Receive	*/
+#define	MD25		0x0200	/* Enable Mailbox 25 For Receive	*/
+#define	MD26		0x0400	/* Enable Mailbox 26 For Receive	*/
+#define	MD27		0x0800	/* Enable Mailbox 27 For Receive	*/
+#define	MD28		0x1000	/* Enable Mailbox 28 For Receive	*/
+#define	MD29		0x2000	/* Enable Mailbox 29 For Receive	*/
+#define	MD30		0x4000	/* Enable Mailbox 30 For Receive	*/
+#define	MD31		0x8000	/* Enable Mailbox 31 For Receive	*/
+
+/* CAN_RMP1 Masks												*/
+#define	RMP0		0x0001	/* RX Message Pending In Mailbox 0	*/
+#define	RMP1		0x0002	/* RX Message Pending In Mailbox 1	*/
+#define	RMP2		0x0004	/* RX Message Pending In Mailbox 2	*/
+#define	RMP3		0x0008	/* RX Message Pending In Mailbox 3	*/
+#define	RMP4		0x0010	/* RX Message Pending In Mailbox 4	*/
+#define	RMP5		0x0020	/* RX Message Pending In Mailbox 5	*/
+#define	RMP6		0x0040	/* RX Message Pending In Mailbox 6	*/
+#define	RMP7		0x0080	/* RX Message Pending In Mailbox 7	*/
+#define	RMP8		0x0100	/* RX Message Pending In Mailbox 8	*/
+#define	RMP9		0x0200	/* RX Message Pending In Mailbox 9	*/
+#define	RMP10		0x0400	/* RX Message Pending In Mailbox 10	*/
+#define	RMP11		0x0800	/* RX Message Pending In Mailbox 11	*/
+#define	RMP12		0x1000	/* RX Message Pending In Mailbox 12	*/
+#define	RMP13		0x2000	/* RX Message Pending In Mailbox 13	*/
+#define	RMP14		0x4000	/* RX Message Pending In Mailbox 14	*/
+#define	RMP15		0x8000	/* RX Message Pending In Mailbox 15	*/
+
+/* CAN_RMP2 Masks												*/
+#define	RMP16		0x0001	/* RX Message Pending In Mailbox 16	*/
+#define	RMP17		0x0002	/* RX Message Pending In Mailbox 17	*/
+#define	RMP18		0x0004	/* RX Message Pending In Mailbox 18	*/
+#define	RMP19		0x0008	/* RX Message Pending In Mailbox 19	*/
+#define	RMP20		0x0010	/* RX Message Pending In Mailbox 20	*/
+#define	RMP21		0x0020	/* RX Message Pending In Mailbox 21	*/
+#define	RMP22		0x0040	/* RX Message Pending In Mailbox 22	*/
+#define	RMP23		0x0080	/* RX Message Pending In Mailbox 23	*/
+#define	RMP24		0x0100	/* RX Message Pending In Mailbox 24	*/
+#define	RMP25		0x0200	/* RX Message Pending In Mailbox 25	*/
+#define	RMP26		0x0400	/* RX Message Pending In Mailbox 26	*/
+#define	RMP27		0x0800	/* RX Message Pending In Mailbox 27	*/
+#define	RMP28		0x1000	/* RX Message Pending In Mailbox 28	*/
+#define	RMP29		0x2000	/* RX Message Pending In Mailbox 29	*/
+#define	RMP30		0x4000	/* RX Message Pending In Mailbox 30	*/
+#define	RMP31		0x8000	/* RX Message Pending In Mailbox 31	*/
+
+/* CAN_RML1 Masks												*/
+#define	RML0		0x0001	/* RX Message Lost In Mailbox 0		*/
+#define	RML1		0x0002	/* RX Message Lost In Mailbox 1		*/
+#define	RML2		0x0004	/* RX Message Lost In Mailbox 2		*/
+#define	RML3		0x0008	/* RX Message Lost In Mailbox 3		*/
+#define	RML4		0x0010	/* RX Message Lost In Mailbox 4		*/
+#define	RML5		0x0020	/* RX Message Lost In Mailbox 5		*/
+#define	RML6		0x0040	/* RX Message Lost In Mailbox 6		*/
+#define	RML7		0x0080	/* RX Message Lost In Mailbox 7		*/
+#define	RML8		0x0100	/* RX Message Lost In Mailbox 8		*/
+#define	RML9		0x0200	/* RX Message Lost In Mailbox 9		*/
+#define	RML10		0x0400	/* RX Message Lost In Mailbox 10	*/
+#define	RML11		0x0800	/* RX Message Lost In Mailbox 11	*/
+#define	RML12		0x1000	/* RX Message Lost In Mailbox 12	*/
+#define	RML13		0x2000	/* RX Message Lost In Mailbox 13	*/
+#define	RML14		0x4000	/* RX Message Lost In Mailbox 14	*/
+#define	RML15		0x8000	/* RX Message Lost In Mailbox 15	*/
+
+/* CAN_RML2 Masks												*/
+#define	RML16		0x0001	/* RX Message Lost In Mailbox 16	*/
+#define	RML17		0x0002	/* RX Message Lost In Mailbox 17	*/
+#define	RML18		0x0004	/* RX Message Lost In Mailbox 18	*/
+#define	RML19		0x0008	/* RX Message Lost In Mailbox 19	*/
+#define	RML20		0x0010	/* RX Message Lost In Mailbox 20	*/
+#define	RML21		0x0020	/* RX Message Lost In Mailbox 21	*/
+#define	RML22		0x0040	/* RX Message Lost In Mailbox 22	*/
+#define	RML23		0x0080	/* RX Message Lost In Mailbox 23	*/
+#define	RML24		0x0100	/* RX Message Lost In Mailbox 24	*/
+#define	RML25		0x0200	/* RX Message Lost In Mailbox 25	*/
+#define	RML26		0x0400	/* RX Message Lost In Mailbox 26	*/
+#define	RML27		0x0800	/* RX Message Lost In Mailbox 27	*/
+#define	RML28		0x1000	/* RX Message Lost In Mailbox 28	*/
+#define	RML29		0x2000	/* RX Message Lost In Mailbox 29	*/
+#define	RML30		0x4000	/* RX Message Lost In Mailbox 30	*/
+#define	RML31		0x8000	/* RX Message Lost In Mailbox 31	*/
+
+/* CAN_OPSS1 Masks																				*/
+#define	OPSS0		0x0001	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 0	*/
+#define	OPSS1		0x0002	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 1	*/
+#define	OPSS2		0x0004	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 2	*/
+#define	OPSS3		0x0008	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 3	*/
+#define	OPSS4		0x0010	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 4	*/
+#define	OPSS5		0x0020	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 5	*/
+#define	OPSS6		0x0040	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 6	*/
+#define	OPSS7		0x0080	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 7	*/
+#define	OPSS8		0x0100	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 8	*/
+#define	OPSS9		0x0200	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 9	*/
+#define	OPSS10		0x0400	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 10	*/
+#define	OPSS11		0x0800	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 11	*/
+#define	OPSS12		0x1000	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 12	*/
+#define	OPSS13		0x2000	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 13	*/
+#define	OPSS14		0x4000	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 14	*/
+#define	OPSS15		0x8000	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 15	*/
+
+/* CAN_OPSS2 Masks																				*/
+#define	OPSS16		0x0001	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 16	*/
+#define	OPSS17		0x0002	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 17	*/
+#define	OPSS18		0x0004	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 18	*/
+#define	OPSS19		0x0008	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 19	*/
+#define	OPSS20		0x0010	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 20	*/
+#define	OPSS21		0x0020	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 21	*/
+#define	OPSS22		0x0040	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 22	*/
+#define	OPSS23		0x0080	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 23	*/
+#define	OPSS24		0x0100	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 24	*/
+#define	OPSS25		0x0200	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 25	*/
+#define	OPSS26		0x0400	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 26	*/
+#define	OPSS27		0x0800	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 27	*/
+#define	OPSS28		0x1000	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 28	*/
+#define	OPSS29		0x2000	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 29	*/
+#define	OPSS30		0x4000	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 30	*/
+#define	OPSS31		0x8000	/* Enable RX Overwrite Protection or TX Single-Shot For Mailbox 31	*/
+
+/* CAN_TRR1 Masks														*/
+#define	TRR0		0x0001	/* Deny But Don't Lock Access To Mailbox 0	*/
+#define	TRR1		0x0002	/* Deny But Don't Lock Access To Mailbox 1	*/
+#define	TRR2		0x0004	/* Deny But Don't Lock Access To Mailbox 2	*/
+#define	TRR3		0x0008	/* Deny But Don't Lock Access To Mailbox 3	*/
+#define	TRR4		0x0010	/* Deny But Don't Lock Access To Mailbox 4	*/
+#define	TRR5		0x0020	/* Deny But Don't Lock Access To Mailbox 5	*/
+#define	TRR6		0x0040	/* Deny But Don't Lock Access To Mailbox 6	*/
+#define	TRR7		0x0080	/* Deny But Don't Lock Access To Mailbox 7	*/
+#define	TRR8		0x0100	/* Deny But Don't Lock Access To Mailbox 8	*/
+#define	TRR9		0x0200	/* Deny But Don't Lock Access To Mailbox 9	*/
+#define	TRR10		0x0400	/* Deny But Don't Lock Access To Mailbox 10	*/
+#define	TRR11		0x0800	/* Deny But Don't Lock Access To Mailbox 11	*/
+#define	TRR12		0x1000	/* Deny But Don't Lock Access To Mailbox 12	*/
+#define	TRR13		0x2000	/* Deny But Don't Lock Access To Mailbox 13	*/
+#define	TRR14		0x4000	/* Deny But Don't Lock Access To Mailbox 14	*/
+#define	TRR15		0x8000	/* Deny But Don't Lock Access To Mailbox 15	*/
+
+/* CAN_TRR2 Masks														*/
+#define	TRR16		0x0001	/* Deny But Don't Lock Access To Mailbox 16	*/
+#define	TRR17		0x0002	/* Deny But Don't Lock Access To Mailbox 17	*/
+#define	TRR18		0x0004	/* Deny But Don't Lock Access To Mailbox 18	*/
+#define	TRR19		0x0008	/* Deny But Don't Lock Access To Mailbox 19	*/
+#define	TRR20		0x0010	/* Deny But Don't Lock Access To Mailbox 20	*/
+#define	TRR21		0x0020	/* Deny But Don't Lock Access To Mailbox 21	*/
+#define	TRR22		0x0040	/* Deny But Don't Lock Access To Mailbox 22	*/
+#define	TRR23		0x0080	/* Deny But Don't Lock Access To Mailbox 23	*/
+#define	TRR24		0x0100	/* Deny But Don't Lock Access To Mailbox 24	*/
+#define	TRR25		0x0200	/* Deny But Don't Lock Access To Mailbox 25	*/
+#define	TRR26		0x0400	/* Deny But Don't Lock Access To Mailbox 26	*/
+#define	TRR27		0x0800	/* Deny But Don't Lock Access To Mailbox 27	*/
+#define	TRR28		0x1000	/* Deny But Don't Lock Access To Mailbox 28	*/
+#define	TRR29		0x2000	/* Deny But Don't Lock Access To Mailbox 29	*/
+#define	TRR30		0x4000	/* Deny But Don't Lock Access To Mailbox 30	*/
+#define	TRR31		0x8000	/* Deny But Don't Lock Access To Mailbox 31	*/
+
+/* CAN_TRS1 Masks													*/
+#define	TRS0		0x0001	/* Remote Frame Request For Mailbox 0	*/
+#define	TRS1		0x0002	/* Remote Frame Request For Mailbox 1	*/
+#define	TRS2		0x0004	/* Remote Frame Request For Mailbox 2	*/
+#define	TRS3		0x0008	/* Remote Frame Request For Mailbox 3	*/
+#define	TRS4		0x0010	/* Remote Frame Request For Mailbox 4	*/
+#define	TRS5		0x0020	/* Remote Frame Request For Mailbox 5	*/
+#define	TRS6		0x0040	/* Remote Frame Request For Mailbox 6	*/
+#define	TRS7		0x0080	/* Remote Frame Request For Mailbox 7	*/
+#define	TRS8		0x0100	/* Remote Frame Request For Mailbox 8	*/
+#define	TRS9		0x0200	/* Remote Frame Request For Mailbox 9	*/
+#define	TRS10		0x0400	/* Remote Frame Request For Mailbox 10	*/
+#define	TRS11		0x0800	/* Remote Frame Request For Mailbox 11	*/
+#define	TRS12		0x1000	/* Remote Frame Request For Mailbox 12	*/
+#define	TRS13		0x2000	/* Remote Frame Request For Mailbox 13	*/
+#define	TRS14		0x4000	/* Remote Frame Request For Mailbox 14	*/
+#define	TRS15		0x8000	/* Remote Frame Request For Mailbox 15	*/
+
+/* CAN_TRS2 Masks													*/
+#define	TRS16		0x0001	/* Remote Frame Request For Mailbox 16	*/
+#define	TRS17		0x0002	/* Remote Frame Request For Mailbox 17	*/
+#define	TRS18		0x0004	/* Remote Frame Request For Mailbox 18	*/
+#define	TRS19		0x0008	/* Remote Frame Request For Mailbox 19	*/
+#define	TRS20		0x0010	/* Remote Frame Request For Mailbox 20	*/
+#define	TRS21		0x0020	/* Remote Frame Request For Mailbox 21	*/
+#define	TRS22		0x0040	/* Remote Frame Request For Mailbox 22	*/
+#define	TRS23		0x0080	/* Remote Frame Request For Mailbox 23	*/
+#define	TRS24		0x0100	/* Remote Frame Request For Mailbox 24	*/
+#define	TRS25		0x0200	/* Remote Frame Request For Mailbox 25	*/
+#define	TRS26		0x0400	/* Remote Frame Request For Mailbox 26	*/
+#define	TRS27		0x0800	/* Remote Frame Request For Mailbox 27	*/
+#define	TRS28		0x1000	/* Remote Frame Request For Mailbox 28	*/
+#define	TRS29		0x2000	/* Remote Frame Request For Mailbox 29	*/
+#define	TRS30		0x4000	/* Remote Frame Request For Mailbox 30	*/
+#define	TRS31		0x8000	/* Remote Frame Request For Mailbox 31	*/
+
+/* CAN_AA1 Masks												*/
+#define	AA0			0x0001	/* Aborted Message In Mailbox 0		*/
+#define	AA1			0x0002	/* Aborted Message In Mailbox 1		*/
+#define	AA2			0x0004	/* Aborted Message In Mailbox 2		*/
+#define	AA3			0x0008	/* Aborted Message In Mailbox 3		*/
+#define	AA4			0x0010	/* Aborted Message In Mailbox 4		*/
+#define	AA5			0x0020	/* Aborted Message In Mailbox 5		*/
+#define	AA6			0x0040	/* Aborted Message In Mailbox 6		*/
+#define	AA7			0x0080	/* Aborted Message In Mailbox 7		*/
+#define	AA8			0x0100	/* Aborted Message In Mailbox 8		*/
+#define	AA9			0x0200	/* Aborted Message In Mailbox 9		*/
+#define	AA10		0x0400	/* Aborted Message In Mailbox 10	*/
+#define	AA11		0x0800	/* Aborted Message In Mailbox 11	*/
+#define	AA12		0x1000	/* Aborted Message In Mailbox 12	*/
+#define	AA13		0x2000	/* Aborted Message In Mailbox 13	*/
+#define	AA14		0x4000	/* Aborted Message In Mailbox 14	*/
+#define	AA15		0x8000	/* Aborted Message In Mailbox 15	*/
+
+/* CAN_AA2 Masks												*/
+#define	AA16		0x0001	/* Aborted Message In Mailbox 16	*/
+#define	AA17		0x0002	/* Aborted Message In Mailbox 17	*/
+#define	AA18		0x0004	/* Aborted Message In Mailbox 18	*/
+#define	AA19		0x0008	/* Aborted Message In Mailbox 19	*/
+#define	AA20		0x0010	/* Aborted Message In Mailbox 20	*/
+#define	AA21		0x0020	/* Aborted Message In Mailbox 21	*/
+#define	AA22		0x0040	/* Aborted Message In Mailbox 22	*/
+#define	AA23		0x0080	/* Aborted Message In Mailbox 23	*/
+#define	AA24		0x0100	/* Aborted Message In Mailbox 24	*/
+#define	AA25		0x0200	/* Aborted Message In Mailbox 25	*/
+#define	AA26		0x0400	/* Aborted Message In Mailbox 26	*/
+#define	AA27		0x0800	/* Aborted Message In Mailbox 27	*/
+#define	AA28		0x1000	/* Aborted Message In Mailbox 28	*/
+#define	AA29		0x2000	/* Aborted Message In Mailbox 29	*/
+#define	AA30		0x4000	/* Aborted Message In Mailbox 30	*/
+#define	AA31		0x8000	/* Aborted Message In Mailbox 31	*/
+
+/* CAN_TA1 Masks													*/
+#define	TA0			0x0001	/* Transmit Successful From Mailbox 0	*/
+#define	TA1			0x0002	/* Transmit Successful From Mailbox 1	*/
+#define	TA2			0x0004	/* Transmit Successful From Mailbox 2	*/
+#define	TA3			0x0008	/* Transmit Successful From Mailbox 3	*/
+#define	TA4			0x0010	/* Transmit Successful From Mailbox 4	*/
+#define	TA5			0x0020	/* Transmit Successful From Mailbox 5	*/
+#define	TA6			0x0040	/* Transmit Successful From Mailbox 6	*/
+#define	TA7			0x0080	/* Transmit Successful From Mailbox 7	*/
+#define	TA8			0x0100	/* Transmit Successful From Mailbox 8	*/
+#define	TA9			0x0200	/* Transmit Successful From Mailbox 9	*/
+#define	TA10		0x0400	/* Transmit Successful From Mailbox 10	*/
+#define	TA11		0x0800	/* Transmit Successful From Mailbox 11	*/
+#define	TA12		0x1000	/* Transmit Successful From Mailbox 12	*/
+#define	TA13		0x2000	/* Transmit Successful From Mailbox 13	*/
+#define	TA14		0x4000	/* Transmit Successful From Mailbox 14	*/
+#define	TA15		0x8000	/* Transmit Successful From Mailbox 15	*/
+
+/* CAN_TA2 Masks													*/
+#define	TA16		0x0001	/* Transmit Successful From Mailbox 16	*/
+#define	TA17		0x0002	/* Transmit Successful From Mailbox 17	*/
+#define	TA18		0x0004	/* Transmit Successful From Mailbox 18	*/
+#define	TA19		0x0008	/* Transmit Successful From Mailbox 19	*/
+#define	TA20		0x0010	/* Transmit Successful From Mailbox 20	*/
+#define	TA21		0x0020	/* Transmit Successful From Mailbox 21	*/
+#define	TA22		0x0040	/* Transmit Successful From Mailbox 22	*/
+#define	TA23		0x0080	/* Transmit Successful From Mailbox 23	*/
+#define	TA24		0x0100	/* Transmit Successful From Mailbox 24	*/
+#define	TA25		0x0200	/* Transmit Successful From Mailbox 25	*/
+#define	TA26		0x0400	/* Transmit Successful From Mailbox 26	*/
+#define	TA27		0x0800	/* Transmit Successful From Mailbox 27	*/
+#define	TA28		0x1000	/* Transmit Successful From Mailbox 28	*/
+#define	TA29		0x2000	/* Transmit Successful From Mailbox 29	*/
+#define	TA30		0x4000	/* Transmit Successful From Mailbox 30	*/
+#define	TA31		0x8000	/* Transmit Successful From Mailbox 31	*/
+
+/* CAN_MBTD Masks												*/
+#define TDPTR		0x001F	/* Mailbox To Temporarily Disable	*/
+#define	TDA			0x0040	/* Temporary Disable Acknowledge	*/
+#define	TDR			0x0080	/* Temporary Disable Request		*/
+
+/* CAN_RFH1 Masks																		*/
+#define	RFH0		0x0001	/* Enable Automatic Remote Frame Handling For Mailbox 0		*/
+#define	RFH1		0x0002	/* Enable Automatic Remote Frame Handling For Mailbox 1		*/
+#define	RFH2		0x0004	/* Enable Automatic Remote Frame Handling For Mailbox 2		*/
+#define	RFH3		0x0008	/* Enable Automatic Remote Frame Handling For Mailbox 3		*/
+#define	RFH4		0x0010	/* Enable Automatic Remote Frame Handling For Mailbox 4		*/
+#define	RFH5		0x0020	/* Enable Automatic Remote Frame Handling For Mailbox 5		*/
+#define	RFH6		0x0040	/* Enable Automatic Remote Frame Handling For Mailbox 6		*/
+#define	RFH7		0x0080	/* Enable Automatic Remote Frame Handling For Mailbox 7		*/
+#define	RFH8		0x0100	/* Enable Automatic Remote Frame Handling For Mailbox 8		*/
+#define	RFH9		0x0200	/* Enable Automatic Remote Frame Handling For Mailbox 9		*/
+#define	RFH10		0x0400	/* Enable Automatic Remote Frame Handling For Mailbox 10	*/
+#define	RFH11		0x0800	/* Enable Automatic Remote Frame Handling For Mailbox 11	*/
+#define	RFH12		0x1000	/* Enable Automatic Remote Frame Handling For Mailbox 12	*/
+#define	RFH13		0x2000	/* Enable Automatic Remote Frame Handling For Mailbox 13	*/
+#define	RFH14		0x4000	/* Enable Automatic Remote Frame Handling For Mailbox 14	*/
+#define	RFH15		0x8000	/* Enable Automatic Remote Frame Handling For Mailbox 15	*/
+
+/* CAN_RFH2 Masks																		*/
+#define	RFH16		0x0001	/* Enable Automatic Remote Frame Handling For Mailbox 16	*/
+#define	RFH17		0x0002	/* Enable Automatic Remote Frame Handling For Mailbox 17	*/
+#define	RFH18		0x0004	/* Enable Automatic Remote Frame Handling For Mailbox 18	*/
+#define	RFH19		0x0008	/* Enable Automatic Remote Frame Handling For Mailbox 19	*/
+#define	RFH20		0x0010	/* Enable Automatic Remote Frame Handling For Mailbox 20	*/
+#define	RFH21		0x0020	/* Enable Automatic Remote Frame Handling For Mailbox 21	*/
+#define	RFH22		0x0040	/* Enable Automatic Remote Frame Handling For Mailbox 22	*/
+#define	RFH23		0x0080	/* Enable Automatic Remote Frame Handling For Mailbox 23	*/
+#define	RFH24		0x0100	/* Enable Automatic Remote Frame Handling For Mailbox 24	*/
+#define	RFH25		0x0200	/* Enable Automatic Remote Frame Handling For Mailbox 25	*/
+#define	RFH26		0x0400	/* Enable Automatic Remote Frame Handling For Mailbox 26	*/
+#define	RFH27		0x0800	/* Enable Automatic Remote Frame Handling For Mailbox 27	*/
+#define	RFH28		0x1000	/* Enable Automatic Remote Frame Handling For Mailbox 28	*/
+#define	RFH29		0x2000	/* Enable Automatic Remote Frame Handling For Mailbox 29	*/
+#define	RFH30		0x4000	/* Enable Automatic Remote Frame Handling For Mailbox 30	*/
+#define	RFH31		0x8000	/* Enable Automatic Remote Frame Handling For Mailbox 31	*/
+
+/* CAN_MBTIF1 Masks													*/
+#define	MBTIF0		0x0001	/* TX Interrupt Active In Mailbox 0		*/
+#define	MBTIF1		0x0002	/* TX Interrupt Active In Mailbox 1		*/
+#define	MBTIF2		0x0004	/* TX Interrupt Active In Mailbox 2		*/
+#define	MBTIF3		0x0008	/* TX Interrupt Active In Mailbox 3		*/
+#define	MBTIF4		0x0010	/* TX Interrupt Active In Mailbox 4		*/
+#define	MBTIF5		0x0020	/* TX Interrupt Active In Mailbox 5		*/
+#define	MBTIF6		0x0040	/* TX Interrupt Active In Mailbox 6		*/
+#define	MBTIF7		0x0080	/* TX Interrupt Active In Mailbox 7		*/
+#define	MBTIF8		0x0100	/* TX Interrupt Active In Mailbox 8		*/
+#define	MBTIF9		0x0200	/* TX Interrupt Active In Mailbox 9		*/
+#define	MBTIF10		0x0400	/* TX Interrupt Active In Mailbox 10	*/
+#define	MBTIF11		0x0800	/* TX Interrupt Active In Mailbox 11	*/
+#define	MBTIF12		0x1000	/* TX Interrupt Active In Mailbox 12	*/
+#define	MBTIF13		0x2000	/* TX Interrupt Active In Mailbox 13	*/
+#define	MBTIF14		0x4000	/* TX Interrupt Active In Mailbox 14	*/
+#define	MBTIF15		0x8000	/* TX Interrupt Active In Mailbox 15	*/
+
+/* CAN_MBTIF2 Masks													*/
+#define	MBTIF16		0x0001	/* TX Interrupt Active In Mailbox 16	*/
+#define	MBTIF17		0x0002	/* TX Interrupt Active In Mailbox 17	*/
+#define	MBTIF18		0x0004	/* TX Interrupt Active In Mailbox 18	*/
+#define	MBTIF19		0x0008	/* TX Interrupt Active In Mailbox 19	*/
+#define	MBTIF20		0x0010	/* TX Interrupt Active In Mailbox 20	*/
+#define	MBTIF21		0x0020	/* TX Interrupt Active In Mailbox 21	*/
+#define	MBTIF22		0x0040	/* TX Interrupt Active In Mailbox 22	*/
+#define	MBTIF23		0x0080	/* TX Interrupt Active In Mailbox 23	*/
+#define	MBTIF24		0x0100	/* TX Interrupt Active In Mailbox 24	*/
+#define	MBTIF25		0x0200	/* TX Interrupt Active In Mailbox 25	*/
+#define	MBTIF26		0x0400	/* TX Interrupt Active In Mailbox 26	*/
+#define	MBTIF27		0x0800	/* TX Interrupt Active In Mailbox 27	*/
+#define	MBTIF28		0x1000	/* TX Interrupt Active In Mailbox 28	*/
+#define	MBTIF29		0x2000	/* TX Interrupt Active In Mailbox 29	*/
+#define	MBTIF30		0x4000	/* TX Interrupt Active In Mailbox 30	*/
+#define	MBTIF31		0x8000	/* TX Interrupt Active In Mailbox 31	*/
+
+/* CAN_MBRIF1 Masks													*/
+#define	MBRIF0		0x0001	/* RX Interrupt Active In Mailbox 0		*/
+#define	MBRIF1		0x0002	/* RX Interrupt Active In Mailbox 1		*/
+#define	MBRIF2		0x0004	/* RX Interrupt Active In Mailbox 2		*/
+#define	MBRIF3		0x0008	/* RX Interrupt Active In Mailbox 3		*/
+#define	MBRIF4		0x0010	/* RX Interrupt Active In Mailbox 4		*/
+#define	MBRIF5		0x0020	/* RX Interrupt Active In Mailbox 5		*/
+#define	MBRIF6		0x0040	/* RX Interrupt Active In Mailbox 6		*/
+#define	MBRIF7		0x0080	/* RX Interrupt Active In Mailbox 7		*/
+#define	MBRIF8		0x0100	/* RX Interrupt Active In Mailbox 8		*/
+#define	MBRIF9		0x0200	/* RX Interrupt Active In Mailbox 9		*/
+#define	MBRIF10		0x0400	/* RX Interrupt Active In Mailbox 10	*/
+#define	MBRIF11		0x0800	/* RX Interrupt Active In Mailbox 11	*/
+#define	MBRIF12		0x1000	/* RX Interrupt Active In Mailbox 12	*/
+#define	MBRIF13		0x2000	/* RX Interrupt Active In Mailbox 13	*/
+#define	MBRIF14		0x4000	/* RX Interrupt Active In Mailbox 14	*/
+#define	MBRIF15		0x8000	/* RX Interrupt Active In Mailbox 15	*/
+
+/* CAN_MBRIF2 Masks													*/
+#define	MBRIF16		0x0001	/* RX Interrupt Active In Mailbox 16	*/
+#define	MBRIF17		0x0002	/* RX Interrupt Active In Mailbox 17	*/
+#define	MBRIF18		0x0004	/* RX Interrupt Active In Mailbox 18	*/
+#define	MBRIF19		0x0008	/* RX Interrupt Active In Mailbox 19	*/
+#define	MBRIF20		0x0010	/* RX Interrupt Active In Mailbox 20	*/
+#define	MBRIF21		0x0020	/* RX Interrupt Active In Mailbox 21	*/
+#define	MBRIF22		0x0040	/* RX Interrupt Active In Mailbox 22	*/
+#define	MBRIF23		0x0080	/* RX Interrupt Active In Mailbox 23	*/
+#define	MBRIF24		0x0100	/* RX Interrupt Active In Mailbox 24	*/
+#define	MBRIF25		0x0200	/* RX Interrupt Active In Mailbox 25	*/
+#define	MBRIF26		0x0400	/* RX Interrupt Active In Mailbox 26	*/
+#define	MBRIF27		0x0800	/* RX Interrupt Active In Mailbox 27	*/
+#define	MBRIF28		0x1000	/* RX Interrupt Active In Mailbox 28	*/
+#define	MBRIF29		0x2000	/* RX Interrupt Active In Mailbox 29	*/
+#define	MBRIF30		0x4000	/* RX Interrupt Active In Mailbox 30	*/
+#define	MBRIF31		0x8000	/* RX Interrupt Active In Mailbox 31	*/
+
+/* CAN_MBIM1 Masks												*/
+#define	MBIM0		0x0001	/* Enable Interrupt For Mailbox 0	*/
+#define	MBIM1		0x0002	/* Enable Interrupt For Mailbox 1	*/
+#define	MBIM2		0x0004	/* Enable Interrupt For Mailbox 2	*/
+#define	MBIM3		0x0008	/* Enable Interrupt For Mailbox 3	*/
+#define	MBIM4		0x0010	/* Enable Interrupt For Mailbox 4	*/
+#define	MBIM5		0x0020	/* Enable Interrupt For Mailbox 5	*/
+#define	MBIM6		0x0040	/* Enable Interrupt For Mailbox 6	*/
+#define	MBIM7		0x0080	/* Enable Interrupt For Mailbox 7	*/
+#define	MBIM8		0x0100	/* Enable Interrupt For Mailbox 8	*/
+#define	MBIM9		0x0200	/* Enable Interrupt For Mailbox 9	*/
+#define	MBIM10		0x0400	/* Enable Interrupt For Mailbox 10	*/
+#define	MBIM11		0x0800	/* Enable Interrupt For Mailbox 11	*/
+#define	MBIM12		0x1000	/* Enable Interrupt For Mailbox 12	*/
+#define	MBIM13		0x2000	/* Enable Interrupt For Mailbox 13	*/
+#define	MBIM14		0x4000	/* Enable Interrupt For Mailbox 14	*/
+#define	MBIM15		0x8000	/* Enable Interrupt For Mailbox 15	*/
+
+/* CAN_MBIM2 Masks												*/
+#define	MBIM16		0x0001	/* Enable Interrupt For Mailbox 16	*/
+#define	MBIM17		0x0002	/* Enable Interrupt For Mailbox 17	*/
+#define	MBIM18		0x0004	/* Enable Interrupt For Mailbox 18	*/
+#define	MBIM19		0x0008	/* Enable Interrupt For Mailbox 19	*/
+#define	MBIM20		0x0010	/* Enable Interrupt For Mailbox 20	*/
+#define	MBIM21		0x0020	/* Enable Interrupt For Mailbox 21	*/
+#define	MBIM22		0x0040	/* Enable Interrupt For Mailbox 22	*/
+#define	MBIM23		0x0080	/* Enable Interrupt For Mailbox 23	*/
+#define	MBIM24		0x0100	/* Enable Interrupt For Mailbox 24	*/
+#define	MBIM25		0x0200	/* Enable Interrupt For Mailbox 25	*/
+#define	MBIM26		0x0400	/* Enable Interrupt For Mailbox 26	*/
+#define	MBIM27		0x0800	/* Enable Interrupt For Mailbox 27	*/
+#define	MBIM28		0x1000	/* Enable Interrupt For Mailbox 28	*/
+#define	MBIM29		0x2000	/* Enable Interrupt For Mailbox 29	*/
+#define	MBIM30		0x4000	/* Enable Interrupt For Mailbox 30	*/
+#define	MBIM31		0x8000	/* Enable Interrupt For Mailbox 31	*/
+
+/* CAN_GIM Masks																*/
+#define	EWTIM		0x0001	/* Enable TX Error Count Interrupt					*/
+#define	EWRIM		0x0002	/* Enable RX Error Count Interrupt					*/
+#define	EPIM		0x0004	/* Enable Error-Passive Mode Interrupt				*/
+#define	BOIM		0x0008	/* Enable Bus Off Interrupt							*/
+#define	WUIM		0x0010	/* Enable Wake-Up Interrupt							*/
+#define	UIAIM		0x0020	/* Enable Access To Unimplemented Address Interrupt	*/
+#define	AAIM		0x0040	/* Enable Abort Acknowledge Interrupt				*/
+#define	RMLIM		0x0080	/* Enable RX Message Lost Interrupt					*/
+#define	UCEIM		0x0100	/* Enable Universal Counter Overflow Interrupt		*/
+#define	EXTIM		0x0200	/* Enable External Trigger Output Interrupt			*/
+#define	ADIM		0x0400	/* Enable Access Denied Interrupt					*/
+
+/* CAN_GIS Masks															*/
+#define	EWTIS		0x0001	/* TX Error Count IRQ Status					*/
+#define	EWRIS		0x0002	/* RX Error Count IRQ Status					*/
+#define	EPIS		0x0004	/* Error-Passive Mode IRQ Status				*/
+#define	BOIS		0x0008	/* Bus Off IRQ Status							*/
+#define	WUIS		0x0010	/* Wake-Up IRQ Status							*/
+#define	UIAIS		0x0020	/* Access To Unimplemented Address IRQ Status	*/
+#define	AAIS		0x0040	/* Abort Acknowledge IRQ Status					*/
+#define	RMLIS		0x0080	/* RX Message Lost IRQ Status					*/
+#define	UCEIS		0x0100	/* Universal Counter Overflow IRQ Status		*/
+#define	EXTIS		0x0200	/* External Trigger Output IRQ Status			*/
+#define	ADIS		0x0400	/* Access Denied IRQ Status						*/
+
+/* CAN_GIF Masks															*/
+#define	EWTIF		0x0001	/* TX Error Count IRQ Flag						*/
+#define	EWRIF		0x0002	/* RX Error Count IRQ Flag						*/
+#define	EPIF		0x0004	/* Error-Passive Mode IRQ Flag					*/
+#define	BOIF		0x0008	/* Bus Off IRQ Flag								*/
+#define	WUIF		0x0010	/* Wake-Up IRQ Flag								*/
+#define	UIAIF		0x0020	/* Access To Unimplemented Address IRQ Flag		*/
+#define	AAIF		0x0040	/* Abort Acknowledge IRQ Flag					*/
+#define	RMLIF		0x0080	/* RX Message Lost IRQ Flag						*/
+#define	UCEIF		0x0100	/* Universal Counter Overflow IRQ Flag			*/
+#define	EXTIF		0x0200	/* External Trigger Output IRQ Flag				*/
+#define	ADIF		0x0400	/* Access Denied IRQ Flag						*/
+
+/* CAN_UCCNF Masks															*/
+#define	UCCNF		0x000F	/* Universal Counter Mode						*/
+#define UC_STAMP	0x0001	/* 		Timestamp Mode							*/
+#define UC_WDOG		0x0002	/* 		Watchdog Mode							*/
+#define UC_AUTOTX	0x0003	/* 		Auto-Transmit Mode						*/
+#define UC_ERROR	0x0006	/* 		CAN Error Frame Count					*/
+#define UC_OVER		0x0007	/* 		CAN Overload Frame Count				*/
+#define UC_LOST		0x0008	/* 		Arbitration Lost During TX Count		*/
+#define UC_AA		0x0009	/* 		TX Abort Count							*/
+#define UC_TA		0x000A	/* 		TX Successful Count						*/
+#define UC_REJECT	0x000B	/* 		RX Message Rejected Count				*/
+#define UC_RML		0x000C	/* 		RX Message Lost Count					*/
+#define UC_RX		0x000D	/* 		Total Successful RX Messages Count		*/
+#define UC_RMP		0x000E	/* 		Successful RX W/Matching ID Count		*/
+#define UC_ALL		0x000F	/* 		Correct Message On CAN Bus Line Count	*/
+#define	UCRC		0x0020	/* Universal Counter Reload/Clear				*/
+#define	UCCT		0x0040	/* Universal Counter CAN Trigger				*/
+#define	UCE			0x0080	/* Universal Counter Enable						*/
+
+/* CAN_ESR Masks										*/
+#define	ACKE		0x0004	/* Acknowledge Error		*/
+#define	SER			0x0008	/* Stuff Error				*/
+#define	CRCE		0x0010	/* CRC Error				*/
+#define	SA0			0x0020	/* Stuck At Dominant Error	*/
+#define	BEF			0x0040	/* Bit Error Flag			*/
+#define	FER			0x0080	/* Form Error Flag			*/
+
+/* CAN_EWR Masks												*/
+#define	EWLREC		0x00FF	/* RX Error Count Limit (For EWRIS)	*/
+#define	EWLTEC		0xFF00	/* TX Error Count Limit (For EWTIS)	*/
+
+/*  *******************  PIN CONTROL REGISTER MASKS  ************************/
+/* PORT_MUX Masks															*/
+#define	PJSE			0x0001			/* Port J SPI/SPORT Enable			*/
+#define	PJSE_SPORT		0x0000			/* 		Enable TFS0/DT0PRI			*/
+#define	PJSE_SPI		0x0001			/* 		Enable SPI_SSEL3:2			*/
+
+#define	PJCE(x)			(((x)&0x3)<<1)	/* Port J CAN/SPI/SPORT Enable		*/
+#define	PJCE_SPORT		0x0000			/* 		Enable DR0SEC/DT0SEC		*/
+#define	PJCE_CAN		0x0002			/* 		Enable CAN RX/TX			*/
+#define	PJCE_SPI		0x0004			/* 		Enable SPI_SSEL7			*/
+
+#define	PFDE			0x0008			/* Port F DMA Request Enable		*/
+#define	PGDE_UART		0x0000			/* 		Enable UART0 RX/TX			*/
+#define	PGDE_DMA		0x0008			/* 		Enable DMAR1:0				*/
+
+#define	PFTE			0x0010			/* Port F Timer Enable				*/
+#define	PFTE_UART		0x0000			/*		Enable UART1 RX/TX			*/
+#define	PFTE_TIMER		0x0010			/* 		Enable TMR7:6				*/
+
+#define	PFS6E			0x0020			/* Port F SPI SSEL 6 Enable			*/
+#define	PFS6E_TIMER		0x0000			/*		Enable TMR5					*/
+#define	PFS6E_SPI		0x0020			/* 		Enable SPI_SSEL6			*/
+
+#define	PFS5E			0x0040			/* Port F SPI SSEL 5 Enable			*/
+#define	PFS5E_TIMER		0x0000			/*		Enable TMR4					*/
+#define	PFS5E_SPI		0x0040			/* 		Enable SPI_SSEL5			*/
+
+#define	PFS4E			0x0080			/* Port F SPI SSEL 4 Enable			*/
+#define	PFS4E_TIMER		0x0000			/*		Enable TMR3					*/
+#define	PFS4E_SPI		0x0080			/* 		Enable SPI_SSEL4			*/
+
+#define	PFFE			0x0100			/* Port F PPI Frame Sync Enable		*/
+#define	PFFE_TIMER		0x0000			/* 		Enable TMR2					*/
+#define	PFFE_PPI		0x0100			/* 		Enable PPI FS3				*/
+
+#define	PGSE			0x0200			/* Port G SPORT1 Secondary Enable	*/
+#define	PGSE_PPI		0x0000			/* 		Enable PPI D9:8				*/
+#define	PGSE_SPORT		0x0200			/* 		Enable DR1SEC/DT1SEC		*/
+
+#define	PGRE			0x0400			/* Port G SPORT1 Receive Enable		*/
+#define	PGRE_PPI		0x0000			/* 		Enable PPI D12:10			*/
+#define	PGRE_SPORT		0x0400			/* 		Enable DR1PRI/RFS1/RSCLK1	*/
+
+#define	PGTE			0x0800			/* Port G SPORT1 Transmit Enable	*/
+#define	PGTE_PPI		0x0000			/* 		Enable PPI D15:13			*/
+#define	PGTE_SPORT		0x0800			/* 		Enable DT1PRI/TFS1/TSCLK1	*/
+
+/*  ******************  HANDSHAKE DMA (HDMA) MASKS  *********************/
+/* HDMAx_CTL Masks														*/
+#define	HMDMAEN		0x0001	/* Enable Handshake DMA 0/1					*/
+#define	REP			0x0002	/* HDMA Request Polarity					*/
+#define	UTE			0x0004	/* Urgency Threshold Enable					*/
+#define	OIE			0x0010	/* Overflow Interrupt Enable				*/
+#define	BDIE		0x0020	/* Block Done Interrupt Enable				*/
+#define	MBDI		0x0040	/* Mask Block Done IRQ If Pending ECNT		*/
+#define	DRQ			0x0300	/* HDMA Request Type						*/
+#define	DRQ_NONE	0x0000	/* 		No Request							*/
+#define	DRQ_SINGLE	0x0100	/* 		Channels Request Single				*/
+#define	DRQ_MULTI	0x0200	/* 		Channels Request Multi (Default)	*/
+#define	DRQ_URGENT	0x0300	/* 		Channels Request Multi Urgent		*/
+#define	RBC			0x1000	/* Reload BCNT With IBCNT					*/
+#define	PS			0x2000	/* HDMA Pin Status							*/
+#define	OI			0x4000	/* Overflow Interrupt Generated				*/
+#define	BDI			0x8000	/* Block Done Interrupt Generated			*/
+
+#endif	/* _DEF_BF534_H */
Index: git/linux-2.6/include/asm-blackfin/mach-bf537/defBF537.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf537/defBF537.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,404 @@
+/*
+ * file:         include/asm-blackfin/mach-bf537/defbf537.h
+ * based on:
+ * author:
+ *
+ * created:
+ * description:
+ *	system mmr register map
+ * rev:
+ *
+ * modified:
+ *
+ *
+ * bugs:         enter bugs at http://blackfin.uclinux.org/
+ *
+ * this program is free software; you can redistribute it and/or modify
+ * it under the terms of the gnu general public license as published by
+ * the free software foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * this program is distributed in the hope that it will be useful,
+ * but without any warranty; without even the implied warranty of
+ * merchantability or fitness for a particular purpose.  see the
+ * gnu general public license for more details.
+ *
+ * you should have received a copy of the gnu general public license
+ * along with this program; see the file copying.
+ * if not, write to the free software foundation,
+ * 59 temple place - suite 330, boston, ma 02111-1307, usa.
+ */
+
+#ifndef _DEF_BF537_H
+#define _DEF_BF537_H
+
+/*include all Core registers and bit definitions*/
+#include "defBF537.h"
+
+/*include core specific register pointer definitions*/
+#include <asm/mach-common/cdef_LPBlackfin.h>
+
+/************************************************************************************
+** Define EMAC Section Unique to BF536/BF537
+*************************************************************************************/
+
+/* 10/100 Ethernet Controller	(0xFFC03000 - 0xFFC031FF)										*/
+#define	EMAC_OPMODE			0xFFC03000	/* Operating Mode Register                                                              */
+#define EMAC_ADDRLO			0xFFC03004	/* Address Low (32 LSBs) Register                                               */
+#define EMAC_ADDRHI			0xFFC03008	/* Address High (16 MSBs) Register                                              */
+#define EMAC_HASHLO			0xFFC0300C	/* Multicast Hash Table Low (Bins 31-0) Register                */
+#define EMAC_HASHHI			0xFFC03010	/* Multicast Hash Table High (Bins 63-32) Register              */
+#define EMAC_STAADD			0xFFC03014	/* Station Management Address Register                                  */
+#define EMAC_STADAT			0xFFC03018	/* Station Management Data Register                                     */
+#define EMAC_FLC			0xFFC0301C	/* Flow Control Register                                                                */
+#define EMAC_VLAN1			0xFFC03020	/* VLAN1 Tag Register                                                                   */
+#define EMAC_VLAN2			0xFFC03024	/* VLAN2 Tag Register                                                                   */
+#define EMAC_WKUP_CTL		0xFFC0302C	/* Wake-Up Control/Status Register                                              */
+#define EMAC_WKUP_FFMSK0	0xFFC03030	/* Wake-Up Frame Filter 0 Byte Mask Register                    */
+#define EMAC_WKUP_FFMSK1	0xFFC03034	/* Wake-Up Frame Filter 1 Byte Mask Register                    */
+#define EMAC_WKUP_FFMSK2	0xFFC03038	/* Wake-Up Frame Filter 2 Byte Mask Register                    */
+#define EMAC_WKUP_FFMSK3	0xFFC0303C	/* Wake-Up Frame Filter 3 Byte Mask Register                    */
+#define EMAC_WKUP_FFCMD		0xFFC03040	/* Wake-Up Frame Filter Commands Register                               */
+#define EMAC_WKUP_FFOFF		0xFFC03044	/* Wake-Up Frame Filter Offsets Register                                */
+#define EMAC_WKUP_FFCRC0	0xFFC03048	/* Wake-Up Frame Filter 0,1 CRC-16 Register                             */
+#define EMAC_WKUP_FFCRC1	0xFFC0304C	/* Wake-Up Frame Filter 2,3 CRC-16 Register                             */
+
+#define	EMAC_SYSCTL			0xFFC03060	/* EMAC System Control Register                                                 */
+#define EMAC_SYSTAT			0xFFC03064	/* EMAC System Status Register                                                  */
+#define EMAC_RX_STAT		0xFFC03068	/* RX Current Frame Status Register                                             */
+#define EMAC_RX_STKY		0xFFC0306C	/* RX Sticky Frame Status Register                                              */
+#define EMAC_RX_IRQE		0xFFC03070	/* RX Frame Status Interrupt Enables Register                   */
+#define EMAC_TX_STAT		0xFFC03074	/* TX Current Frame Status Register                                             */
+#define EMAC_TX_STKY		0xFFC03078	/* TX Sticky Frame Status Register                                              */
+#define EMAC_TX_IRQE		0xFFC0307C	/* TX Frame Status Interrupt Enables Register                   */
+
+#define EMAC_MMC_CTL		0xFFC03080	/* MMC Counter Control Register                                                 */
+#define EMAC_MMC_RIRQS		0xFFC03084	/* MMC RX Interrupt Status Register                                             */
+#define EMAC_MMC_RIRQE		0xFFC03088	/* MMC RX Interrupt Enables Register                                    */
+#define EMAC_MMC_TIRQS		0xFFC0308C	/* MMC TX Interrupt Status Register                                             */
+#define EMAC_MMC_TIRQE		0xFFC03090	/* MMC TX Interrupt Enables Register                                    */
+
+#define EMAC_RXC_OK			0xFFC03100	/* RX Frame Successful Count                                                    */
+#define EMAC_RXC_FCS		0xFFC03104	/* RX Frame FCS Failure Count                                                   */
+#define EMAC_RXC_ALIGN		0xFFC03108	/* RX Alignment Error Count                                                             */
+#define EMAC_RXC_OCTET		0xFFC0310C	/* RX Octets Successfully Received Count                                */
+#define EMAC_RXC_DMAOVF		0xFFC03110	/* Internal MAC Sublayer Error RX Frame Count                   */
+#define EMAC_RXC_UNICST		0xFFC03114	/* Unicast RX Frame Count                                                               */
+#define EMAC_RXC_MULTI		0xFFC03118	/* Multicast RX Frame Count                                                             */
+#define EMAC_RXC_BROAD		0xFFC0311C	/* Broadcast RX Frame Count                                                             */
+#define EMAC_RXC_LNERRI		0xFFC03120	/* RX Frame In Range Error Count                                                */
+#define EMAC_RXC_LNERRO		0xFFC03124	/* RX Frame Out Of Range Error Count                                    */
+#define EMAC_RXC_LONG		0xFFC03128	/* RX Frame Too Long Count                                                              */
+#define EMAC_RXC_MACCTL		0xFFC0312C	/* MAC Control RX Frame Count                                                   */
+#define EMAC_RXC_OPCODE		0xFFC03130	/* Unsupported Op-Code RX Frame Count                                   */
+#define EMAC_RXC_PAUSE		0xFFC03134	/* MAC Control Pause RX Frame Count                                             */
+#define EMAC_RXC_ALLFRM		0xFFC03138	/* Overall RX Frame Count                                                               */
+#define EMAC_RXC_ALLOCT		0xFFC0313C	/* Overall RX Octet Count                                                               */
+#define EMAC_RXC_TYPED		0xFFC03140	/* Type/Length Consistent RX Frame Count                                */
+#define EMAC_RXC_SHORT		0xFFC03144	/* RX Frame Fragment Count - Byte Count x < 64                  */
+#define EMAC_RXC_EQ64		0xFFC03148	/* Good RX Frame Count - Byte Count x = 64                              */
+#define EMAC_RXC_LT128		0xFFC0314C	/* Good RX Frame Count - Byte Count  64 <= x < 128              */
+#define EMAC_RXC_LT256		0xFFC03150	/* Good RX Frame Count - Byte Count 128 <= x < 256              */
+#define EMAC_RXC_LT512		0xFFC03154	/* Good RX Frame Count - Byte Count 256 <= x < 512              */
+#define EMAC_RXC_LT1024		0xFFC03158	/* Good RX Frame Count - Byte Count 512 <= x < 1024             */
+#define EMAC_RXC_GE1024		0xFFC0315C	/* Good RX Frame Count - Byte Count x >= 1024                   */
+
+#define EMAC_TXC_OK			0xFFC03180	/* TX Frame Successful Count                                                    */
+#define EMAC_TXC_1COL		0xFFC03184	/* TX Frames Successful After Single Collision Count    */
+#define EMAC_TXC_GT1COL		0xFFC03188	/* TX Frames Successful After Multiple Collisions Count */
+#define EMAC_TXC_OCTET		0xFFC0318C	/* TX Octets Successfully Received Count                                */
+#define EMAC_TXC_DEFER		0xFFC03190	/* TX Frame Delayed Due To Busy Count                                   */
+#define EMAC_TXC_LATECL		0xFFC03194	/* Late TX Collisions Count                                                             */
+#define EMAC_TXC_XS_COL		0xFFC03198	/* TX Frame Failed Due To Excessive Collisions Count    */
+#define EMAC_TXC_DMAUND		0xFFC0319C	/* Internal MAC Sublayer Error TX Frame Count                   */
+#define EMAC_TXC_CRSERR		0xFFC031A0	/* Carrier Sense Deasserted During TX Frame Count               */
+#define EMAC_TXC_UNICST		0xFFC031A4	/* Unicast TX Frame Count                                                               */
+#define EMAC_TXC_MULTI		0xFFC031A8	/* Multicast TX Frame Count                                                             */
+#define EMAC_TXC_BROAD		0xFFC031AC	/* Broadcast TX Frame Count                                                             */
+#define EMAC_TXC_XS_DFR		0xFFC031B0	/* TX Frames With Excessive Deferral Count                              */
+#define EMAC_TXC_MACCTL		0xFFC031B4	/* MAC Control TX Frame Count                                                   */
+#define EMAC_TXC_ALLFRM		0xFFC031B8	/* Overall TX Frame Count                                                               */
+#define EMAC_TXC_ALLOCT		0xFFC031BC	/* Overall TX Octet Count                                                               */
+#define EMAC_TXC_EQ64		0xFFC031C0	/* Good TX Frame Count - Byte Count x = 64                              */
+#define EMAC_TXC_LT128		0xFFC031C4	/* Good TX Frame Count - Byte Count  64 <= x < 128              */
+#define EMAC_TXC_LT256		0xFFC031C8	/* Good TX Frame Count - Byte Count 128 <= x < 256              */
+#define EMAC_TXC_LT512		0xFFC031CC	/* Good TX Frame Count - Byte Count 256 <= x < 512              */
+#define EMAC_TXC_LT1024		0xFFC031D0	/* Good TX Frame Count - Byte Count 512 <= x < 1024             */
+#define EMAC_TXC_GE1024		0xFFC031D4	/* Good TX Frame Count - Byte Count x >= 1024                   */
+#define EMAC_TXC_ABORT		0xFFC031D8	/* Total TX Frames Aborted Count                                                */
+
+/* Listing for IEEE-Supported Count Registers																	*/
+#define FramesReceivedOK				EMAC_RXC_OK	/* RX Frame Successful Count                                                    */
+#define FrameCheckSequenceErrors		EMAC_RXC_FCS	/* RX Frame FCS Failure Count                                                   */
+#define AlignmentErrors					EMAC_RXC_ALIGN	/* RX Alignment Error Count                                                             */
+#define OctetsReceivedOK				EMAC_RXC_OCTET	/* RX Octets Successfully Received Count                                */
+#define FramesLostDueToIntMACRcvError	EMAC_RXC_DMAOVF	/* Internal MAC Sublayer Error RX Frame Count                   */
+#define UnicastFramesReceivedOK			EMAC_RXC_UNICST	/* Unicast RX Frame Count                                                               */
+#define MulticastFramesReceivedOK		EMAC_RXC_MULTI	/* Multicast RX Frame Count                                                             */
+#define BroadcastFramesReceivedOK		EMAC_RXC_BROAD	/* Broadcast RX Frame Count                                                             */
+#define InRangeLengthErrors				EMAC_RXC_LNERRI	/* RX Frame In Range Error Count                                                */
+#define OutOfRangeLengthField			EMAC_RXC_LNERRO	/* RX Frame Out Of Range Error Count                                    */
+#define FrameTooLongErrors				EMAC_RXC_LONG	/* RX Frame Too Long Count                                                              */
+#define MACControlFramesReceived		EMAC_RXC_MACCTL	/* MAC Control RX Frame Count                                                   */
+#define UnsupportedOpcodesReceived		EMAC_RXC_OPCODE	/* Unsupported Op-Code RX Frame Count                                   */
+#define PAUSEMACCtrlFramesReceived		EMAC_RXC_PAUSE	/* MAC Control Pause RX Frame Count                                             */
+#define FramesReceivedAll				EMAC_RXC_ALLFRM	/* Overall RX Frame Count                                                               */
+#define OctetsReceivedAll				EMAC_RXC_ALLOCT	/* Overall RX Octet Count                                                               */
+#define TypedFramesReceived				EMAC_RXC_TYPED	/* Type/Length Consistent RX Frame Count                                */
+#define FramesLenLt64Received			EMAC_RXC_SHORT	/* RX Frame Fragment Count - Byte Count x < 64                  */
+#define FramesLenEq64Received			EMAC_RXC_EQ64	/* Good RX Frame Count - Byte Count x = 64                              */
+#define FramesLen65_127Received			EMAC_RXC_LT128	/* Good RX Frame Count - Byte Count  64 <= x < 128              */
+#define FramesLen128_255Received		EMAC_RXC_LT256	/* Good RX Frame Count - Byte Count 128 <= x < 256              */
+#define FramesLen256_511Received		EMAC_RXC_LT512	/* Good RX Frame Count - Byte Count 256 <= x < 512              */
+#define FramesLen512_1023Received		EMAC_RXC_LT1024	/* Good RX Frame Count - Byte Count 512 <= x < 1024             */
+#define FramesLen1024_MaxReceived		EMAC_RXC_GE1024	/* Good RX Frame Count - Byte Count x >= 1024                   */
+
+#define FramesTransmittedOK				EMAC_TXC_OK	/* TX Frame Successful Count                                                    */
+#define SingleCollisionFrames			EMAC_TXC_1COL	/* TX Frames Successful After Single Collision Count    */
+#define MultipleCollisionFrames			EMAC_TXC_GT1COL	/* TX Frames Successful After Multiple Collisions Count */
+#define OctetsTransmittedOK				EMAC_TXC_OCTET	/* TX Octets Successfully Received Count                                */
+#define FramesWithDeferredXmissions		EMAC_TXC_DEFER	/* TX Frame Delayed Due To Busy Count                                   */
+#define LateCollisions					EMAC_TXC_LATECL	/* Late TX Collisions Count                                                             */
+#define FramesAbortedDueToXSColls		EMAC_TXC_XS_COL	/* TX Frame Failed Due To Excessive Collisions Count    */
+#define FramesLostDueToIntMacXmitError	EMAC_TXC_DMAUND	/* Internal MAC Sublayer Error TX Frame Count                   */
+#define CarrierSenseErrors				EMAC_TXC_CRSERR	/* Carrier Sense Deasserted During TX Frame Count               */
+#define UnicastFramesXmittedOK			EMAC_TXC_UNICST	/* Unicast TX Frame Count                                                               */
+#define MulticastFramesXmittedOK		EMAC_TXC_MULTI	/* Multicast TX Frame Count                                                             */
+#define BroadcastFramesXmittedOK		EMAC_TXC_BROAD	/* Broadcast TX Frame Count                                                             */
+#define FramesWithExcessiveDeferral		EMAC_TXC_XS_DFR	/* TX Frames With Excessive Deferral Count                              */
+#define MACControlFramesTransmitted		EMAC_TXC_MACCTL	/* MAC Control TX Frame Count                                                   */
+#define FramesTransmittedAll			EMAC_TXC_ALLFRM	/* Overall TX Frame Count                                                               */
+#define OctetsTransmittedAll			EMAC_TXC_ALLOCT	/* Overall TX Octet Count                                                               */
+#define FramesLenEq64Transmitted		EMAC_TXC_EQ64	/* Good TX Frame Count - Byte Count x = 64                              */
+#define FramesLen65_127Transmitted		EMAC_TXC_LT128	/* Good TX Frame Count - Byte Count  64 <= x < 128              */
+#define FramesLen128_255Transmitted		EMAC_TXC_LT256	/* Good TX Frame Count - Byte Count 128 <= x < 256              */
+#define FramesLen256_511Transmitted		EMAC_TXC_LT512	/* Good TX Frame Count - Byte Count 256 <= x < 512              */
+#define FramesLen512_1023Transmitted	EMAC_TXC_LT1024	/* Good TX Frame Count - Byte Count 512 <= x < 1024             */
+#define FramesLen1024_MaxTransmitted	EMAC_TXC_GE1024	/* Good TX Frame Count - Byte Count x >= 1024                   */
+#define TxAbortedFrames					EMAC_TXC_ABORT	/* Total TX Frames Aborted Count                                                */
+
+/***********************************************************************************
+** System MMR Register Bits And Macros
+**
+** Disclaimer:	All macros are intended to make C and Assembly code more readable.
+**				Use these macros carefully, as any that do left shifts for field
+**				depositing will result in the lower order bits being destroyed.  Any
+**				macro that shifts left to properly position the bit-field should be
+**				used as part of an OR to initialize a register and NOT as a dynamic
+**				modifier UNLESS the lower order bits are saved and ORed back in when
+**				the macro is used.
+*************************************************************************************/
+/************************  ETHERNET 10/100 CONTROLLER MASKS  ************************/
+/* EMAC_OPMODE Masks																*/
+#define	RE			0x00000001	/* Receiver Enable                                                                      */
+#define	ASTP		0x00000002	/* Enable Automatic Pad Stripping On RX Frames          */
+#define	HU			0x00000010	/* Hash Filter Unicast Address                                          */
+#define	HM			0x00000020	/* Hash Filter Multicast Address                                        */
+#define	PAM			0x00000040	/* Pass-All-Multicast Mode Enable                                       */
+#define	PR			0x00000080	/* Promiscuous Mode Enable                                                      */
+#define	IFE			0x00000100	/* Inverse Filtering Enable                                                     */
+#define	DBF			0x00000200	/* Disable Broadcast Frame Reception                            */
+#define	PBF			0x00000400	/* Pass Bad Frames Enable                                                       */
+#define	PSF			0x00000800	/* Pass Short Frames Enable                                                     */
+#define	RAF			0x00001000	/* Receive-All Mode                                                                     */
+#define	TE			0x00010000	/* Transmitter Enable                                                           */
+#define	DTXPAD		0x00020000	/* Disable Automatic TX Padding                                         */
+#define	DTXCRC		0x00040000	/* Disable Automatic TX CRC Generation                          */
+#define	DC			0x00080000	/* Deferral Check                                                                       */
+#define	BOLMT		0x00300000	/* Back-Off Limit                                                                       */
+#define	BOLMT_10	0x00000000	/*              10-bit range                                                            */
+#define	BOLMT_8		0x00100000	/*              8-bit range                                                                     */
+#define	BOLMT_4		0x00200000	/*              4-bit range                                                                     */
+#define	BOLMT_1		0x00300000	/*              1-bit range                                                                     */
+#define	DRTY		0x00400000	/* Disable TX Retry On Collision                                        */
+#define	LCTRE		0x00800000	/* Enable TX Retry On Late Collision                            */
+#define	RMII		0x01000000	/* RMII/MII* Mode                                                                       */
+#define	RMII_10		0x02000000	/* Speed Select for RMII Port (10MBit/100MBit*)         */
+#define	FDMODE		0x04000000	/* Duplex Mode Enable (Full/Half*)                                      */
+#define	LB			0x08000000	/* Internal Loopback Enable                                                     */
+#define	DRO			0x10000000	/* Disable Receive Own Frames (Half-Duplex Mode)        */
+
+/* EMAC_STAADD Masks																*/
+#define	STABUSY		0x00000001	/* Initiate Station Mgt Reg Access / STA Busy Stat      */
+#define	STAOP		0x00000002	/* Station Management Operation Code (Write/Read*)      */
+#define	STADISPRE	0x00000004	/* Disable Preamble Generation                                          */
+#define	STAIE		0x00000008	/* Station Mgt. Transfer Done Interrupt Enable          */
+#define	REGAD		0x000007C0	/* STA Register Address                                                         */
+#define	PHYAD		0x0000F800	/* PHY Device Address                                                           */
+
+#define	SET_REGAD(x)	(((x)&0x1F)<<  6 )	/* Set STA Register Address                             */
+#define	SET_PHYAD(x)	(((x)&0x1F)<< 11 )	/* Set PHY Device Address                               */
+
+/* EMAC_STADAT Mask											*/
+#define	STADATA		0x0000FFFF	/* Station Management Data      */
+
+/* EMAC_FLC Masks																	*/
+#define	FLCBUSY		0x00000001	/* Send Flow Ctrl Frame / Flow Ctrl Busy Status         */
+#define	FLCE		0x00000002	/* Flow Control Enable                                                          */
+#define	PCF			0x00000004	/* Pass Control Frames                                                          */
+#define	BKPRSEN		0x00000008	/* Enable Backpressure                                                          */
+#define	FLCPAUSE	0xFFFF0000	/* Pause Time                                                                           */
+
+#define	SET_FLCPAUSE(x)	(((x)&0xFFFF)<< 16)	/* Set Pause Time                                               */
+
+/* EMAC_WKUP_CTL Masks																*/
+#define	CAPWKFRM	0x00000001	/* Capture Wake-Up Frames                                                       */
+#define	MPKE		0x00000002	/* Magic Packet Enable                                                          */
+#define	RWKE		0x00000004	/* Remote Wake-Up Frame Enable                                          */
+#define	GUWKE		0x00000008	/* Global Unicast Wake Enable                                           */
+#define	MPKS		0x00000020	/* Magic Packet Received Status                                         */
+#define	RWKS		0x00000F00	/* Wake-Up Frame Received Status, Filters 3:0           */
+
+/* EMAC_WKUP_FFCMD Masks															*/
+#define	WF0_E		0x00000001	/* Enable Wake-Up Filter 0                                                      */
+#define	WF0_T		0x00000008	/* Wake-Up Filter 0 Addr Type (Multicast/Unicast*)      */
+#define	WF1_E		0x00000100	/* Enable Wake-Up Filter 1                                                      */
+#define	WF1_T		0x00000800	/* Wake-Up Filter 1 Addr Type (Multicast/Unicast*)      */
+#define	WF2_E		0x00010000	/* Enable Wake-Up Filter 2                                                      */
+#define	WF2_T		0x00080000	/* Wake-Up Filter 2 Addr Type (Multicast/Unicast*)      */
+#define	WF3_E		0x01000000	/* Enable Wake-Up Filter 3                                                      */
+#define	WF3_T		0x08000000	/* Wake-Up Filter 3 Addr Type (Multicast/Unicast*)      */
+
+/* EMAC_WKUP_FFOFF Masks															*/
+#define	WF0_OFF		0x000000FF	/* Wake-Up Filter 0 Pattern Offset                                      */
+#define	WF1_OFF		0x0000FF00	/* Wake-Up Filter 1 Pattern Offset                                      */
+#define	WF2_OFF		0x00FF0000	/* Wake-Up Filter 2 Pattern Offset                                      */
+#define	WF3_OFF		0xFF000000	/* Wake-Up Filter 3 Pattern Offset                                      */
+
+#define	SET_WF0_OFF(x) (((x)&0xFF)<<  0 )	/* Set Wake-Up Filter 0 Byte Offset           */
+#define	SET_WF1_OFF(x) (((x)&0xFF)<<  8 )	/* Set Wake-Up Filter 1 Byte Offset           */
+#define	SET_WF2_OFF(x) (((x)&0xFF)<< 16 )	/* Set Wake-Up Filter 2 Byte Offset           */
+#define	SET_WF3_OFF(x) (((x)&0xFF)<< 24 )	/* Set Wake-Up Filter 3 Byte Offset           */
+/* Set ALL Offsets																	*/
+#define	SET_WF_OFFS(x0,x1,x2,x3) 	(SET_WF0_OFF((x0))|SET_WF1_OFF((x1))|SET_WF2_OFF((x2))|SET_WF3_OFF((x3)))
+
+/* EMAC_WKUP_FFCRC0 Masks															*/
+#define	WF0_CRC		0x0000FFFF	/* Wake-Up Filter 0 Pattern CRC                                         */
+#define	WF1_CRC		0xFFFF0000	/* Wake-Up Filter 1 Pattern CRC                                         */
+
+#define	SET_WF0_CRC(x) (((x)&0xFFFF)<<   0 )	/* Set Wake-Up Filter 0 Target CRC         */
+#define	SET_WF1_CRC(x) (((x)&0xFFFF)<<  16 )	/* Set Wake-Up Filter 1 Target CRC         */
+
+/* EMAC_WKUP_FFCRC1 Masks															*/
+#define	WF2_CRC		0x0000FFFF	/* Wake-Up Filter 2 Pattern CRC                                         */
+#define	WF3_CRC		0xFFFF0000	/* Wake-Up Filter 3 Pattern CRC                                         */
+
+#define	SET_WF2_CRC(x) (((x)&0xFFFF)<<   0 )	/* Set Wake-Up Filter 2 Target CRC         */
+#define	SET_WF3_CRC(x) (((x)&0xFFFF)<<  16 )	/* Set Wake-Up Filter 3 Target CRC         */
+
+/* EMAC_SYSCTL Masks																*/
+#define	PHYIE		0x00000001	/* PHY_INT Interrupt Enable                                                     */
+#define	RXDWA		0x00000002	/* Receive Frame DMA Word Alignment (Odd/Even*)         */
+#define	RXCKS		0x00000004	/* Enable RX Frame TCP/UDP Checksum Computation         */
+#define	MDCDIV		0x00003F00	/* SCLK:MDC Clock Divisor [MDC=SCLK/(2*(N+1))]          */
+
+#define	SET_MDCDIV(x)	(((x)&0x3F)<< 8)	/* Set MDC Clock Divisor                                */
+
+/* EMAC_SYSTAT Masks															*/
+#define	PHYINT		0x00000001	/* PHY_INT Interrupt Status                                             */
+#define	MMCINT		0x00000002	/* MMC Counter Interrupt Status                                 */
+#define	RXFSINT		0x00000004	/* RX Frame-Status Interrupt Status                             */
+#define	TXFSINT		0x00000008	/* TX Frame-Status Interrupt Status                             */
+#define	WAKEDET		0x00000010	/* Wake-Up Detected Status                                              */
+#define	RXDMAERR	0x00000020	/* RX DMA Direction Error Status                                */
+#define	TXDMAERR	0x00000040	/* TX DMA Direction Error Status                                */
+#define	STMDONE		0x00000080	/* Station Mgt. Transfer Done Interrupt Status  */
+
+/* EMAC_RX_STAT, EMAC_RX_STKY, and EMAC_RX_IRQE Masks							*/
+#define	RX_FRLEN	0x000007FF	/* Frame Length In Bytes                                                */
+#define	RX_COMP		0x00001000	/* RX Frame Complete                                                    */
+#define	RX_OK		0x00002000	/* RX Frame Received With No Errors                             */
+#define	RX_LONG		0x00004000	/* RX Frame Too Long Error                                              */
+#define	RX_ALIGN	0x00008000	/* RX Frame Alignment Error                                             */
+#define	RX_CRC		0x00010000	/* RX Frame CRC Error                                                   */
+#define	RX_LEN		0x00020000	/* RX Frame Length Error                                                */
+#define	RX_FRAG		0x00040000	/* RX Frame Fragment Error                                              */
+#define	RX_ADDR		0x00080000	/* RX Frame Address Filter Failed Error                 */
+#define	RX_DMAO		0x00100000	/* RX Frame DMA Overrun Error                                   */
+#define	RX_PHY		0x00200000	/* RX Frame PHY Error                                                   */
+#define	RX_LATE		0x00400000	/* RX Frame Late Collision Error                                */
+#define	RX_RANGE	0x00800000	/* RX Frame Length Field Out of Range Error             */
+#define	RX_MULTI	0x01000000	/* RX Multicast Frame Indicator                                 */
+#define	RX_BROAD	0x02000000	/* RX Broadcast Frame Indicator                                 */
+#define	RX_CTL		0x04000000	/* RX Control Frame Indicator                                   */
+#define	RX_UCTL		0x08000000	/* Unsupported RX Control Frame Indicator               */
+#define	RX_TYPE		0x10000000	/* RX Typed Frame Indicator                                             */
+#define	RX_VLAN1	0x20000000	/* RX VLAN1 Frame Indicator                                             */
+#define	RX_VLAN2	0x40000000	/* RX VLAN2 Frame Indicator                                             */
+#define	RX_ACCEPT	0x80000000	/* RX Frame Accepted Indicator                                  */
+
+/*  EMAC_TX_STAT, EMAC_TX_STKY, and EMAC_TX_IRQE Masks							*/
+#define	TX_COMP		0x00000001	/* TX Frame Complete                                                    */
+#define	TX_OK		0x00000002	/* TX Frame Sent With No Errors                                 */
+#define	TX_ECOLL	0x00000004	/* TX Frame Excessive Collision Error                   */
+#define	TX_LATE		0x00000008	/* TX Frame Late Collision Error                                */
+#define	TX_DMAU		0x00000010	/* TX Frame DMA Underrun Error (STAT)                   */
+#define	TX_MACE		0x00000010	/* Internal MAC Error Detected (STKY and IRQE)  */
+#define	TX_EDEFER	0x00000020	/* TX Frame Excessive Deferral Error                    */
+#define	TX_BROAD	0x00000040	/* TX Broadcast Frame Indicator                                 */
+#define	TX_MULTI	0x00000080	/* TX Multicast Frame Indicator                                 */
+#define	TX_CCNT		0x00000F00	/* TX Frame Collision Count                                             */
+#define	TX_DEFER	0x00001000	/* TX Frame Deferred Indicator                                  */
+#define	TX_CRS		0x00002000	/* TX Frame Carrier Sense Not Asserted Error    */
+#define	TX_LOSS		0x00004000	/* TX Frame Carrier Lost During TX Error                */
+#define	TX_RETRY	0x00008000	/* TX Frame Successful After Retry                              */
+#define	TX_FRLEN	0x07FF0000	/* TX Frame Length (Bytes)                                              */
+
+/* EMAC_MMC_CTL Masks															*/
+#define	RSTC		0x00000001	/* Reset All Counters                                                   */
+#define	CROLL		0x00000002	/* Counter Roll-Over Enable                                             */
+#define	CCOR		0x00000004	/* Counter Clear-On-Read Mode Enable                    */
+#define	MMCE		0x00000008	/* Enable MMC Counter Operation                                 */
+
+/* EMAC_MMC_RIRQS and EMAC_MMC_RIRQE Masks											*/
+#define	RX_OK_CNT		0x00000001	/* RX Frames Received With No Errors                    */
+#define	RX_FCS_CNT		0x00000002	/* RX Frames W/Frame Check Sequence Errors              */
+#define	RX_ALIGN_CNT	0x00000004	/* RX Frames With Alignment Errors                              */
+#define	RX_OCTET_CNT	0x00000008	/* RX Octets Received OK                                                */
+#define	RX_LOST_CNT		0x00000010	/* RX Frames Lost Due To Internal MAC RX Error  */
+#define	RX_UNI_CNT		0x00000020	/* Unicast RX Frames Received OK                                */
+#define	RX_MULTI_CNT	0x00000040	/* Multicast RX Frames Received OK                              */
+#define	RX_BROAD_CNT	0x00000080	/* Broadcast RX Frames Received OK                              */
+#define	RX_IRL_CNT		0x00000100	/* RX Frames With In-Range Length Errors                */
+#define	RX_ORL_CNT		0x00000200	/* RX Frames With Out-Of-Range Length Errors    */
+#define	RX_LONG_CNT		0x00000400	/* RX Frames With Frame Too Long Errors                 */
+#define	RX_MACCTL_CNT	0x00000800	/* MAC Control RX Frames Received                               */
+#define	RX_OPCODE_CTL	0x00001000	/* Unsupported Op-Code RX Frames Received               */
+#define	RX_PAUSE_CNT	0x00002000	/* PAUSEMAC Control RX Frames Received                  */
+#define	RX_ALLF_CNT		0x00004000	/* All RX Frames Received                                               */
+#define	RX_ALLO_CNT		0x00008000	/* All RX Octets Received                                               */
+#define	RX_TYPED_CNT	0x00010000	/* Typed RX Frames Received                                             */
+#define	RX_SHORT_CNT	0x00020000	/* RX Frame Fragments (< 64 Bytes) Received             */
+#define	RX_EQ64_CNT		0x00040000	/* 64-Byte RX Frames Received                                   */
+#define	RX_LT128_CNT	0x00080000	/* 65-127-Byte RX Frames Received                               */
+#define	RX_LT256_CNT	0x00100000	/* 128-255-Byte RX Frames Received                              */
+#define	RX_LT512_CNT	0x00200000	/* 256-511-Byte RX Frames Received                              */
+#define	RX_LT1024_CNT	0x00400000	/* 512-1023-Byte RX Frames Received                             */
+#define	RX_GE1024_CNT	0x00800000	/* 1024-Max-Byte RX Frames Received                             */
+
+/* EMAC_MMC_TIRQS and EMAC_MMC_TIRQE Masks											*/
+#define	TX_OK_CNT		0x00000001	/* TX Frames Sent OK                                                    */
+#define	TX_SCOLL_CNT	0x00000002	/* TX Frames With Single Collisions                             */
+#define	TX_MCOLL_CNT	0x00000004	/* TX Frames With Multiple Collisions                   */
+#define	TX_OCTET_CNT	0x00000008	/* TX Octets Sent OK                                                    */
+#define	TX_DEFER_CNT	0x00000010	/* TX Frames With Deferred Transmission                 */
+#define	TX_LATE_CNT		0x00000020	/* TX Frames With Late Collisions                               */
+#define	TX_ABORTC_CNT	0x00000040	/* TX Frames Aborted Due To Excess Collisions   */
+#define	TX_LOST_CNT		0x00000080	/* TX Frames Lost Due To Internal MAC TX Error  */
+#define	TX_CRS_CNT		0x00000100	/* TX Frames With Carrier Sense Errors                  */
+#define	TX_UNI_CNT		0x00000200	/* Unicast TX Frames Sent                                               */
+#define	TX_MULTI_CNT	0x00000400	/* Multicast TX Frames Sent                                             */
+#define	TX_BROAD_CNT	0x00000800	/* Broadcast TX Frames Sent                                             */
+#define	TX_EXDEF_CTL	0x00001000	/* TX Frames With Excessive Deferral                    */
+#define	TX_MACCTL_CNT	0x00002000	/* MAC Control TX Frames Sent                                   */
+#define	TX_ALLF_CNT		0x00004000	/* All TX Frames Sent                                                   */
+#define	TX_ALLO_CNT		0x00008000	/* All TX Octets Sent                                                   */
+#define	TX_EQ64_CNT		0x00010000	/* 64-Byte TX Frames Sent                                               */
+#define	TX_LT128_CNT	0x00020000	/* 65-127-Byte TX Frames Sent                                   */
+#define	TX_LT256_CNT	0x00040000	/* 128-255-Byte TX Frames Sent                                  */
+#define	TX_LT512_CNT	0x00080000	/* 256-511-Byte TX Frames Sent                                  */
+#define	TX_LT1024_CNT	0x00100000	/* 512-1023-Byte TX Frames Sent                                 */
+#define	TX_GE1024_CNT	0x00200000	/* 1024-Max-Byte TX Frames Sent                                 */
+#define	TX_ABORT_CNT	0x00400000	/* TX Frames Aborted                                                    */
+
+#endif				/* _DEF_BF537_H */
Index: git/linux-2.6/include/asm-blackfin/mach-bf537/dma.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf537/dma.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,55 @@
+/*
+ * file:         include/asm-blackfin/mach-bf537/dma.h
+ * based on:
+ * author:
+ *
+ * created:
+ * description:
+ *	system mmr register map
+ * rev:
+ *
+ * modified:
+ *
+ *
+ * bugs:         enter bugs at http://blackfin.uclinux.org/
+ *
+ * this program is free software; you can redistribute it and/or modify
+ * it under the terms of the gnu general public license as published by
+ * the free software foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * this program is distributed in the hope that it will be useful,
+ * but without any warranty; without even the implied warranty of
+ * merchantability or fitness for a particular purpose.  see the
+ * gnu general public license for more details.
+ *
+ * you should have received a copy of the gnu general public license
+ * along with this program; see the file copying.
+ * if not, write to the free software foundation,
+ * 59 temple place - suite 330, boston, ma 02111-1307, usa.
+ */
+
+#ifndef _MACH_DMA_H_
+#define _MACH_DMA_H_
+
+#define MAX_BLACKFIN_DMA_CHANNEL 16
+
+#define CH_PPI 			    0
+#define CH_EMAC_RX 		    1
+#define CH_EMAC_TX 		    2
+#define CH_SPORT0_RX 		3
+#define CH_SPORT0_TX 		4
+#define CH_SPORT1_RX 		5
+#define CH_SPORT1_TX 		6
+#define CH_SPI 			    7
+#define CH_UART0_RX 		8
+#define CH_UART0_TX 		9
+#define CH_UART1_RX 		10
+#define CH_UART1_TX 		11
+
+#define CH_MEM_STREAM0_DEST	12	// TX
+#define CH_MEM_STREAM0_SRC  13	// RX
+#define CH_MEM_STREAM1_DEST	14	// TX
+#define CH_MEM_STREAM1_SRC 	15	// RX
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/mach-bf537/irq.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf537/irq.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,185 @@
+/*
+ * file:         include/asm-blackfin/mach-bf537/irq.h
+ * based on:
+ * author:
+ *
+ * created:
+ * description:
+ *	system mmr register map
+ * rev:
+ *
+ * modified:
+ *
+ *
+ * bugs:         enter bugs at http://blackfin.uclinux.org/
+ *
+ * this program is free software; you can redistribute it and/or modify
+ * it under the terms of the gnu general public license as published by
+ * the free software foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * this program is distributed in the hope that it will be useful,
+ * but without any warranty; without even the implied warranty of
+ * merchantability or fitness for a particular purpose.  see the
+ * gnu general public license for more details.
+ *
+ * you should have received a copy of the gnu general public license
+ * along with this program; see the file copying.
+ * if not, write to the free software foundation,
+ * 59 temple place - suite 330, boston, ma 02111-1307, usa.
+ */
+
+#ifndef _BF537_IRQ_H_
+#define _BF537_IRQ_H_
+
+/*
+ * Interrupt source definitions
+             Event Source    Core Event Name
+Core        Emulation               **
+ Events         (highest priority)  EMU         0
+            Reset                   RST         1
+            NMI                     NMI         2
+            Exception               EVX         3
+            Reserved                --          4
+            Hardware Error          IVHW        5
+            Core Timer              IVTMR       6 *
+
+.....
+
+            Software Interrupt 1    IVG14       31
+            Software Interrupt 2    --
+                 (lowest priority)  IVG15       32 *
+ */
+
+#define SYS_IRQS        41
+#define NR_PERI_INTS    32
+
+/* The ABSTRACT IRQ definitions */
+/** the first seven of the following are fixed, the rest you change if you need to **/
+#define IRQ_EMU             0	/*Emulation */
+#define IRQ_RST             1	/*reset */
+#define IRQ_NMI             2	/*Non Maskable */
+#define IRQ_EVX             3	/*Exception */
+#define IRQ_UNUSED          4	/*- unused interrupt*/
+#define IRQ_HWERR           5	/*Hardware Error */
+#define IRQ_CORETMR         6	/*Core timer */
+
+#define IRQ_PLL_WAKEUP      7	/*PLL Wakeup Interrupt */
+#define IRQ_DMA_ERROR       8	/*DMA Error (general) */
+#define IRQ_GENERIC_ERROR   9	/*GENERIC Error Interrupt */
+#define IRQ_RTC             10	/*RTC Interrupt */
+#define IRQ_PPI             11	/*DMA0 Interrupt (PPI) */
+#define IRQ_SPORT0_RX       12	/*DMA3 Interrupt (SPORT0 RX) */
+#define IRQ_SPORT0_TX       13	/*DMA4 Interrupt (SPORT0 TX) */
+#define IRQ_SPORT1_RX       14	/*DMA5 Interrupt (SPORT1 RX) */
+#define IRQ_SPORT1_TX       15	/*DMA6 Interrupt (SPORT1 TX) */
+#define IRQ_TWI             16	/*TWI Interrupt */
+#define IRQ_SPI             17	/*DMA7 Interrupt (SPI) */
+#define IRQ_UART0_RX        18	/*DMA8 Interrupt (UART0 RX) */
+#define IRQ_UART0_TX        19	/*DMA9 Interrupt (UART0 TX) */
+#define IRQ_UART1_RX        20	/*DMA10 Interrupt (UART1 RX) */
+#define IRQ_UART1_TX        21	/*DMA11 Interrupt (UART1 TX) */
+#define IRQ_CAN_RX          22	/*CAN Receive Interrupt */
+#define IRQ_CAN_TX          23	/*CAN Transmit Interrupt */
+#define IRQ_MAC_RX          24	/*DMA1 (Ethernet RX) Interrupt */
+#define IRQ_MAC_TX          25	/*DMA2 (Ethernet TX) Interrupt */
+#define IRQ_TMR0            26	/*Timer 0 */
+#define IRQ_TMR1            27	/*Timer 1 */
+#define IRQ_TMR2            28	/*Timer 2 */
+#define IRQ_TMR3            29	/*Timer 3 */
+#define IRQ_TMR4            30	/*Timer 4 */
+#define IRQ_TMR5            31	/*Timer 5 */
+#define IRQ_TMR6            32	/*Timer 6 */
+#define IRQ_TMR7            33	/*Timer 7 */
+#define IRQ_PROG_INTA       34	/* PF Ports F&G (PF31:0) Interrupt A */
+#define IRQ_PROG_INTB       35	/* PF Port F (PF15:0) Interrupt B */
+#define IRQ_MEM_DMA0        36	/*(Memory DMA Stream 0) */
+#define IRQ_MEM_DMA1        37	/*(Memory DMA Stream 1) */
+#define IRQ_WATCH           38	/*Watch Dog Timer */
+#define IRQ_PFB_PORTG       39	/*PF Port G (PF31:16) Interrupt B   */
+#define IRQ_SW_INT1         40	/*Software Int 1 */
+#define IRQ_SW_INT2         41	/*Software Int 2 (reserved for SYSCALL) */
+
+#define IRQ_PPI_ERROR       42	/*PPI Error Interrupt */
+#define IRQ_CAN_ERROR       43	/*CAN Error Interrupt */
+#define IRQ_MAC_ERROR       44	/*PPI Error Interrupt */
+#define IRQ_SPORT0_ERROR    45	/*SPORT0 Error Interrupt */
+#define IRQ_SPORT1_ERROR    46	/*SPORT1 Error Interrupt */
+#define IRQ_SPI_ERROR       47	/*SPI Error Interrupt */
+#define IRQ_UART0_ERROR     48	/*UART Error Interrupt */
+#define IRQ_UART1_ERROR     49	/*UART Error Interrupt */
+
+#define IRQ_PF0         50
+#define IRQ_PF1         51
+#define IRQ_PF2         52
+#define IRQ_PF3         53
+#define IRQ_PF4         54
+#define IRQ_PF5         55
+#define IRQ_PF6         56
+#define IRQ_PF7         57
+#define IRQ_PF8         58
+#define IRQ_PF9         59
+#define IRQ_PF10        60
+#define IRQ_PF11        61
+#define IRQ_PF12        62
+#define IRQ_PF13        63
+#define IRQ_PF14        64
+#define IRQ_PF15        65
+
+#ifdef CONFIG_IRQCHIP_DEMUX_GPIO
+#define NR_IRQS     (IRQ_PF15+1)
+#else
+#define NR_IRQS     (IRQ_UART1_ERROR+1)
+#endif
+
+#define IVG7            7
+#define IVG8            8
+#define IVG9            9
+#define IVG10           10
+#define IVG11           11
+#define IVG12           12
+#define IVG13           13
+#define IVG14           14
+#define IVG15           15
+
+/* IAR0 BIT FIELDS*/
+#define IRQ_PLL_WAKEUP_POS  0
+#define IRQ_DMA_ERROR_POS   4
+#define IRQ_ERROR_POS       8
+#define IRQ_RTC_POS         12
+#define IRQ_PPI_POS         16
+#define IRQ_SPORT0_RX_POS   20
+#define IRQ_SPORT0_TX_POS   24
+#define IRQ_SPORT1_RX_POS   28
+
+/* IAR1 BIT FIELDS*/
+#define IRQ_SPORT1_TX_POS   0
+#define IRQ_TWI_POS         4
+#define IRQ_SPI_POS         8
+#define IRQ_UART0_RX_POS    12
+#define IRQ_UART0_TX_POS    16
+#define IRQ_UART1_RX_POS    20
+#define IRQ_UART1_TX_POS    24
+#define IRQ_CAN_RX_POS      28
+
+/* IAR2 BIT FIELDS*/
+#define IRQ_CAN_TX_POS      0
+#define IRQ_MAC_RX_POS      4
+#define IRQ_MAC_TX_POS      8
+#define IRQ_TMR0_POS        12
+#define IRQ_TMR1_POS        16
+#define IRQ_TMR2_POS        20
+#define IRQ_TMR3_POS        24
+#define IRQ_TMR4_POS        28
+
+/* IAR3 BIT FIELDS*/
+#define IRQ_TMR5_POS        0
+#define IRQ_TMR6_POS        4
+#define IRQ_TMR7_POS        8
+#define IRQ_PROG_INTA_POS   12
+#define IRQ_PROG_INTB_POS   16
+#define IRQ_MEM_DMA0_POS    20
+#define IRQ_MEM_DMA1_POS    24
+#define IRQ_WATCH_POS       28
+
+#endif				/* _BF537_IRQ_H_ */
Index: git/linux-2.6/include/asm-blackfin/mach-bf537/mem_init.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf537/mem_init.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,321 @@
+/*
+ * file:         include/asm-blackfin/mach-bf537/mem_init.h
+ * based on:
+ * author:
+ *
+ * created:
+ * description:
+ *	Memory MAP
+ * rev:
+ *
+ * modified:
+ *
+ *
+ * bugs:         enter bugs at http://blackfin.uclinux.org/
+ *
+ * this program is free software; you can redistribute it and/or modify
+ * it under the terms of the gnu general public license as published by
+ * the free software foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * this program is distributed in the hope that it will be useful,
+ * but without any warranty; without even the implied warranty of
+ * merchantability or fitness for a particular purpose.  see the
+ * gnu general public license for more details.
+ *
+ * you should have received a copy of the gnu general public license
+ * along with this program; see the file copying.
+ * if not, write to the free software foundation,
+ * 59 temple place - suite 330, boston, ma 02111-1307, usa.
+ */
+
+#if ( CONFIG_MEM_MT48LC16M16A2TG_75  ||  CONFIG_MEM_MT48LC64M4A2FB_7E  || CONFIG_MEM_MT48LC16M8A2TG_75 || CONFIG_MEM_GENERIC_BOARD)
+#if ( CONFIG_SCLK_HZ > 119402985 )
+#define SDRAM_tRP       TRP_2
+#define SDRAM_tRP_num   2
+#define SDRAM_tRAS      TRAS_7
+#define SDRAM_tRAS_num  7
+#define SDRAM_tRCD      TRCD_2
+#define SDRAM_tWR       TWR_2
+#endif
+#if ( CONFIG_SCLK_HZ > 104477612 ) && ( CONFIG_SCLK_HZ <= 119402985 )
+#define SDRAM_tRP       TRP_2
+#define SDRAM_tRP_num   2
+#define SDRAM_tRAS      TRAS_6
+#define SDRAM_tRAS_num  6
+#define SDRAM_tRCD      TRCD_2
+#define SDRAM_tWR       TWR_2
+#endif
+#if ( CONFIG_SCLK_HZ >  89552239 ) && ( CONFIG_SCLK_HZ <= 104477612 )
+#define SDRAM_tRP       TRP_2
+#define SDRAM_tRP_num   2
+#define SDRAM_tRAS      TRAS_5
+#define SDRAM_tRAS_num  5
+#define SDRAM_tRCD      TRCD_2
+#define SDRAM_tWR       TWR_2
+#endif
+#if ( CONFIG_SCLK_HZ >  74626866 ) && ( CONFIG_SCLK_HZ <=  89552239 )
+#define SDRAM_tRP       TRP_2
+#define SDRAM_tRP_num   2
+#define SDRAM_tRAS      TRAS_4
+#define SDRAM_tRAS_num  4
+#define SDRAM_tRCD      TRCD_2
+#define SDRAM_tWR       TWR_2
+#endif
+#if ( CONFIG_SCLK_HZ >  66666667 ) && ( CONFIG_SCLK_HZ <= 74626866 )
+#define SDRAM_tRP       TRP_2
+#define SDRAM_tRP_num   2
+#define SDRAM_tRAS      TRAS_3
+#define SDRAM_tRAS_num  3
+#define SDRAM_tRCD      TRCD_2
+#define SDRAM_tWR       TWR_2
+#endif
+#if ( CONFIG_SCLK_HZ >  59701493 ) && ( CONFIG_SCLK_HZ <= 66666667 )
+#define SDRAM_tRP       TRP_1
+#define SDRAM_tRP_num   1
+#define SDRAM_tRAS      TRAS_4
+#define SDRAM_tRAS_num  3
+#define SDRAM_tRCD      TRCD_1
+#define SDRAM_tWR       TWR_2
+#endif
+#if ( CONFIG_SCLK_HZ >  44776119 ) && ( CONFIG_SCLK_HZ <=  59701493 )
+#define SDRAM_tRP       TRP_1
+#define SDRAM_tRP_num   1
+#define SDRAM_tRAS      TRAS_3
+#define SDRAM_tRAS_num  3
+#define SDRAM_tRCD      TRCD_1
+#define SDRAM_tWR       TWR_2
+#endif
+#if ( CONFIG_SCLK_HZ >  29850746 ) && ( CONFIG_SCLK_HZ <=  44776119 )
+#define SDRAM_tRP       TRP_1
+#define SDRAM_tRP_num   1
+#define SDRAM_tRAS      TRAS_2
+#define SDRAM_tRAS_num  2
+#define SDRAM_tRCD      TRCD_1
+#define SDRAM_tWR       TWR_2
+#endif
+#if ( CONFIG_SCLK_HZ <=  29850746 )
+#define SDRAM_tRP       TRP_1
+#define SDRAM_tRP_num   1
+#define SDRAM_tRAS      TRAS_1
+#define SDRAM_tRAS_num  1
+#define SDRAM_tRCD      TRCD_1
+#define SDRAM_tWR       TWR_2
+#endif
+#endif
+
+#if (CONFIG_MEM_MT48LC16M16A2TG_75)
+  /*SDRAM INFORMATION: */
+#define SDRAM_Tref  64		/* Refresh period in milliseconds   */
+#define SDRAM_NRA   8192	/* Number of row addresses in SDRAM */
+#define SDRAM_CL    CL_3
+#endif
+
+#if (CONFIG_MEM_MT48LC16M8A2TG_75)
+  /*SDRAM INFORMATION: */
+#define SDRAM_Tref  64		/* Refresh period in milliseconds   */
+#define SDRAM_NRA   4096	/* Number of row addresses in SDRAM */
+#define SDRAM_CL    CL_3
+#endif
+
+#if (CONFIG_MEM_MT48LC64M4A2FB_7E)
+  /*SDRAM INFORMATION: */
+#define SDRAM_Tref  64		/* Refresh period in milliseconds   */
+#define SDRAM_NRA   8192	/* Number of row addresses in SDRAM */
+#define SDRAM_CL    CL_3
+#endif
+
+#if (CONFIG_MEM_GENERIC_BOARD)
+  /*SDRAM INFORMATION: Modify this for your board */
+#define SDRAM_Tref  64		/* Refresh period in milliseconds   */
+#define SDRAM_NRA   8192	/* Number of row addresses in SDRAM */
+#define SDRAM_CL    CL_3
+#endif
+
+#if ( CONFIG_MEM_SIZE == 128 )
+#define SDRAM_SIZE      EBSZ_128
+#endif
+#if ( CONFIG_MEM_SIZE == 64 )
+#define SDRAM_SIZE      EBSZ_64
+#endif
+#if (  CONFIG_MEM_SIZE == 32 )
+#define SDRAM_SIZE      EBSZ_32
+#endif
+#if ( CONFIG_MEM_SIZE == 16 )
+#define SDRAM_SIZE      EBSZ_16
+#endif
+#if ( CONFIG_MEM_ADD_WIDTH == 11 )
+#define SDRAM_WIDTH     EBCAW_11
+#endif
+#if ( CONFIG_MEM_ADD_WIDTH == 10 )
+#define SDRAM_WIDTH     EBCAW_10
+#endif
+#if ( CONFIG_MEM_ADD_WIDTH == 9 )
+#define SDRAM_WIDTH     EBCAW_9
+#endif
+#if ( CONFIG_MEM_ADD_WIDTH == 8 )
+#define SDRAM_WIDTH     EBCAW_8
+#endif
+
+#define mem_SDBCTL      SDRAM_WIDTH | SDRAM_SIZE | EBE
+
+/* Equation from section 17 (p17-46) of BF533 HRM */
+#define mem_SDRRC       ((( CONFIG_SCLK_HZ / 1000) * SDRAM_Tref)  / SDRAM_NRA) - (SDRAM_tRAS_num + SDRAM_tRP_num)
+
+/* Enable SCLK Out */
+#define mem_SDGCTL        ( SCTLE | SDRAM_CL | SDRAM_tRAS | SDRAM_tRP | SDRAM_tRCD | SDRAM_tWR | PSS )
+
+#if defined CONFIG_CLKIN_HALF
+#define CLKIN_HALF       1
+#else
+#define CLKIN_HALF       0
+#endif
+
+#if defined CONFIG_PLL_BYPASS
+#define PLL_BYPASS      1
+#else
+#define PLL_BYPASS       0
+#endif
+
+/***************************************Currently Not Being Used *********************************/
+#define flash_EBIU_AMBCTL_WAT  ( ( CONFIG_FLASH_SPEED_BWAT * 4 )  / ( 4000000000 / CONFIG_SCLK_HZ ) ) + 1
+#define flash_EBIU_AMBCTL_RAT  ( ( CONFIG_FLASH_SPEED_BRAT * 4 )  / ( 4000000000 / CONFIG_SCLK_HZ ) ) + 1
+#define flash_EBIU_AMBCTL_HT   ( ( CONFIG_FLASH_SPEED_BHT  * 4 )  / ( 4000000000 / CONFIG_SCLK_HZ ) )
+#define flash_EBIU_AMBCTL_ST   ( ( CONFIG_FLASH_SPEED_BST  * 4 )  / ( 4000000000 / CONFIG_SCLK_HZ ) ) + 1
+#define flash_EBIU_AMBCTL_TT   ( ( CONFIG_FLASH_SPEED_BTT  * 4 )  / ( 4000000000 / CONFIG_SCLK_HZ ) ) + 1
+
+#if (flash_EBIU_AMBCTL_TT > 3 )
+#define flash_EBIU_AMBCTL0_TT   B0TT_4
+#endif
+#if (flash_EBIU_AMBCTL_TT == 3 )
+#define flash_EBIU_AMBCTL0_TT   B0TT_3
+#endif
+#if (flash_EBIU_AMBCTL_TT == 2 )
+#define flash_EBIU_AMBCTL0_TT   B0TT_2
+#endif
+#if (flash_EBIU_AMBCTL_TT < 2 )
+#define flash_EBIU_AMBCTL0_TT   B0TT_1
+#endif
+
+#if (flash_EBIU_AMBCTL_ST > 3 )
+#define flash_EBIU_AMBCTL0_ST   B0ST_4
+#endif
+#if (flash_EBIU_AMBCTL_ST == 3 )
+#define flash_EBIU_AMBCTL0_ST   B0ST_3
+#endif
+#if (flash_EBIU_AMBCTL_ST == 2 )
+#define flash_EBIU_AMBCTL0_ST   B0ST_2
+#endif
+#if (flash_EBIU_AMBCTL_ST < 2 )
+#define flash_EBIU_AMBCTL0_ST   B0ST_1
+#endif
+
+#if (flash_EBIU_AMBCTL_HT > 2 )
+#define flash_EBIU_AMBCTL0_HT   B0HT_3
+#endif
+#if (flash_EBIU_AMBCTL_HT == 2 )
+#define flash_EBIU_AMBCTL0_HT   B0HT_2
+#endif
+#if (flash_EBIU_AMBCTL_HT == 1 )
+#define flash_EBIU_AMBCTL0_HT   B0HT_1
+#endif
+#if (flash_EBIU_AMBCTL_HT == 0  && CONFIG_FLASH_SPEED_BHT == 0)
+#define flash_EBIU_AMBCTL0_HT   B0HT_0
+#endif
+#if (flash_EBIU_AMBCTL_HT == 0  && CONFIG_FLASH_SPEED_BHT != 0)
+#define flash_EBIU_AMBCTL0_HT   B0HT_1
+#endif
+
+#if (flash_EBIU_AMBCTL_WAT > 14)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_15
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 14)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_14
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 13)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_13
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 12)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_12
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 11)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_11
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 10)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_10
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 9)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_9
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 8)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_8
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 7)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_7
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 6)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_6
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 5)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_5
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 4)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_4
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 3)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_3
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 2)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_2
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 1)
+#define flash_EBIU_AMBCTL0_WAT  B0WAT_1
+#endif
+
+#if (flash_EBIU_AMBCTL_RAT > 14)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_15
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 14)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_14
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 13)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_13
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 12)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_12
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 11)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_11
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 10)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_10
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 9)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_9
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 8)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_8
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 7)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_7
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 6)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_6
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 5)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_5
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 4)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_4
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 3)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_3
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 2)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_2
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 1)
+#define flash_EBIU_AMBCTL0_RAT  B0RAT_1
+#endif
+
+#define flash_EBIU_AMBCTL0  flash_EBIU_AMBCTL0_WAT | flash_EBIU_AMBCTL0_RAT | flash_EBIU_AMBCTL0_HT | flash_EBIU_AMBCTL0_ST | flash_EBIU_AMBCTL0_TT | CONFIG_FLASH_SPEED_RDYEN
Index: git/linux-2.6/include/asm-blackfin/mach-bf537/mem_map.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf537/mem_map.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,144 @@
+/*
+ * Memory MAP
+ * Common header file for blackfin BF537/6/4 of processors.
+ *
+ *
+ */
+/*
+ * file:         include/asm-blackfin/mach-bf537/mem_map.h
+ * based on:
+ * author:
+ *
+ * created:
+ * description:
+ *	Memory MAP
+ * rev:
+ *
+ * modified:
+ *
+ *
+ * bugs:         enter bugs at http://blackfin.uclinux.org/
+ *
+ * this program is free software; you can redistribute it and/or modify
+ * it under the terms of the gnu general public license as published by
+ * the free software foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * this program is distributed in the hope that it will be useful,
+ * but without any warranty; without even the implied warranty of
+ * merchantability or fitness for a particular purpose.  see the
+ * gnu general public license for more details.
+ *
+ * you should have received a copy of the gnu general public license
+ * along with this program; see the file copying.
+ * if not, write to the free software foundation,
+ * 59 temple place - suite 330, boston, ma 02111-1307, usa.
+ */
+
+#ifndef _MEM_MAP_537_H_
+#define _MEM_MAP_537_H_
+
+#define COREMMR_BASE           0xFFE00000	// Core MMRs
+#define SYSMMR_BASE            0xFFC00000	// System MMRs
+
+/* Level 3 SDRAM Memory */
+#define RAM_START		0x1000
+#define RAM_LENGTH		(CONFIG_MEM_SIZE * 1024 * 1024)
+#define RAM_END 		(CONFIG_MEM_SIZE * 1024 * 1024)
+
+/* Async Memory Banks */
+#define ASYNC_BANK3_BASE	0x20300000	// Async Bank 3
+#define ASYNC_BANK3_SIZE	0x00100000	/* 1M */
+#define ASYNC_BANK2_BASE	0x20200000	// Async Bank 2
+#define ASYNC_BANK2_SIZE	0x00100000	/* 1M */
+#define ASYNC_BANK1_BASE	0x20100000	// Async Bank 1
+#define ASYNC_BANK1_SIZE	0x00100000	/* 1M */
+#define ASYNC_BANK0_BASE	0x20000000	// Async Bank 0
+#define ASYNC_BANK0_SIZE	0x00100000	/* 1M */
+
+/* Level 1 Memory */
+
+/* Memory Map for ADSP-BF537 processors */
+
+#ifdef CONFIG_BF537
+#define L1_CODE_START       0xFFA00000
+#define L1_DATA_A_START     0xFF800000
+#define L1_DATA_B_START     0xFF900000
+
+#define L1_CODE_LENGTH      0xC000
+
+#ifdef CONFIG_BLKFIN_DCACHE
+#define DMEM_CNTR (ACACHE_BCACHE | ENDCPLB | PORT_PREF0)
+#define L1_DATA_A_LENGTH      (0x8000 - 0x4000)
+#else
+#define DMEM_CNTR (ASRAM_BSRAM | ENDCPLB | PORT_PREF0)
+#define L1_DATA_A_LENGTH      0x8000
+#endif
+
+#ifdef CONFIG_BLKFIN_DCACHE
+#define L1_DATA_B_LENGTH      (0x8000 - 0x4000)
+#else
+#define L1_DATA_B_LENGTH      0x8000
+#endif
+
+#endif
+
+/* Memory Map for ADSP-BF536 processors */
+
+#ifdef CONFIG_BF536
+#define L1_CODE_START       0xFFA00000
+#define L1_DATA_A_START     0xFF804000
+#define L1_DATA_B_START     0xFF904000
+
+#define L1_CODE_LENGTH      0xC000
+
+#ifdef CONFIG_BLKFIN_DCACHE
+#define DMEM_CNTR (ACACHE_BSRAM | ENDCPLB)
+#define L1_DATA_A_LENGTH      (0x4000 - 0x4000)
+#else
+#define DMEM_CNTR (ASRAM_BSRAM | ENDCPLB)
+#define L1_DATA_A_LENGTH      0x4000
+#endif
+
+#ifdef CONFIG_BLKFIN_DCACHE
+#define L1_DATA_B_LENGTH      (0x4000 - 0x4000)
+#else
+#define L1_DATA_B_LENGTH      0x4000
+#endif
+
+#endif
+
+/* Memory Map for ADSP-BF534 processors */
+
+#ifdef CONFIG_BF534
+#define L1_CODE_START       0xFFA00000
+#define L1_DATA_A_START     0xFF800000
+#define L1_DATA_B_START     0xFF900000
+
+#define L1_CODE_LENGTH      0xC000
+
+#ifdef CONFIG_BLKFIN_DCACHE
+
+#define DMEM_CNTR (ACACHE_BCACHE | ENDCPLB | PORT_PREF0)
+#define L1_DATA_A_LENGTH      (0x8000 - 0x4000)
+#else
+#define DMEM_CNTR (ASRAM_BSRAM | ENDCPLB | PORT_PREF0)
+#define L1_DATA_A_LENGTH      0x8000
+#endif
+#ifdef CONFIG_BLKFIN_DCACHE
+#define L1_DATA_B_LENGTH      (0x8000 - 0x4000)
+
+#else
+#define L1_DATA_B_LENGTH      0x8000
+#endif
+
+#endif
+
+/* Scratch Pad Memory */
+
+#if defined(CONFIG_BF537) || defined(CONFIG_BF536) || defined(CONFIG_BF534)
+#define L1_SCRATCH_START	0xFFB00000
+#define L1_SCRATCH_LENGTH	0x1000
+#endif
+
+#endif				/* _MEM_MAP_537_H_ */
Index: git/linux-2.6/include/asm-blackfin/mach-bf561/bf561.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf561/bf561.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,383 @@
+/*
+ * File:         include/asm-blackfin/mach-bf561/defBF561.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ * SYSTEM MMR REGISTER AND MEMORY MAP FOR ADSP-BF561
+ * Rev:
+ *
+ * Modified:
+ * HH Tech China
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef __ADSPLPBLACKFIN__
+#ifndef _BLKFin_H_
+#define _BLKFin_H_
+
+#include <linux/config.h>
+
+#define SUPPORTED_DSPID		0x300
+
+#define OFFSET_( x ) ((x) & 0x0000FFFF) /* define macro for offset */
+#define L1_ISRAM		0xFFA00000
+#define L1_ISRAM_END		0xFFA04000
+#define DATA_BANKA_SRAM		0xFF800000
+#define DATA_BANKA_SRAM_END	0xFF804000
+#define DATA_BANKB_SRAM		0xFF900000
+#define DATA_BANKB_SRAM_END	0xFF904000
+#define L1_DSRAMA		0xFF800000
+#define L1_DSRAMA_END		0xFF804000
+#define L1_DSRAMB		0xFF900000
+#define L1_DSRAMB_END		0xFF904000
+#define L2_SRAM			0xFEB00000
+#define L2_SRAM_END		0xFEB20000
+#define AMB_FLASH		0x20000000
+#define AMB_FLASH_END		0x21000000
+#define AMB_FLASH_LENGTH	0x01000000
+#define L1_ISRAM_LENGTH		0x4000
+#define L1_DSRAMA_LENGTH	0x4000
+#define L1_DSRAMB_LENGTH	0x4000
+#define L2_SRAM_LENGTH		0x20000
+
+/*some misc defines*/
+#define IMASK_IVG15		0x8000
+#define IMASK_IVG14		0x4000
+#define IMASK_IVG13		0x2000
+#define IMASK_IVG12		0x1000
+
+#define IMASK_IVG11		0x0800
+#define IMASK_IVG10		0x0400
+#define IMASK_IVG9		0x0200
+#define IMASK_IVG8		0x0100
+
+#define IMASK_IVG7		0x0080
+#define IMASK_IVGTMR		0x0040
+#define IMASK_IVGHW		0x0020
+
+/***************************
+ * Blackfin Cache setup
+ */
+
+#define BLKFIN_ICACHESIZE	(16*1024)
+#define BLKFIN_DCACHESIZE	(32*1024)
+
+#define BLKFIN_ISUBBANKS	4
+#define BLKFIN_IWAYS		4
+#define BLKFIN_ILINES		32
+
+#define BLKFIN_DSUPBANKS	2
+#define BLKFIN_DSUBBANKS	4
+#define BLKFIN_DWAYS		2
+#define BLKFIN_DLINES		64
+
+#define WAY0_L			0x1
+#define WAY1_L			0x2
+#define WAY01_L			0x3
+#define WAY2_L			0x4
+#define WAY02_L			0x5
+#define	WAY12_L			0x6
+#define	WAY012_L		0x7
+
+#define	WAY3_L			0x8
+#define	WAY03_L			0x9
+#define	WAY13_L			0xA
+#define	WAY013_L		0xB
+
+#define	WAY32_L			0xC
+#define	WAY320_L		0xD
+#define	WAY321_L		0xE
+#define	WAYALL_L		0xF
+
+#define DMC_ENABLE (2<<2)	/*yes, 2, not 1 */
+
+/* IAR0 BIT FIELDS */
+#define	PLL_WAKEUP_BIT		0xFFFFFFFF
+#define	DMA1_ERROR_BIT		0xFFFFFF0F
+#define	DMA2_ERROR_BIT		0xFFFFF0FF
+#define IMDMA_ERROR_BIT		0xFFFF0FFF
+#define	PPI1_ERROR_BIT		0xFFF0FFFF
+#define	PPI2_ERROR_BIT		0xFF0FFFFF
+#define	SPORT0_ERROR_BIT	0xF0FFFFFF
+#define	SPORT1_ERROR_BIT	0x0FFFFFFF
+/* IAR1 BIT FIELDS */
+#define	SPI_ERROR_BIT		0xFFFFFFFF
+#define	UART_ERROR_BIT		0xFFFFFF0F
+#define RESERVED_ERROR_BIT	0xFFFFF0FF
+#define	DMA1_0_BIT		0xFFFF0FFF
+#define	DMA1_1_BIT		0xFFF0FFFF
+#define	DMA1_2_BIT		0xFF0FFFFF
+#define	DMA1_3_BIT		0xF0FFFFFF
+#define	DMA1_4_BIT		0x0FFFFFFF
+/* IAR2 BIT FIELDS */
+#define	DMA1_5_BIT		0xFFFFFFFF
+#define	DMA1_6_BIT		0xFFFFFF0F
+#define	DMA1_7_BIT		0xFFFFF0FF
+#define	DMA1_8_BIT		0xFFFF0FFF
+#define	DMA1_9_BIT		0xFFF0FFFF
+#define	DMA1_10_BIT		0xFF0FFFFF
+#define	DMA1_11_BIT		0xF0FFFFFF
+#define	DMA2_0_BIT		0x0FFFFFFF
+/* IAR3 BIT FIELDS */
+#define	DMA2_1_BIT		0xFFFFFFFF
+#define	DMA2_2_BIT		0xFFFFFF0F
+#define	DMA2_3_BIT		0xFFFFF0FF
+#define	DMA2_4_BIT		0xFFFF0FFF
+#define	DMA2_5_BIT		0xFFF0FFFF
+#define	DMA2_6_BIT		0xFF0FFFFF
+#define	DMA2_7_BIT		0xF0FFFFFF
+#define	DMA2_8_BIT		0x0FFFFFFF
+/* IAR4 BIT FIELDS */
+#define	DMA2_9_BIT		0xFFFFFFFF
+#define	DMA2_10_BIT             0xFFFFFF0F
+#define	DMA2_11_BIT             0xFFFFF0FF
+#define TIMER0_BIT	        0xFFFF0FFF
+#define TIMER1_BIT              0xFFF0FFFF
+#define TIMER2_BIT              0xFF0FFFFF
+#define TIMER3_BIT              0xF0FFFFFF
+#define TIMER4_BIT              0x0FFFFFFF
+/* IAR5 BIT FIELDS */
+#define TIMER5_BIT		0xFFFFFFFF
+#define TIMER6_BIT              0xFFFFFF0F
+#define TIMER7_BIT              0xFFFFF0FF
+#define TIMER8_BIT              0xFFFF0FFF
+#define TIMER9_BIT              0xFFF0FFFF
+#define TIMER10_BIT             0xFF0FFFFF
+#define TIMER11_BIT             0xF0FFFFFF
+#define	PROG0_INTA_BIT	        0x0FFFFFFF
+/* IAR6 BIT FIELDS */
+#define	PROG0_INTB_BIT		0xFFFFFFFF
+#define	PROG1_INTA_BIT          0xFFFFFF0F
+#define	PROG1_INTB_BIT          0xFFFFF0FF
+#define	PROG2_INTA_BIT          0xFFFF0FFF
+#define	PROG2_INTB_BIT          0xFFF0FFFF
+#define DMA1_WRRD0_BIT          0xFF0FFFFF
+#define DMA1_WRRD1_BIT          0xF0FFFFFF
+#define DMA2_WRRD0_BIT          0x0FFFFFFF
+/* IAR7 BIT FIELDS */
+#define DMA2_WRRD1_BIT		0xFFFFFFFF
+#define IMDMA_WRRD0_BIT         0xFFFFFF0F
+#define IMDMA_WRRD1_BIT         0xFFFFF0FF
+#define	WATCH_BIT	        0xFFFF0FFF
+#define RESERVED_1_BIT	        0xFFF0FFFF
+#define RESERVED_2_BIT	        0xFF0FFFFF
+#define SUPPLE_0_BIT	        0xF0FFFFFF
+#define SUPPLE_1_BIT	        0x0FFFFFFF
+
+/* Miscellaneous Values */
+#define ZERO			0x0
+
+#ifdef	CONFIG_HHBF
+#define RAM_LENGTH		(CONFIG_MEM_SIZE * 1024 * 1024)
+#define RAM_END			0x02000000	/* 0x04000000 */
+#endif				/* comment by mhfan */
+
+/****************************** EBIU Settings ********************************/
+#define AMBCTL0VAL	((CONFIG_BANK_1 << 16) | CONFIG_BANK_0)
+#define AMBCTL1VAL	((CONFIG_BANK_3 << 16) | CONFIG_BANK_2)
+
+#if (CONFIG_C_AMBEN_ALL)
+#define V_AMBEN AMBEN_ALL
+#endif
+#if (CONFIG_C_AMBEN)
+#define V_AMBEN 0x0
+#endif
+#if (CONFIG_C_AMBEN_B0)
+#define V_AMBEN AMBEN_B0
+#endif
+#if (CONFIG_C_AMBEN_B0_B1)
+#define V_AMBEN AMBEN_B0_B1
+#endif
+#if (CONFIG_C_AMBEN_B0_B1_B2)
+#define V_AMBEN AMBEN_B0_B1_B2
+#endif
+#if (CONFIG_C_AMCKEN)
+#define V_AMCKEN AMCKEN
+#else
+#define V_AMCKEN 0x0
+#endif
+#if (CONFIG_C_B0PEN)
+#define V_B0PEN 0x10
+#else
+#define V_B0PEN 0x00
+#endif
+#if (CONFIG_C_B1PEN)
+#define V_B1PEN 0x20
+#else
+#define V_B1PEN 0x00
+#endif
+#if (CONFIG_C_B2PEN)
+#define V_B2PEN 0x40
+#else
+#define V_B2PEN 0x00
+#endif
+#if (CONFIG_C_B3PEN)
+#define V_B3PEN 0x80
+#else
+#define V_B3PEN 0x00
+#endif
+#if (CONFIG_C_CDPRIO)
+#define V_CDPRIO 0x100
+#else
+#define V_CDPRIO 0x0
+#endif
+
+#define AMGCTLVAL	(V_AMBEN | V_AMCKEN | V_CDPRIO | V_B0PEN | V_B1PEN | V_B2PEN | V_B3PEN | 0x0002)
+
+/******************************* PLL Settings ********************************/
+#if CONFIG_BFIN_KERNEL_CLOCK
+#if (CONFIG_VCO_MULT < 0)
+#error "VCO Multiplier is less than 0. Please select a different value"
+#endif
+
+#if (CONFIG_VCO_MULT == 0)
+#error "VCO Multiplier should be greater than 0. Please select a different value"
+#endif
+
+#if(CONFIG_CLKIN_HALF == 0)
+#define CONFIG_VCO_HZ	(CONFIG_CLKIN_HZ * CONFIG_VCO_MULT)
+#else
+#define CONFIG_VCO_HZ	((CONFIG_CLKIN_HZ * CONFIG_VCO_MULT)/2)
+#endif
+
+#if(CONFIG_PLL_BYPASS == 0)
+#define CONFIG_CCLK_HZ	(CONFIG_VCO_HZ/CONFIG_CCLK_DIV)
+#define CONFIG_SCLK_HZ	(CONFIG_VCO_HZ/CONFIG_SCLK_DIV)
+#else
+#define CONFIG_CCLK_HZ	CONFIG_CLKIN_HZ
+#define CONFIG_SCLK_HZ	CONFIG_CLKIN_HZ
+#endif
+
+#if (CONFIG_SCLK_DIV < 1)
+#error "SCLK DIV cannot be less than 1 or more than 15. Please select a proper value"
+#endif
+
+#if (CONFIG_SCLK_DIV > 15)
+#error "SCLK DIV cannot be less than 1 or more than 15. Please select a proper value"
+#endif
+
+#if (CONFIG_CCLK_DIV != 1)
+#if (CONFIG_CCLK_DIV != 2)
+#if (CONFIG_CCLK_DIV != 4)
+#if (CONFIG_CCLK_DIV != 8)
+#error "CCLK DIV can be 1,2,4 or 8 only.Please select a proper value"
+#endif
+#endif
+#endif
+#endif
+
+#define MAX_VC	600000000
+
+#if(CONFIG_VCO_HZ > MAX_VC)
+#error "VCO selected is more than maximum value. Please change the VCO multipler"
+#endif
+
+#if (CONFIG_SCLK_HZ > 133000000)
+#error "Sclk value selected is more than maximum.Please select a proper value for SCLK multiplier"
+#endif
+
+#if (CONFIG_SCLK_HZ < 27000000)
+#error "Sclk value selected is less than minimum.Please select a proper value for SCLK multiplier"
+#endif
+
+#if (CONFIG_SCLK_HZ >= CONFIG_CCLK_HZ)
+#if(CONFIG_SCLK_HZ != CONFIG_CLKIN_HZ)
+#if(CONFIG_CCLK_HZ != CONFIG_CLKIN_HZ)
+#error "Please select sclk less than cclk"
+#endif
+#endif
+#endif
+
+#if (CONFIG_CCLK_DIV == 1)
+#define CONFIG_CCLK_ACT_DIV   CCLK_DIV1
+#endif
+#if (CONFIG_CCLK_DIV == 2)
+#define CONFIG_CCLK_ACT_DIV   CCLK_DIV2
+#endif
+#if (CONFIG_CCLK_DIV == 4)
+#define CONFIG_CCLK_ACT_DIV   CCLK_DIV4
+#endif
+#if (CONFIG_CCLK_DIV == 8)
+#define CONFIG_CCLK_ACT_DIV   CCLK_DIV8
+#endif
+#ifndef CONFIG_CCLK_ACT_DIV
+#define CONFIG_CCLK_ACT_DIV   CONFIG_CCLK_DIV_not_defined_properly
+#endif
+
+#endif /* CONFIG_BFIN_KERNEL_CLOCK */
+
+#ifdef CONFIG_BF561
+#define CPU "BF561"
+#endif
+#ifndef CPU
+#define CPU "UNKOWN"
+#endif
+
+#if (CONFIG_MEM_SIZE % 4)
+	#error "SDRAM memory size must be a multiple of 4MB!"
+#endif
+
+
+#define SDRAM_IGENERIC	(CPLB_L1_CHBL | CPLB_USER_RD | CPLB_VALID | CPLB_PORTPRIO)
+#define SDRAM_IKERNEL	(SDRAM_IGENERIC | CPLB_LOCK)
+#define L1_IMEMORY	(CPLB_USER_RD | CPLB_VALID | CPLB_LOCK)
+#define SDRAM_INON_CHBL	(CPLB_USER_RD | CPLB_VALID)
+
+#define ANOMALY_05000158	0x200
+#ifdef CONFIG_BLKFIN_WB
+#define SDRAM_DGENERIC	(CPLB_L1_CHBL | CPLB_DIRTY | CPLB_SUPV_WR | CPLB_USER_WR | CPLB_USER_RD | CPLB_VALID | ANOMALY_05000158)
+#else
+#define SDRAM_DGENERIC	(CPLB_L1_CHBL | CPLB_WT | CPLB_L1_AOW | CPLB_SUPV_WR | CPLB_USER_WR | CPLB_USER_RD | CPLB_VALID | ANOMALY_05000158)
+#endif
+#define SDRAM_DKERNEL	(SDRAM_DGENERIC | CPLB_LOCK)
+
+#define L1_DMEMORY	(CPLB_SUPV_WR | CPLB_USER_WR | CPLB_USER_RD | CPLB_VALID | ANOMALY_05000158)
+#define SDRAM_DNON_CHBL	(CPLB_SUPV_WR | CPLB_USER_WR | CPLB_USER_RD | CPLB_VALID | ANOMALY_05000158)
+#define SDRAM_EBIU	(CPLB_SUPV_WR | CPLB_USER_WR | CPLB_USER_RD | CPLB_VALID | ANOMALY_05000158)
+#define SDRAM_OOPS	(CPLB_VALID | ANOMALY_05000158)
+
+#define SIZE_1K 0x00000400
+#define SIZE_4K	0x00001000
+#define SIZE_1M 0x00100000
+#define SIZE_4M 0x00400000
+
+#if 0 	/* comment by mhfan */
+/* Event Vector Table Address */
+#define EVT_EMULATION_ADDR      0xffe02000
+#define EVT_RESET_ADDR          0xffe02004
+#define EVT_NMI_ADDR            0xffe02008
+#define EVT_EXCEPTION_ADDR      0xffe0200c
+#define EVT_GLOBAL_INT_ENB_ADDR 0xffe02010
+#define EVT_HARDWARE_ERROR_ADDR 0xffe02014
+#define EVT_TIMER_ADDR          0xffe02018
+#define EVT_IVG7_ADDR           0xffe0201c
+#define EVT_IVG8_ADDR           0xffe02020
+#define EVT_IVG9_ADDR           0xffe02024
+#define EVT_IVG10_ADDR          0xffe02028
+#define EVT_IVG11_ADDR          0xffe0202c
+#define EVT_IVG12_ADDR          0xffe02030
+#define EVT_IVG13_ADDR          0xffe02034
+#define EVT_IVG14_ADDR          0xffe02038
+#define EVT_IVG15_ADDR          0xffe0203c
+#define EVT_OVERRIDE_ADDR       0xffe02100
+#endif				/* comment by mhfan */
+
+#endif				/* _BLKFin_H_  */
+#endif				/* !defined __ADSPLPBLACKFIN__ */
Index: git/linux-2.6/include/asm-blackfin/mach-bf561/blackfin.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf561/blackfin.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,47 @@
+/*
+ * Common header file for blackfin family of processors.
+ *
+ */
+/*
+ * File:         include/asm-blackfin/mach-bf561/blackfin.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MACH_BLACKFIN_H_
+#define _MACH_BLACKFIN_H_
+
+#include "bf561.h"
+#include "mem_map.h"
+#include "defBF561.h"
+
+#if !(defined(__ASSEMBLY__) || defined(ASSEMBLY))
+#include "cdefBF561.h"
+#endif
+
+#endif				/* _MACH_BLACKFIN_H_ */
Index: git/linux-2.6/include/asm-blackfin/mach-bf561/cdefBF561.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf561/cdefBF561.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,807 @@
+
+/*  */
+/*
+ * File:         include/asm-blackfin/mach-bf561/cdefBF561.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ * C POINTERS TO SYSTEM MMR REGISTER AND MEMORY MAP FOR ADSP-BF561
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _CDEF_BF561_H
+#define _CDEF_BF561_H
+
+/*
+#if !defined(__ADSPBF561__)
+#warning cdefBF561.h should only be included for BF561 chip.
+#endif
+*/
+/* include all Core registers and bit definitions */
+#include "defBF561.h"
+
+/*include core specific register pointer definitions*/
+#include <asm/mach-common/cdef_LPBlackfin.h>
+
+/*********************************************************************************** */
+/* System MMR Register Map */
+/*********************************************************************************** */
+
+/* Clock and System Control (0xFFC00000 - 0xFFC000FF) */
+#define pPLL_CTL (volatile unsigned short *)PLL_CTL
+#define pPLL_DIV (volatile unsigned short *)PLL_DIV
+#define pVR_CTL (volatile unsigned short *)VR_CTL
+#define pPLL_STAT (volatile unsigned short *)PLL_STAT
+#define pPLL_LOCKCNT (volatile unsigned short *)PLL_LOCKCNT
+
+/* System Reset and Interrupt Controller registers for core A (0xFFC0 0100-0xFFC0 01FF) */
+#define pSICA_SWRST (volatile unsigned short *)SICA_SWRST
+#define pSICA_SYSCR (volatile unsigned short *)SICA_SYSCR
+#define pSICA_RVECT (volatile unsigned short *)SICA_RVECT
+#define pSICA_IMASK (volatile unsigned long *)SICA_IMASK
+#define pSICA_IMASK0 (volatile unsigned long *)SICA_IMASK0
+#define pSICA_IMASK1 (volatile unsigned long *)SICA_IMASK1
+#define pSICA_IAR0 ((volatile unsigned long *)SICA_IAR0)
+#define pSICA_IAR1 (volatile unsigned long *)SICA_IAR1
+#define pSICA_IAR2 (volatile unsigned long *)SICA_IAR2
+#define pSICA_IAR3 (volatile unsigned long *)SICA_IAR3
+#define pSICA_IAR4 (volatile unsigned long *)SICA_IAR4
+#define pSICA_IAR5 (volatile unsigned long *)SICA_IAR5
+#define pSICA_IAR6 (volatile unsigned long *)SICA_IAR6
+#define pSICA_IAR7 (volatile unsigned long *)SICA_IAR7
+#define pSICA_ISR0 (volatile unsigned long *)SICA_ISR0
+#define pSICA_ISR1 (volatile unsigned long *)SICA_ISR1
+#define pSICA_IWR0 (volatile unsigned long *)SICA_IWR0
+#define pSICA_IWR1 (volatile unsigned long *)SICA_IWR1
+
+/* System Reset and Interrupt Controller registers for Core B (0xFFC0 1100-0xFFC0 11FF) */
+#define pSICB_SWRST (volatile unsigned short *)SICB_SWRST
+#define pSICB_SYSCR (volatile unsigned short *)SICB_SYSCR
+#define pSICB_RVECT (volatile unsigned short *)SICB_RVECT
+#define pSICB_IMASK0 (volatile unsigned long *)SICB_IMASK0
+#define pSICB_IMASK1 (volatile unsigned long *)SICB_IMASK1
+#define pSICB_IAR0 (volatile unsigned long *)SICB_IAR0
+#define pSICB_IAR1 (volatile unsigned long *)SICB_IAR1
+#define pSICB_IAR2 (volatile unsigned long *)SICB_IAR2
+#define pSICB_IAR3 (volatile unsigned long *)SICB_IAR3
+#define pSICB_IAR4 (volatile unsigned long *)SICB_IAR4
+#define pSICB_IAR5 (volatile unsigned long *)SICB_IAR5
+#define pSICB_IAR6 (volatile unsigned long *)SICB_IAR6
+#define pSICB_IAR7 (volatile unsigned long *)SICB_IAR7
+#define pSICB_ISR0 (volatile unsigned long *)SICB_ISR0
+#define pSICB_ISR1 (volatile unsigned long *)SICB_ISR1
+#define pSICB_IWR0 (volatile unsigned long *)SICB_IWR0
+#define pSICB_IWR1 (volatile unsigned long *)SICB_IWR1
+/* Watchdog Timer registers for Core A (0xFFC0 0200-0xFFC0 02FF) */
+#define pWDOGA_CTL (volatile unsigned short *)WDOGA_CTL
+#define pWDOGA_CNT (volatile unsigned long *)WDOGA_CNT
+#define pWDOGA_STAT (volatile unsigned long *)WDOGA_STAT
+
+/* Watchdog Timer registers for Core B (0xFFC0 1200-0xFFC0 12FF) */
+#define pWDOGB_CTL (volatile unsigned short *)WDOGB_CTL
+#define pWDOGB_CNT (volatile unsigned long *)WDOGB_CNT
+#define pWDOGB_STAT (volatile unsigned long *)WDOGB_STAT
+
+/* UART Controller (0xFFC00400 - 0xFFC004FF) */
+#define pUART_THR (volatile unsigned short *)UART_THR
+#define pUART_RBR (volatile unsigned short *)UART_RBR
+#define pUART_DLL (volatile unsigned short *)UART_DLL
+#define pUART_IER (volatile unsigned short *)UART_IER
+#define pUART_DLH (volatile unsigned short *)UART_DLH
+#define pUART_IIR (volatile unsigned short *)UART_IIR
+#define pUART_LCR (volatile unsigned short *)UART_LCR
+#define pUART_MCR (volatile unsigned short *)UART_MCR
+#define pUART_LSR (volatile unsigned short *)UART_LSR
+#define pUART_MSR (volatile unsigned short *)UART_MSR
+#define pUART_SCR (volatile unsigned short *)UART_SCR
+#define pUART_GCTL (volatile unsigned short *)UART_GCTL
+
+/* SPI Controller (0xFFC00500 - 0xFFC005FF) */
+#define pSPI_CTL (volatile unsigned short *)SPI_CTL
+#define pSPI_FLG (volatile unsigned short *)SPI_FLG
+#define pSPI_STAT (volatile unsigned short *)SPI_STAT
+#define pSPI_TDBR (volatile unsigned short *)SPI_TDBR
+#define pSPI_RDBR (volatile unsigned short *)SPI_RDBR
+#define pSPI_BAUD (volatile unsigned short *)SPI_BAUD
+#define pSPI_SHADOW (volatile unsigned short *)SPI_SHADOW
+
+/* Timer 0-7 registers (0xFFC0 0600-0xFFC0 06FF) */
+#define pTIMER0_CONFIG (volatile unsigned short *)TIMER0_CONFIG
+#define pTIMER0_COUNTER (volatile unsigned long *)TIMER0_COUNTER
+#define pTIMER0_PERIOD (volatile unsigned long *)TIMER0_PERIOD
+#define pTIMER0_WIDTH (volatile unsigned long *)TIMER0_WIDTH
+#define pTIMER1_CONFIG (volatile unsigned short *)TIMER1_CONFIG
+#define pTIMER1_COUNTER (volatile unsigned long *)TIMER1_COUNTER
+#define pTIMER1_PERIOD (volatile unsigned long *)TIMER1_PERIOD
+#define pTIMER1_WIDTH (volatile unsigned long *)TIMER1_WIDTH
+#define pTIMER2_CONFIG (volatile unsigned short *)TIMER2_CONFIG
+#define pTIMER2_COUNTER (volatile unsigned long *)TIMER2_COUNTER
+#define pTIMER2_PERIOD (volatile unsigned long *)TIMER2_PERIOD
+#define pTIMER2_WIDTH (volatile unsigned long *)TIMER2_WIDTH
+#define pTIMER3_CONFIG (volatile unsigned short *)TIMER3_CONFIG
+#define pTIMER3_COUNTER (volatile unsigned long *)TIMER3_COUNTER
+#define pTIMER3_PERIOD (volatile unsigned long *)TIMER3_PERIOD
+#define pTIMER3_WIDTH (volatile unsigned long *)TIMER3_WIDTH
+#define pTIMER4_CONFIG (volatile unsigned short *)TIMER4_CONFIG
+#define pTIMER4_COUNTER (volatile unsigned long *)TIMER4_COUNTER
+#define pTIMER4_PERIOD (volatile unsigned long *)TIMER4_PERIOD
+#define pTIMER4_WIDTH (volatile unsigned long *)TIMER4_WIDTH
+#define pTIMER5_CONFIG (volatile unsigned short *)TIMER5_CONFIG
+#define pTIMER5_COUNTER (volatile unsigned long *)TIMER5_COUNTER
+#define pTIMER5_PERIOD (volatile unsigned long *)TIMER5_PERIOD
+#define pTIMER5_WIDTH (volatile unsigned long *)TIMER5_WIDTH
+#define pTIMER6_CONFIG (volatile unsigned short *)TIMER6_CONFIG
+#define pTIMER6_COUNTER (volatile unsigned long *)TIMER6_COUNTER
+#define pTIMER6_PERIOD (volatile unsigned long *)TIMER6_PERIOD
+#define pTIMER6_WIDTH (volatile unsigned long *)TIMER6_WIDTH
+#define pTIMER7_CONFIG (volatile unsigned short *)TIMER7_CONFIG
+#define pTIMER7_COUNTER (volatile unsigned long *)TIMER7_COUNTER
+#define pTIMER7_PERIOD (volatile unsigned long *)TIMER7_PERIOD
+#define pTIMER7_WIDTH (volatile unsigned long *)TIMER7_WIDTH
+
+/* Timer registers 8-11 (0xFFC0 1600-0xFFC0 16FF) */
+#define pTMRS8_ENABLE (volatile unsigned short *)TMRS8_ENABLE
+#define pTMRS8_DISABLE (volatile unsigned short *)TMRS8_DISABLE
+#define pTMRS8_STATUS (volatile unsigned long *)TMRS8_STATUS
+#define pTIMER8_CONFIG (volatile unsigned short *)TIMER8_CONFIG
+#define pTIMER8_COUNTER (volatile unsigned long *)TIMER8_COUNTER
+#define pTIMER8_PERIOD (volatile unsigned long *)TIMER8_PERIOD
+#define pTIMER8_WIDTH (volatile unsigned long *)TIMER8_WIDTH
+#define pTIMER9_CONFIG (volatile unsigned short *)TIMER9_CONFIG
+#define pTIMER9_COUNTER (volatile unsigned long *)TIMER9_COUNTER
+#define pTIMER9_PERIOD (volatile unsigned long *)TIMER9_PERIOD
+#define pTIMER9_WIDTH (volatile unsigned long *)TIMER9_WIDTH
+#define pTIMER10_CONFIG (volatile unsigned short *)TIMER10_CONFIG
+#define pTIMER10_COUNTER (volatile unsigned long *)TIMER10_COUNTER
+#define pTIMER10_PERIOD (volatile unsigned long *)TIMER10_PERIOD
+#define pTIMER10_WIDTH (volatile unsigned long *)TIMER10_WIDTH
+#define pTIMER11_CONFIG (volatile unsigned short *)TIMER11_CONFIG
+#define pTIMER11_COUNTER (volatile unsigned long *)TIMER11_COUNTER
+#define pTIMER11_PERIOD (volatile unsigned long *)TIMER11_PERIOD
+#define pTIMER11_WIDTH (volatile unsigned long *)TIMER11_WIDTH
+#define pTMRS4_ENABLE (volatile unsigned short *)TMRS4_ENABLE
+#define pTMRS4_DISABLE (volatile unsigned short *)TMRS4_DISABLE
+#define pTMRS4_STATUS (volatile unsigned long *)TMRS4_STATUS
+
+/* Programmable Flag 0 registers (0xFFC0 0700-0xFFC0 07FF) */
+#define pFIO0_FLAG_D (volatile unsigned short *)FIO0_FLAG_D
+#define pFIO0_FLAG_C (volatile unsigned short *)FIO0_FLAG_C
+#define pFIO0_FLAG_S (volatile unsigned short *)FIO0_FLAG_S
+#define pFIO0_FLAG_T (volatile unsigned short *)FIO0_FLAG_T
+#define pFIO0_MASKA_D (volatile unsigned short *)FIO0_MASKA_D
+#define pFIO0_MASKA_C ((volatile unsigned short *)FIO0_MASKA_C)
+#define pFIO0_MASKA_S ((volatile unsigned short *)FIO0_MASKA_S)
+#define pFIO0_MASKA_T (volatile unsigned short *)FIO0_MASKA_T
+#define pFIO0_MASKB_D (volatile unsigned short *)FIO0_MASKB_D
+#define pFIO0_MASKB_C (volatile unsigned short *)FIO0_MASKB_C
+#define pFIO0_MASKB_S (volatile unsigned short *)FIO0_MASKB_S
+#define pFIO0_MASKB_T (volatile unsigned short *)FIO0_MASKB_T
+#define pFIO0_DIR (volatile unsigned short *)FIO0_DIR
+#define pFIO0_POLAR (volatile unsigned short *)FIO0_POLAR
+#define pFIO0_EDGE (volatile unsigned short *)FIO0_EDGE
+#define pFIO0_BOTH (volatile unsigned short *)FIO0_BOTH
+#define pFIO0_INEN (volatile unsigned short *)FIO0_INEN
+/* Programmable Flag 1 registers (0xFFC0 1500-0xFFC0 15FF) */
+#define pFIO1_FLAG_D (volatile unsigned short *)FIO1_FLAG_D
+#define pFIO1_FLAG_C (volatile unsigned short *)FIO1_FLAG_C
+#define pFIO1_FLAG_S (volatile unsigned short *)FIO1_FLAG_S
+#define pFIO1_FLAG_T (volatile unsigned short *)FIO1_FLAG_T
+#define pFIO1_MASKA_D (volatile unsigned short *)FIO1_MASKA_D
+#define pFIO1_MASKA_C (volatile unsigned short *)FIO1_MASKA_C
+#define pFIO1_MASKA_S (volatile unsigned short *)FIO1_MASKA_S
+#define pFIO1_MASKA_T (volatile unsigned short *)FIO1_MASKA_T
+#define pFIO1_MASKB_D (volatile unsigned short *)FIO1_MASKB_D
+#define pFIO1_MASKB_C (volatile unsigned short *)FIO1_MASKB_C
+#define pFIO1_MASKB_S (volatile unsigned short *)FIO1_MASKB_S
+#define pFIO1_MASKB_T (volatile unsigned short *)FIO1_MASKB_T
+#define pFIO1_DIR (volatile unsigned short *)FIO1_DIR
+#define pFIO1_POLAR (volatile unsigned short *)FIO1_POLAR
+#define pFIO1_EDGE (volatile unsigned short *)FIO1_EDGE
+#define pFIO1_BOTH (volatile unsigned short *)FIO1_BOTH
+#define pFIO1_INEN (volatile unsigned short *)FIO1_INEN
+/* Programmable Flag registers (0xFFC0 1700-0xFFC0 17FF) */
+#define pFIO2_FLAG_D (volatile unsigned short *)FIO2_FLAG_D
+#define pFIO2_FLAG_C (volatile unsigned short *)FIO2_FLAG_C
+#define pFIO2_FLAG_S (volatile unsigned short *)FIO2_FLAG_S
+#define pFIO2_FLAG_T (volatile unsigned short *)FIO2_FLAG_T
+#define pFIO2_MASKA_D (volatile unsigned short *)FIO2_MASKA_D
+#define pFIO2_MASKA_C (volatile unsigned short *)FIO2_MASKA_C
+#define pFIO2_MASKA_S (volatile unsigned short *)FIO2_MASKA_S
+#define pFIO2_MASKA_T (volatile unsigned short *)FIO2_MASKA_T
+#define pFIO2_MASKB_D (volatile unsigned short *)FIO2_MASKB_D
+#define pFIO2_MASKB_C (volatile unsigned short *)FIO2_MASKB_C
+#define pFIO2_MASKB_S (volatile unsigned short *)FIO2_MASKB_S
+#define pFIO2_MASKB_T (volatile unsigned short *)FIO2_MASKB_T
+#define pFIO2_DIR (volatile unsigned short *)FIO2_DIR
+#define pFIO2_POLAR (volatile unsigned short *)FIO2_POLAR
+#define pFIO2_EDGE (volatile unsigned short *)FIO2_EDGE
+#define pFIO2_BOTH (volatile unsigned short *)FIO2_BOTH
+#define pFIO2_INEN (volatile unsigned short *)FIO2_INEN
+/* SPORT0 Controller (0xFFC00800 - 0xFFC008FF) */
+#define pSPORT0_TCR1 (volatile unsigned short *)SPORT0_TCR1
+#define pSPORT0_TCR2 (volatile unsigned short *)SPORT0_TCR2
+#define pSPORT0_TCLKDIV (volatile unsigned short *)SPORT0_TCLKDIV
+#define pSPORT0_TFSDIV (volatile unsigned short *)SPORT0_TFSDIV
+#define pSPORT0_TX (volatile unsigned long *)SPORT0_TX
+#define pSPORT0_RX (volatile unsigned long *)SPORT0_RX
+#define pSPORT0_TX32 ((volatile long *)SPORT0_TX)
+#define pSPORT0_RX32 ((volatile long *)SPORT0_RX)
+#define pSPORT0_TX16 ((volatile unsigned short *)SPORT0_TX)
+#define pSPORT0_RX16 ((volatile unsigned short *)SPORT0_RX)
+#define pSPORT0_RCR1 (volatile unsigned short *)SPORT0_RCR1
+#define pSPORT0_RCR2 (volatile unsigned short *)SPORT0_RCR2
+#define pSPORT0_RCLKDIV (volatile unsigned short *)SPORT0_RCLKDIV
+#define pSPORT0_RFSDIV (volatile unsigned short *)SPORT0_RFSDIV
+#define pSPORT0_STAT (volatile unsigned short *)SPORT0_STAT
+#define pSPORT0_CHNL (volatile unsigned short *)SPORT0_CHNL
+#define pSPORT0_MCMC1 (volatile unsigned short *)SPORT0_MCMC1
+#define pSPORT0_MCMC2 (volatile unsigned short *)SPORT0_MCMC2
+#define pSPORT0_MTCS0 (volatile unsigned long *)SPORT0_MTCS0
+#define pSPORT0_MTCS1 (volatile unsigned long *)SPORT0_MTCS1
+#define pSPORT0_MTCS2 (volatile unsigned long *)SPORT0_MTCS2
+#define pSPORT0_MTCS3 (volatile unsigned long *)SPORT0_MTCS3
+#define pSPORT0_MRCS0 (volatile unsigned long *)SPORT0_MRCS0
+#define pSPORT0_MRCS1 (volatile unsigned long *)SPORT0_MRCS1
+#define pSPORT0_MRCS2 (volatile unsigned long *)SPORT0_MRCS2
+#define pSPORT0_MRCS3 (volatile unsigned long *)SPORT0_MRCS3
+/* SPORT1 Controller (0xFFC00900 - 0xFFC009FF) */
+#define pSPORT1_TCR1 (volatile unsigned short *)SPORT1_TCR1
+#define pSPORT1_TCR2 (volatile unsigned short *)SPORT1_TCR2
+#define pSPORT1_TCLKDIV (volatile unsigned short *)SPORT1_TCLKDIV
+#define pSPORT1_TFSDIV (volatile unsigned short *)SPORT1_TFSDIV
+#define pSPORT1_TX (volatile unsigned long *)SPORT1_TX
+#define pSPORT1_RX (volatile unsigned long *)SPORT1_RX
+#define pSPORT1_TX32 ((volatile long *)SPORT1_TX)
+#define pSPORT1_RX32 ((volatile long *)SPORT1_RX)
+#define pSPORT1_TX16 ((volatile unsigned short *)SPORT1_TX)
+#define pSPORT1_RX16 ((volatile unsigned short *)SPORT1_RX)
+#define pSPORT1_RCR1 (volatile unsigned short *)SPORT1_RCR1
+#define pSPORT1_RCR2 (volatile unsigned short *)SPORT1_RCR2
+#define pSPORT1_RCLKDIV (volatile unsigned short *)SPORT1_RCLKDIV
+#define pSPORT1_RFSDIV (volatile unsigned short *)SPORT1_RFSDIV
+#define pSPORT1_STAT (volatile unsigned short *)SPORT1_STAT
+#define pSPORT1_CHNL (volatile unsigned short *)SPORT1_CHNL
+#define pSPORT1_MCMC1 (volatile unsigned short *)SPORT1_MCMC1
+#define pSPORT1_MCMC2 (volatile unsigned short *)SPORT1_MCMC2
+#define pSPORT1_MTCS0 (volatile unsigned long *)SPORT1_MTCS0
+#define pSPORT1_MTCS1 (volatile unsigned long *)SPORT1_MTCS1
+#define pSPORT1_MTCS2 (volatile unsigned long *)SPORT1_MTCS2
+#define pSPORT1_MTCS3 (volatile unsigned long *)SPORT1_MTCS3
+#define pSPORT1_MRCS0 (volatile unsigned long *)SPORT1_MRCS0
+#define pSPORT1_MRCS1 (volatile unsigned long *)SPORT1_MRCS1
+#define pSPORT1_MRCS2 (volatile unsigned long *)SPORT1_MRCS2
+#define pSPORT1_MRCS3 (volatile unsigned long *)SPORT1_MRCS3
+/* Asynchronous Memory Controller - External Bus Interface Unit */
+#define pEBIU_AMGCTL (volatile unsigned short *)EBIU_AMGCTL
+#define pEBIU_AMBCTL0 (volatile unsigned long *)EBIU_AMBCTL0
+#define pEBIU_AMBCTL1 (volatile unsigned long *)EBIU_AMBCTL1
+/* SDRAM Controller External Bus Interface Unit (0xFFC00A00 - 0xFFC00AFF) */
+#define pEBIU_SDGCTL (volatile unsigned long *)EBIU_SDGCTL
+#define pEBIU_SDBCTL (volatile unsigned long *)EBIU_SDBCTL
+#define pEBIU_SDRRC (volatile unsigned short *)EBIU_SDRRC
+#define pEBIU_SDSTAT (volatile unsigned short *)EBIU_SDSTAT
+/* Parallel Peripheral Interface (PPI) 0 registers (0xFFC0 1000-0xFFC0 10FF) */
+#define pPPI0_CONTROL (volatile unsigned short *)PPI0_CONTROL
+#define pPPI0_STATUS (volatile unsigned short *)PPI0_STATUS
+#define pPPI0_COUNT (volatile unsigned short *)PPI0_COUNT
+#define pPPI0_DELAY (volatile unsigned short *)PPI0_DELAY
+#define pPPI0_FRAME (volatile unsigned short *)PPI0_FRAME
+/* Parallel Peripheral Interface (PPI) 1 registers (0xFFC0 1300-0xFFC0 13FF) */
+#define pPPI1_CONTROL (volatile unsigned short *)PPI1_CONTROL
+#define pPPI1_STATUS (volatile unsigned short *)PPI1_STATUS
+#define pPPI1_COUNT (volatile unsigned short *)PPI1_COUNT
+#define pPPI1_DELAY (volatile unsigned short *)PPI1_DELAY
+#define pPPI1_FRAME (volatile unsigned short *)PPI1_FRAME
+/*DMA traffic control registers */
+#define pDMA1_TC_PER (volatile unsigned short *)DMA1_TC_PER
+#define pDMA1_TC_CNT (volatile unsigned short *)DMA1_TC_CNT
+#define pDMA2_TC_PER (volatile unsigned short *)DMA2_TC_PER
+#define pDMA2_TC_CNT (volatile unsigned short *)DMA2_TC_CNT
+/* DMA1 Controller registers (0xFFC0 1C00-0xFFC0 1FFF) */
+#define pDMA1_0_CONFIG (volatile unsigned short *)DMA1_0_CONFIG
+#define pDMA1_0_NEXT_DESC_PTR (volatile void **)DMA1_0_NEXT_DESC_PTR
+#define pDMA1_0_START_ADDR (volatile void **)DMA1_0_START_ADDR
+#define pDMA1_0_X_COUNT (volatile unsigned short *)DMA1_0_X_COUNT
+#define pDMA1_0_Y_COUNT (volatile unsigned short *)DMA1_0_Y_COUNT
+#define pDMA1_0_X_MODIFY (volatile signed short *)DMA1_0_X_MODIFY
+#define pDMA1_0_Y_MODIFY (volatile signed short *)DMA1_0_Y_MODIFY
+#define pDMA1_0_CURR_DESC_PTR (volatile void **)DMA1_0_CURR_DESC_PTR
+#define pDMA1_0_CURR_ADDR (volatile void **)DMA1_0_CURR_ADDR
+#define pDMA1_0_CURR_X_COUNT (volatile unsigned short *)DMA1_0_CURR_X_COUNT
+#define pDMA1_0_CURR_Y_COUNT (volatile unsigned short *)DMA1_0_CURR_Y_COUNT
+#define pDMA1_0_IRQ_STATUS (volatile unsigned short *)DMA1_0_IRQ_STATUS
+#define pDMA1_0_PERIPHERAL_MAP (volatile unsigned short *)DMA1_0_PERIPHERAL_MAP
+#define pDMA1_1_CONFIG (volatile unsigned short *)DMA1_1_CONFIG
+#define pDMA1_1_NEXT_DESC_PTR (volatile void **)DMA1_1_NEXT_DESC_PTR
+#define pDMA1_1_START_ADDR (volatile void **)DMA1_1_START_ADDR
+#define pDMA1_1_X_COUNT (volatile unsigned short *)DMA1_1_X_COUNT
+#define pDMA1_1_Y_COUNT (volatile unsigned short *)DMA1_1_Y_COUNT
+#define pDMA1_1_X_MODIFY (volatile signed short *)DMA1_1_X_MODIFY
+#define pDMA1_1_Y_MODIFY (volatile signed short *)DMA1_1_Y_MODIFY
+#define pDMA1_1_CURR_DESC_PTR (volatile void **)DMA1_1_CURR_DESC_PTR
+#define pDMA1_1_CURR_ADDR (volatile void **)DMA1_1_CURR_ADDR
+#define pDMA1_1_CURR_X_COUNT (volatile unsigned short *)DMA1_1_CURR_X_COUNT
+#define pDMA1_1_CURR_Y_COUNT (volatile unsigned short *)DMA1_1_CURR_Y_COUNT
+#define pDMA1_1_IRQ_STATUS (volatile unsigned short *)DMA1_1_IRQ_STATUS
+#define pDMA1_1_PERIPHERAL_MAP (volatile unsigned short *)DMA1_1_PERIPHERAL_MAP
+#define pDMA1_2_CONFIG (volatile unsigned short *)DMA1_2_CONFIG
+#define pDMA1_2_NEXT_DESC_PTR (volatile void **)DMA1_2_NEXT_DESC_PTR
+#define pDMA1_2_START_ADDR (volatile void **)DMA1_2_START_ADDR
+#define pDMA1_2_X_COUNT (volatile unsigned short *)DMA1_2_X_COUNT
+#define pDMA1_2_Y_COUNT (volatile unsigned short *)DMA1_2_Y_COUNT
+#define pDMA1_2_X_MODIFY (volatile signed short *)DMA1_2_X_MODIFY
+#define pDMA1_2_Y_MODIFY (volatile signed short *)DMA1_2_Y_MODIFY
+#define pDMA1_2_CURR_DESC_PTR (volatile void **)DMA1_2_CURR_DESC_PTR
+#define pDMA1_2_CURR_ADDR (volatile void **)DMA1_2_CURR_ADDR
+#define pDMA1_2_CURR_X_COUNT (volatile unsigned short *)DMA1_2_CURR_X_COUNT
+#define pDMA1_2_CURR_Y_COUNT (volatile unsigned short *)DMA1_2_CURR_Y_COUNT
+#define pDMA1_2_IRQ_STATUS (volatile unsigned short *)DMA1_2_IRQ_STATUS
+#define pDMA1_2_PERIPHERAL_MAP (volatile unsigned short *)DMA1_2_PERIPHERAL_MAP
+#define pDMA1_3_CONFIG (volatile unsigned short *)DMA1_3_CONFIG
+#define pDMA1_3_NEXT_DESC_PTR (volatile void **)DMA1_3_NEXT_DESC_PTR
+#define pDMA1_3_START_ADDR (volatile void **)DMA1_3_START_ADDR
+#define pDMA1_3_X_COUNT (volatile unsigned short *)DMA1_3_X_COUNT
+#define pDMA1_3_Y_COUNT (volatile unsigned short *)DMA1_3_Y_COUNT
+#define pDMA1_3_X_MODIFY (volatile signed short *)DMA1_3_X_MODIFY
+#define pDMA1_3_Y_MODIFY (volatile signed short *)DMA1_3_Y_MODIFY
+#define pDMA1_3_CURR_DESC_PTR (volatile void **)DMA1_3_CURR_DESC_PTR
+#define pDMA1_3_CURR_ADDR (volatile void **)DMA1_3_CURR_ADDR
+#define pDMA1_3_CURR_X_COUNT (volatile unsigned short *)DMA1_3_CURR_X_COUNT
+#define pDMA1_3_CURR_Y_COUNT (volatile unsigned short *)DMA1_3_CURR_Y_COUNT
+#define pDMA1_3_IRQ_STATUS (volatile unsigned short *)DMA1_3_IRQ_STATUS
+#define pDMA1_3_PERIPHERAL_MAP (volatile unsigned short *)DMA1_3_PERIPHERAL_MAP
+#define pDMA1_4_CONFIG (volatile unsigned short *)DMA1_4_CONFIG
+#define pDMA1_4_NEXT_DESC_PTR (volatile void **)DMA1_4_NEXT_DESC_PTR
+#define pDMA1_4_START_ADDR (volatile void **)DMA1_4_START_ADDR
+#define pDMA1_4_X_COUNT (volatile unsigned short *)DMA1_4_X_COUNT
+#define pDMA1_4_Y_COUNT (volatile unsigned short *)DMA1_4_Y_COUNT
+#define pDMA1_4_X_MODIFY (volatile signed short *)DMA1_4_X_MODIFY
+#define pDMA1_4_Y_MODIFY (volatile signed short *)DMA1_4_Y_MODIFY
+#define pDMA1_4_CURR_DESC_PTR (volatile void **)DMA1_4_CURR_DESC_PTR
+#define pDMA1_4_CURR_ADDR (volatile void **)DMA1_4_CURR_ADDR
+#define pDMA1_4_CURR_X_COUNT (volatile unsigned short *)DMA1_4_CURR_X_COUNT
+#define pDMA1_4_CURR_Y_COUNT (volatile unsigned short *)DMA1_4_CURR_Y_COUNT
+#define pDMA1_4_IRQ_STATUS (volatile unsigned short *)DMA1_4_IRQ_STATUS
+#define pDMA1_4_PERIPHERAL_MAP (volatile unsigned short *)DMA1_4_PERIPHERAL_MAP
+#define pDMA1_5_CONFIG (volatile unsigned short *)DMA1_5_CONFIG
+#define pDMA1_5_NEXT_DESC_PTR (volatile void **)DMA1_5_NEXT_DESC_PTR
+#define pDMA1_5_START_ADDR (volatile void **)DMA1_5_START_ADDR
+#define pDMA1_5_X_COUNT (volatile unsigned short *)DMA1_5_X_COUNT
+#define pDMA1_5_Y_COUNT (volatile unsigned short *)DMA1_5_Y_COUNT
+#define pDMA1_5_X_MODIFY (volatile signed short *)DMA1_5_X_MODIFY
+#define pDMA1_5_Y_MODIFY (volatile signed short *)DMA1_5_Y_MODIFY
+#define pDMA1_5_CURR_DESC_PTR (volatile void **)DMA1_5_CURR_DESC_PTR
+#define pDMA1_5_CURR_ADDR (volatile void **)DMA1_5_CURR_ADDR
+#define pDMA1_5_CURR_X_COUNT (volatile unsigned short *)DMA1_5_CURR_X_COUNT
+#define pDMA1_5_CURR_Y_COUNT (volatile unsigned short *)DMA1_5_CURR_Y_COUNT
+#define pDMA1_5_IRQ_STATUS (volatile unsigned short *)DMA1_5_IRQ_STATUS
+#define pDMA1_5_PERIPHERAL_MAP (volatile unsigned short *)DMA1_5_PERIPHERAL_MAP
+#define pDMA1_6_CONFIG (volatile unsigned short *)DMA1_6_CONFIG
+#define pDMA1_6_NEXT_DESC_PTR (volatile void **)DMA1_6_NEXT_DESC_PTR
+#define pDMA1_6_START_ADDR (volatile void **)DMA1_6_START_ADDR
+#define pDMA1_6_X_COUNT (volatile unsigned short *)DMA1_6_X_COUNT
+#define pDMA1_6_Y_COUNT (volatile unsigned short *)DMA1_6_Y_COUNT
+#define pDMA1_6_X_MODIFY (volatile signed short *)DMA1_6_X_MODIFY
+#define pDMA1_6_Y_MODIFY (volatile signed short *)DMA1_6_Y_MODIFY
+#define pDMA1_6_CURR_DESC_PTR (volatile void **)DMA1_6_CURR_DESC_PTR
+#define pDMA1_6_CURR_ADDR (volatile void **)DMA1_6_CURR_ADDR
+#define pDMA1_6_CURR_X_COUNT (volatile unsigned short *)DMA1_6_CURR_X_COUNT
+#define pDMA1_6_CURR_Y_COUNT (volatile unsigned short *)DMA1_6_CURR_Y_COUNT
+#define pDMA1_6_IRQ_STATUS (volatile unsigned short *)DMA1_6_IRQ_STATUS
+#define pDMA1_6_PERIPHERAL_MAP (volatile unsigned short *)DMA1_6_PERIPHERAL_MAP
+#define pDMA1_7_CONFIG (volatile unsigned short *)DMA1_7_CONFIG
+#define pDMA1_7_NEXT_DESC_PTR (volatile void **)DMA1_7_NEXT_DESC_PTR
+#define pDMA1_7_START_ADDR (volatile void **)DMA1_7_START_ADDR
+#define pDMA1_7_X_COUNT (volatile unsigned short *)DMA1_7_X_COUNT
+#define pDMA1_7_Y_COUNT (volatile unsigned short *)DMA1_7_Y_COUNT
+#define pDMA1_7_X_MODIFY (volatile signed short *)DMA1_7_X_MODIFY
+#define pDMA1_7_Y_MODIFY (volatile signed short *)DMA1_7_Y_MODIFY
+#define pDMA1_7_CURR_DESC_PTR (volatile void **)DMA1_7_CURR_DESC_PTR
+#define pDMA1_7_CURR_ADDR (volatile void **)DMA1_7_CURR_ADDR
+#define pDMA1_7_CURR_X_COUNT (volatile unsigned short *)DMA1_7_CURR_X_COUNT
+#define pDMA1_7_CURR_Y_COUNT (volatile unsigned short *)DMA1_7_CURR_Y_COUNT
+#define pDMA1_7_IRQ_STATUS (volatile unsigned short *)DMA1_7_IRQ_STATUS
+#define pDMA1_7_PERIPHERAL_MAP (volatile unsigned short *)DMA1_7_PERIPHERAL_MAP
+#define pDMA1_8_CONFIG (volatile unsigned short *)DMA1_8_CONFIG
+#define pDMA1_8_NEXT_DESC_PTR (volatile void **)DMA1_8_NEXT_DESC_PTR
+#define pDMA1_8_START_ADDR (volatile void **)DMA1_8_START_ADDR
+#define pDMA1_8_X_COUNT (volatile unsigned short *)DMA1_8_X_COUNT
+#define pDMA1_8_Y_COUNT (volatile unsigned short *)DMA1_8_Y_COUNT
+#define pDMA1_8_X_MODIFY (volatile signed short *)DMA1_8_X_MODIFY
+#define pDMA1_8_Y_MODIFY (volatile signed short *)DMA1_8_Y_MODIFY
+#define pDMA1_8_CURR_DESC_PTR (volatile void **)DMA1_8_CURR_DESC_PTR
+#define pDMA1_8_CURR_ADDR (volatile void **)DMA1_8_CURR_ADDR
+#define pDMA1_8_CURR_X_COUNT (volatile unsigned short *)DMA1_8_CURR_X_COUNT
+#define pDMA1_8_CURR_Y_COUNT (volatile unsigned short *)DMA1_8_CURR_Y_COUNT
+#define pDMA1_8_IRQ_STATUS (volatile unsigned short *)DMA1_8_IRQ_STATUS
+#define pDMA1_8_PERIPHERAL_MAP (volatile unsigned short *)DMA1_8_PERIPHERAL_MAP
+#define pDMA1_9_CONFIG (volatile unsigned short *)DMA1_9_CONFIG
+#define pDMA1_9_NEXT_DESC_PTR (volatile void **)DMA1_9_NEXT_DESC_PTR
+#define pDMA1_9_START_ADDR (volatile void **)DMA1_9_START_ADDR
+#define pDMA1_9_X_COUNT (volatile unsigned short *)DMA1_9_X_COUNT
+#define pDMA1_9_Y_COUNT (volatile unsigned short *)DMA1_9_Y_COUNT
+#define pDMA1_9_X_MODIFY (volatile signed short *)DMA1_9_X_MODIFY
+#define pDMA1_9_Y_MODIFY (volatile signed short *)DMA1_9_Y_MODIFY
+#define pDMA1_9_CURR_DESC_PTR (volatile void **)DMA1_9_CURR_DESC_PTR
+#define pDMA1_9_CURR_ADDR (volatile void **)DMA1_9_CURR_ADDR
+#define pDMA1_9_CURR_X_COUNT (volatile unsigned short *)DMA1_9_CURR_X_COUNT
+#define pDMA1_9_CURR_Y_COUNT (volatile unsigned short *)DMA1_9_CURR_Y_COUNT
+#define pDMA1_9_IRQ_STATUS (volatile unsigned short *)DMA1_9_IRQ_STATUS
+#define pDMA1_9_PERIPHERAL_MAP (volatile unsigned short *)DMA1_9_PERIPHERAL_MAP
+#define pDMA1_10_CONFIG (volatile unsigned short *)DMA1_10_CONFIG
+#define pDMA1_10_NEXT_DESC_PTR (volatile void **)DMA1_10_NEXT_DESC_PTR
+#define pDMA1_10_START_ADDR (volatile void **)DMA1_10_START_ADDR
+#define pDMA1_10_X_COUNT (volatile unsigned short *)DMA1_10_X_COUNT
+#define pDMA1_10_Y_COUNT (volatile unsigned short *)DMA1_10_Y_COUNT
+#define pDMA1_10_X_MODIFY (volatile signed short *)DMA1_10_X_MODIFY
+#define pDMA1_10_Y_MODIFY (volatile signed short *)DMA1_10_Y_MODIFY
+#define pDMA1_10_CURR_DESC_PTR (volatile void **)DMA1_10_CURR_DESC_PTR
+#define pDMA1_10_CURR_ADDR (volatile void **)DMA1_10_CURR_ADDR
+#define pDMA1_10_CURR_X_COUNT (volatile unsigned short *)DMA1_10_CURR_X_COUNT
+#define pDMA1_10_CURR_Y_COUNT (volatile unsigned short *)DMA1_10_CURR_Y_COUNT
+#define pDMA1_10_IRQ_STATUS (volatile unsigned short *)DMA1_10_IRQ_STATUS
+#define pDMA1_10_PERIPHERAL_MAP (volatile unsigned short *)DMA1_10_PERIPHERAL_MAP
+#define pDMA1_11_CONFIG (volatile unsigned short *)DMA1_11_CONFIG
+#define pDMA1_11_NEXT_DESC_PTR (volatile void **)DMA1_11_NEXT_DESC_PTR
+#define pDMA1_11_START_ADDR (volatile void **)DMA1_11_START_ADDR
+#define pDMA1_11_X_COUNT (volatile unsigned short *)DMA1_11_X_COUNT
+#define pDMA1_11_Y_COUNT (volatile unsigned short *)DMA1_11_Y_COUNT
+#define pDMA1_11_X_MODIFY (volatile signed short *)DMA1_11_X_MODIFY
+#define pDMA1_11_Y_MODIFY (volatile signed short *)DMA1_11_Y_MODIFY
+#define pDMA1_11_CURR_DESC_PTR (volatile void **)DMA1_11_CURR_DESC_PTR
+#define pDMA1_11_CURR_ADDR (volatile void **)DMA1_11_CURR_ADDR
+#define pDMA1_11_CURR_X_COUNT (volatile unsigned short *)DMA1_11_CURR_X_COUNT
+#define pDMA1_11_CURR_Y_COUNT (volatile unsigned short *)DMA1_11_CURR_Y_COUNT
+#define pDMA1_11_IRQ_STATUS (volatile unsigned short *)DMA1_11_IRQ_STATUS
+#define pDMA1_11_PERIPHERAL_MAP (volatile unsigned short *)DMA1_11_PERIPHERAL_MAP
+/* Memory DMA1 Controller registers (0xFFC0 1E80-0xFFC0 1FFF) */
+#define pMDMA1_D0_CONFIG (volatile unsigned short *)MDMA1_D0_CONFIG
+#define pMDMA1_D0_NEXT_DESC_PTR (volatile void **)MDMA1_D0_NEXT_DESC_PTR
+#define pMDMA1_D0_START_ADDR (volatile void **)MDMA1_D0_START_ADDR
+#define pMDMA1_D0_X_COUNT (volatile unsigned short *)MDMA1_D0_X_COUNT
+#define pMDMA1_D0_Y_COUNT (volatile unsigned short *)MDMA1_D0_Y_COUNT
+#define pMDMA1_D0_X_MODIFY (volatile signed short *)MDMA1_D0_X_MODIFY
+#define pMDMA1_D0_Y_MODIFY (volatile signed short *)MDMA1_D0_Y_MODIFY
+#define pMDMA1_D0_CURR_DESC_PTR (volatile void **)MDMA1_D0_CURR_DESC_PTR
+#define pMDMA1_D0_CURR_ADDR (volatile void **)MDMA1_D0_CURR_ADDR
+#define pMDMA1_D0_CURR_X_COUNT (volatile unsigned short *)MDMA1_D0_CURR_X_COUNT
+#define pMDMA1_D0_CURR_Y_COUNT (volatile unsigned short *)MDMA1_D0_CURR_Y_COUNT
+#define pMDMA1_D0_IRQ_STATUS (volatile unsigned short *)MDMA1_D0_IRQ_STATUS
+#define pMDMA1_D0_PERIPHERAL_MAP (volatile unsigned short *)MDMA1_D0_PERIPHERAL_MAP
+#define pMDMA1_S0_CONFIG (volatile unsigned short *)MDMA1_S0_CONFIG
+#define pMDMA1_S0_NEXT_DESC_PTR (volatile void **)MDMA1_S0_NEXT_DESC_PTR
+#define pMDMA1_S0_START_ADDR (volatile void **)MDMA1_S0_START_ADDR
+#define pMDMA1_S0_X_COUNT (volatile unsigned short *)MDMA1_S0_X_COUNT
+#define pMDMA1_S0_Y_COUNT (volatile unsigned short *)MDMA1_S0_Y_COUNT
+#define pMDMA1_S0_X_MODIFY (volatile signed short *)MDMA1_S0_X_MODIFY
+#define pMDMA1_S0_Y_MODIFY (volatile signed short *)MDMA1_S0_Y_MODIFY
+#define pMDMA1_S0_CURR_DESC_PTR (volatile void **)MDMA1_S0_CURR_DESC_PTR
+#define pMDMA1_S0_CURR_ADDR (volatile void **)MDMA1_S0_CURR_ADDR
+#define pMDMA1_S0_CURR_X_COUNT (volatile unsigned short *)MDMA1_S0_CURR_X_COUNT
+#define pMDMA1_S0_CURR_Y_COUNT (volatile unsigned short *)MDMA1_S0_CURR_Y_COUNT
+#define pMDMA1_S0_IRQ_STATUS (volatile unsigned short *)MDMA1_S0_IRQ_STATUS
+#define pMDMA1_S0_PERIPHERAL_MAP (volatile unsigned short *)MDMA1_S0_PERIPHERAL_MAP
+#define pMDMA1_D1_CONFIG (volatile unsigned short *)MDMA1_D1_CONFIG
+#define pMDMA1_D1_NEXT_DESC_PTR (volatile void **)MDMA1_D1_NEXT_DESC_PTR
+#define pMDMA1_D1_START_ADDR (volatile void **)MDMA1_D1_START_ADDR
+#define pMDMA1_D1_X_COUNT (volatile unsigned short *)MDMA1_D1_X_COUNT
+#define pMDMA1_D1_Y_COUNT (volatile unsigned short *)MDMA1_D1_Y_COUNT
+#define pMDMA1_D1_X_MODIFY (volatile signed short *)MDMA1_D1_X_MODIFY
+#define pMDMA1_D1_Y_MODIFY (volatile signed short *)MDMA1_D1_Y_MODIFY
+#define pMDMA1_D1_CURR_DESC_PTR (volatile void **)MDMA1_D1_CURR_DESC_PTR
+#define pMDMA1_D1_CURR_ADDR (volatile void **)MDMA1_D1_CURR_ADDR
+#define pMDMA1_D1_CURR_X_COUNT (volatile unsigned short *)MDMA1_D1_CURR_X_COUNT
+#define pMDMA1_D1_CURR_Y_COUNT (volatile unsigned short *)MDMA1_D1_CURR_Y_COUNT
+#define pMDMA1_D1_IRQ_STATUS (volatile unsigned short *)MDMA1_D1_IRQ_STATUS
+#define pMDMA1_D1_PERIPHERAL_MAP (volatile unsigned short *)MDMA1_D1_PERIPHERAL_MAP
+#define pMDMA1_S1_CONFIG (volatile unsigned short *)MDMA1_S1_CONFIG
+#define pMDMA1_S1_NEXT_DESC_PTR (volatile void **)MDMA1_S1_NEXT_DESC_PTR
+#define pMDMA1_S1_START_ADDR (volatile void **)MDMA1_S1_START_ADDR
+#define pMDMA1_S1_X_COUNT (volatile unsigned short *)MDMA1_S1_X_COUNT
+#define pMDMA1_S1_Y_COUNT (volatile unsigned short *)MDMA1_S1_Y_COUNT
+#define pMDMA1_S1_X_MODIFY (volatile signed short *)MDMA1_S1_X_MODIFY
+#define pMDMA1_S1_Y_MODIFY (volatile signed short *)MDMA1_S1_Y_MODIFY
+#define pMDMA1_S1_CURR_DESC_PTR (volatile void **)MDMA1_S1_CURR_DESC_PTR
+#define pMDMA1_S1_CURR_ADDR (volatile void **)MDMA1_S1_CURR_ADDR
+#define pMDMA1_S1_CURR_X_COUNT (volatile unsigned short *)MDMA1_S1_CURR_X_COUNT
+#define pMDMA1_S1_CURR_Y_COUNT (volatile unsigned short *)MDMA1_S1_CURR_Y_COUNT
+#define pMDMA1_S1_IRQ_STATUS (volatile unsigned short *)MDMA1_S1_IRQ_STATUS
+#define pMDMA1_S1_PERIPHERAL_MAP (volatile unsigned short *)MDMA1_S1_PERIPHERAL_MAP
+/* DMA2 Controller registers (0xFFC0 0C00-0xFFC0 0DFF) */
+#define pDMA2_0_CONFIG (volatile unsigned short *)DMA2_0_CONFIG
+#define pDMA2_0_NEXT_DESC_PTR (volatile void **)DMA2_0_NEXT_DESC_PTR
+#define pDMA2_0_START_ADDR (volatile void **)DMA2_0_START_ADDR
+#define pDMA2_0_X_COUNT (volatile unsigned short *)DMA2_0_X_COUNT
+#define pDMA2_0_Y_COUNT (volatile unsigned short *)DMA2_0_Y_COUNT
+#define pDMA2_0_X_MODIFY (volatile signed short *)DMA2_0_X_MODIFY
+#define pDMA2_0_Y_MODIFY (volatile signed short *)DMA2_0_Y_MODIFY
+#define pDMA2_0_CURR_DESC_PTR (volatile void **)DMA2_0_CURR_DESC_PTR
+#define pDMA2_0_CURR_ADDR (volatile void **)DMA2_0_CURR_ADDR
+#define pDMA2_0_CURR_X_COUNT (volatile unsigned short *)DMA2_0_CURR_X_COUNT
+#define pDMA2_0_CURR_Y_COUNT (volatile unsigned short *)DMA2_0_CURR_Y_COUNT
+#define pDMA2_0_IRQ_STATUS (volatile unsigned short *)DMA2_0_IRQ_STATUS
+#define pDMA2_0_PERIPHERAL_MAP (volatile unsigned short *)DMA2_0_PERIPHERAL_MAP
+#define pDMA2_1_CONFIG (volatile unsigned short *)DMA2_1_CONFIG
+#define pDMA2_1_NEXT_DESC_PTR (volatile void **)DMA2_1_NEXT_DESC_PTR
+#define pDMA2_1_START_ADDR (volatile void **)DMA2_1_START_ADDR
+#define pDMA2_1_X_COUNT (volatile unsigned short *)DMA2_1_X_COUNT
+#define pDMA2_1_Y_COUNT (volatile unsigned short *)DMA2_1_Y_COUNT
+#define pDMA2_1_X_MODIFY (volatile signed short *)DMA2_1_X_MODIFY
+#define pDMA2_1_Y_MODIFY (volatile signed short *)DMA2_1_Y_MODIFY
+#define pDMA2_1_CURR_DESC_PTR (volatile void **)DMA2_1_CURR_DESC_PTR
+#define pDMA2_1_CURR_ADDR (volatile void **)DMA2_1_CURR_ADDR
+#define pDMA2_1_CURR_X_COUNT (volatile unsigned short *)DMA2_1_CURR_X_COUNT
+#define pDMA2_1_CURR_Y_COUNT (volatile unsigned short *)DMA2_1_CURR_Y_COUNT
+#define pDMA2_1_IRQ_STATUS (volatile unsigned short *)DMA2_1_IRQ_STATUS
+#define pDMA2_1_PERIPHERAL_MAP (volatile unsigned short *)DMA2_1_PERIPHERAL_MAP
+#define pDMA2_2_CONFIG (volatile unsigned short *)DMA2_2_CONFIG
+#define pDMA2_2_NEXT_DESC_PTR (volatile void **)DMA2_2_NEXT_DESC_PTR
+#define pDMA2_2_START_ADDR (volatile void **)DMA2_2_START_ADDR
+#define pDMA2_2_X_COUNT (volatile unsigned short *)DMA2_2_X_COUNT
+#define pDMA2_2_Y_COUNT (volatile unsigned short *)DMA2_2_Y_COUNT
+#define pDMA2_2_X_MODIFY (volatile signed short *)DMA2_2_X_MODIFY
+#define pDMA2_2_Y_MODIFY (volatile signed short *)DMA2_2_Y_MODIFY
+#define pDMA2_2_CURR_DESC_PTR (volatile void **)DMA2_2_CURR_DESC_PTR
+#define pDMA2_2_CURR_ADDR (volatile void **)DMA2_2_CURR_ADDR
+#define pDMA2_2_CURR_X_COUNT (volatile unsigned short *)DMA2_2_CURR_X_COUNT
+#define pDMA2_2_CURR_Y_COUNT (volatile unsigned short *)DMA2_2_CURR_Y_COUNT
+#define pDMA2_2_IRQ_STATUS (volatile unsigned short *)DMA2_2_IRQ_STATUS
+#define pDMA2_2_PERIPHERAL_MAP (volatile unsigned short *)DMA2_2_PERIPHERAL_MAP
+#define pDMA2_3_CONFIG (volatile unsigned short *)DMA2_3_CONFIG
+#define pDMA2_3_NEXT_DESC_PTR (volatile void **)DMA2_3_NEXT_DESC_PTR
+#define pDMA2_3_START_ADDR (volatile void **)DMA2_3_START_ADDR
+#define pDMA2_3_X_COUNT (volatile unsigned short *)DMA2_3_X_COUNT
+#define pDMA2_3_Y_COUNT (volatile unsigned short *)DMA2_3_Y_COUNT
+#define pDMA2_3_X_MODIFY (volatile signed short *)DMA2_3_X_MODIFY
+#define pDMA2_3_Y_MODIFY (volatile signed short *)DMA2_3_Y_MODIFY
+#define pDMA2_3_CURR_DESC_PTR (volatile void **)DMA2_3_CURR_DESC_PTR
+#define pDMA2_3_CURR_ADDR (volatile void **)DMA2_3_CURR_ADDR
+#define pDMA2_3_CURR_X_COUNT (volatile unsigned short *)DMA2_3_CURR_X_COUNT
+#define pDMA2_3_CURR_Y_COUNT (volatile unsigned short *)DMA2_3_CURR_Y_COUNT
+#define pDMA2_3_IRQ_STATUS (volatile unsigned short *)DMA2_3_IRQ_STATUS
+#define pDMA2_3_PERIPHERAL_MAP (volatile unsigned short *)DMA2_3_PERIPHERAL_MAP
+#define pDMA2_4_CONFIG (volatile unsigned short *)DMA2_4_CONFIG
+#define pDMA2_4_NEXT_DESC_PTR (volatile void **)DMA2_4_NEXT_DESC_PTR
+#define pDMA2_4_START_ADDR (volatile void **)DMA2_4_START_ADDR
+#define pDMA2_4_X_COUNT (volatile unsigned short *)DMA2_4_X_COUNT
+#define pDMA2_4_Y_COUNT (volatile unsigned short *)DMA2_4_Y_COUNT
+#define pDMA2_4_X_MODIFY (volatile signed short *)DMA2_4_X_MODIFY
+#define pDMA2_4_Y_MODIFY (volatile signed short *)DMA2_4_Y_MODIFY
+#define pDMA2_4_CURR_DESC_PTR (volatile void **)DMA2_4_CURR_DESC_PTR
+#define pDMA2_4_CURR_ADDR (volatile void **)DMA2_4_CURR_ADDR
+#define pDMA2_4_CURR_X_COUNT (volatile unsigned short *)DMA2_4_CURR_X_COUNT
+#define pDMA2_4_CURR_Y_COUNT (volatile unsigned short *)DMA2_4_CURR_Y_COUNT
+#define pDMA2_4_IRQ_STATUS (volatile unsigned short *)DMA2_4_IRQ_STATUS
+#define pDMA2_4_PERIPHERAL_MAP (volatile unsigned short *)DMA2_4_PERIPHERAL_MAP
+#define pDMA2_5_CONFIG (volatile unsigned short *)DMA2_5_CONFIG
+#define pDMA2_5_NEXT_DESC_PTR (volatile void **)DMA2_5_NEXT_DESC_PTR
+#define pDMA2_5_START_ADDR (volatile void **)DMA2_5_START_ADDR
+#define pDMA2_5_X_COUNT (volatile unsigned short *)DMA2_5_X_COUNT
+#define pDMA2_5_Y_COUNT (volatile unsigned short *)DMA2_5_Y_COUNT
+#define pDMA2_5_X_MODIFY (volatile signed short *)DMA2_5_X_MODIFY
+#define pDMA2_5_Y_MODIFY (volatile signed short *)DMA2_5_Y_MODIFY
+#define pDMA2_5_CURR_DESC_PTR (volatile void **)DMA2_5_CURR_DESC_PTR
+#define pDMA2_5_CURR_ADDR (volatile void **)DMA2_5_CURR_ADDR
+#define pDMA2_5_CURR_X_COUNT (volatile unsigned short *)DMA2_5_CURR_X_COUNT
+#define pDMA2_5_CURR_Y_COUNT (volatile unsigned short *)DMA2_5_CURR_Y_COUNT
+#define pDMA2_5_IRQ_STATUS (volatile unsigned short *)DMA2_5_IRQ_STATUS
+#define pDMA2_5_PERIPHERAL_MAP (volatile unsigned short *)DMA2_5_PERIPHERAL_MAP
+#define pDMA2_6_CONFIG (volatile unsigned short *)DMA2_6_CONFIG
+#define pDMA2_6_NEXT_DESC_PTR (volatile void **)DMA2_6_NEXT_DESC_PTR
+#define pDMA2_6_START_ADDR (volatile void **)DMA2_6_START_ADDR
+#define pDMA2_6_X_COUNT (volatile unsigned short *)DMA2_6_X_COUNT
+#define pDMA2_6_Y_COUNT (volatile unsigned short *)DMA2_6_Y_COUNT
+#define pDMA2_6_X_MODIFY (volatile signed short *)DMA2_6_X_MODIFY
+#define pDMA2_6_Y_MODIFY (volatile signed short *)DMA2_6_Y_MODIFY
+#define pDMA2_6_CURR_DESC_PTR (volatile void **)DMA2_6_CURR_DESC_PTR
+#define pDMA2_6_CURR_ADDR (volatile void **)DMA2_6_CURR_ADDR
+#define pDMA2_6_CURR_X_COUNT (volatile unsigned short *)DMA2_6_CURR_X_COUNT
+#define pDMA2_6_CURR_Y_COUNT (volatile unsigned short *)DMA2_6_CURR_Y_COUNT
+#define pDMA2_6_IRQ_STATUS (volatile unsigned short *)DMA2_6_IRQ_STATUS
+#define pDMA2_6_PERIPHERAL_MAP (volatile unsigned short *)DMA2_6_PERIPHERAL_MAP
+#define pDMA2_7_CONFIG (volatile unsigned short *)DMA2_7_CONFIG
+#define pDMA2_7_NEXT_DESC_PTR (volatile void **)DMA2_7_NEXT_DESC_PTR
+#define pDMA2_7_START_ADDR (volatile void **)DMA2_7_START_ADDR
+#define pDMA2_7_X_COUNT (volatile unsigned short *)DMA2_7_X_COUNT
+#define pDMA2_7_Y_COUNT (volatile unsigned short *)DMA2_7_Y_COUNT
+#define pDMA2_7_X_MODIFY (volatile signed short *)DMA2_7_X_MODIFY
+#define pDMA2_7_Y_MODIFY (volatile signed short *)DMA2_7_Y_MODIFY
+#define pDMA2_7_CURR_DESC_PTR (volatile void **)DMA2_7_CURR_DESC_PTR
+#define pDMA2_7_CURR_ADDR (volatile void **)DMA2_7_CURR_ADDR
+#define pDMA2_7_CURR_X_COUNT (volatile unsigned short *)DMA2_7_CURR_X_COUNT
+#define pDMA2_7_CURR_Y_COUNT (volatile unsigned short *)DMA2_7_CURR_Y_COUNT
+#define pDMA2_7_IRQ_STATUS (volatile unsigned short *)DMA2_7_IRQ_STATUS
+#define pDMA2_7_PERIPHERAL_MAP (volatile unsigned short *)DMA2_7_PERIPHERAL_MAP
+#define pDMA2_8_CONFIG (volatile unsigned short *)DMA2_8_CONFIG
+#define pDMA2_8_NEXT_DESC_PTR (volatile void **)DMA2_8_NEXT_DESC_PTR
+#define pDMA2_8_START_ADDR (volatile void **)DMA2_8_START_ADDR
+#define pDMA2_8_X_COUNT (volatile unsigned short *)DMA2_8_X_COUNT
+#define pDMA2_8_Y_COUNT (volatile unsigned short *)DMA2_8_Y_COUNT
+#define pDMA2_8_X_MODIFY (volatile signed short *)DMA2_8_X_MODIFY
+#define pDMA2_8_Y_MODIFY (volatile signed short *)DMA2_8_Y_MODIFY
+#define pDMA2_8_CURR_DESC_PTR (volatile void **)DMA2_8_CURR_DESC_PTR
+#define pDMA2_8_CURR_ADDR (volatile void **)DMA2_8_CURR_ADDR
+#define pDMA2_8_CURR_X_COUNT (volatile unsigned short *)DMA2_8_CURR_X_COUNT
+#define pDMA2_8_CURR_Y_COUNT (volatile unsigned short *)DMA2_8_CURR_Y_COUNT
+#define pDMA2_8_IRQ_STATUS (volatile unsigned short *)DMA2_8_IRQ_STATUS
+#define pDMA2_8_PERIPHERAL_MAP (volatile unsigned short *)DMA2_8_PERIPHERAL_MAP
+#define pDMA2_9_CONFIG (volatile unsigned short *)DMA2_9_CONFIG
+#define pDMA2_9_NEXT_DESC_PTR (volatile void **)DMA2_9_NEXT_DESC_PTR
+#define pDMA2_9_START_ADDR (volatile void **)DMA2_9_START_ADDR
+#define pDMA2_9_X_COUNT (volatile unsigned short *)DMA2_9_X_COUNT
+#define pDMA2_9_Y_COUNT (volatile unsigned short *)DMA2_9_Y_COUNT
+#define pDMA2_9_X_MODIFY (volatile signed short *)DMA2_9_X_MODIFY
+#define pDMA2_9_Y_MODIFY (volatile signed short *)DMA2_9_Y_MODIFY
+#define pDMA2_9_CURR_DESC_PTR (volatile void **)DMA2_9_CURR_DESC_PTR
+#define pDMA2_9_CURR_ADDR (volatile void **)DMA2_9_CURR_ADDR
+#define pDMA2_9_CURR_X_COUNT (volatile unsigned short *)DMA2_9_CURR_X_COUNT
+#define pDMA2_9_CURR_Y_COUNT (volatile unsigned short *)DMA2_9_CURR_Y_COUNT
+#define pDMA2_9_IRQ_STATUS (volatile unsigned short *)DMA2_9_IRQ_STATUS
+#define pDMA2_9_PERIPHERAL_MAP (volatile unsigned short *)DMA2_9_PERIPHERAL_MAP
+#define pDMA2_10_CONFIG (volatile unsigned short *)DMA2_10_CONFIG
+#define pDMA2_10_NEXT_DESC_PTR (volatile void **)DMA2_10_NEXT_DESC_PTR
+#define pDMA2_10_START_ADDR (volatile void **)DMA2_10_START_ADDR
+#define pDMA2_10_X_COUNT (volatile unsigned short *)DMA2_10_X_COUNT
+#define pDMA2_10_Y_COUNT (volatile unsigned short *)DMA2_10_Y_COUNT
+#define pDMA2_10_X_MODIFY (volatile signed short *)DMA2_10_X_MODIFY
+#define pDMA2_10_Y_MODIFY (volatile signed short *)DMA2_10_Y_MODIFY
+#define pDMA2_10_CURR_DESC_PTR (volatile void **)DMA2_10_CURR_DESC_PTR
+#define pDMA2_10_CURR_ADDR (volatile void **)DMA2_10_CURR_ADDR
+#define pDMA2_10_CURR_X_COUNT (volatile unsigned short *)DMA2_10_CURR_X_COUNT
+#define pDMA2_10_CURR_Y_COUNT (volatile unsigned short *)DMA2_10_CURR_Y_COUNT
+#define pDMA2_10_IRQ_STATUS (volatile unsigned short *)DMA2_10_IRQ_STATUS
+#define pDMA2_10_PERIPHERAL_MAP (volatile unsigned short *)DMA2_10_PERIPHERAL_MAP
+#define pDMA2_11_CONFIG (volatile unsigned short *)DMA2_11_CONFIG
+#define pDMA2_11_NEXT_DESC_PTR (volatile void **)DMA2_11_NEXT_DESC_PTR
+#define pDMA2_11_START_ADDR (volatile void **)DMA2_11_START_ADDR
+#define pDMA2_11_X_COUNT (volatile unsigned short *)DMA2_11_X_COUNT
+#define pDMA2_11_Y_COUNT (volatile unsigned short *)DMA2_11_Y_COUNT
+#define pDMA2_11_X_MODIFY (volatile signed short *)DMA2_11_X_MODIFY
+#define pDMA2_11_Y_MODIFY (volatile signed short *)DMA2_11_Y_MODIFY
+#define pDMA2_11_CURR_DESC_PTR (volatile void **)DMA2_11_CURR_DESC_PTR
+#define pDMA2_11_CURR_ADDR (volatile void **)DMA2_11_CURR_ADDR
+#define pDMA2_11_CURR_X_COUNT (volatile unsigned short *)DMA2_11_CURR_X_COUNT
+#define pDMA2_11_CURR_Y_COUNT (volatile unsigned short *)DMA2_11_CURR_Y_COUNT
+#define pDMA2_11_IRQ_STATUS (volatile unsigned short *)DMA2_11_IRQ_STATUS
+#define pDMA2_11_PERIPHERAL_MAP (volatile unsigned short *)DMA2_11_PERIPHERAL_MAP
+/* Memory DMA2 Controller registers (0xFFC0 0E80-0xFFC0 0FFF) */
+#define pMDMA2_D0_CONFIG (volatile unsigned short *)MDMA2_D0_CONFIG
+#define pMDMA2_D0_NEXT_DESC_PTR (volatile void **)MDMA2_D0_NEXT_DESC_PTR
+#define pMDMA2_D0_START_ADDR (volatile void **)MDMA2_D0_START_ADDR
+#define pMDMA2_D0_X_COUNT (volatile unsigned short *)MDMA2_D0_X_COUNT
+#define pMDMA2_D0_Y_COUNT (volatile unsigned short *)MDMA2_D0_Y_COUNT
+#define pMDMA2_D0_X_MODIFY (volatile signed short *)MDMA2_D0_X_MODIFY
+#define pMDMA2_D0_Y_MODIFY (volatile signed short *)MDMA2_D0_Y_MODIFY
+#define pMDMA2_D0_CURR_DESC_PTR (volatile void **)MDMA2_D0_CURR_DESC_PTR
+#define pMDMA2_D0_CURR_ADDR (volatile void **)MDMA2_D0_CURR_ADDR
+#define pMDMA2_D0_CURR_X_COUNT (volatile unsigned short *)MDMA2_D0_CURR_X_COUNT
+#define pMDMA2_D0_CURR_Y_COUNT (volatile unsigned short *)MDMA2_D0_CURR_Y_COUNT
+#define pMDMA2_D0_IRQ_STATUS (volatile unsigned short *)MDMA2_D0_IRQ_STATUS
+#define pMDMA2_D0_PERIPHERAL_MAP (volatile unsigned short *)MDMA2_D0_PERIPHERAL_MAP
+#define pMDMA2_S0_CONFIG (volatile unsigned short *)MDMA2_S0_CONFIG
+#define pMDMA2_S0_NEXT_DESC_PTR (volatile void **)MDMA2_S0_NEXT_DESC_PTR
+#define pMDMA2_S0_START_ADDR (volatile void **)MDMA2_S0_START_ADDR
+#define pMDMA2_S0_X_COUNT (volatile unsigned short *)MDMA2_S0_X_COUNT
+#define pMDMA2_S0_Y_COUNT (volatile unsigned short *)MDMA2_S0_Y_COUNT
+#define pMDMA2_S0_X_MODIFY (volatile signed short *)MDMA2_S0_X_MODIFY
+#define pMDMA2_S0_Y_MODIFY (volatile signed short *)MDMA2_S0_Y_MODIFY
+#define pMDMA2_S0_CURR_DESC_PTR (volatile void **)MDMA2_S0_CURR_DESC_PTR
+#define pMDMA2_S0_CURR_ADDR (volatile void **)MDMA2_S0_CURR_ADDR
+#define pMDMA2_S0_CURR_X_COUNT (volatile unsigned short *)MDMA2_S0_CURR_X_COUNT
+#define pMDMA2_S0_CURR_Y_COUNT (volatile unsigned short *)MDMA2_S0_CURR_Y_COUNT
+#define pMDMA2_S0_IRQ_STATUS (volatile unsigned short *)MDMA2_S0_IRQ_STATUS
+#define pMDMA2_S0_PERIPHERAL_MAP (volatile unsigned short *)MDMA2_S0_PERIPHERAL_MAP
+#define pMDMA2_D1_CONFIG (volatile unsigned short *)MDMA2_D1_CONFIG
+#define pMDMA2_D1_NEXT_DESC_PTR (volatile void **)MDMA2_D1_NEXT_DESC_PTR
+#define pMDMA2_D1_START_ADDR (volatile void **)MDMA2_D1_START_ADDR
+#define pMDMA2_D1_X_COUNT (volatile unsigned short *)MDMA2_D1_X_COUNT
+#define pMDMA2_D1_Y_COUNT (volatile unsigned short *)MDMA2_D1_Y_COUNT
+#define pMDMA2_D1_X_MODIFY (volatile signed short *)MDMA2_D1_X_MODIFY
+#define pMDMA2_D1_Y_MODIFY (volatile signed short *)MDMA2_D1_Y_MODIFY
+#define pMDMA2_D1_CURR_DESC_PTR (volatile void **)MDMA2_D1_CURR_DESC_PTR
+#define pMDMA2_D1_CURR_ADDR (volatile void **)MDMA2_D1_CURR_ADDR
+#define pMDMA2_D1_CURR_X_COUNT (volatile unsigned short *)MDMA2_D1_CURR_X_COUNT
+#define pMDMA2_D1_CURR_Y_COUNT (volatile unsigned short *)MDMA2_D1_CURR_Y_COUNT
+#define pMDMA2_D1_IRQ_STATUS (volatile unsigned short *)MDMA2_D1_IRQ_STATUS
+#define pMDMA2_D1_PERIPHERAL_MAP (volatile unsigned short *)MDMA2_D1_PERIPHERAL_MAP
+#define pMDMA2_S1_CONFIG (volatile unsigned short *)MDMA2_S1_CONFIG
+#define pMDMA2_S1_NEXT_DESC_PTR (volatile void **)MDMA2_S1_NEXT_DESC_PTR
+#define pMDMA2_S1_START_ADDR (volatile void **)MDMA2_S1_START_ADDR
+#define pMDMA2_S1_X_COUNT (volatile unsigned short *)MDMA2_S1_X_COUNT
+#define pMDMA2_S1_Y_COUNT (volatile unsigned short *)MDMA2_S1_Y_COUNT
+#define pMDMA2_S1_X_MODIFY (volatile signed short *)MDMA2_S1_X_MODIFY
+#define pMDMA2_S1_Y_MODIFY (volatile signed short *)MDMA2_S1_Y_MODIFY
+#define pMDMA2_S1_CURR_DESC_PTR (volatile void **)MDMA2_S1_CURR_DESC_PTR
+#define pMDMA2_S1_CURR_ADDR (volatile void **)MDMA2_S1_CURR_ADDR
+#define pMDMA2_S1_CURR_X_COUNT (volatile unsigned short *)MDMA2_S1_CURR_X_COUNT
+#define pMDMA2_S1_CURR_Y_COUNT (volatile unsigned short *)MDMA2_S1_CURR_Y_COUNT
+#define pMDMA2_S1_IRQ_STATUS (volatile unsigned short *)MDMA2_S1_IRQ_STATUS
+#define pMDMA2_S1_PERIPHERAL_MAP (volatile unsigned short *)MDMA2_S1_PERIPHERAL_MAP
+/* Internal Memory DMA Registers (0xFFC0_1800 - 0xFFC0_19FF) */
+#define pIMDMA_D0_CONFIG (volatile unsigned short *)IMDMA_D0_CONFIG
+#define pIMDMA_D0_NEXT_DESC_PTR (volatile void **)IMDMA_D0_NEXT_DESC_PTR
+#define pIMDMA_D0_START_ADDR (volatile void **)IMDMA_D0_START_ADDR
+#define pIMDMA_D0_X_COUNT (volatile unsigned short *)IMDMA_D0_X_COUNT
+#define pIMDMA_D0_Y_COUNT (volatile unsigned short *)IMDMA_D0_Y_COUNT
+#define pIMDMA_D0_X_MODIFY (volatile signed short *)IMDMA_D0_X_MODIFY
+#define pIMDMA_D0_Y_MODIFY (volatile signed short *)IMDMA_D0_Y_MODIFY
+#define pIMDMA_D0_CURR_DESC_PTR (volatile void **)IMDMA_D0_CURR_DESC_PTR
+#define pIMDMA_D0_CURR_ADDR (volatile void **)IMDMA_D0_CURR_ADDR
+#define pIMDMA_D0_CURR_X_COUNT (volatile unsigned short *)IMDMA_D0_CURR_X_COUNT
+#define pIMDMA_D0_CURR_Y_COUNT (volatile unsigned short *)IMDMA_D0_CURR_Y_COUNT
+#define pIMDMA_D0_IRQ_STATUS (volatile unsigned short *)IMDMA_D0_IRQ_STATUS
+#define pIMDMA_S0_CONFIG (volatile unsigned short *)IMDMA_S0_CONFIG
+#define pIMDMA_S0_NEXT_DESC_PTR (volatile void **)IMDMA_S0_NEXT_DESC_PTR
+#define pIMDMA_S0_START_ADDR (volatile void **)IMDMA_S0_START_ADDR
+#define pIMDMA_S0_X_COUNT (volatile unsigned short *)IMDMA_S0_X_COUNT
+#define pIMDMA_S0_Y_COUNT (volatile unsigned short *)IMDMA_S0_Y_COUNT
+#define pIMDMA_S0_X_MODIFY (volatile signed short *)IMDMA_S0_X_MODIFY
+#define pIMDMA_S0_Y_MODIFY (volatile signed short *)IMDMA_S0_Y_MODIFY
+#define pIMDMA_S0_CURR_DESC_PTR (volatile void **)IMDMA_S0_CURR_DESC_PTR
+#define pIMDMA_S0_CURR_ADDR (volatile void **)IMDMA_S0_CURR_ADDR
+#define pIMDMA_S0_CURR_X_COUNT (volatile unsigned short *)IMDMA_S0_CURR_X_COUNT
+#define pIMDMA_S0_CURR_Y_COUNT (volatile unsigned short *)IMDMA_S0_CURR_Y_COUNT
+#define pIMDMA_S0_IRQ_STATUS (volatile unsigned short *)IMDMA_S0_IRQ_STATUS
+#define pIMDMA_D1_CONFIG (volatile unsigned short *)IMDMA_D1_CONFIG
+#define pIMDMA_D1_NEXT_DESC_PTR (volatile void **)IMDMA_D1_NEXT_DESC_PTR
+#define pIMDMA_D1_START_ADDR (volatile void **)IMDMA_D1_START_ADDR
+#define pIMDMA_D1_X_COUNT (volatile unsigned short *)IMDMA_D1_X_COUNT
+#define pIMDMA_D1_Y_COUNT (volatile unsigned short *)IMDMA_D1_Y_COUNT
+#define pIMDMA_D1_X_MODIFY (volatile signed short *)IMDMA_D1_X_MODIFY
+#define pIMDMA_D1_Y_MODIFY (volatile signed short *)IMDMA_D1_Y_MODIFY
+#define pIMDMA_D1_CURR_DESC_PTR (volatile void **)IMDMA_D1_CURR_DESC_PTR
+#define pIMDMA_D1_CURR_ADDR (volatile void **)IMDMA_D1_CURR_ADDR
+#define pIMDMA_D1_CURR_X_COUNT (volatile unsigned short *)IMDMA_D1_CURR_X_COUNT
+#define pIMDMA_D1_CURR_Y_COUNT (volatile unsigned short *)IMDMA_D1_CURR_Y_COUNT
+#define pIMDMA_D1_IRQ_STATUS (volatile unsigned short *)IMDMA_D1_IRQ_STATUS
+#define pIMDMA_S1_CONFIG (volatile unsigned short *)IMDMA_S1_CONFIG
+#define pIMDMA_S1_NEXT_DESC_PTR (volatile void **)IMDMA_S1_NEXT_DESC_PTR
+#define pIMDMA_S1_START_ADDR (volatile void **)IMDMA_S1_START_ADDR
+#define pIMDMA_S1_X_COUNT (volatile unsigned short *)IMDMA_S1_X_COUNT
+#define pIMDMA_S1_Y_COUNT (volatile unsigned short *)IMDMA_S1_Y_COUNT
+#define pIMDMA_S1_X_MODIFY (volatile signed short *)IMDMA_S1_X_MODIFY
+#define pIMDMA_S1_Y_MODIFY (volatile signed short *)IMDMA_S1_Y_MODIFY
+#define pIMDMA_S1_CURR_DESC_PTR (volatile void **)IMDMA_S1_CURR_DESC_PTR
+#define pIMDMA_S1_CURR_ADDR (volatile void **)IMDMA_S1_CURR_ADDR
+#define pIMDMA_S1_CURR_X_COUNT (volatile unsigned short *)IMDMA_S1_CURR_X_COUNT
+#define pIMDMA_S1_CURR_Y_COUNT (volatile unsigned short *)IMDMA_S1_CURR_Y_COUNT
+#define pIMDMA_S1_IRQ_STATUS (volatile unsigned short *)IMDMA_S1_IRQ_STATUS
+
+#define pMDMA_S0_CONFIG		pMDMA1_S0_CONFIG
+#define PMDMA_S0_IRQ_STATUS	pMDMA1_S0_IRQ_STATUS
+#define pMDMA_S0_X_MODIFY	pMDMA1_S0_X_MODIFY
+#define pMDMA_S0_Y_MODIFY	pMDMA1_S0_Y_MODIFY
+#define pMDMA_S0_X_COUNT	pMDMA1_S0_X_COUNT
+#define pMDMA_S0_Y_COUNT	pMDMA1_S0_Y_COUNT
+#define pMDMA_S0_START_ADDR	pMDMA1_S0_START_ADDR
+#define pMDMA_D0_CONFIG		pMDMA1_D0_CONFIG
+#define pMDMA_D0_IRQ_STATUS	pMDMA1_D0_IRQ_STATUS
+#define pMDMA_D0_X_MODIFY	pMDMA1_D0_X_MODIFY
+#define pMDMA_D0_Y_MODIFY	pMDMA1_D0_Y_MODIFY
+#define pMDMA_D0_X_COUNT	pMDMA1_D0_X_COUNT
+#define pMDMA_D0_Y_COUNT	pMDMA1_D0_Y_COUNT
+#define pMDMA_D0_START_ADDR	pMDMA1_D0_START_ADDR
+
+#endif /* _CDEF_BF561_H */
Index: git/linux-2.6/include/asm-blackfin/mach-bf561/defBF561.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf561/defBF561.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,1688 @@
+
+/*
+ * File:         include/asm-blackfin/mach-bf561/defBF561.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ * SYSTEM MMR REGISTER AND MEMORY MAP FOR ADSP-BF561
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DEF_BF561_H
+#define _DEF_BF561_H
+/*
+#if !defined(__ADSPBF561__)
+#warning defBF561.h should only be included for BF561 chip.
+#endif
+*/
+/* include all Core registers and bit definitions */
+#include <asm/mach-common/def_LPBlackfin.h>
+
+/*********************************************************************************** */
+/* System MMR Register Map */
+/*********************************************************************************** */
+
+/*// Clock and System Control (0xFFC00000 - 0xFFC000FF) */
+
+#define PLL_CTL                0xFFC00000       /* PLL Control register (16-bit) */
+#define PLL_DIV			        0xFFC00004		/* PLL Divide Register (16-bit) */
+#define VR_CTL			        0xFFC00008		/* Voltage Regulator Control Register (16-bit) */
+#define PLL_STAT               0xFFC0000C       /* PLL Status register (16-bit) */
+#define PLL_LOCKCNT            0xFFC00010   	/* PLL Lock Count register (16-bit) */
+
+/* System Reset and Interrupt Controller registers for core A (0xFFC0 0100-0xFFC0 01FF) */
+#define SICA_SWRST              0xFFC00100      /* Software Reset register */
+#define SICA_SYSCR              0xFFC00104      /* System Reset Configuration register */
+#define SICA_RVECT              0xFFC00108      /* SIC Reset Vector Address Register */
+#define SICA_IMASK              0xFFC0010C      /* SIC Interrupt Mask register 0 - hack to fix old tests */
+#define SICA_IMASK0             0xFFC0010C      /* SIC Interrupt Mask register 0 */
+#define SICA_IMASK1             0xFFC00110      /* SIC Interrupt Mask register 1 */
+#define SICA_IAR0               0xFFC00124      /* SIC Interrupt Assignment Register 0 */
+#define SICA_IAR1               0xFFC00128      /* SIC Interrupt Assignment Register 1 */
+#define SICA_IAR2               0xFFC0012C      /* SIC Interrupt Assignment Register 2 */
+#define SICA_IAR3               0xFFC00130      /* SIC Interrupt Assignment Register 3 */
+#define SICA_IAR4               0xFFC00134      /* SIC Interrupt Assignment Register 4 */
+#define SICA_IAR5               0xFFC00138      /* SIC Interrupt Assignment Register 5 */
+#define SICA_IAR6               0xFFC0013C      /* SIC Interrupt Assignment Register 6 */
+#define SICA_IAR7               0xFFC00140      /* SIC Interrupt Assignment Register 7 */
+#define SICA_ISR0               0xFFC00114      /* SIC Interrupt Status register 0 */
+#define SICA_ISR1               0xFFC00118      /* SIC Interrupt Status register 1 */
+#define SICA_IWR0               0xFFC0011C      /* SIC Interrupt Wakeup-Enable register 0 */
+#define SICA_IWR1               0xFFC00120      /* SIC Interrupt Wakeup-Enable register 1 */
+
+/* System Reset and Interrupt Controller registers for Core B (0xFFC0 1100-0xFFC0 11FF) */
+#define SICB_SWRST              0xFFC01100      /* reserved */
+#define SICB_SYSCR              0xFFC01104      /* reserved */
+#define SICB_RVECT              0xFFC01108      /* SIC Reset Vector Address Register */
+#define SICB_IMASK0             0xFFC0110C      /* SIC Interrupt Mask register 0 */
+#define SICB_IMASK1             0xFFC01110      /* SIC Interrupt Mask register 1 */
+#define SICB_IAR0               0xFFC01124      /* SIC Interrupt Assignment Register 0 */
+#define SICB_IAR1               0xFFC01128      /* SIC Interrupt Assignment Register 1 */
+#define SICB_IAR2               0xFFC0112C      /* SIC Interrupt Assignment Register 2 */
+#define SICB_IAR3               0xFFC01130      /* SIC Interrupt Assignment Register 3 */
+#define SICB_IAR4               0xFFC01134      /* SIC Interrupt Assignment Register 4 */
+#define SICB_IAR5               0xFFC01138      /* SIC Interrupt Assignment Register 5 */
+#define SICB_IAR6               0xFFC0113C      /* SIC Interrupt Assignment Register 6 */
+#define SICB_IAR7               0xFFC01140      /* SIC Interrupt Assignment Register 7 */
+#define SICB_ISR0               0xFFC01114      /* SIC Interrupt Status register 0 */
+#define SICB_ISR1               0xFFC01118      /* SIC Interrupt Status register 1 */
+#define SICB_IWR0               0xFFC0111C      /* SIC Interrupt Wakeup-Enable register 0 */
+#define SICB_IWR1               0xFFC01120      /* SIC Interrupt Wakeup-Enable register 1 */
+
+/* Watchdog Timer registers for Core A (0xFFC0 0200-0xFFC0 02FF) */
+#define WDOGA_CTL 				0xFFC00200 		/* Watchdog Control register */
+#define WDOGA_CNT 				0xFFC00204 		/* Watchdog Count register */
+#define WDOGA_STAT 				0xFFC00208 		/* Watchdog Status register */
+
+/* Watchdog Timer registers for Core B (0xFFC0 1200-0xFFC0 12FF) */
+#define WDOGB_CTL 				0xFFC01200 		/* Watchdog Control register */
+#define WDOGB_CNT 				0xFFC01204 		/* Watchdog Count register */
+#define WDOGB_STAT 				0xFFC01208 		/* Watchdog Status register */
+
+/* UART Controller (0xFFC00400 - 0xFFC004FF) */
+#define UART_THR             	0xFFC00400  /* Transmit Holding register */
+#define UART_RBR             	0xFFC00400  /* Receive Buffer register */
+#define UART_DLL              	0xFFC00400  /* Divisor Latch (Low-Byte) */
+#define UART_IER              	0xFFC00404  /* Interrupt Enable Register */
+#define UART_DLH              	0xFFC00404  /* Divisor Latch (High-Byte) */
+#define UART_IIR              	0xFFC00408  /* Interrupt Identification Register */
+#define UART_LCR              	0xFFC0040C  /* Line Control Register */
+#define UART_MCR			 	0xFFC00410  /* Modem Control Register */
+#define UART_LSR              	0xFFC00414  /* Line Status Register */
+#define UART_MSR            	0xFFC00418  /* Modem Status Register */
+#define UART_SCR              	0xFFC0041C  /* SCR Scratch Register */
+#define UART_GCTL      	      	0xFFC00424  /* Global Control Register */
+
+/* SPI Controller (0xFFC00500 - 0xFFC005FF) */
+#define SPI_CTL               		0xFFC00500  /* SPI Control Register */
+#define SPI_FLG               		0xFFC00504  /* SPI Flag register */
+#define SPI_STAT              		0xFFC00508  /* SPI Status register */
+#define SPI_TDBR              		0xFFC0050C  /* SPI Transmit Data Buffer Register */
+#define SPI_RDBR              		0xFFC00510  /* SPI Receive Data Buffer Register */
+#define SPI_BAUD              		0xFFC00514  /* SPI Baud rate Register */
+#define SPI_SHADOW            		0xFFC00518  /* SPI_RDBR Shadow Register */
+
+/* Timer 0-7 registers (0xFFC0 0600-0xFFC0 06FF) */
+#define TIMER0_CONFIG 				0xFFC00600 /* Timer0 Configuration register */
+#define TIMER0_COUNTER 				0xFFC00604 /* Timer0 Counter register */
+#define TIMER0_PERIOD 				0xFFC00608 /* Timer0 Period register */
+#define TIMER0_WIDTH 				0xFFC0060C /* Timer0 Width register */
+
+#define TIMER1_CONFIG 				0xFFC00610 /* Timer1 Configuration register */
+#define TIMER1_COUNTER 				0xFFC00614 /* Timer1 Counter register */
+#define TIMER1_PERIOD 				0xFFC00618 /* Timer1 Period register */
+#define TIMER1_WIDTH 				0xFFC0061C /* Timer1 Width register */
+
+#define TIMER2_CONFIG 				0xFFC00620 /* Timer2 Configuration register */
+#define TIMER2_COUNTER 				0xFFC00624 /* Timer2 Counter register */
+#define TIMER2_PERIOD 				0xFFC00628 /* Timer2 Period register */
+#define TIMER2_WIDTH 				0xFFC0062C /* Timer2 Width register */
+
+#define TIMER3_CONFIG 				0xFFC00630 /* Timer3 Configuration register */
+#define TIMER3_COUNTER 				0xFFC00634 /* Timer3 Counter register */
+#define TIMER3_PERIOD 				0xFFC00638 /* Timer3 Period register */
+#define TIMER3_WIDTH 				0xFFC0063C /* Timer3 Width register */
+
+#define TIMER4_CONFIG 				0xFFC00640 /* Timer4 Configuration register */
+#define TIMER4_COUNTER 				0xFFC00644 /* Timer4 Counter register */
+#define TIMER4_PERIOD 				0xFFC00648 /* Timer4 Period register */
+#define TIMER4_WIDTH 				0xFFC0064C /* Timer4 Width register */
+
+#define TIMER5_CONFIG 				0xFFC00650 /* Timer5 Configuration register */
+#define TIMER5_COUNTER 				0xFFC00654 /* Timer5 Counter register */
+#define TIMER5_PERIOD 				0xFFC00658 /* Timer5 Period register */
+#define TIMER5_WIDTH 				0xFFC0065C /* Timer5 Width register */
+
+#define TIMER6_CONFIG 				0xFFC00660 /* Timer6 Configuration register */
+#define TIMER6_COUNTER 				0xFFC00664 /* Timer6 Counter register */
+#define TIMER6_PERIOD 				0xFFC00668 /* Timer6 Period register */
+#define TIMER6_WIDTH 				0xFFC0066C /* Timer6 Width register */
+
+#define TIMER7_CONFIG 				0xFFC00670 /* Timer7 Configuration register */
+#define TIMER7_COUNTER 				0xFFC00674 /* Timer7 Counter register */
+#define TIMER7_PERIOD 				0xFFC00678 /* Timer7 Period register */
+#define TIMER7_WIDTH 				0xFFC0067C /* Timer7 Width register */
+
+#define TMRS8_ENABLE 				0xFFC00680 /* Timer Enable Register */
+#define TMRS8_DISABLE 				0xFFC00684 /* Timer Disable register */
+#define TMRS8_STATUS 				0xFFC00688 /* Timer Status register */
+
+/* Timer registers 8-11 (0xFFC0 1600-0xFFC0 16FF) */
+#define TIMER8_CONFIG 				0xFFC01600 /* Timer8 Configuration register */
+#define TIMER8_COUNTER 				0xFFC01604 /* Timer8 Counter register */
+#define TIMER8_PERIOD 				0xFFC01608 /* Timer8 Period register */
+#define TIMER8_WIDTH 				0xFFC0160C /* Timer8 Width register */
+
+#define TIMER9_CONFIG 				0xFFC01610 /* Timer9 Configuration register */
+#define TIMER9_COUNTER 				0xFFC01614 /* Timer9 Counter register */
+#define TIMER9_PERIOD 				0xFFC01618 /* Timer9 Period register */
+#define TIMER9_WIDTH 				0xFFC0161C /* Timer9 Width register */
+
+#define TIMER10_CONFIG 				0xFFC01620 /* Timer10 Configuration register */
+#define TIMER10_COUNTER 			0xFFC01624 /* Timer10 Counter register */
+#define TIMER10_PERIOD 				0xFFC01628 /* Timer10 Period register */
+#define TIMER10_WIDTH 				0xFFC0162C /* Timer10 Width register */
+
+#define TIMER11_CONFIG 				0xFFC01630 /* Timer11 Configuration register */
+#define TIMER11_COUNTER 			0xFFC01634 /* Timer11 Counter register */
+#define TIMER11_PERIOD 				0xFFC01638 /* Timer11 Period register */
+#define TIMER11_WIDTH 				0xFFC0163C /* Timer11 Width register */
+
+#define TMRS4_ENABLE 				0xFFC01640 /* Timer Enable Register */
+#define TMRS4_DISABLE 				0xFFC01644 /* Timer Disable register */
+#define TMRS4_STATUS 				0xFFC01648 /* Timer Status register */
+
+/* Programmable Flag 0 registers (0xFFC0 0700-0xFFC0 07FF) */
+#define FIO0_FLAG_D 				0xFFC00700 /* Flag Data register */
+#define FIO0_FLAG_C 				0xFFC00704 /* Flag Clear register */
+#define FIO0_FLAG_S 				0xFFC00708 /* Flag Set register */
+#define FIO0_FLAG_T 				0xFFC0070C /* Flag Toggle register */
+#define FIO0_MASKA_D 				0xFFC00710 /* Flag Mask Interrupt A Data register */
+#define FIO0_MASKA_C 				0xFFC00714 /* Flag Mask Interrupt A Clear register */
+#define FIO0_MASKA_S 				0xFFC00718 /* Flag Mask Interrupt A Set register */
+#define FIO0_MASKA_T 				0xFFC0071C /* Flag Mask Interrupt A Toggle register */
+#define FIO0_MASKB_D 				0xFFC00720 /* Flag Mask Interrupt B Data register */
+#define FIO0_MASKB_C 				0xFFC00724 /* Flag Mask Interrupt B Clear register */
+#define FIO0_MASKB_S 				0xFFC00728 /* Flag Mask Interrupt B Set register */
+#define FIO0_MASKB_T 				0xFFC0072C /* Flag Mask Interrupt B Toggle register */
+#define FIO0_DIR 					0xFFC00730 /* Flag Direction register */
+#define FIO0_POLAR 					0xFFC00734 /* Flag Polarity register */
+#define FIO0_EDGE 					0xFFC00738 /* Flag Interrupt Sensitivity register */
+#define FIO0_BOTH 					0xFFC0073C /* Flag Set on Both Edges register */
+#define FIO0_INEN 					0xFFC00740 /* Flag Input Enable register */
+
+/* Programmable Flag 1 registers (0xFFC0 1500-0xFFC0 15FF) */
+#define FIO1_FLAG_D 				0xFFC01500 /* Flag Data register (mask used to directly */
+#define FIO1_FLAG_C 				0xFFC01504 /* Flag Clear register */
+#define FIO1_FLAG_S 				0xFFC01508 /* Flag Set register */
+#define FIO1_FLAG_T 				0xFFC0150C /* Flag Toggle register (mask used to */
+#define FIO1_MASKA_D 				0xFFC01510 /* Flag Mask Interrupt A Data register */
+#define FIO1_MASKA_C 				0xFFC01514 /* Flag Mask Interrupt A Clear register */
+#define FIO1_MASKA_S 				0xFFC01518 /* Flag Mask Interrupt A Set register */
+#define FIO1_MASKA_T 				0xFFC0151C /* Flag Mask Interrupt A Toggle register */
+#define FIO1_MASKB_D 				0xFFC01520 /* Flag Mask Interrupt B Data register */
+#define FIO1_MASKB_C 				0xFFC01524 /* Flag Mask Interrupt B Clear register */
+#define FIO1_MASKB_S 				0xFFC01528 /* Flag Mask Interrupt B Set register */
+#define FIO1_MASKB_T 				0xFFC0152C /* Flag Mask Interrupt B Toggle register */
+#define FIO1_DIR 					0xFFC01530 /* Flag Direction register */
+#define FIO1_POLAR 					0xFFC01534 /* Flag Polarity register */
+#define FIO1_EDGE 					0xFFC01538 /* Flag Interrupt Sensitivity register */
+#define FIO1_BOTH 					0xFFC0153C /* Flag Set on Both Edges register */
+#define FIO1_INEN 					0xFFC01540 /* Flag Input Enable register */
+
+/* Programmable Flag registers (0xFFC0 1700-0xFFC0 17FF) */
+#define FIO2_FLAG_D 				0xFFC01700 /* Flag Data register (mask used to directly */
+#define FIO2_FLAG_C 				0xFFC01704 /* Flag Clear register */
+#define FIO2_FLAG_S 				0xFFC01708 /* Flag Set register */
+#define FIO2_FLAG_T 				0xFFC0170C /* Flag Toggle register (mask used to */
+#define FIO2_MASKA_D 				0xFFC01710 /* Flag Mask Interrupt A Data register */
+#define FIO2_MASKA_C 				0xFFC01714 /* Flag Mask Interrupt A Clear register */
+#define FIO2_MASKA_S 				0xFFC01718 /* Flag Mask Interrupt A Set register */
+#define FIO2_MASKA_T 				0xFFC0171C /* Flag Mask Interrupt A Toggle register */
+#define FIO2_MASKB_D 				0xFFC01720 /* Flag Mask Interrupt B Data register */
+#define FIO2_MASKB_C 				0xFFC01724 /* Flag Mask Interrupt B Clear register */
+#define FIO2_MASKB_S 				0xFFC01728 /* Flag Mask Interrupt B Set register */
+#define FIO2_MASKB_T 				0xFFC0172C /* Flag Mask Interrupt B Toggle register */
+#define FIO2_DIR 					0xFFC01730 /* Flag Direction register */
+#define FIO2_POLAR 					0xFFC01734 /* Flag Polarity register */
+#define FIO2_EDGE 					0xFFC01738 /* Flag Interrupt Sensitivity register */
+#define FIO2_BOTH 					0xFFC0173C /* Flag Set on Both Edges register */
+#define FIO2_INEN 					0xFFC01740 /* Flag Input Enable register */
+
+/*// SPORT0 Controller (0xFFC00800 - 0xFFC008FF) */
+#define SPORT0_TCR1     	 	0xFFC00800  /* SPORT0 Transmit Configuration 1 Register */
+#define SPORT0_TCR2      	 	0xFFC00804  /* SPORT0 Transmit Configuration 2 Register */
+#define SPORT0_TCLKDIV        		0xFFC00808  /* SPORT0 Transmit Clock Divider */
+#define SPORT0_TFSDIV          		0xFFC0080C  /* SPORT0 Transmit Frame Sync Divider */
+#define SPORT0_TX	             	0xFFC00810  /* SPORT0 TX Data Register */
+#define SPORT0_RX	            	0xFFC00818  /* SPORT0 RX Data Register */
+#define SPORT0_RCR1      	 		0xFFC00820  /* SPORT0 Transmit Configuration 1 Register */
+#define SPORT0_RCR2      	 		0xFFC00824  /* SPORT0 Transmit Configuration 2 Register */
+#define SPORT0_RCLKDIV        		0xFFC00828  /* SPORT0 Receive Clock Divider */
+#define SPORT0_RFSDIV          		0xFFC0082C  /* SPORT0 Receive Frame Sync Divider */
+#define SPORT0_STAT            		0xFFC00830  /* SPORT0 Status Register */
+#define SPORT0_CHNL            		0xFFC00834  /* SPORT0 Current Channel Register */
+#define SPORT0_MCMC1           		0xFFC00838  /* SPORT0 Multi-Channel Configuration Register 1 */
+#define SPORT0_MCMC2           		0xFFC0083C  /* SPORT0 Multi-Channel Configuration Register 2 */
+#define SPORT0_MTCS0           		0xFFC00840  /* SPORT0 Multi-Channel Transmit Select Register 0 */
+#define SPORT0_MTCS1           		0xFFC00844  /* SPORT0 Multi-Channel Transmit Select Register 1 */
+#define SPORT0_MTCS2           		0xFFC00848  /* SPORT0 Multi-Channel Transmit Select Register 2 */
+#define SPORT0_MTCS3           		0xFFC0084C  /* SPORT0 Multi-Channel Transmit Select Register 3 */
+#define SPORT0_MRCS0           		0xFFC00850  /* SPORT0 Multi-Channel Receive Select Register 0 */
+#define SPORT0_MRCS1           		0xFFC00854  /* SPORT0 Multi-Channel Receive Select Register 1 */
+#define SPORT0_MRCS2           		0xFFC00858  /* SPORT0 Multi-Channel Receive Select Register 2 */
+#define SPORT0_MRCS3           		0xFFC0085C  /* SPORT0 Multi-Channel Receive Select Register 3 */
+
+/*// SPORT1 Controller (0xFFC00900 - 0xFFC009FF) */
+#define SPORT1_TCR1     	 		0xFFC00900  /* SPORT1 Transmit Configuration 1 Register */
+#define SPORT1_TCR2      	 		0xFFC00904  /* SPORT1 Transmit Configuration 2 Register */
+#define SPORT1_TCLKDIV        		0xFFC00908  /* SPORT1 Transmit Clock Divider */
+#define SPORT1_TFSDIV          		0xFFC0090C  /* SPORT1 Transmit Frame Sync Divider */
+#define SPORT1_TX	             	0xFFC00910  /* SPORT1 TX Data Register */
+#define SPORT1_RX	            	0xFFC00918  /* SPORT1 RX Data Register */
+#define SPORT1_RCR1      	 		0xFFC00920  /* SPORT1 Transmit Configuration 1 Register */
+#define SPORT1_RCR2      	 		0xFFC00924  /* SPORT1 Transmit Configuration 2 Register */
+#define SPORT1_RCLKDIV        		0xFFC00928  /* SPORT1 Receive Clock Divider */
+#define SPORT1_RFSDIV          		0xFFC0092C  /* SPORT1 Receive Frame Sync Divider */
+#define SPORT1_STAT            		0xFFC00930  /* SPORT1 Status Register */
+#define SPORT1_CHNL            		0xFFC00934  /* SPORT1 Current Channel Register */
+#define SPORT1_MCMC1           		0xFFC00938  /* SPORT1 Multi-Channel Configuration Register 1 */
+#define SPORT1_MCMC2           		0xFFC0093C  /* SPORT1 Multi-Channel Configuration Register 2 */
+#define SPORT1_MTCS0           		0xFFC00940  /* SPORT1 Multi-Channel Transmit Select Register 0 */
+#define SPORT1_MTCS1           		0xFFC00944  /* SPORT1 Multi-Channel Transmit Select Register 1 */
+#define SPORT1_MTCS2           		0xFFC00948  /* SPORT1 Multi-Channel Transmit Select Register 2 */
+#define SPORT1_MTCS3           		0xFFC0094C  /* SPORT1 Multi-Channel Transmit Select Register 3 */
+#define SPORT1_MRCS0           		0xFFC00950  /* SPORT1 Multi-Channel Receive Select Register 0 */
+#define SPORT1_MRCS1           		0xFFC00954  /* SPORT1 Multi-Channel Receive Select Register 1 */
+#define SPORT1_MRCS2           		0xFFC00958  /* SPORT1 Multi-Channel Receive Select Register 2 */
+#define SPORT1_MRCS3           		0xFFC0095C  /* SPORT1 Multi-Channel Receive Select Register 3 */
+
+/* Asynchronous Memory Controller - External Bus Interface Unit  */
+#define EBIU_AMGCTL					0xFFC00A00  /* Asynchronous Memory Global Control Register */
+#define EBIU_AMBCTL0				0xFFC00A04  /* Asynchronous Memory Bank Control Register 0 */
+#define EBIU_AMBCTL1				0xFFC00A08  /* Asynchronous Memory Bank Control Register 1 */
+
+/* SDRAM Controller External Bus Interface Unit (0xFFC00A00 - 0xFFC00AFF) */
+#define EBIU_SDGCTL					0xFFC00A10  /* SDRAM Global Control Register */
+#define EBIU_SDBCTL					0xFFC00A14  /* SDRAM Bank Control Register */
+#define EBIU_SDRRC 					0xFFC00A18  /* SDRAM Refresh Rate Control Register */
+#define EBIU_SDSTAT					0xFFC00A1C  /* SDRAM Status Register */
+
+/* Parallel Peripheral Interface (PPI) 0 registers (0xFFC0 1000-0xFFC0 10FF) */
+#define PPI0_CONTROL 				0xFFC01000 /* PPI0 Control register */
+#define PPI0_STATUS 				0xFFC01004 /* PPI0 Status register */
+#define PPI0_COUNT 					0xFFC01008 /* PPI0 Transfer Count register */
+#define PPI0_DELAY 					0xFFC0100C /* PPI0 Delay Count register */
+#define PPI0_FRAME 					0xFFC01010 /* PPI0 Frame Length register */
+
+/*Parallel Peripheral Interface (PPI) 1 registers (0xFFC0 1300-0xFFC0 13FF) */
+#define PPI1_CONTROL 				0xFFC01300 /* PPI1 Control register */
+#define PPI1_STATUS 				0xFFC01304 /* PPI1 Status register */
+#define PPI1_COUNT 					0xFFC01308 /* PPI1 Transfer Count register */
+#define PPI1_DELAY 					0xFFC0130C /* PPI1 Delay Count register */
+#define PPI1_FRAME 					0xFFC01310 /* PPI1 Frame Length register */
+
+/*DMA traffic control registers */
+#define	DMA1_TC_PER  0xFFC01B0C	/* Traffic control periods */
+#define	DMA1_TC_CNT  0xFFC01B10	/* Traffic control current counts */
+#define	DMA2_TC_PER  0xFFC00B0C	/* Traffic control periods */
+#define	DMA2_TC_CNT  0xFFC00B10	/* Traffic control current counts	 */
+
+/* DMA1 Controller registers (0xFFC0 1C00-0xFFC0 1FFF) */
+#define DMA1_0_CONFIG 0xFFC01C08 /* DMA1 Channel 0 Configuration register */
+#define DMA1_0_NEXT_DESC_PTR 0xFFC01C00 /* DMA1 Channel 0 Next Descripter Ptr Reg */
+#define DMA1_0_START_ADDR 0xFFC01C04 /* DMA1 Channel 0 Start Address */
+#define DMA1_0_X_COUNT 0xFFC01C10 /* DMA1 Channel 0 Inner Loop Count */
+#define DMA1_0_Y_COUNT 0xFFC01C18 /* DMA1 Channel 0 Outer Loop Count */
+#define DMA1_0_X_MODIFY 0xFFC01C14 /* DMA1 Channel 0 Inner Loop Addr Increment */
+#define DMA1_0_Y_MODIFY 0xFFC01C1C /* DMA1 Channel 0 Outer Loop Addr Increment */
+#define DMA1_0_CURR_DESC_PTR 0xFFC01C20 /* DMA1 Channel 0 Current Descriptor Pointer */
+#define DMA1_0_CURR_ADDR 0xFFC01C24 /* DMA1 Channel 0 Current Address Pointer */
+#define DMA1_0_CURR_X_COUNT 0xFFC01C30 /* DMA1 Channel 0 Current Inner Loop Count */
+#define DMA1_0_CURR_Y_COUNT 0xFFC01C38 /* DMA1 Channel 0 Current Outer Loop Count */
+#define DMA1_0_IRQ_STATUS 0xFFC01C28 /* DMA1 Channel 0 Interrupt/Status Register */
+#define DMA1_0_PERIPHERAL_MAP 0xFFC01C2C /* DMA1 Channel 0 Peripheral Map Register */
+
+#define DMA1_1_CONFIG 0xFFC01C48 /* DMA1 Channel 1 Configuration register */
+#define DMA1_1_NEXT_DESC_PTR 0xFFC01C40 /* DMA1 Channel 1 Next Descripter Ptr Reg */
+#define DMA1_1_START_ADDR 0xFFC01C44 /* DMA1 Channel 1 Start Address */
+#define DMA1_1_X_COUNT 0xFFC01C50 /* DMA1 Channel 1 Inner Loop Count */
+#define DMA1_1_Y_COUNT 0xFFC01C58 /* DMA1 Channel 1 Outer Loop Count */
+#define DMA1_1_X_MODIFY 0xFFC01C54 /* DMA1 Channel 1 Inner Loop Addr Increment */
+#define DMA1_1_Y_MODIFY 0xFFC01C5C /* DMA1 Channel 1 Outer Loop Addr Increment */
+#define DMA1_1_CURR_DESC_PTR 0xFFC01C60 /* DMA1 Channel 1 Current Descriptor Pointer */
+#define DMA1_1_CURR_ADDR 0xFFC01C64 /* DMA1 Channel 1 Current Address Pointer */
+#define DMA1_1_CURR_X_COUNT 0xFFC01C70 /* DMA1 Channel 1 Current Inner Loop Count */
+#define DMA1_1_CURR_Y_COUNT 0xFFC01C78 /* DMA1 Channel 1 Current Outer Loop Count */
+#define DMA1_1_IRQ_STATUS 0xFFC01C68 /* DMA1 Channel 1 Interrupt/Status Register */
+#define DMA1_1_PERIPHERAL_MAP 0xFFC01C6C /* DMA1 Channel 1 Peripheral Map Register */
+
+#define DMA1_2_CONFIG 0xFFC01C88 /* DMA1 Channel 2 Configuration register */
+#define DMA1_2_NEXT_DESC_PTR 0xFFC01C80 /* DMA1 Channel 2 Next Descripter Ptr Reg */
+#define DMA1_2_START_ADDR 0xFFC01C84 /* DMA1 Channel 2 Start Address */
+#define DMA1_2_X_COUNT 0xFFC01C90 /* DMA1 Channel 2 Inner Loop Count */
+#define DMA1_2_Y_COUNT 0xFFC01C98 /* DMA1 Channel 2 Outer Loop Count */
+#define DMA1_2_X_MODIFY 0xFFC01C94 /* DMA1 Channel 2 Inner Loop Addr Increment */
+#define DMA1_2_Y_MODIFY 0xFFC01C9C /* DMA1 Channel 2 Outer Loop Addr Increment */
+#define DMA1_2_CURR_DESC_PTR 0xFFC01CA0 /* DMA1 Channel 2 Current Descriptor Pointer */
+#define DMA1_2_CURR_ADDR 0xFFC01CA4 /* DMA1 Channel 2 Current Address Pointer */
+#define DMA1_2_CURR_X_COUNT 0xFFC01CB0 /* DMA1 Channel 2 Current Inner Loop Count */
+#define DMA1_2_CURR_Y_COUNT 0xFFC01CB8 /* DMA1 Channel 2 Current Outer Loop Count */
+#define DMA1_2_IRQ_STATUS 0xFFC01CA8 /* DMA1 Channel 2 Interrupt/Status Register */
+#define DMA1_2_PERIPHERAL_MAP 0xFFC01CAC /* DMA1 Channel 2 Peripheral Map Register */
+
+#define DMA1_3_CONFIG 0xFFC01CC8 /* DMA1 Channel 3 Configuration register */
+#define DMA1_3_NEXT_DESC_PTR 0xFFC01CC0 /* DMA1 Channel 3 Next Descripter Ptr Reg */
+#define DMA1_3_START_ADDR 0xFFC01CC4 /* DMA1 Channel 3 Start Address */
+#define DMA1_3_X_COUNT 0xFFC01CD0 /* DMA1 Channel 3 Inner Loop Count */
+#define DMA1_3_Y_COUNT 0xFFC01CD8 /* DMA1 Channel 3 Outer Loop Count */
+#define DMA1_3_X_MODIFY 0xFFC01CD4 /* DMA1 Channel 3 Inner Loop Addr Increment */
+#define DMA1_3_Y_MODIFY 0xFFC01CDC /* DMA1 Channel 3 Outer Loop Addr Increment */
+#define DMA1_3_CURR_DESC_PTR 0xFFC01CE0 /* DMA1 Channel 3 Current Descriptor Pointer */
+#define DMA1_3_CURR_ADDR 0xFFC01CE4 /* DMA1 Channel 3 Current Address Pointer */
+#define DMA1_3_CURR_X_COUNT 0xFFC01CF0 /* DMA1 Channel 3 Current Inner Loop Count */
+#define DMA1_3_CURR_Y_COUNT 0xFFC01CF8 /* DMA1 Channel 3 Current Outer Loop Count */
+#define DMA1_3_IRQ_STATUS 0xFFC01CE8 /* DMA1 Channel 3 Interrupt/Status Register */
+#define DMA1_3_PERIPHERAL_MAP 0xFFC01CEC /* DMA1 Channel 3 Peripheral Map Register */
+
+#define DMA1_4_CONFIG 0xFFC01D08 /* DMA1 Channel 4 Configuration register */
+#define DMA1_4_NEXT_DESC_PTR 0xFFC01D00 /* DMA1 Channel 4 Next Descripter Ptr Reg */
+#define DMA1_4_START_ADDR 0xFFC01D04 /* DMA1 Channel 4 Start Address */
+#define DMA1_4_X_COUNT 0xFFC01D10 /* DMA1 Channel 4 Inner Loop Count */
+#define DMA1_4_Y_COUNT 0xFFC01D18 /* DMA1 Channel 4 Outer Loop Count */
+#define DMA1_4_X_MODIFY 0xFFC01D14 /* DMA1 Channel 4 Inner Loop Addr Increment */
+#define DMA1_4_Y_MODIFY 0xFFC01D1C /* DMA1 Channel 4 Outer Loop Addr Increment */
+#define DMA1_4_CURR_DESC_PTR 0xFFC01D20 /* DMA1 Channel 4 Current Descriptor Pointer */
+#define DMA1_4_CURR_ADDR 0xFFC01D24 /* DMA1 Channel 4 Current Address Pointer */
+#define DMA1_4_CURR_X_COUNT 0xFFC01D30 /* DMA1 Channel 4 Current Inner Loop Count */
+#define DMA1_4_CURR_Y_COUNT 0xFFC01D38 /* DMA1 Channel 4 Current Outer Loop Count */
+#define DMA1_4_IRQ_STATUS 0xFFC01D28 /* DMA1 Channel 4 Interrupt/Status Register */
+#define DMA1_4_PERIPHERAL_MAP 0xFFC01D2C /* DMA1 Channel 4 Peripheral Map Register */
+
+#define DMA1_5_CONFIG 0xFFC01D48 /* DMA1 Channel 5 Configuration register */
+#define DMA1_5_NEXT_DESC_PTR 0xFFC01D40 /* DMA1 Channel 5 Next Descripter Ptr Reg */
+#define DMA1_5_START_ADDR 0xFFC01D44 /* DMA1 Channel 5 Start Address */
+#define DMA1_5_X_COUNT 0xFFC01D50 /* DMA1 Channel 5 Inner Loop Count */
+#define DMA1_5_Y_COUNT 0xFFC01D58 /* DMA1 Channel 5 Outer Loop Count */
+#define DMA1_5_X_MODIFY 0xFFC01D54 /* DMA1 Channel 5 Inner Loop Addr Increment */
+#define DMA1_5_Y_MODIFY 0xFFC01D5C /* DMA1 Channel 5 Outer Loop Addr Increment */
+#define DMA1_5_CURR_DESC_PTR 0xFFC01D60 /* DMA1 Channel 5 Current Descriptor Pointer */
+#define DMA1_5_CURR_ADDR 0xFFC01D64 /* DMA1 Channel 5 Current Address Pointer */
+#define DMA1_5_CURR_X_COUNT 0xFFC01D70 /* DMA1 Channel 5 Current Inner Loop Count */
+#define DMA1_5_CURR_Y_COUNT 0xFFC01D78 /* DMA1 Channel 5 Current Outer Loop Count */
+#define DMA1_5_IRQ_STATUS 0xFFC01D68 /* DMA1 Channel 5 Interrupt/Status Register */
+#define DMA1_5_PERIPHERAL_MAP 0xFFC01D6C /* DMA1 Channel 5 Peripheral Map Register */
+
+#define DMA1_6_CONFIG 0xFFC01D88 /* DMA1 Channel 6 Configuration register */
+#define DMA1_6_NEXT_DESC_PTR 0xFFC01D80 /* DMA1 Channel 6 Next Descripter Ptr Reg */
+#define DMA1_6_START_ADDR 0xFFC01D84 /* DMA1 Channel 6 Start Address */
+#define DMA1_6_X_COUNT 0xFFC01D90 /* DMA1 Channel 6 Inner Loop Count */
+#define DMA1_6_Y_COUNT 0xFFC01D98 /* DMA1 Channel 6 Outer Loop Count */
+#define DMA1_6_X_MODIFY 0xFFC01D94 /* DMA1 Channel 6 Inner Loop Addr Increment */
+#define DMA1_6_Y_MODIFY 0xFFC01D9C /* DMA1 Channel 6 Outer Loop Addr Increment */
+#define DMA1_6_CURR_DESC_PTR 0xFFC01DA0 /* DMA1 Channel 6 Current Descriptor Pointer */
+#define DMA1_6_CURR_ADDR 0xFFC01DA4 /* DMA1 Channel 6 Current Address Pointer */
+#define DMA1_6_CURR_X_COUNT 0xFFC01DB0 /* DMA1 Channel 6 Current Inner Loop Count */
+#define DMA1_6_CURR_Y_COUNT 0xFFC01DB8 /* DMA1 Channel 6 Current Outer Loop Count */
+#define DMA1_6_IRQ_STATUS 0xFFC01DA8 /* DMA1 Channel 6 Interrupt/Status Register */
+#define DMA1_6_PERIPHERAL_MAP 0xFFC01DAC /* DMA1 Channel 6 Peripheral Map Register */
+
+#define DMA1_7_CONFIG 0xFFC01DC8 /* DMA1 Channel 7 Configuration register */
+#define DMA1_7_NEXT_DESC_PTR 0xFFC01DC0 /* DMA1 Channel 7 Next Descripter Ptr Reg */
+#define DMA1_7_START_ADDR 0xFFC01DC4 /* DMA1 Channel 7 Start Address */
+#define DMA1_7_X_COUNT 0xFFC01DD0 /* DMA1 Channel 7 Inner Loop Count */
+#define DMA1_7_Y_COUNT 0xFFC01DD8 /* DMA1 Channel 7 Outer Loop Count */
+#define DMA1_7_X_MODIFY 0xFFC01DD4 /* DMA1 Channel 7 Inner Loop Addr Increment */
+#define DMA1_7_Y_MODIFY 0xFFC01DDC /* DMA1 Channel 7 Outer Loop Addr Increment */
+#define DMA1_7_CURR_DESC_PTR 0xFFC01DE0 /* DMA1 Channel 7 Current Descriptor Pointer */
+#define DMA1_7_CURR_ADDR 0xFFC01DE4 /* DMA1 Channel 7 Current Address Pointer */
+#define DMA1_7_CURR_X_COUNT 0xFFC01DF0 /* DMA1 Channel 7 Current Inner Loop Count */
+#define DMA1_7_CURR_Y_COUNT 0xFFC01DF8 /* DMA1 Channel 7 Current Outer Loop Count */
+#define DMA1_7_IRQ_STATUS 0xFFC01DE8 /* DMA1 Channel 7 Interrupt/Status Register */
+#define DMA1_7_PERIPHERAL_MAP 0xFFC01DEC /* DMA1 Channel 7 Peripheral Map Register */
+
+#define DMA1_8_CONFIG 0xFFC01E08 /* DMA1 Channel 8 Configuration register */
+#define DMA1_8_NEXT_DESC_PTR 0xFFC01E00 /* DMA1 Channel 8 Next Descripter Ptr Reg */
+#define DMA1_8_START_ADDR 0xFFC01E04 /* DMA1 Channel 8 Start Address */
+#define DMA1_8_X_COUNT 0xFFC01E10 /* DMA1 Channel 8 Inner Loop Count */
+#define DMA1_8_Y_COUNT 0xFFC01E18 /* DMA1 Channel 8 Outer Loop Count */
+#define DMA1_8_X_MODIFY 0xFFC01E14 /* DMA1 Channel 8 Inner Loop Addr Increment */
+#define DMA1_8_Y_MODIFY 0xFFC01E1C /* DMA1 Channel 8 Outer Loop Addr Increment */
+#define DMA1_8_CURR_DESC_PTR 0xFFC01E20 /* DMA1 Channel 8 Current Descriptor Pointer */
+#define DMA1_8_CURR_ADDR 0xFFC01E24 /* DMA1 Channel 8 Current Address Pointer */
+#define DMA1_8_CURR_X_COUNT 0xFFC01E30 /* DMA1 Channel 8 Current Inner Loop Count */
+#define DMA1_8_CURR_Y_COUNT 0xFFC01E38 /* DMA1 Channel 8 Current Outer Loop Count */
+#define DMA1_8_IRQ_STATUS 0xFFC01E28 /* DMA1 Channel 8 Interrupt/Status Register */
+#define DMA1_8_PERIPHERAL_MAP 0xFFC01E2C /* DMA1 Channel 8 Peripheral Map Register */
+
+#define DMA1_9_CONFIG 0xFFC01E48 /* DMA1 Channel 9 Configuration register */
+#define DMA1_9_NEXT_DESC_PTR 0xFFC01E40 /* DMA1 Channel 9 Next Descripter Ptr Reg */
+#define DMA1_9_START_ADDR 0xFFC01E44 /* DMA1 Channel 9 Start Address */
+#define DMA1_9_X_COUNT 0xFFC01E50 /* DMA1 Channel 9 Inner Loop Count */
+#define DMA1_9_Y_COUNT 0xFFC01E58 /* DMA1 Channel 9 Outer Loop Count */
+#define DMA1_9_X_MODIFY 0xFFC01E54 /* DMA1 Channel 9 Inner Loop Addr Increment */
+#define DMA1_9_Y_MODIFY 0xFFC01E5C /* DMA1 Channel 9 Outer Loop Addr Increment */
+#define DMA1_9_CURR_DESC_PTR 0xFFC01E60 /* DMA1 Channel 9 Current Descriptor Pointer */
+#define DMA1_9_CURR_ADDR 0xFFC01E64 /* DMA1 Channel 9 Current Address Pointer */
+#define DMA1_9_CURR_X_COUNT 0xFFC01E70 /* DMA1 Channel 9 Current Inner Loop Count */
+#define DMA1_9_CURR_Y_COUNT 0xFFC01E78 /* DMA1 Channel 9 Current Outer Loop Count */
+#define DMA1_9_IRQ_STATUS 0xFFC01E68 /* DMA1 Channel 9 Interrupt/Status Register */
+#define DMA1_9_PERIPHERAL_MAP 0xFFC01E6C /* DMA1 Channel 9 Peripheral Map Register */
+
+#define DMA1_10_CONFIG 0xFFC01E88 /* DMA1 Channel 10 Configuration register */
+#define DMA1_10_NEXT_DESC_PTR 0xFFC01E80 /* DMA1 Channel 10 Next Descripter Ptr Reg */
+#define DMA1_10_START_ADDR 0xFFC01E84 /* DMA1 Channel 10 Start Address */
+#define DMA1_10_X_COUNT 0xFFC01E90 /* DMA1 Channel 10 Inner Loop Count */
+#define DMA1_10_Y_COUNT 0xFFC01E98 /* DMA1 Channel 10 Outer Loop Count */
+#define DMA1_10_X_MODIFY 0xFFC01E94 /* DMA1 Channel 10 Inner Loop Addr Increment */
+#define DMA1_10_Y_MODIFY 0xFFC01E9C /* DMA1 Channel 10 Outer Loop Addr Increment */
+#define DMA1_10_CURR_DESC_PTR 0xFFC01EA0 /* DMA1 Channel 10 Current Descriptor Pointer */
+#define DMA1_10_CURR_ADDR 0xFFC01EA4 /* DMA1 Channel 10 Current Address Pointer */
+#define DMA1_10_CURR_X_COUNT 0xFFC01EB0 /* DMA1 Channel 10 Current Inner Loop Count */
+#define DMA1_10_CURR_Y_COUNT 0xFFC01EB8 /* DMA1 Channel 10 Current Outer Loop Count */
+#define DMA1_10_IRQ_STATUS 0xFFC01EA8 /* DMA1 Channel 10 Interrupt/Status Register */
+#define DMA1_10_PERIPHERAL_MAP 0xFFC01EAC /* DMA1 Channel 10 Peripheral Map Register */
+
+#define DMA1_11_CONFIG 0xFFC01EC8 /* DMA1 Channel 11 Configuration register */
+#define DMA1_11_NEXT_DESC_PTR 0xFFC01EC0 /* DMA1 Channel 11 Next Descripter Ptr Reg */
+#define DMA1_11_START_ADDR 0xFFC01EC4 /* DMA1 Channel 11 Start Address */
+#define DMA1_11_X_COUNT 0xFFC01ED0 /* DMA1 Channel 11 Inner Loop Count */
+#define DMA1_11_Y_COUNT 0xFFC01ED8 /* DMA1 Channel 11 Outer Loop Count */
+#define DMA1_11_X_MODIFY 0xFFC01ED4 /* DMA1 Channel 11 Inner Loop Addr Increment */
+#define DMA1_11_Y_MODIFY 0xFFC01EDC /* DMA1 Channel 11 Outer Loop Addr Increment */
+#define DMA1_11_CURR_DESC_PTR 0xFFC01EE0 /* DMA1 Channel 11 Current Descriptor Pointer */
+#define DMA1_11_CURR_ADDR 0xFFC01EE4 /* DMA1 Channel 11 Current Address Pointer */
+#define DMA1_11_CURR_X_COUNT 0xFFC01EF0 /* DMA1 Channel 11 Current Inner Loop Count */
+#define DMA1_11_CURR_Y_COUNT 0xFFC01EF8 /* DMA1 Channel 11 Current Outer Loop Count */
+#define DMA1_11_IRQ_STATUS 0xFFC01EE8 /* DMA1 Channel 11 Interrupt/Status Register */
+#define DMA1_11_PERIPHERAL_MAP 0xFFC01EEC /* DMA1 Channel 11 Peripheral Map Register */
+
+/* Memory DMA1 Controller registers (0xFFC0 1E80-0xFFC0 1FFF) */
+#define MDMA1_D0_CONFIG 0xFFC01F08 /*MemDMA1 Stream 0 Destination Configuration */
+#define MDMA1_D0_NEXT_DESC_PTR 0xFFC01F00 /*MemDMA1 Stream 0 Destination Next Descriptor Ptr Reg */
+#define MDMA1_D0_START_ADDR 0xFFC01F04 /*MemDMA1 Stream 0 Destination Start Address */
+#define MDMA1_D0_X_COUNT 0xFFC01F10 /*MemDMA1 Stream 0 Destination Inner-Loop Count */
+#define MDMA1_D0_Y_COUNT 0xFFC01F18 /*MemDMA1 Stream 0 Destination Outer-Loop Count */
+#define MDMA1_D0_X_MODIFY 0xFFC01F14 /*MemDMA1 Stream 0 Dest Inner-Loop Address-Increment */
+#define MDMA1_D0_Y_MODIFY 0xFFC01F1C /*MemDMA1 Stream 0 Dest Outer-Loop Address-Increment */
+#define MDMA1_D0_CURR_DESC_PTR 0xFFC01F20 /*MemDMA1 Stream 0 Dest Current Descriptor Ptr reg */
+#define MDMA1_D0_CURR_ADDR 0xFFC01F24 /*MemDMA1 Stream 0 Destination Current Address */
+#define MDMA1_D0_CURR_X_COUNT 0xFFC01F30 /*MemDMA1 Stream 0 Dest Current Inner-Loop Count */
+#define MDMA1_D0_CURR_Y_COUNT 0xFFC01F38 /*MemDMA1 Stream 0 Dest Current Outer-Loop Count */
+#define MDMA1_D0_IRQ_STATUS 0xFFC01F28 /*MemDMA1 Stream 0 Destination Interrupt/Status */
+#define MDMA1_D0_PERIPHERAL_MAP 0xFFC01F2C /*MemDMA1 Stream 0 Destination Peripheral Map */
+
+#define MDMA1_S0_CONFIG 0xFFC01F48 /*MemDMA1 Stream 0 Source Configuration */
+#define MDMA1_S0_NEXT_DESC_PTR 0xFFC01F40 /*MemDMA1 Stream 0 Source Next Descriptor Ptr Reg */
+#define MDMA1_S0_START_ADDR 0xFFC01F44 /*MemDMA1 Stream 0 Source Start Address */
+#define MDMA1_S0_X_COUNT 0xFFC01F50 /*MemDMA1 Stream 0 Source Inner-Loop Count */
+#define MDMA1_S0_Y_COUNT 0xFFC01F58 /*MemDMA1 Stream 0 Source Outer-Loop Count */
+#define MDMA1_S0_X_MODIFY 0xFFC01F54 /*MemDMA1 Stream 0 Source Inner-Loop Address-Increment */
+#define MDMA1_S0_Y_MODIFY 0xFFC01F5C /*MemDMA1 Stream 0 Source Outer-Loop Address-Increment */
+#define MDMA1_S0_CURR_DESC_PTR 0xFFC01F60 /*MemDMA1 Stream 0 Source Current Descriptor Ptr reg */
+#define MDMA1_S0_CURR_ADDR 0xFFC01F64 /*MemDMA1 Stream 0 Source Current Address */
+#define MDMA1_S0_CURR_X_COUNT 0xFFC01F70 /*MemDMA1 Stream 0 Source Current Inner-Loop Count */
+#define MDMA1_S0_CURR_Y_COUNT 0xFFC01F78 /*MemDMA1 Stream 0 Source Current Outer-Loop Count */
+#define MDMA1_S0_IRQ_STATUS 0xFFC01F68 /*MemDMA1 Stream 0 Source Interrupt/Status */
+#define MDMA1_S0_PERIPHERAL_MAP 0xFFC01F6C /*MemDMA1 Stream 0 Source Peripheral Map */
+
+#define MDMA1_D1_CONFIG 0xFFC01F88 /*MemDMA1 Stream 1 Destination Configuration */
+#define MDMA1_D1_NEXT_DESC_PTR 0xFFC01F80 /*MemDMA1 Stream 1 Destination Next Descriptor Ptr Reg */
+#define MDMA1_D1_START_ADDR 0xFFC01F84 /*MemDMA1 Stream 1 Destination Start Address */
+#define MDMA1_D1_X_COUNT 0xFFC01F90 /*MemDMA1 Stream 1 Destination Inner-Loop Count */
+#define MDMA1_D1_Y_COUNT 0xFFC01F98 /*MemDMA1 Stream 1 Destination Outer-Loop Count */
+#define MDMA1_D1_X_MODIFY 0xFFC01F94 /*MemDMA1 Stream 1 Dest Inner-Loop Address-Increment */
+#define MDMA1_D1_Y_MODIFY 0xFFC01F9C /*MemDMA1 Stream 1 Dest Outer-Loop Address-Increment */
+#define MDMA1_D1_CURR_DESC_PTR 0xFFC01FA0 /*MemDMA1 Stream 1 Dest Current Descriptor Ptr reg */
+#define MDMA1_D1_CURR_ADDR 0xFFC01FA4 /*MemDMA1 Stream 1 Dest Current Address */
+#define MDMA1_D1_CURR_X_COUNT 0xFFC01FB0 /*MemDMA1 Stream 1 Dest Current Inner-Loop Count */
+#define MDMA1_D1_CURR_Y_COUNT 0xFFC01FB8 /*MemDMA1 Stream 1 Dest Current Outer-Loop Count */
+#define MDMA1_D1_IRQ_STATUS 0xFFC01FA8 /*MemDMA1 Stream 1 Dest Interrupt/Status */
+#define MDMA1_D1_PERIPHERAL_MAP 0xFFC01FAC /*MemDMA1 Stream 1 Dest Peripheral Map */
+
+#define MDMA1_S1_CONFIG 0xFFC01FC8 /*MemDMA1 Stream 1 Source Configuration */
+#define MDMA1_S1_NEXT_DESC_PTR 0xFFC01FC0 /*MemDMA1 Stream 1 Source Next Descriptor Ptr Reg */
+#define MDMA1_S1_START_ADDR 0xFFC01FC4 /*MemDMA1 Stream 1 Source Start Address */
+#define MDMA1_S1_X_COUNT 0xFFC01FD0 /*MemDMA1 Stream 1 Source Inner-Loop Count */
+#define MDMA1_S1_Y_COUNT 0xFFC01FD8 /*MemDMA1 Stream 1 Source Outer-Loop Count */
+#define MDMA1_S1_X_MODIFY 0xFFC01FD4 /*MemDMA1 Stream 1 Source Inner-Loop Address-Increment */
+#define MDMA1_S1_Y_MODIFY 0xFFC01FDC /*MemDMA1 Stream 1 Source Outer-Loop Address-Increment */
+#define MDMA1_S1_CURR_DESC_PTR 0xFFC01FE0 /*MemDMA1 Stream 1 Source Current Descriptor Ptr reg */
+#define MDMA1_S1_CURR_ADDR 0xFFC01FE4 /*MemDMA1 Stream 1 Source Current Address */
+#define MDMA1_S1_CURR_X_COUNT 0xFFC01FF0 /*MemDMA1 Stream 1 Source Current Inner-Loop Count */
+#define MDMA1_S1_CURR_Y_COUNT 0xFFC01FF8 /*MemDMA1 Stream 1 Source Current Outer-Loop Count */
+#define MDMA1_S1_IRQ_STATUS 0xFFC01FE8 /*MemDMA1 Stream 1 Source Interrupt/Status */
+#define MDMA1_S1_PERIPHERAL_MAP 0xFFC01FEC /*MemDMA1 Stream 1 Source Peripheral Map */
+
+/* DMA2 Controller registers (0xFFC0 0C00-0xFFC0 0DFF) */
+#define DMA2_0_CONFIG 0xFFC00C08 /* DMA2 Channel 0 Configuration register */
+#define DMA2_0_NEXT_DESC_PTR 0xFFC00C00 /* DMA2 Channel 0 Next Descripter Ptr Reg */
+#define DMA2_0_START_ADDR 0xFFC00C04 /* DMA2 Channel 0 Start Address */
+#define DMA2_0_X_COUNT 0xFFC00C10 /* DMA2 Channel 0 Inner Loop Count */
+#define DMA2_0_Y_COUNT 0xFFC00C18 /* DMA2 Channel 0 Outer Loop Count */
+#define DMA2_0_X_MODIFY 0xFFC00C14 /* DMA2 Channel 0 Inner Loop Addr Increment */
+#define DMA2_0_Y_MODIFY 0xFFC00C1C /* DMA2 Channel 0 Outer Loop Addr Increment */
+#define DMA2_0_CURR_DESC_PTR 0xFFC00C20 /* DMA2 Channel 0 Current Descriptor Pointer */
+#define DMA2_0_CURR_ADDR 0xFFC00C24 /* DMA2 Channel 0 Current Address Pointer */
+#define DMA2_0_CURR_X_COUNT 0xFFC00C30 /* DMA2 Channel 0 Current Inner Loop Count */
+#define DMA2_0_CURR_Y_COUNT 0xFFC00C38 /* DMA2 Channel 0 Current Outer Loop Count */
+#define DMA2_0_IRQ_STATUS 0xFFC00C28 /* DMA2 Channel 0 Interrupt/Status Register */
+#define DMA2_0_PERIPHERAL_MAP 0xFFC00C2C /* DMA2 Channel 0 Peripheral Map Register */
+
+#define DMA2_1_CONFIG 0xFFC00C48 /* DMA2 Channel 1 Configuration register */
+#define DMA2_1_NEXT_DESC_PTR 0xFFC00C40 /* DMA2 Channel 1 Next Descripter Ptr Reg */
+#define DMA2_1_START_ADDR 0xFFC00C44 /* DMA2 Channel 1 Start Address */
+#define DMA2_1_X_COUNT 0xFFC00C50 /* DMA2 Channel 1 Inner Loop Count */
+#define DMA2_1_Y_COUNT 0xFFC00C58 /* DMA2 Channel 1 Outer Loop Count */
+#define DMA2_1_X_MODIFY 0xFFC00C54 /* DMA2 Channel 1 Inner Loop Addr Increment */
+#define DMA2_1_Y_MODIFY 0xFFC00C5C /* DMA2 Channel 1 Outer Loop Addr Increment */
+#define DMA2_1_CURR_DESC_PTR 0xFFC00C60 /* DMA2 Channel 1 Current Descriptor Pointer */
+#define DMA2_1_CURR_ADDR 0xFFC00C64 /* DMA2 Channel 1 Current Address Pointer */
+#define DMA2_1_CURR_X_COUNT 0xFFC00C70 /* DMA2 Channel 1 Current Inner Loop Count */
+#define DMA2_1_CURR_Y_COUNT 0xFFC00C78 /* DMA2 Channel 1 Current Outer Loop Count */
+#define DMA2_1_IRQ_STATUS 0xFFC00C68 /* DMA2 Channel 1 Interrupt/Status Register */
+#define DMA2_1_PERIPHERAL_MAP 0xFFC00C6C /* DMA2 Channel 1 Peripheral Map Register */
+
+#define DMA2_2_CONFIG 0xFFC00C88 /* DMA2 Channel 2 Configuration register */
+#define DMA2_2_NEXT_DESC_PTR 0xFFC00C80 /* DMA2 Channel 2 Next Descripter Ptr Reg */
+#define DMA2_2_START_ADDR 0xFFC00C84 /* DMA2 Channel 2 Start Address */
+#define DMA2_2_X_COUNT 0xFFC00C90 /* DMA2 Channel 2 Inner Loop Count */
+#define DMA2_2_Y_COUNT 0xFFC00C98 /* DMA2 Channel 2 Outer Loop Count */
+#define DMA2_2_X_MODIFY 0xFFC00C94 /* DMA2 Channel 2 Inner Loop Addr Increment */
+#define DMA2_2_Y_MODIFY 0xFFC00C9C /* DMA2 Channel 2 Outer Loop Addr Increment */
+#define DMA2_2_CURR_DESC_PTR 0xFFC00CA0 /* DMA2 Channel 2 Current Descriptor Pointer */
+#define DMA2_2_CURR_ADDR 0xFFC00CA4 /* DMA2 Channel 2 Current Address Pointer */
+#define DMA2_2_CURR_X_COUNT 0xFFC00CB0 /* DMA2 Channel 2 Current Inner Loop Count */
+#define DMA2_2_CURR_Y_COUNT 0xFFC00CB8 /* DMA2 Channel 2 Current Outer Loop Count */
+#define DMA2_2_IRQ_STATUS 0xFFC00CA8 /* DMA2 Channel 2 Interrupt/Status Register */
+#define DMA2_2_PERIPHERAL_MAP 0xFFC00CAC /* DMA2 Channel 2 Peripheral Map Register */
+
+#define DMA2_3_CONFIG 0xFFC00CC8 /* DMA2 Channel 3 Configuration register */
+#define DMA2_3_NEXT_DESC_PTR 0xFFC00CC0 /* DMA2 Channel 3 Next Descripter Ptr Reg */
+#define DMA2_3_START_ADDR 0xFFC00CC4 /* DMA2 Channel 3 Start Address */
+#define DMA2_3_X_COUNT 0xFFC00CD0 /* DMA2 Channel 3 Inner Loop Count */
+#define DMA2_3_Y_COUNT 0xFFC00CD8 /* DMA2 Channel 3 Outer Loop Count */
+#define DMA2_3_X_MODIFY 0xFFC00CD4 /* DMA2 Channel 3 Inner Loop Addr Increment */
+#define DMA2_3_Y_MODIFY 0xFFC00CDC /* DMA2 Channel 3 Outer Loop Addr Increment */
+#define DMA2_3_CURR_DESC_PTR 0xFFC00CE0 /* DMA2 Channel 3 Current Descriptor Pointer */
+#define DMA2_3_CURR_ADDR 0xFFC00CE4 /* DMA2 Channel 3 Current Address Pointer */
+#define DMA2_3_CURR_X_COUNT 0xFFC00CF0 /* DMA2 Channel 3 Current Inner Loop Count */
+#define DMA2_3_CURR_Y_COUNT 0xFFC00CF8 /* DMA2 Channel 3 Current Outer Loop Count */
+#define DMA2_3_IRQ_STATUS 0xFFC00CE8 /* DMA2 Channel 3 Interrupt/Status Register */
+#define DMA2_3_PERIPHERAL_MAP 0xFFC00CEC /* DMA2 Channel 3 Peripheral Map Register */
+
+#define DMA2_4_CONFIG 0xFFC00D08 /* DMA2 Channel 4 Configuration register */
+#define DMA2_4_NEXT_DESC_PTR 0xFFC00D00 /* DMA2 Channel 4 Next Descripter Ptr Reg */
+#define DMA2_4_START_ADDR 0xFFC00D04 /* DMA2 Channel 4 Start Address */
+#define DMA2_4_X_COUNT 0xFFC00D10 /* DMA2 Channel 4 Inner Loop Count */
+#define DMA2_4_Y_COUNT 0xFFC00D18 /* DMA2 Channel 4 Outer Loop Count */
+#define DMA2_4_X_MODIFY 0xFFC00D14 /* DMA2 Channel 4 Inner Loop Addr Increment */
+#define DMA2_4_Y_MODIFY 0xFFC00D1C /* DMA2 Channel 4 Outer Loop Addr Increment */
+#define DMA2_4_CURR_DESC_PTR 0xFFC00D20 /* DMA2 Channel 4 Current Descriptor Pointer */
+#define DMA2_4_CURR_ADDR 0xFFC00D24 /* DMA2 Channel 4 Current Address Pointer */
+#define DMA2_4_CURR_X_COUNT 0xFFC00D30 /* DMA2 Channel 4 Current Inner Loop Count */
+#define DMA2_4_CURR_Y_COUNT 0xFFC00D38 /* DMA2 Channel 4 Current Outer Loop Count */
+#define DMA2_4_IRQ_STATUS 0xFFC00D28 /* DMA2 Channel 4 Interrupt/Status Register */
+#define DMA2_4_PERIPHERAL_MAP 0xFFC00D2C /* DMA2 Channel 4 Peripheral Map Register */
+
+#define DMA2_5_CONFIG 0xFFC00D48 /* DMA2 Channel 5 Configuration register */
+#define DMA2_5_NEXT_DESC_PTR 0xFFC00D40 /* DMA2 Channel 5 Next Descripter Ptr Reg */
+#define DMA2_5_START_ADDR 0xFFC00D44 /* DMA2 Channel 5 Start Address */
+#define DMA2_5_X_COUNT 0xFFC00D50 /* DMA2 Channel 5 Inner Loop Count */
+#define DMA2_5_Y_COUNT 0xFFC00D58 /* DMA2 Channel 5 Outer Loop Count */
+#define DMA2_5_X_MODIFY 0xFFC00D54 /* DMA2 Channel 5 Inner Loop Addr Increment */
+#define DMA2_5_Y_MODIFY 0xFFC00D5C /* DMA2 Channel 5 Outer Loop Addr Increment */
+#define DMA2_5_CURR_DESC_PTR 0xFFC00D60 /* DMA2 Channel 5 Current Descriptor Pointer */
+#define DMA2_5_CURR_ADDR 0xFFC00D64 /* DMA2 Channel 5 Current Address Pointer */
+#define DMA2_5_CURR_X_COUNT 0xFFC00D70 /* DMA2 Channel 5 Current Inner Loop Count */
+#define DMA2_5_CURR_Y_COUNT 0xFFC00D78 /* DMA2 Channel 5 Current Outer Loop Count */
+#define DMA2_5_IRQ_STATUS 0xFFC00D68 /* DMA2 Channel 5 Interrupt/Status Register */
+#define DMA2_5_PERIPHERAL_MAP 0xFFC00D6C /* DMA2 Channel 5 Peripheral Map Register */
+
+#define DMA2_6_CONFIG 0xFFC00D88 /* DMA2 Channel 6 Configuration register */
+#define DMA2_6_NEXT_DESC_PTR 0xFFC00D80 /* DMA2 Channel 6 Next Descripter Ptr Reg */
+#define DMA2_6_START_ADDR 0xFFC00D84 /* DMA2 Channel 6 Start Address */
+#define DMA2_6_X_COUNT 0xFFC00D90 /* DMA2 Channel 6 Inner Loop Count */
+#define DMA2_6_Y_COUNT 0xFFC00D98 /* DMA2 Channel 6 Outer Loop Count */
+#define DMA2_6_X_MODIFY 0xFFC00D94 /* DMA2 Channel 6 Inner Loop Addr Increment */
+#define DMA2_6_Y_MODIFY 0xFFC00D9C /* DMA2 Channel 6 Outer Loop Addr Increment */
+#define DMA2_6_CURR_DESC_PTR 0xFFC00DA0 /* DMA2 Channel 6 Current Descriptor Pointer */
+#define DMA2_6_CURR_ADDR 0xFFC00DA4 /* DMA2 Channel 6 Current Address Pointer */
+#define DMA2_6_CURR_X_COUNT 0xFFC00DB0 /* DMA2 Channel 6 Current Inner Loop Count */
+#define DMA2_6_CURR_Y_COUNT 0xFFC00DB8 /* DMA2 Channel 6 Current Outer Loop Count */
+#define DMA2_6_IRQ_STATUS 0xFFC00DA8 /* DMA2 Channel 6 Interrupt/Status Register */
+#define DMA2_6_PERIPHERAL_MAP 0xFFC00DAC /* DMA2 Channel 6 Peripheral Map Register */
+
+#define DMA2_7_CONFIG 0xFFC00DC8 /* DMA2 Channel 7 Configuration register */
+#define DMA2_7_NEXT_DESC_PTR 0xFFC00DC0 /* DMA2 Channel 7 Next Descripter Ptr Reg */
+#define DMA2_7_START_ADDR 0xFFC00DC4 /* DMA2 Channel 7 Start Address */
+#define DMA2_7_X_COUNT 0xFFC00DD0 /* DMA2 Channel 7 Inner Loop Count */
+#define DMA2_7_Y_COUNT 0xFFC00DD8 /* DMA2 Channel 7 Outer Loop Count */
+#define DMA2_7_X_MODIFY 0xFFC00DD4 /* DMA2 Channel 7 Inner Loop Addr Increment */
+#define DMA2_7_Y_MODIFY 0xFFC00DDC /* DMA2 Channel 7 Outer Loop Addr Increment */
+#define DMA2_7_CURR_DESC_PTR 0xFFC00DE0 /* DMA2 Channel 7 Current Descriptor Pointer */
+#define DMA2_7_CURR_ADDR 0xFFC00DE4 /* DMA2 Channel 7 Current Address Pointer */
+#define DMA2_7_CURR_X_COUNT 0xFFC00DF0 /* DMA2 Channel 7 Current Inner Loop Count */
+#define DMA2_7_CURR_Y_COUNT 0xFFC00DF8 /* DMA2 Channel 7 Current Outer Loop Count */
+#define DMA2_7_IRQ_STATUS 0xFFC00DE8 /* DMA2 Channel 7 Interrupt/Status Register */
+#define DMA2_7_PERIPHERAL_MAP 0xFFC00DEC /* DMA2 Channel 7 Peripheral Map Register */
+
+#define DMA2_8_CONFIG 0xFFC00E08 /* DMA2 Channel 8 Configuration register */
+#define DMA2_8_NEXT_DESC_PTR 0xFFC00E00 /* DMA2 Channel 8 Next Descripter Ptr Reg */
+#define DMA2_8_START_ADDR 0xFFC00E04 /* DMA2 Channel 8 Start Address */
+#define DMA2_8_X_COUNT 0xFFC00E10 /* DMA2 Channel 8 Inner Loop Count */
+#define DMA2_8_Y_COUNT 0xFFC00E18 /* DMA2 Channel 8 Outer Loop Count */
+#define DMA2_8_X_MODIFY 0xFFC00E14 /* DMA2 Channel 8 Inner Loop Addr Increment */
+#define DMA2_8_Y_MODIFY 0xFFC00E1C /* DMA2 Channel 8 Outer Loop Addr Increment */
+#define DMA2_8_CURR_DESC_PTR 0xFFC00E20 /* DMA2 Channel 8 Current Descriptor Pointer */
+#define DMA2_8_CURR_ADDR 0xFFC00E24 /* DMA2 Channel 8 Current Address Pointer */
+#define DMA2_8_CURR_X_COUNT 0xFFC00E30 /* DMA2 Channel 8 Current Inner Loop Count */
+#define DMA2_8_CURR_Y_COUNT 0xFFC00E38 /* DMA2 Channel 8 Current Outer Loop Count */
+#define DMA2_8_IRQ_STATUS 0xFFC00E28 /* DMA2 Channel 8 Interrupt/Status Register */
+#define DMA2_8_PERIPHERAL_MAP 0xFFC00E2C /* DMA2 Channel 8 Peripheral Map Register */
+
+#define DMA2_9_CONFIG 0xFFC00E48 /* DMA2 Channel 9 Configuration register */
+#define DMA2_9_NEXT_DESC_PTR 0xFFC00E40 /* DMA2 Channel 9 Next Descripter Ptr Reg */
+#define DMA2_9_START_ADDR 0xFFC00E44 /* DMA2 Channel 9 Start Address */
+#define DMA2_9_X_COUNT 0xFFC00E50 /* DMA2 Channel 9 Inner Loop Count */
+#define DMA2_9_Y_COUNT 0xFFC00E58 /* DMA2 Channel 9 Outer Loop Count */
+#define DMA2_9_X_MODIFY 0xFFC00E54 /* DMA2 Channel 9 Inner Loop Addr Increment */
+#define DMA2_9_Y_MODIFY 0xFFC00E5C /* DMA2 Channel 9 Outer Loop Addr Increment */
+#define DMA2_9_CURR_DESC_PTR 0xFFC00E60 /* DMA2 Channel 9 Current Descriptor Pointer */
+#define DMA2_9_CURR_ADDR 0xFFC00E64 /* DMA2 Channel 9 Current Address Pointer */
+#define DMA2_9_CURR_X_COUNT 0xFFC00E70 /* DMA2 Channel 9 Current Inner Loop Count */
+#define DMA2_9_CURR_Y_COUNT 0xFFC00E78 /* DMA2 Channel 9 Current Outer Loop Count */
+#define DMA2_9_IRQ_STATUS 0xFFC00E68 /* DMA2 Channel 9 Interrupt/Status Register */
+#define DMA2_9_PERIPHERAL_MAP 0xFFC00E6C /* DMA2 Channel 9 Peripheral Map Register */
+
+#define DMA2_10_CONFIG 0xFFC00E88 /* DMA2 Channel 10 Configuration register */
+#define DMA2_10_NEXT_DESC_PTR 0xFFC00E80 /* DMA2 Channel 10 Next Descripter Ptr Reg */
+#define DMA2_10_START_ADDR 0xFFC00E84 /* DMA2 Channel 10 Start Address */
+#define DMA2_10_X_COUNT 0xFFC00E90 /* DMA2 Channel 10 Inner Loop Count */
+#define DMA2_10_Y_COUNT 0xFFC00E98 /* DMA2 Channel 10 Outer Loop Count */
+#define DMA2_10_X_MODIFY 0xFFC00E94 /* DMA2 Channel 10 Inner Loop Addr Increment */
+#define DMA2_10_Y_MODIFY 0xFFC00E9C /* DMA2 Channel 10 Outer Loop Addr Increment */
+#define DMA2_10_CURR_DESC_PTR 0xFFC00EA0 /* DMA2 Channel 10 Current Descriptor Pointer */
+#define DMA2_10_CURR_ADDR 0xFFC00EA4 /* DMA2 Channel 10 Current Address Pointer */
+#define DMA2_10_CURR_X_COUNT 0xFFC00EB0 /* DMA2 Channel 10 Current Inner Loop Count */
+#define DMA2_10_CURR_Y_COUNT 0xFFC00EB8 /* DMA2 Channel 10 Current Outer Loop Count */
+#define DMA2_10_IRQ_STATUS 0xFFC00EA8 /* DMA2 Channel 10 Interrupt/Status Register */
+#define DMA2_10_PERIPHERAL_MAP 0xFFC00EAC /* DMA2 Channel 10 Peripheral Map Register */
+
+#define DMA2_11_CONFIG 0xFFC00EC8 /* DMA2 Channel 11 Configuration register */
+#define DMA2_11_NEXT_DESC_PTR 0xFFC00EC0 /* DMA2 Channel 11 Next Descripter Ptr Reg */
+#define DMA2_11_START_ADDR 0xFFC00EC4 /* DMA2 Channel 11 Start Address */
+#define DMA2_11_X_COUNT 0xFFC00ED0 /* DMA2 Channel 11 Inner Loop Count */
+#define DMA2_11_Y_COUNT 0xFFC00ED8 /* DMA2 Channel 11 Outer Loop Count */
+#define DMA2_11_X_MODIFY 0xFFC00ED4 /* DMA2 Channel 11 Inner Loop Addr Increment */
+#define DMA2_11_Y_MODIFY 0xFFC00EDC /* DMA2 Channel 11 Outer Loop Addr Increment */
+#define DMA2_11_CURR_DESC_PTR 0xFFC00EE0 /* DMA2 Channel 11 Current Descriptor Pointer */
+#define DMA2_11_CURR_ADDR 0xFFC00EE4 /* DMA2 Channel 11 Current Address Pointer */
+#define DMA2_11_CURR_X_COUNT 0xFFC00EF0 /* DMA2 Channel 11 Current Inner Loop Count */
+#define DMA2_11_CURR_Y_COUNT 0xFFC00EF8 /* DMA2 Channel 11 Current Outer Loop Count */
+#define DMA2_11_IRQ_STATUS 0xFFC00EE8 /* DMA2 Channel 11 Interrupt/Status Register */
+#define DMA2_11_PERIPHERAL_MAP 0xFFC00EEC /* DMA2 Channel 11 Peripheral Map Register */
+
+/* Memory DMA2 Controller registers (0xFFC0 0E80-0xFFC0 0FFF) */
+#define MDMA2_D0_CONFIG 0xFFC00F08 /*MemDMA2 Stream 0 Destination Configuration register */
+#define MDMA2_D0_NEXT_DESC_PTR 0xFFC00F00 /*MemDMA2 Stream 0 Destination Next Descriptor Ptr Reg */
+#define MDMA2_D0_START_ADDR 0xFFC00F04 /*MemDMA2 Stream 0 Destination Start Address */
+#define MDMA2_D0_X_COUNT 0xFFC00F10 /*MemDMA2 Stream 0 Dest Inner-Loop Count register */
+#define MDMA2_D0_Y_COUNT 0xFFC00F18 /*MemDMA2 Stream 0 Dest Outer-Loop Count register */
+#define MDMA2_D0_X_MODIFY 0xFFC00F14 /*MemDMA2 Stream 0 Dest Inner-Loop Address-Increment */
+#define MDMA2_D0_Y_MODIFY 0xFFC00F1C /*MemDMA2 Stream 0 Dest Outer-Loop Address-Increment */
+#define MDMA2_D0_CURR_DESC_PTR 0xFFC00F20 /*MemDMA2 Stream 0 Dest Current Descriptor Ptr reg */
+#define MDMA2_D0_CURR_ADDR 0xFFC00F24 /*MemDMA2 Stream 0 Destination Current Address */
+#define MDMA2_D0_CURR_X_COUNT 0xFFC00F30 /*MemDMA2 Stream 0 Dest Current Inner-Loop Count reg */
+#define MDMA2_D0_CURR_Y_COUNT 0xFFC00F38 /*MemDMA2 Stream 0 Dest Current Outer-Loop Count reg */
+#define MDMA2_D0_IRQ_STATUS 0xFFC00F28 /*MemDMA2 Stream 0 Dest Interrupt/Status Register */
+#define MDMA2_D0_PERIPHERAL_MAP 0xFFC00F2C /*MemDMA2 Stream 0 Destination Peripheral Map register */
+
+#define MDMA2_S0_CONFIG 0xFFC00F48 /*MemDMA2 Stream 0 Source Configuration register */
+#define MDMA2_S0_NEXT_DESC_PTR 0xFFC00F40 /*MemDMA2 Stream 0 Source Next Descriptor Ptr Reg */
+#define MDMA2_S0_START_ADDR 0xFFC00F44 /*MemDMA2 Stream 0 Source Start Address */
+#define MDMA2_S0_X_COUNT 0xFFC00F50 /*MemDMA2 Stream 0 Source Inner-Loop Count register */
+#define MDMA2_S0_Y_COUNT 0xFFC00F58 /*MemDMA2 Stream 0 Source Outer-Loop Count register */
+#define MDMA2_S0_X_MODIFY 0xFFC00F54 /*MemDMA2 Stream 0 Src Inner-Loop Addr-Increment reg */
+#define MDMA2_S0_Y_MODIFY 0xFFC00F5C /*MemDMA2 Stream 0 Src Outer-Loop Addr-Increment reg */
+#define MDMA2_S0_CURR_DESC_PTR 0xFFC00F60 /*MemDMA2 Stream 0 Source Current Descriptor Ptr reg */
+#define MDMA2_S0_CURR_ADDR 0xFFC00F64 /*MemDMA2 Stream 0 Source Current Address */
+#define MDMA2_S0_CURR_X_COUNT 0xFFC00F70 /*MemDMA2 Stream 0 Src Current Inner-Loop Count reg */
+#define MDMA2_S0_CURR_Y_COUNT 0xFFC00F78 /*MemDMA2 Stream 0 Src Current Outer-Loop Count reg */
+#define MDMA2_S0_IRQ_STATUS 0xFFC00F68 /*MemDMA2 Stream 0 Source Interrupt/Status Register */
+#define MDMA2_S0_PERIPHERAL_MAP 0xFFC00F6C /*MemDMA2 Stream 0 Source Peripheral Map register */
+
+#define MDMA2_D1_CONFIG 0xFFC00F88 /*MemDMA2 Stream 1 Destination Configuration register */
+#define MDMA2_D1_NEXT_DESC_PTR 0xFFC00F80 /*MemDMA2 Stream 1 Destination Next Descriptor Ptr Reg */
+#define MDMA2_D1_START_ADDR 0xFFC00F84 /*MemDMA2 Stream 1 Destination Start Address */
+#define MDMA2_D1_X_COUNT 0xFFC00F90 /*MemDMA2 Stream 1 Dest Inner-Loop Count register */
+#define MDMA2_D1_Y_COUNT 0xFFC00F98 /*MemDMA2 Stream 1 Dest Outer-Loop Count register */
+#define MDMA2_D1_X_MODIFY 0xFFC00F94 /*MemDMA2 Stream 1 Dest Inner-Loop Address-Increment */
+#define MDMA2_D1_Y_MODIFY 0xFFC00F9C /*MemDMA2 Stream 1 Dest Outer-Loop Address-Increment */
+#define MDMA2_D1_CURR_DESC_PTR 0xFFC00FA0 /*MemDMA2 Stream 1 Destination Current Descriptor Ptr */
+#define MDMA2_D1_CURR_ADDR 0xFFC00FA4 /*MemDMA2 Stream 1 Destination Current Address reg */
+#define MDMA2_D1_CURR_X_COUNT 0xFFC00FB0 /*MemDMA2 Stream 1 Dest Current Inner-Loop Count reg */
+#define MDMA2_D1_CURR_Y_COUNT 0xFFC00FB8 /*MemDMA2 Stream 1 Dest Current Outer-Loop Count reg */
+#define MDMA2_D1_IRQ_STATUS 0xFFC00FA8 /*MemDMA2 Stream 1 Destination Interrupt/Status Reg */
+#define MDMA2_D1_PERIPHERAL_MAP 0xFFC00FAC /*MemDMA2 Stream 1 Destination Peripheral Map register */
+
+#define MDMA2_S1_CONFIG 0xFFC00FC8 /*MemDMA2 Stream 1 Source Configuration register */
+#define MDMA2_S1_NEXT_DESC_PTR 0xFFC00FC0 /*MemDMA2 Stream 1 Source Next Descriptor Ptr Reg */
+#define MDMA2_S1_START_ADDR 0xFFC00FC4 /*MemDMA2 Stream 1 Source Start Address */
+#define MDMA2_S1_X_COUNT 0xFFC00FD0 /*MemDMA2 Stream 1 Source Inner-Loop Count register */
+#define MDMA2_S1_Y_COUNT 0xFFC00FD8 /*MemDMA2 Stream 1 Source Outer-Loop Count register */
+#define MDMA2_S1_X_MODIFY 0xFFC00FD4 /*MemDMA2 Stream 1 Src Inner-Loop Address-Increment */
+#define MDMA2_S1_Y_MODIFY 0xFFC00FDC /*MemDMA2 Stream 1 Source Outer-Loop Address-Increment */
+#define MDMA2_S1_CURR_DESC_PTR 0xFFC00FE0 /*MemDMA2 Stream 1 Source Current Descriptor Ptr reg */
+#define MDMA2_S1_CURR_ADDR 0xFFC00FE4 /*MemDMA2 Stream 1 Source Current Address */
+#define MDMA2_S1_CURR_X_COUNT 0xFFC00FF0 /*MemDMA2 Stream 1 Source Current Inner-Loop Count */
+#define MDMA2_S1_CURR_Y_COUNT 0xFFC00FF8 /*MemDMA2 Stream 1 Source Current Outer-Loop Count */
+#define MDMA2_S1_IRQ_STATUS 0xFFC00FE8 /*MemDMA2 Stream 1 Source Interrupt/Status Register */
+#define MDMA2_S1_PERIPHERAL_MAP 0xFFC00FEC /*MemDMA2 Stream 1 Source Peripheral Map register */
+
+/* Internal Memory DMA Registers (0xFFC0_1800 - 0xFFC0_19FF) */
+#define IMDMA_D0_CONFIG 0xFFC01808 /*IMDMA Stream 0 Destination Configuration */
+#define IMDMA_D0_NEXT_DESC_PTR 0xFFC01800 /*IMDMA Stream 0 Destination Next Descriptor Ptr Reg */
+#define IMDMA_D0_START_ADDR 0xFFC01804 /*IMDMA Stream 0 Destination Start Address */
+#define IMDMA_D0_X_COUNT 0xFFC01810 /*IMDMA Stream 0 Destination Inner-Loop Count */
+#define IMDMA_D0_Y_COUNT 0xFFC01818 /*IMDMA Stream 0 Destination Outer-Loop Count */
+#define IMDMA_D0_X_MODIFY 0xFFC01814 /*IMDMA Stream 0 Dest Inner-Loop Address-Increment */
+#define IMDMA_D0_Y_MODIFY 0xFFC0181C /*IMDMA Stream 0 Dest Outer-Loop Address-Increment */
+#define IMDMA_D0_CURR_DESC_PTR 0xFFC01820 /*IMDMA Stream 0 Destination Current Descriptor Ptr */
+#define IMDMA_D0_CURR_ADDR 0xFFC01824 /*IMDMA Stream 0 Destination Current Address */
+#define IMDMA_D0_CURR_X_COUNT 0xFFC01830 /*IMDMA Stream 0 Destination Current Inner-Loop Count */
+#define IMDMA_D0_CURR_Y_COUNT 0xFFC01838 /*IMDMA Stream 0 Destination Current Outer-Loop Count */
+#define IMDMA_D0_IRQ_STATUS 0xFFC01828 /*IMDMA Stream 0 Destination Interrupt/Status */
+
+#define IMDMA_S0_CONFIG 0xFFC01848 /*IMDMA Stream 0 Source Configuration */
+#define IMDMA_S0_NEXT_DESC_PTR 0xFFC01840 /*IMDMA Stream 0 Source Next Descriptor Ptr Reg */
+#define IMDMA_S0_START_ADDR 0xFFC01844 /*IMDMA Stream 0 Source Start Address */
+#define IMDMA_S0_X_COUNT 0xFFC01850 /*IMDMA Stream 0 Source Inner-Loop Count */
+#define IMDMA_S0_Y_COUNT 0xFFC01858 /*IMDMA Stream 0 Source Outer-Loop Count */
+#define IMDMA_S0_X_MODIFY 0xFFC01854 /*IMDMA Stream 0 Source Inner-Loop Address-Increment */
+#define IMDMA_S0_Y_MODIFY 0xFFC0185C /*IMDMA Stream 0 Source Outer-Loop Address-Increment */
+#define IMDMA_S0_CURR_DESC_PTR 0xFFC01860 /*IMDMA Stream 0 Source Current Descriptor Ptr reg */
+#define IMDMA_S0_CURR_ADDR 0xFFC01864 /*IMDMA Stream 0 Source Current Address */
+#define IMDMA_S0_CURR_X_COUNT 0xFFC01870 /*IMDMA Stream 0 Source Current Inner-Loop Count */
+#define IMDMA_S0_CURR_Y_COUNT 0xFFC01878 /*IMDMA Stream 0 Source Current Outer-Loop Count */
+#define IMDMA_S0_IRQ_STATUS 0xFFC01868 /*IMDMA Stream 0 Source Interrupt/Status */
+
+#define IMDMA_D1_CONFIG 0xFFC01888 /*IMDMA Stream 1 Destination Configuration */
+#define IMDMA_D1_NEXT_DESC_PTR 0xFFC01880 /*IMDMA Stream 1 Destination Next Descriptor Ptr Reg */
+#define IMDMA_D1_START_ADDR 0xFFC01884 /*IMDMA Stream 1 Destination Start Address */
+#define IMDMA_D1_X_COUNT 0xFFC01890 /*IMDMA Stream 1 Destination Inner-Loop Count */
+#define IMDMA_D1_Y_COUNT 0xFFC01898 /*IMDMA Stream 1 Destination Outer-Loop Count */
+#define IMDMA_D1_X_MODIFY 0xFFC01894 /*IMDMA Stream 1 Dest Inner-Loop Address-Increment */
+#define IMDMA_D1_Y_MODIFY 0xFFC0189C /*IMDMA Stream 1 Dest Outer-Loop Address-Increment */
+#define IMDMA_D1_CURR_DESC_PTR 0xFFC018A0 /*IMDMA Stream 1 Destination Current Descriptor Ptr */
+#define IMDMA_D1_CURR_ADDR 0xFFC018A4 /*IMDMA Stream 1 Destination Current Address */
+#define IMDMA_D1_CURR_X_COUNT 0xFFC018B0 /*IMDMA Stream 1 Destination Current Inner-Loop Count */
+#define IMDMA_D1_CURR_Y_COUNT 0xFFC018B8 /*IMDMA Stream 1 Destination Current Outer-Loop Count */
+#define IMDMA_D1_IRQ_STATUS 0xFFC018A8 /*IMDMA Stream 1 Destination Interrupt/Status */
+
+#define IMDMA_S1_CONFIG 0xFFC018C8 /*IMDMA Stream 1 Source Configuration */
+#define IMDMA_S1_NEXT_DESC_PTR 0xFFC018C0 /*IMDMA Stream 1 Source Next Descriptor Ptr Reg */
+#define IMDMA_S1_START_ADDR 0xFFC018C4 /*IMDMA Stream 1 Source Start Address */
+#define IMDMA_S1_X_COUNT 0xFFC018D0 /*IMDMA Stream 1 Source Inner-Loop Count */
+#define IMDMA_S1_Y_COUNT 0xFFC018D8 /*IMDMA Stream 1 Source Outer-Loop Count */
+#define IMDMA_S1_X_MODIFY 0xFFC018D4 /*IMDMA Stream 1 Source Inner-Loop Address-Increment */
+#define IMDMA_S1_Y_MODIFY 0xFFC018DC /*IMDMA Stream 1 Source Outer-Loop Address-Increment */
+#define IMDMA_S1_CURR_DESC_PTR 0xFFC018E0 /*IMDMA Stream 1 Source Current Descriptor Ptr reg */
+#define IMDMA_S1_CURR_ADDR 0xFFC018E4 /*IMDMA Stream 1 Source Current Address */
+#define IMDMA_S1_CURR_X_COUNT 0xFFC018F0 /*IMDMA Stream 1 Source Current Inner-Loop Count */
+#define IMDMA_S1_CURR_Y_COUNT 0xFFC018F8 /*IMDMA Stream 1 Source Current Outer-Loop Count */
+#define IMDMA_S1_IRQ_STATUS 0xFFC018E8 /*IMDMA Stream 1 Source Interrupt/Status */
+
+/*********************************************************************************** */
+/* System MMR Register Bits */
+/******************************************************************************* */
+
+/* ********************* PLL AND RESET MASKS ************************ */
+
+/*// PLL_CTL Masks */
+#define PLL_CLKIN              0x00000000  /* Pass CLKIN to PLL */
+#define PLL_CLKIN_DIV2         0x00000001  /* Pass CLKIN/2 to PLL */
+#define PLL_OFF                0x00000002  /* Shut off PLL clocks */
+#define STOPCK_OFF             0x00000008  /* Core clock off */
+#define PDWN                   0x00000020  /* Put the PLL in a Deep Sleep state */
+#define BYPASS                 0x00000100  /* Bypass the PLL */
+
+/*// PLL_DIV Masks */
+
+#define SCLK_DIV(x)  (x)		   /* SCLK = VCO / x */
+
+#define CCLK_DIV1              0x00000000  /* CCLK = VCO / 1 */
+#define CCLK_DIV2              0x00000010  /* CCLK = VCO / 2 */
+#define CCLK_DIV4              0x00000020  /* CCLK = VCO / 4 */
+#define CCLK_DIV8              0x00000030  /* CCLK = VCO / 8 */
+
+/* SWRST Mask */
+#define SYSTEM_RESET           0x00000007  /* Initiates a system software reset */
+#define SWRST_DBL_FAULT_B      0x00000800  /* SWRST Core B Double Fault */
+#define SWRST_DBL_FAULT_A      0x00001000  /* SWRST Core A Double Fault */
+#define SWRST_WDT_B		       0x00002000  /* SWRST Watchdog B */
+#define SWRST_WDT_A		       0x00004000  /* SWRST Watchdog A */
+#define SWRST_OCCURRED         0x00008000  /* SWRST Status */
+
+/* *************  SYSTEM INTERRUPT CONTROLLER MASKS ***************** */
+
+/* SICu_IARv Masks	 */
+/* u = A or B */
+/* v = 0 to 7 */
+/* w = 0 or 1 */
+
+/* Per_number = 0 to 63 */
+/* IVG_number = 7 to 15   */
+#define Peripheral_IVG(Per_number, IVG_number)    \
+    ((IVG_number) - 7) << (((Per_number) % 8) * 4) /* Peripheral #Per_number assigned IVG #IVG_number  */
+    /* Usage: r0.l = lo(Peripheral_IVG(62, 10)); */
+    /*        r0.h = hi(Peripheral_IVG(62, 10)); */
+
+/* SICx_IMASKw Masks */
+/* masks are 32 bit wide, so two writes reguired for "64 bit" wide registers  */
+#define SIC_UNMASK_ALL         0x00000000  /* Unmask all peripheral interrupts */
+#define SIC_MASK_ALL           0xFFFFFFFF  /* Mask all peripheral interrupts */
+#define SIC_MASK(x)	       (1 << (x))    /* Mask Peripheral #x interrupt */
+#define SIC_UNMASK(x) (0xFFFFFFFF ^ (1 << (x))) /* Unmask Peripheral #x interrupt */
+
+/* SIC_IWR Masks */
+#define IWR_DISABLE_ALL        0x00000000  /* Wakeup Disable all peripherals */
+#define IWR_ENABLE_ALL         0xFFFFFFFF  /* Wakeup Enable all peripherals */
+/* x = pos 0 to 31, for 32-63 use value-32 */
+#define IWR_ENABLE(x)	       (1 << (x))    /* Wakeup Enable Peripheral #x */
+#define IWR_DISABLE(x) (0xFFFFFFFF ^ (1 << (x))) /* Wakeup Disable Peripheral #x */
+
+/* *********  WATCHDOG TIMER MASKS  ********************8 */
+
+/* Watchdog Timer WDOG_CTL Register */
+#define ICTL(x) ((x<<1) & 0x0006)
+#define ENABLE_RESET     0x00000000  /* Set Watchdog Timer to generate reset */
+#define ENABLE_NMI       0x00000002  /* Set Watchdog Timer to generate non-maskable interrupt */
+#define ENABLE_GPI       0x00000004  /* Set Watchdog Timer to generate general-purpose interrupt */
+#define DISABLE_EVT      0x00000006  /* Disable Watchdog Timer interrupts */
+
+#define TMR_EN		0x0000
+#define TMR_DIS		0x0AD0
+#define TRO		0x8000
+
+#define ICTL_P0		0x01
+#define ICTL_P1		0x02
+#define TRO_P		0x0F
+
+/* ***************************** UART CONTROLLER MASKS ********************** */
+
+/* UART_LCR Register */
+
+#define DLAB	0x80
+#define SB      0x40
+#define STP      0x20
+#define EPS     0x10
+#define PEN	0x08
+#define STB	0x04
+#define WLS(x)	((x-5) & 0x03)
+
+#define DLAB_P	0x07
+#define SB_P	0x06
+#define STP_P	0x05
+#define EPS_P	0x04
+#define PEN_P	0x03
+#define STB_P	0x02
+#define WLS_P1	0x01
+#define WLS_P0	0x00
+
+/* UART_MCR Register */
+#define LOOP_ENA	0x10
+#define LOOP_ENA_P	0x04
+
+/* UART_LSR Register */
+#define TEMT	0x40
+#define THRE	0x20
+#define BI	0x10
+#define FE	0x08
+#define PE	0x04
+#define OE	0x02
+#define DR	0x01
+
+#define TEMP_P	0x06
+#define THRE_P	0x05
+#define BI_P	0x04
+#define FE_P	0x03
+#define PE_P	0x02
+#define OE_P	0x01
+#define DR_P	0x00
+
+/* UART_IER Register */
+#define ELSI	0x04
+#define ETBEI	0x02
+#define ERBFI	0x01
+
+#define ELSI_P	0x02
+#define ETBEI_P	0x01
+#define ERBFI_P	0x00
+
+/* UART_IIR Register */
+#define STATUS(x)	((x << 1) & 0x06)
+#define NINT		0x01
+#define STATUS_P1	0x02
+#define STATUS_P0	0x01
+#define NINT_P		0x00
+
+/* UART_GCTL Register */
+#define FFE	0x20
+#define FPE	0x10
+#define RPOLC	0x08
+#define TPOLC	0x04
+#define IREN	0x02
+#define UCEN	0x01
+
+#define FFE_P	0x05
+#define FPE_P	0x04
+#define RPOLC_P	0x03
+#define TPOLC_P	0x02
+#define IREN_P	0x01
+#define UCEN_P	0x00
+
+/* **********  SERIAL PORT MASKS  ********************** */
+
+/* SPORTx_TCR1 Masks */
+#define TSPEN    0x0001  /* TX enable  */
+#define ITCLK    0x0002  /* Internal TX Clock Select  */
+#define TDTYPE   0x000C  /* TX Data Formatting Select */
+#define TLSBIT   0x0010  /* TX Bit Order */
+#define ITFS     0x0200  /* Internal TX Frame Sync Select  */
+#define TFSR     0x0400  /* TX Frame Sync Required Select  */
+#define DITFS    0x0800  /* Data Independent TX Frame Sync Select  */
+#define LTFS     0x1000  /* Low TX Frame Sync Select  */
+#define LATFS    0x2000  /* Late TX Frame Sync Select  */
+#define TCKFE    0x4000  /* TX Clock Falling Edge Select  */
+
+/* SPORTx_TCR2 Masks */
+#define SLEN	    0x001F  /*TX Word Length  */
+#define TXSE        0x0100  /*TX Secondary Enable */
+#define TSFSE       0x0200  /*TX Stereo Frame Sync Enable */
+#define TRFST       0x0400  /*TX Right-First Data Order  */
+
+/* SPORTx_RCR1 Masks */
+#define RSPEN    0x0001  /* RX enable  */
+#define IRCLK    0x0002  /* Internal RX Clock Select  */
+#define RDTYPE   0x000C  /* RX Data Formatting Select */
+#define RULAW    0x0008  /* u-Law enable  */
+#define RALAW    0x000C  /* A-Law enable  */
+#define RLSBIT   0x0010  /* RX Bit Order */
+#define IRFS     0x0200  /* Internal RX Frame Sync Select  */
+#define RFSR     0x0400  /* RX Frame Sync Required Select  */
+#define LRFS     0x1000  /* Low RX Frame Sync Select  */
+#define LARFS    0x2000  /* Late RX Frame Sync Select  */
+#define RCKFE    0x4000  /* RX Clock Falling Edge Select  */
+
+/* SPORTx_RCR2 Masks */
+#define SLEN	    0x001F  /*RX Word Length  */
+#define RXSE        0x0100  /*RX Secondary Enable */
+#define RSFSE       0x0200  /*RX Stereo Frame Sync Enable */
+#define RRFST       0x0400  /*Right-First Data Order  */
+
+/*SPORTx_STAT Masks */
+#define RXNE		0x0001		/*RX FIFO Not Empty Status */
+#define RUVF	    	0x0002  	/*RX Underflow Status */
+#define ROVF		0x0004		/*RX Overflow Status */
+#define TXF		0x0008		/*TX FIFO Full Status */
+#define TUVF         	0x0010  	/*TX Underflow Status */
+#define TOVF         	0x0020  	/*TX Overflow Status */
+#define TXHRE        	0x0040  	/*TX Hold Register Empty */
+
+/*SPORTx_MCMC1 Masks */
+#define SP_WSIZE		0x0000F000 	/*Multichannel Window Size Field */
+#define SP_WOFF		0x000003FF 	/*Multichannel Window Offset Field */
+
+/*SPORTx_MCMC2 Masks */
+#define MCCRM		0x00000003 	/*Multichannel Clock Recovery Mode */
+#define MCDTXPE		0x00000004 	/*Multichannel DMA Transmit Packing */
+#define MCDRXPE		0x00000008 	/*Multichannel DMA Receive Packing */
+#define MCMEN		0x00000010 	/*Multichannel Frame Mode Enable */
+#define FSDR		0x00000080 	/*Multichannel Frame Sync to Data Relationship */
+#define MFD		0x0000F000 	/*Multichannel Frame Delay    */
+
+/*  *********  PARALLEL PERIPHERAL INTERFACE (PPI) MASKS ****************   */
+
+/*//  PPI_CONTROL Masks         */
+#define PORT_EN              0x00000001  /* PPI Port Enable  */
+#define PORT_DIR             0x00000002  /* PPI Port Direction       */
+#define XFR_TYPE             0x0000000C  /* PPI Transfer Type  */
+#define PORT_CFG             0x00000030  /* PPI Port Configuration */
+#define FLD_SEL              0x00000040  /* PPI Active Field Select */
+#define PACK_EN              0x00000080  /* PPI Packing Mode */
+#define DMA32                0x00000100  /* PPI 32-bit DMA Enable */
+#define SKIP_EN              0x00000200  /* PPI Skip Element Enable */
+#define SKIP_EO              0x00000400  /* PPI Skip Even/Odd Elements */
+#define DLENGTH              0x00003800  /* PPI Data Length  */
+#define DLEN_8		     0x0	     /* PPI Data Length mask for DLEN=8 */
+#define DLEN(x)	(((x-9) & 0x07) << 11)  /* PPI Data Length (only works for x=10-->x=16) */
+#define POL                  0x0000C000  /* PPI Signal Polarities       */
+
+/*// PPI_STATUS Masks                                          */
+#define FLD	             0x00000400  /* Field Indicator   */
+#define FT_ERR	             0x00000800  /* Frame Track Error */
+#define OVR	             0x00001000  /* FIFO Overflow Error */
+#define UNDR	             0x00002000  /* FIFO Underrun Error */
+#define ERR_DET	      	     0x00004000  /* Error Detected Indicator */
+#define ERR_NCOR	     0x00008000  /* Error Not Corrected Indicator */
+
+/* **********  DMA CONTROLLER MASKS  *********************8 */
+
+/*//DMAx_CONFIG, MDMA_yy_CONFIG, IMDMA_yy_CONFIG Masks */
+#define DMAEN	        0x00000001  /* Channel Enable */
+#define WNR	   	0x00000002  /* Channel Direction (W/R*) */
+#define WDSIZE_8	0x00000000  /* Word Size 8 bits */
+#define WDSIZE_16	0x00000004  /* Word Size 16 bits */
+#define WDSIZE_32	0x00000008  /* Word Size 32 bits */
+#define DMA2D	        0x00000010  /* 2D/1D* Mode */
+#define RESTART         0x00000020  /* Restart */
+#define DI_SEL	        0x00000040  /* Data Interrupt Select */
+#define DI_EN	        0x00000080  /* Data Interrupt Enable */
+#define NDSIZE	        0x00000900  /* Next Descriptor Size */
+#define FLOW	        0x00007000  /* Flow Control */
+
+#define DMAEN_P	            	0  /* Channel Enable */
+#define WNR_P	            	1  /* Channel Direction (W/R*) */
+#define DMA2D_P	        	4  /* 2D/1D* Mode */
+#define RESTART_P	      	5  /* Restart */
+#define DI_SEL_P	     	6  /* Data Interrupt Select */
+#define DI_EN_P	            	7  /* Data Interrupt Enable */
+
+/*//DMAx_IRQ_STATUS, MDMA_yy_IRQ_STATUS, IMDMA_yy_IRQ_STATUS Masks */
+
+#define DMA_DONE		0x00000001  /* DMA Done Indicator */
+#define DMA_ERR	        	0x00000002  /* DMA Error Indicator */
+#define DFETCH	            	0x00000004  /* Descriptor Fetch Indicator */
+#define DMA_RUN	            	0x00000008  /* DMA Running Indicator */
+
+#define DMA_DONE_P	    	0  /* DMA Done Indicator */
+#define DMA_ERR_P     		1 /* DMA Error Indicator */
+#define DFETCH_P     		2  /* Descriptor Fetch Indicator */
+#define DMA_RUN_P     		3  /* DMA Running Indicator */
+
+/*//DMAx_PERIPHERAL_MAP, MDMA_yy_PERIPHERAL_MAP, IMDMA_yy_PERIPHERAL_MAP Masks */
+
+#define CTYPE	            0x00000040  /* DMA Channel Type Indicator */
+#define CTYPE_P             6       /* DMA Channel Type Indicator BIT POSITION */
+#define PCAP8	            0x00000080  /* DMA 8-bit Operation Indicator   */
+#define PCAP16	            0x00000100  /* DMA 16-bit Operation Indicator */
+#define PCAP32	            0x00000200  /* DMA 32-bit Operation Indicator */
+#define PCAPWR	            0x00000400  /* DMA Write Operation Indicator */
+#define PCAPRD	            0x00000800  /* DMA Read Operation Indicator */
+#define PMAP	            0x00007000  /* DMA Peripheral Map Field */
+
+/*  *************  GENERAL PURPOSE TIMER MASKS  ******************** */
+
+/* PWM Timer bit definitions */
+
+/* TIMER_ENABLE Register */
+#define TIMEN0	0x0001
+#define TIMEN1	0x0002
+#define TIMEN2	0x0004
+#define TIMEN3	0x0008
+#define TIMEN4	0x0010
+#define TIMEN5	0x0020
+#define TIMEN6	0x0040
+#define TIMEN7	0x0080
+#define TIMEN8	0x0001
+#define TIMEN9	0x0002
+#define TIMEN10	0x0004
+#define TIMEN11	0x0008
+
+#define TIMEN0_P	0x00
+#define TIMEN1_P	0x01
+#define TIMEN2_P	0x02
+#define TIMEN3_P	0x03
+#define TIMEN4_P	0x04
+#define TIMEN5_P	0x05
+#define TIMEN6_P	0x06
+#define TIMEN7_P	0x07
+#define TIMEN8_P	0x00
+#define TIMEN9_P	0x01
+#define TIMEN10_P	0x02
+#define TIMEN11_P	0x03
+
+/* TIMER_DISABLE Register */
+#define TIMDIS0		0x0001
+#define TIMDIS1		0x0002
+#define TIMDIS2		0x0004
+#define TIMDIS3		0x0008
+#define TIMDIS4		0x0010
+#define TIMDIS5		0x0020
+#define TIMDIS6		0x0040
+#define TIMDIS7		0x0080
+#define TIMDIS8		0x0001
+#define TIMDIS9		0x0002
+#define TIMDIS10	0x0004
+#define TIMDIS11	0x0008
+
+#define TIMDIS0_P	0x00
+#define TIMDIS1_P	0x01
+#define TIMDIS2_P	0x02
+#define TIMDIS3_P	0x03
+#define TIMDIS4_P	0x04
+#define TIMDIS5_P	0x05
+#define TIMDIS6_P	0x06
+#define TIMDIS7_P	0x07
+#define TIMDIS8_P	0x00
+#define TIMDIS9_P	0x01
+#define TIMDIS10_P	0x02
+#define TIMDIS11_P	0x03
+
+/* TIMER_STATUS Register */
+#define TIMIL0		0x00000001
+#define TIMIL1		0x00000002
+#define TIMIL2		0x00000004
+#define TIMIL3		0x00000008
+#define TIMIL4		0x00010000
+#define TIMIL5		0x00020000
+#define TIMIL6		0x00040000
+#define TIMIL7		0x00080000
+#define TIMIL8		0x0001
+#define TIMIL9		0x0002
+#define TIMIL10		0x0004
+#define TIMIL11		0x0008
+#define TOVL_ERR0	0x00000010
+#define TOVL_ERR1	0x00000020
+#define TOVL_ERR2	0x00000040
+#define TOVL_ERR3	0x00000080
+#define TOVL_ERR4	0x00100000
+#define TOVL_ERR5	0x00200000
+#define TOVL_ERR6	0x00400000
+#define TOVL_ERR7	0x00800000
+#define TOVL_ERR8	0x0010
+#define TOVL_ERR9	0x0020
+#define TOVL_ERR10	0x0040
+#define TOVL_ERR11	0x0080
+#define TRUN0		0x00001000
+#define TRUN1		0x00002000
+#define TRUN2		0x00004000
+#define TRUN3		0x00008000
+#define TRUN4		0x10000000
+#define TRUN5		0x20000000
+#define TRUN6		0x40000000
+#define TRUN7		0x80000000
+#define TRUN8		0x1000
+#define TRUN9		0x2000
+#define TRUN10		0x4000
+#define TRUN11		0x8000
+
+#define TIMIL0_P	0x00
+#define TIMIL1_P	0x01
+#define TIMIL2_P	0x02
+#define TIMIL3_P	0x03
+#define TIMIL4_P	0x10
+#define TIMIL5_P	0x11
+#define TIMIL6_P	0x12
+#define TIMIL7_P	0x13
+#define TIMIL8_P	0x00
+#define TIMIL9_P	0x01
+#define TIMIL10_P	0x02
+#define TIMIL11_P	0x03
+#define TOVL_ERR0_P	0x04
+#define TOVL_ERR1_P	0x05
+#define TOVL_ERR2_P	0x06
+#define TOVL_ERR3_P	0x07
+#define TOVL_ERR4_P	0x14
+#define TOVL_ERR5_P	0x15
+#define TOVL_ERR6_P	0x16
+#define TOVL_ERR7_P	0x17
+#define TOVL_ERR8_P	0x04
+#define TOVL_ERR9_P	0x05
+#define TOVL_ERR10_P	0x06
+#define TOVL_ERR11_P	0x07
+#define TRUN0_P		0x0C
+#define TRUN1_P		0x0D
+#define TRUN2_P		0x0E
+#define TRUN3_P		0x0F
+#define TRUN4_P		0x1C
+#define TRUN5_P		0x1D
+#define TRUN6_P		0x1E
+#define TRUN7_P		0x1F
+#define TRUN8_P		0x0C
+#define TRUN9_P		0x0D
+#define TRUN10_P	0x0E
+#define TRUN11_P	0x0F
+
+/* TIMERx_CONFIG Registers */
+#define PWM_OUT		0x0001
+#define WDTH_CAP	0x0002
+#define EXT_CLK		0x0003
+#define PULSE_HI	0x0004
+#define PERIOD_CNT	0x0008
+#define IRQ_ENA		0x0010
+#define TIN_SEL		0x0020
+#define OUT_DIS		0x0040
+#define CLK_SEL		0x0080
+#define TOGGLE_HI	0x0100
+#define EMU_RUN		0x0200
+#define ERR_TYP(x)	((x & 0x03) << 14)
+
+#define TMODE_P0		0x00
+#define TMODE_P1		0x01
+#define PULSE_HI_P		0x02
+#define PERIOD_CNT_P		0x03
+#define IRQ_ENA_P		0x04
+#define TIN_SEL_P		0x05
+#define OUT_DIS_P		0x06
+#define CLK_SEL_P		0x07
+#define TOGGLE_HI_P		0x08
+#define EMU_RUN_P		0x09
+#define ERR_TYP_P0		0x0E
+#define ERR_TYP_P1		0x0F
+
+/*/ ******************   PROGRAMMABLE FLAG MASKS  ********************* */
+
+/*  General Purpose IO (0xFFC00700 - 0xFFC007FF)  Masks */
+#define PF0         0x0001
+#define PF1         0x0002
+#define PF2         0x0004
+#define PF3         0x0008
+#define PF4         0x0010
+#define PF5         0x0020
+#define PF6         0x0040
+#define PF7         0x0080
+#define PF8         0x0100
+#define PF9         0x0200
+#define PF10        0x0400
+#define PF11        0x0800
+#define PF12        0x1000
+#define PF13        0x2000
+#define PF14        0x4000
+#define PF15        0x8000
+
+/*  General Purpose IO (0xFFC00700 - 0xFFC007FF)  BIT POSITIONS */
+#define PF0_P         0
+#define PF1_P         1
+#define PF2_P         2
+#define PF3_P         3
+#define PF4_P         4
+#define PF5_P         5
+#define PF6_P         6
+#define PF7_P         7
+#define PF8_P         8
+#define PF9_P         9
+#define PF10_P        10
+#define PF11_P        11
+#define PF12_P        12
+#define PF13_P        13
+#define PF14_P        14
+#define PF15_P        15
+
+/* ***********  SERIAL PERIPHERAL INTERFACE (SPI) MASKS  **************** */
+
+/*// SPI_CTL Masks */
+#define TIMOD                  0x00000003  /* Transfer initiation mode and interrupt generation */
+#define SZ                     0x00000004  /* Send Zero (=0) or last (=1) word when TDBR empty. */
+#define GM                     0x00000008  /* When RDBR full, get more (=1) data or discard (=0) incoming Data */
+#define PSSE                   0x00000010  /* Enable (=1) Slave-Select input for Master. */
+#define EMISO                  0x00000020  /* Enable (=1) MISO pin as an output. */
+#define SIZE                   0x00000100  /* Word length (0 => 8 bits, 1 => 16 bits) */
+#define LSBF                   0x00000200  /* Data format (0 => MSB sent/received first 1 => LSB sent/received first) */
+#define CPHA                   0x00000400  /* Clock phase (0 => SPICLK starts toggling in middle of xfer, 1 => SPICLK toggles at the beginning of xfer. */
+#define CPOL                   0x00000800  /* Clock polarity (0 => active-high, 1 => active-low) */
+#define MSTR                   0x00001000  /* Configures SPI as master (=1) or slave (=0) */
+#define WOM                    0x00002000  /* Open drain (=1) data output enable (for MOSI and MISO) */
+#define SPE                    0x00004000  /* SPI module enable (=1), disable (=0) */
+
+/*// SPI_FLG Masks */
+#define FLS1                   0x00000002  /* Enables (=1) SPI_FLOUT1 as flag output for SPI Slave-select */
+#define FLS2                   0x00000004  /* Enables (=1) SPI_FLOUT2 as flag output for SPI Slave-select */
+#define FLS3                   0x00000008  /* Enables (=1) SPI_FLOUT3 as flag output for SPI Slave-select */
+#define FLS4                   0x00000010  /* Enables (=1) SPI_FLOUT4 as flag output for SPI Slave-select */
+#define FLS5                   0x00000020  /* Enables (=1) SPI_FLOUT5 as flag output for SPI Slave-select */
+#define FLS6                   0x00000040  /* Enables (=1) SPI_FLOUT6 as flag output for SPI Slave-select */
+#define FLS7                   0x00000080  /* Enables (=1) SPI_FLOUT7 as flag output for SPI Slave-select */
+#define FLG1                   0x00000200  /* Activates (=0) SPI_FLOUT1 as flag output for SPI Slave-select  */
+#define FLG2                   0x00000400  /* Activates (=0) SPI_FLOUT2 as flag output for SPI Slave-select */
+#define FLG3                   0x00000800  /* Activates (=0) SPI_FLOUT3 as flag output for SPI Slave-select  */
+#define FLG4                   0x00001000  /* Activates (=0) SPI_FLOUT4 as flag output for SPI Slave-select  */
+#define FLG5                   0x00002000  /* Activates (=0) SPI_FLOUT5 as flag output for SPI Slave-select  */
+#define FLG6                   0x00004000  /* Activates (=0) SPI_FLOUT6 as flag output for SPI Slave-select  */
+#define FLG7                   0x00008000  /* Activates (=0) SPI_FLOUT7 as flag output for SPI Slave-select */
+
+/*// SPI_FLG Bit Positions */
+#define FLS1_P                 0x00000001  /* Enables (=1) SPI_FLOUT1 as flag output for SPI Slave-select */
+#define FLS2_P                 0x00000002  /* Enables (=1) SPI_FLOUT2 as flag output for SPI Slave-select */
+#define FLS3_P                 0x00000003  /* Enables (=1) SPI_FLOUT3 as flag output for SPI Slave-select */
+#define FLS4_P                 0x00000004  /* Enables (=1) SPI_FLOUT4 as flag output for SPI Slave-select */
+#define FLS5_P                 0x00000005  /* Enables (=1) SPI_FLOUT5 as flag output for SPI Slave-select */
+#define FLS6_P                 0x00000006  /* Enables (=1) SPI_FLOUT6 as flag output for SPI Slave-select */
+#define FLS7_P                 0x00000007  /* Enables (=1) SPI_FLOUT7 as flag output for SPI Slave-select */
+#define FLG1_P                 0x00000009  /* Activates (=0) SPI_FLOUT1 as flag output for SPI Slave-select  */
+#define FLG2_P                 0x0000000A  /* Activates (=0) SPI_FLOUT2 as flag output for SPI Slave-select */
+#define FLG3_P                 0x0000000B  /* Activates (=0) SPI_FLOUT3 as flag output for SPI Slave-select  */
+#define FLG4_P                 0x0000000C  /* Activates (=0) SPI_FLOUT4 as flag output for SPI Slave-select  */
+#define FLG5_P                 0x0000000D  /* Activates (=0) SPI_FLOUT5 as flag output for SPI Slave-select  */
+#define FLG6_P                 0x0000000E  /* Activates (=0) SPI_FLOUT6 as flag output for SPI Slave-select  */
+#define FLG7_P                 0x0000000F  /* Activates (=0) SPI_FLOUT7 as flag output for SPI Slave-select */
+
+/*// SPI_STAT Masks */
+#define SPIF                   0x00000001  /* Set (=1) when SPI single-word transfer complete */
+#define MODF                   0x00000002  /* Set (=1) in a master device when some other device tries to become master */
+#define TXE                    0x00000004  /* Set (=1) when transmission occurs with no new data in SPI_TDBR */
+#define TXS                    0x00000008  /* SPI_TDBR Data Buffer Status (0=Empty, 1=Full) */
+#define RBSY                   0x00000010  /* Set (=1) when data is received with RDBR full */
+#define RXS                    0x00000020  /* SPI_RDBR Data Buffer Status (0=Empty, 1=Full)  */
+#define TXCOL                  0x00000040  /* When set (=1), corrupt data may have been transmitted  */
+
+/* *********************  ASYNCHRONOUS MEMORY CONTROLLER MASKS  ************* */
+
+/* AMGCTL Masks */
+#define AMCKEN			0x0001  /* Enable CLKOUT */
+#define AMBEN_B0		0x0002  /* Enable Asynchronous Memory Bank 0 only */
+#define AMBEN_B0_B1		0x0004  /* Enable Asynchronous Memory Banks 0 & 1 only */
+#define AMBEN_B0_B1_B2	0x0006  /* Enable Asynchronous Memory Banks 0, 1, and 2 */
+#define AMBEN_ALL		0x0008  /* Enable Asynchronous Memory Banks (all) 0, 1, 2, and 3 */
+#define B0_PEN			0x0010  /* Enable 16-bit packing Bank 0  */
+#define B1_PEN			0x0020  /* Enable 16-bit packing Bank 1  */
+#define B2_PEN			0x0040  /* Enable 16-bit packing Bank 2  */
+#define B3_PEN			0x0080  /* Enable 16-bit packing Bank 3  */
+
+/* AMGCTL Bit Positions */
+#define AMCKEN_P		0x00000000  /* Enable CLKOUT */
+#define AMBEN_P0		0x00000001  /* Asynchronous Memory Enable, 000 - banks 0-3 disabled, 001 - Bank 0 enabled */
+#define AMBEN_P1		0x00000002  /* Asynchronous Memory Enable, 010 - banks 0&1 enabled,  011 - banks 0-3 enabled */
+#define AMBEN_P2		0x00000003 /* Asynchronous Memory Enable, 1xx - All banks (bank 0, 1, 2, and 3) enabled */
+#define B0_PEN_P			0x004  /* Enable 16-bit packing Bank 0  */
+#define B1_PEN_P			0x005  /* Enable 16-bit packing Bank 1  */
+#define B2_PEN_P			0x006  /* Enable 16-bit packing Bank 2  */
+#define B3_PEN_P			0x007  /* Enable 16-bit packing Bank 3  */
+
+/* AMBCTL0 Masks */
+#define B0RDYEN	0x00000001  /* Bank 0 RDY Enable, 0=disable, 1=enable */
+#define B0RDYPOL 0x00000002  /* Bank 0 RDY Active high, 0=active low, 1=active high */
+#define B0TT_1	0x00000004  /* Bank 0 Transition Time from Read to Write = 1 cycle */
+#define B0TT_2	0x00000008  /* Bank 0 Transition Time from Read to Write = 2 cycles */
+#define B0TT_3	0x0000000C  /* Bank 0 Transition Time from Read to Write = 3 cycles */
+#define B0TT_4	0x00000000  /* Bank 0 Transition Time from Read to Write = 4 cycles */
+#define B0ST_1	0x00000010  /* Bank 0 Setup Time from AOE asserted to Read/Write asserted=1 cycle */
+#define B0ST_2	0x00000020  /* Bank 0 Setup Time from AOE asserted to Read/Write asserted=2 cycles */
+#define B0ST_3	0x00000030  /* Bank 0 Setup Time from AOE asserted to Read/Write asserted=3 cycles */
+#define B0ST_4	0x00000000  /* Bank 0 Setup Time from AOE asserted to Read/Write asserted=4 cycles */
+#define B0HT_1	0x00000040  /* Bank 0 Hold Time from Read/Write deasserted to AOE deasserted = 1 cycle */
+#define B0HT_2	0x00000080  /* Bank 0 Hold Time from Read/Write deasserted to AOE deasserted = 2 cycles */
+#define B0HT_3	0x000000C0  /* Bank 0 Hold Time from Read/Write deasserted to AOE deasserted = 3 cycles */
+#define B0HT_0	0x00000000  /* Bank 0 Hold Time from Read/Write deasserted to AOE deasserted = 0 cycles */
+#define B0RAT_1			0x00000100  /* Bank 0 Read Access Time = 1 cycle */
+#define B0RAT_2			0x00000200  /* Bank 0 Read Access Time = 2 cycles */
+#define B0RAT_3			0x00000300  /* Bank 0 Read Access Time = 3 cycles */
+#define B0RAT_4			0x00000400  /* Bank 0 Read Access Time = 4 cycles */
+#define B0RAT_5			0x00000500  /* Bank 0 Read Access Time = 5 cycles */
+#define B0RAT_6			0x00000600  /* Bank 0 Read Access Time = 6 cycles */
+#define B0RAT_7			0x00000700  /* Bank 0 Read Access Time = 7 cycles */
+#define B0RAT_8			0x00000800  /* Bank 0 Read Access Time = 8 cycles */
+#define B0RAT_9			0x00000900  /* Bank 0 Read Access Time = 9 cycles */
+#define B0RAT_10		0x00000A00  /* Bank 0 Read Access Time = 10 cycles */
+#define B0RAT_11		0x00000B00  /* Bank 0 Read Access Time = 11 cycles */
+#define B0RAT_12		0x00000C00  /* Bank 0 Read Access Time = 12 cycles */
+#define B0RAT_13		0x00000D00  /* Bank 0 Read Access Time = 13 cycles */
+#define B0RAT_14		0x00000E00  /* Bank 0 Read Access Time = 14 cycles */
+#define B0RAT_15		0x00000F00  /* Bank 0 Read Access Time = 15 cycles */
+#define B0WAT_1			0x00001000  /* Bank 0 Write Access Time = 1 cycle */
+#define B0WAT_2			0x00002000  /* Bank 0 Write Access Time = 2 cycles */
+#define B0WAT_3			0x00003000  /* Bank 0 Write Access Time = 3 cycles */
+#define B0WAT_4			0x00004000  /* Bank 0 Write Access Time = 4 cycles */
+#define B0WAT_5			0x00005000  /* Bank 0 Write Access Time = 5 cycles */
+#define B0WAT_6			0x00006000  /* Bank 0 Write Access Time = 6 cycles */
+#define B0WAT_7			0x00007000  /* Bank 0 Write Access Time = 7 cycles */
+#define B0WAT_8			0x00008000  /* Bank 0 Write Access Time = 8 cycles */
+#define B0WAT_9			0x00009000  /* Bank 0 Write Access Time = 9 cycles */
+#define B0WAT_10		0x0000A000  /* Bank 0 Write Access Time = 10 cycles */
+#define B0WAT_11		0x0000B000  /* Bank 0 Write Access Time = 11 cycles */
+#define B0WAT_12		0x0000C000  /* Bank 0 Write Access Time = 12 cycles */
+#define B0WAT_13		0x0000D000  /* Bank 0 Write Access Time = 13 cycles */
+#define B0WAT_14		0x0000E000  /* Bank 0 Write Access Time = 14 cycles */
+#define B0WAT_15		0x0000F000  /* Bank 0 Write Access Time = 15 cycles */
+#define B1RDYEN			0x00010000  /* Bank 1 RDY enable, 0=disable, 1=enable */
+#define B1RDYPOL		0x00020000  /* Bank 1 RDY Active high, 0=active low, 1=active high */
+#define B1TT_1			0x00040000  /* Bank 1 Transition Time from Read to Write = 1 cycle */
+#define B1TT_2			0x00080000  /* Bank 1 Transition Time from Read to Write = 2 cycles */
+#define B1TT_3			0x000C0000  /* Bank 1 Transition Time from Read to Write = 3 cycles */
+#define B1TT_4			0x00000000  /* Bank 1 Transition Time from Read to Write = 4 cycles */
+#define B1ST_1			0x00100000  /* Bank 1 Setup Time from AOE asserted to Read or Write asserted = 1 cycle */
+#define B1ST_2			0x00200000  /* Bank 1 Setup Time from AOE asserted to Read or Write asserted = 2 cycles */
+#define B1ST_3			0x00300000  /* Bank 1 Setup Time from AOE asserted to Read or Write asserted = 3 cycles */
+#define B1ST_4			0x00000000  /* Bank 1 Setup Time from AOE asserted to Read or Write asserted = 4 cycles */
+#define B1HT_1			0x00400000  /* Bank 1 Hold Time from Read or Write deasserted to AOE deasserted = 1 cycle */
+#define B1HT_2			0x00800000  /* Bank 1 Hold Time from Read or Write deasserted to AOE deasserted = 2 cycles */
+#define B1HT_3			0x00C00000  /* Bank 1 Hold Time from Read or Write deasserted to AOE deasserted = 3 cycles */
+#define B1HT_0			0x00000000  /* Bank 1 Hold Time from Read or Write deasserted to AOE deasserted = 0 cycles */
+#define B1RAT_1			0x01000000  /* Bank 1 Read Access Time = 1 cycle */
+#define B1RAT_2			0x02000000  /* Bank 1 Read Access Time = 2 cycles */
+#define B1RAT_3			0x03000000  /* Bank 1 Read Access Time = 3 cycles */
+#define B1RAT_4			0x04000000  /* Bank 1 Read Access Time = 4 cycles */
+#define B1RAT_5			0x05000000  /* Bank 1 Read Access Time = 5 cycles */
+#define B1RAT_6			0x06000000  /* Bank 1 Read Access Time = 6 cycles */
+#define B1RAT_7			0x07000000  /* Bank 1 Read Access Time = 7 cycles */
+#define B1RAT_8			0x08000000  /* Bank 1 Read Access Time = 8 cycles */
+#define B1RAT_9			0x09000000  /* Bank 1 Read Access Time = 9 cycles */
+#define B1RAT_10		0x0A000000  /* Bank 1 Read Access Time = 10 cycles */
+#define B1RAT_11		0x0B000000  /* Bank 1 Read Access Time = 11 cycles */
+#define B1RAT_12		0x0C000000  /* Bank 1 Read Access Time = 12 cycles */
+#define B1RAT_13		0x0D000000  /* Bank 1 Read Access Time = 13 cycles */
+#define B1RAT_14		0x0E000000  /* Bank 1 Read Access Time = 14 cycles */
+#define B1RAT_15		0x0F000000  /* Bank 1 Read Access Time = 15 cycles */
+#define B1WAT_1			0x10000000 /* Bank 1 Write Access Time = 1 cycle */
+#define B1WAT_2			0x20000000  /* Bank 1 Write Access Time = 2 cycles */
+#define B1WAT_3			0x30000000  /* Bank 1 Write Access Time = 3 cycles */
+#define B1WAT_4			0x40000000  /* Bank 1 Write Access Time = 4 cycles */
+#define B1WAT_5			0x50000000  /* Bank 1 Write Access Time = 5 cycles */
+#define B1WAT_6			0x60000000  /* Bank 1 Write Access Time = 6 cycles */
+#define B1WAT_7			0x70000000  /* Bank 1 Write Access Time = 7 cycles */
+#define B1WAT_8			0x80000000  /* Bank 1 Write Access Time = 8 cycles */
+#define B1WAT_9			0x90000000  /* Bank 1 Write Access Time = 9 cycles */
+#define B1WAT_10		0xA0000000  /* Bank 1 Write Access Time = 10 cycles */
+#define B1WAT_11		0xB0000000  /* Bank 1 Write Access Time = 11 cycles */
+#define B1WAT_12		0xC0000000  /* Bank 1 Write Access Time = 12 cycles */
+#define B1WAT_13		0xD0000000  /* Bank 1 Write Access Time = 13 cycles */
+#define B1WAT_14		0xE0000000  /* Bank 1 Write Access Time = 14 cycles */
+#define B1WAT_15		0xF0000000  /* Bank 1 Write Access Time = 15 cycles */
+
+/* AMBCTL1 Masks */
+#define B2RDYEN			0x00000001  /* Bank 2 RDY Enable, 0=disable, 1=enable */
+#define B2RDYPOL		0x00000002  /* Bank 2 RDY Active high, 0=active low, 1=active high */
+#define B2TT_1			0x00000004  /* Bank 2 Transition Time from Read to Write = 1 cycle */
+#define B2TT_2			0x00000008  /* Bank 2 Transition Time from Read to Write = 2 cycles */
+#define B2TT_3			0x0000000C  /* Bank 2 Transition Time from Read to Write = 3 cycles */
+#define B2TT_4			0x00000000  /* Bank 2 Transition Time from Read to Write = 4 cycles */
+#define B2ST_1			0x00000010  /* Bank 2 Setup Time from AOE asserted to Read or Write asserted = 1 cycle */
+#define B2ST_2			0x00000020  /* Bank 2 Setup Time from AOE asserted to Read or Write asserted = 2 cycles */
+#define B2ST_3			0x00000030  /* Bank 2 Setup Time from AOE asserted to Read or Write asserted = 3 cycles */
+#define B2ST_4			0x00000000  /* Bank 2 Setup Time from AOE asserted to Read or Write asserted = 4 cycles */
+#define B2HT_1			0x00000040  /* Bank 2 Hold Time from Read or Write deasserted to AOE deasserted = 1 cycle */
+#define B2HT_2			0x00000080  /* Bank 2 Hold Time from Read or Write deasserted to AOE deasserted = 2 cycles */
+#define B2HT_3			0x000000C0  /* Bank 2 Hold Time from Read or Write deasserted to AOE deasserted = 3 cycles */
+#define B2HT_0			0x00000000  /* Bank 2 Hold Time from Read or Write deasserted to AOE deasserted = 0 cycles */
+#define B2RAT_1			0x00000100  /* Bank 2 Read Access Time = 1 cycle */
+#define B2RAT_2			0x00000200  /* Bank 2 Read Access Time = 2 cycles */
+#define B2RAT_3			0x00000300  /* Bank 2 Read Access Time = 3 cycles */
+#define B2RAT_4			0x00000400  /* Bank 2 Read Access Time = 4 cycles */
+#define B2RAT_5			0x00000500  /* Bank 2 Read Access Time = 5 cycles */
+#define B2RAT_6			0x00000600  /* Bank 2 Read Access Time = 6 cycles */
+#define B2RAT_7			0x00000700  /* Bank 2 Read Access Time = 7 cycles */
+#define B2RAT_8			0x00000800  /* Bank 2 Read Access Time = 8 cycles */
+#define B2RAT_9			0x00000900  /* Bank 2 Read Access Time = 9 cycles */
+#define B2RAT_10		0x00000A00  /* Bank 2 Read Access Time = 10 cycles */
+#define B2RAT_11		0x00000B00  /* Bank 2 Read Access Time = 11 cycles */
+#define B2RAT_12		0x00000C00  /* Bank 2 Read Access Time = 12 cycles */
+#define B2RAT_13		0x00000D00  /* Bank 2 Read Access Time = 13 cycles */
+#define B2RAT_14		0x00000E00  /* Bank 2 Read Access Time = 14 cycles */
+#define B2RAT_15		0x00000F00  /* Bank 2 Read Access Time = 15 cycles */
+#define B2WAT_1			0x00001000  /* Bank 2 Write Access Time = 1 cycle */
+#define B2WAT_2			0x00002000  /* Bank 2 Write Access Time = 2 cycles */
+#define B2WAT_3			0x00003000  /* Bank 2 Write Access Time = 3 cycles */
+#define B2WAT_4			0x00004000  /* Bank 2 Write Access Time = 4 cycles */
+#define B2WAT_5			0x00005000  /* Bank 2 Write Access Time = 5 cycles */
+#define B2WAT_6			0x00006000  /* Bank 2 Write Access Time = 6 cycles */
+#define B2WAT_7			0x00007000  /* Bank 2 Write Access Time = 7 cycles */
+#define B2WAT_8			0x00008000  /* Bank 2 Write Access Time = 8 cycles */
+#define B2WAT_9			0x00009000  /* Bank 2 Write Access Time = 9 cycles */
+#define B2WAT_10		0x0000A000  /* Bank 2 Write Access Time = 10 cycles */
+#define B2WAT_11		0x0000B000  /* Bank 2 Write Access Time = 11 cycles */
+#define B2WAT_12		0x0000C000  /* Bank 2 Write Access Time = 12 cycles */
+#define B2WAT_13		0x0000D000  /* Bank 2 Write Access Time = 13 cycles */
+#define B2WAT_14		0x0000E000  /* Bank 2 Write Access Time = 14 cycles */
+#define B2WAT_15		0x0000F000  /* Bank 2 Write Access Time = 15 cycles */
+#define B3RDYEN			0x00010000  /* Bank 3 RDY enable, 0=disable, 1=enable */
+#define B3RDYPOL		0x00020000  /* Bank 3 RDY Active high, 0=active low, 1=active high */
+#define B3TT_1			0x00040000  /* Bank 3 Transition Time from Read to Write = 1 cycle */
+#define B3TT_2			0x00080000  /* Bank 3 Transition Time from Read to Write = 2 cycles */
+#define B3TT_3			0x000C0000  /* Bank 3 Transition Time from Read to Write = 3 cycles */
+#define B3TT_4			0x00000000  /* Bank 3 Transition Time from Read to Write = 4 cycles */
+#define B3ST_1			0x00100000  /* Bank 3 Setup Time from AOE asserted to Read or Write asserted = 1 cycle */
+#define B3ST_2			0x00200000  /* Bank 3 Setup Time from AOE asserted to Read or Write asserted = 2 cycles */
+#define B3ST_3			0x00300000  /* Bank 3 Setup Time from AOE asserted to Read or Write asserted = 3 cycles */
+#define B3ST_4			0x00000000  /* Bank 3 Setup Time from AOE asserted to Read or Write asserted = 4 cycles */
+#define B3HT_1			0x00400000  /* Bank 3 Hold Time from Read or Write deasserted to AOE deasserted = 1 cycle */
+#define B3HT_2			0x00800000  /* Bank 3 Hold Time from Read or Write deasserted to AOE deasserted = 2 cycles */
+#define B3HT_3			0x00C00000  /* Bank 3 Hold Time from Read or Write deasserted to AOE deasserted = 3 cycles */
+#define B3HT_0			0x00000000  /* Bank 3 Hold Time from Read or Write deasserted to AOE deasserted = 0 cycles */
+#define B3RAT_1			0x01000000 /* Bank 3 Read Access Time = 1 cycle */
+#define B3RAT_2			0x02000000  /* Bank 3 Read Access Time = 2 cycles */
+#define B3RAT_3			0x03000000  /* Bank 3 Read Access Time = 3 cycles */
+#define B3RAT_4			0x04000000  /* Bank 3 Read Access Time = 4 cycles */
+#define B3RAT_5			0x05000000  /* Bank 3 Read Access Time = 5 cycles */
+#define B3RAT_6			0x06000000  /* Bank 3 Read Access Time = 6 cycles */
+#define B3RAT_7			0x07000000  /* Bank 3 Read Access Time = 7 cycles */
+#define B3RAT_8			0x08000000  /* Bank 3 Read Access Time = 8 cycles */
+#define B3RAT_9			0x09000000  /* Bank 3 Read Access Time = 9 cycles */
+#define B3RAT_10		0x0A000000  /* Bank 3 Read Access Time = 10 cycles */
+#define B3RAT_11		0x0B000000  /* Bank 3 Read Access Time = 11 cycles */
+#define B3RAT_12		0x0C000000  /* Bank 3 Read Access Time = 12 cycles */
+#define B3RAT_13		0x0D000000  /* Bank 3 Read Access Time = 13 cycles */
+#define B3RAT_14		0x0E000000  /* Bank 3 Read Access Time = 14 cycles */
+#define B3RAT_15		0x0F000000  /* Bank 3 Read Access Time = 15 cycles */
+#define B3WAT_1			0x10000000 /* Bank 3 Write Access Time = 1 cycle */
+#define B3WAT_2			0x20000000  /* Bank 3 Write Access Time = 2 cycles */
+#define B3WAT_3			0x30000000  /* Bank 3 Write Access Time = 3 cycles */
+#define B3WAT_4			0x40000000  /* Bank 3 Write Access Time = 4 cycles */
+#define B3WAT_5			0x50000000  /* Bank 3 Write Access Time = 5 cycles */
+#define B3WAT_6			0x60000000  /* Bank 3 Write Access Time = 6 cycles */
+#define B3WAT_7			0x70000000  /* Bank 3 Write Access Time = 7 cycles */
+#define B3WAT_8			0x80000000  /* Bank 3 Write Access Time = 8 cycles */
+#define B3WAT_9			0x90000000  /* Bank 3 Write Access Time = 9 cycles */
+#define B3WAT_10		0xA0000000  /* Bank 3 Write Access Time = 10 cycles */
+#define B3WAT_11		0xB0000000  /* Bank 3 Write Access Time = 11 cycles */
+#define B3WAT_12		0xC0000000  /* Bank 3 Write Access Time = 12 cycles */
+#define B3WAT_13		0xD0000000  /* Bank 3 Write Access Time = 13 cycles */
+#define B3WAT_14		0xE0000000  /* Bank 3 Write Access Time = 14 cycles */
+#define B3WAT_15		0xF0000000  /* Bank 3 Write Access Time = 15 cycles */
+
+/* **********************  SDRAM CONTROLLER MASKS  *************************** */
+
+/* EBIU_SDGCTL Masks */
+#define SCTLE			0x00000001 /* Enable SCLK[0], /SRAS, /SCAS, /SWE, SDQM[3:0] */
+#define CL_2			0x00000008 /* SDRAM CAS latency = 2 cycles */
+#define CL_3			0x0000000C /* SDRAM CAS latency = 3 cycles */
+#define PFE			0x00000010 /* Enable SDRAM prefetch */
+#define PFP			0x00000020 /* Prefetch has priority over AMC requests */
+#define TRAS_1			0x00000040 /* SDRAM tRAS = 1 cycle */
+#define TRAS_2			0x00000080 /* SDRAM tRAS = 2 cycles */
+#define TRAS_3			0x000000C0 /* SDRAM tRAS = 3 cycles */
+#define TRAS_4			0x00000100 /* SDRAM tRAS = 4 cycles */
+#define TRAS_5			0x00000140 /* SDRAM tRAS = 5 cycles */
+#define TRAS_6			0x00000180 /* SDRAM tRAS = 6 cycles */
+#define TRAS_7			0x000001C0 /* SDRAM tRAS = 7 cycles */
+#define TRAS_8			0x00000200 /* SDRAM tRAS = 8 cycles */
+#define TRAS_9			0x00000240 /* SDRAM tRAS = 9 cycles */
+#define TRAS_10			0x00000280 /* SDRAM tRAS = 10 cycles */
+#define TRAS_11			0x000002C0 /* SDRAM tRAS = 11 cycles */
+#define TRAS_12			0x00000300 /* SDRAM tRAS = 12 cycles */
+#define TRAS_13			0x00000340 /* SDRAM tRAS = 13 cycles */
+#define TRAS_14			0x00000380 /* SDRAM tRAS = 14 cycles */
+#define TRAS_15			0x000003C0 /* SDRAM tRAS = 15 cycles */
+#define TRP_1			0x00000800 /* SDRAM tRP = 1 cycle */
+#define TRP_2			0x00001000 /* SDRAM tRP = 2 cycles */
+#define TRP_3			0x00001800 /* SDRAM tRP = 3 cycles */
+#define TRP_4			0x00002000 /* SDRAM tRP = 4 cycles */
+#define TRP_5			0x00002800 /* SDRAM tRP = 5 cycles */
+#define TRP_6			0x00003000 /* SDRAM tRP = 6 cycles */
+#define TRP_7			0x00003800 /* SDRAM tRP = 7 cycles */
+#define TRCD_1			0x00008000 /* SDRAM tRCD = 1 cycle */
+#define TRCD_2			0x00010000 /* SDRAM tRCD = 2 cycles */
+#define TRCD_3			0x00018000 /* SDRAM tRCD = 3 cycles */
+#define TRCD_4			0x00020000 /* SDRAM tRCD = 4 cycles */
+#define TRCD_5			0x00028000 /* SDRAM tRCD = 5 cycles */
+#define TRCD_6			0x00030000 /* SDRAM tRCD = 6 cycles */
+#define TRCD_7			0x00038000 /* SDRAM tRCD = 7 cycles */
+#define TWR_1			0x00080000 /* SDRAM tWR = 1 cycle */
+#define TWR_2			0x00100000 /* SDRAM tWR = 2 cycles */
+#define TWR_3			0x00180000 /* SDRAM tWR = 3 cycles */
+#define PUPSD			0x00200000 /*Power-up start delay */
+#define PSM			0x00400000 /* SDRAM power-up sequence = Precharge, mode register set, 8 CBR refresh cycles */
+#define PSS				0x00800000 /* enable SDRAM power-up sequence on next SDRAM access */
+#define SRFS			0x01000000 /* Start SDRAM self-refresh mode */
+#define EBUFE			0x02000000 /* Enable external buffering timing */
+#define FBBRW			0x04000000 /* Fast back-to-back read write enable */
+#define EMREN			0x10000000 /* Extended mode register enable */
+#define TCSR			0x20000000 /* Temp compensated self refresh value 85 deg C */
+#define CDDBG			0x40000000 /* Tristate SDRAM controls during bus grant */
+
+/* EBIU_SDBCTL Masks */
+#define EB0_E				0x00000001 /* Enable SDRAM external bank 0 */
+#define EB0_SZ_16			0x00000000 /* SDRAM external bank size = 16MB */
+#define EB0_SZ_32			0x00000002 /* SDRAM external bank size = 32MB */
+#define EB0_SZ_64			0x00000004 /* SDRAM external bank size = 64MB */
+#define EB0_SZ_128			0x00000006 /* SDRAM external bank size = 128MB */
+#define EB0_CAW_8			0x00000000 /* SDRAM external bank column address width = 8 bits */
+#define EB0_CAW_9			0x00000010 /* SDRAM external bank column address width = 9 bits */
+#define EB0_CAW_10			0x00000020 /* SDRAM external bank column address width = 9 bits */
+#define EB0_CAW_11			0x00000030 /* SDRAM external bank column address width = 9 bits */
+
+#define EB1_E				0x00000100 /* Enable SDRAM external bank 1 */
+#define EB1__SZ_16			0x00000000 /* SDRAM external bank size = 16MB */
+#define EB1__SZ_32			0x00000200 /* SDRAM external bank size = 32MB */
+#define EB1__SZ_64			0x00000400 /* SDRAM external bank size = 64MB */
+#define EB1__SZ_128			0x00000600 /* SDRAM external bank size = 128MB */
+#define EB1__CAW_8			0x00000000 /* SDRAM external bank column address width = 8 bits */
+#define EB1__CAW_9			0x00001000 /* SDRAM external bank column address width = 9 bits */
+#define EB1__CAW_10			0x00002000 /* SDRAM external bank column address width = 9 bits */
+#define EB1__CAW_11			0x00003000 /* SDRAM external bank column address width = 9 bits */
+
+#define EB2__E				0x00010000 /* Enable SDRAM external bank 2 */
+#define EB2__SZ_16			0x00000000 /* SDRAM external bank size = 16MB */
+#define EB2__SZ_32			0x00020000 /* SDRAM external bank size = 32MB */
+#define EB2__SZ_64			0x00040000 /* SDRAM external bank size = 64MB */
+#define EB2__SZ_128			0x00060000 /* SDRAM external bank size = 128MB */
+#define EB2__CAW_8			0x00000000 /* SDRAM external bank column address width = 8 bits */
+#define EB2__CAW_9			0x00100000 /* SDRAM external bank column address width = 9 bits */
+#define EB2__CAW_10			0x00200000 /* SDRAM external bank column address width = 9 bits */
+#define EB2__CAW_11			0x00300000 /* SDRAM external bank column address width = 9 bits */
+
+#define EB3__E				0x01000000 /* Enable SDRAM external bank 3 */
+#define EB3__SZ_16			0x00000000 /* SDRAM external bank size = 16MB */
+#define EB3__SZ_32			0x02000000 /* SDRAM external bank size = 32MB */
+#define EB3__SZ_64			0x04000000 /* SDRAM external bank size = 64MB */
+#define EB3__SZ_128			0x06000000 /* SDRAM external bank size = 128MB */
+#define EB3__CAW_8			0x00000000 /* SDRAM external bank column address width = 8 bits */
+#define EB3__CAW_9			0x10000000 /* SDRAM external bank column address width = 9 bits */
+#define EB3__CAW_10			0x20000000 /* SDRAM external bank column address width = 9 bits */
+#define EB3__CAW_11			0x30000000 /* SDRAM external bank column address width = 9 bits */
+
+/* EBIU_SDSTAT Masks */
+#define SDCI			0x00000001 /* SDRAM controller is idle  */
+#define SDSRA			0x00000002 /* SDRAM SDRAM self refresh is active */
+#define SDPUA			0x00000004 /* SDRAM power up active  */
+#define SDRS			0x00000008 /* SDRAM is in reset state */
+#define SDEASE		    0x00000010 /* SDRAM EAB sticky error status - W1C */
+#define BGSTAT			0x00000020 /* Bus granted */
+
+/*VR_CTL Masks*/
+#define WAKE                    0x100
+#define VLEV_6                  0x60
+#define VLEV_7                  0x70
+#define VLEV_8                  0x80
+#define VLEV_9                  0x90
+#define VLEV_10                 0xA0
+#define VLEV_11                 0xB0
+#define VLEV_12                 0xC0
+#define VLEV_13                 0xD0
+#define VLEV_14                 0xE0
+#define VLEV_15                 0xF0
+#define FREQ_3                  0x03
+
+#endif	/* _DEF_BF561_H */
Index: git/linux-2.6/include/asm-blackfin/mach-bf561/dma.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf561/dma.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,37 @@
+/*****************************************************************************
+* $Id$
+*
+*        BF-533/2/1 Specific Declarations
+*
+****************************************************************************/
+
+#ifndef _MACH_DMA_H_
+#define _MACH_DMA_H_
+
+
+#define MAX_BLACKFIN_DMA_CHANNEL 36
+
+#define CH_PPI0			0
+#define CH_PPI			(CH_PPI0)
+#define CH_PPI1			1
+#define CH_SPORT0_RX		12
+#define CH_SPORT0_TX		13
+#define CH_SPORT1_RX		14
+#define CH_SPORT1_TX		15
+#define CH_SPI			16
+#define CH_UART_RX		17
+#define CH_UART_TX		18
+#define CH_MEM_STREAM0_DEST     24   // TX
+#define CH_MEM_STREAM0_SRC      25   // RX
+#define CH_MEM_STREAM1_DEST     26  // TX
+#define CH_MEM_STREAM1_SRC      27  // RX
+#define CH_MEM_STREAM2_DEST	28
+#define CH_MEM_STREAM2_SRC	29
+#define CH_MEM_STREAM3_SRC	30
+#define CH_MEM_STREAM3_DEST	31
+#define CH_IMEM_STREAM0_DEST	32
+#define CH_IMEM_STREAM0_SRC	33
+#define CH_IMEM_STREAM1_SRC	34
+#define CH_IMEM_STREAM1_DEST	35
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/mach-bf561/irq.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf561/irq.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,451 @@
+
+/*
+ * File:         include/asm-blackfin/mach-bf561/irq.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _BF561_IRQ_H_
+#define _BF561_IRQ_H_
+
+/***********************************************************************
+ * Interrupt source definitions:
+             Event Source		Core Event Name	    IRQ No
+						(highest priority)
+	    Emulation Events			EMU         0
+            Reset				RST         1
+            NMI					NMI         2
+            Exception				EVX         3
+            Reserved				--          4
+            Hardware Error			IVHW        5
+            Core Timer				IVTMR       6 *
+
+	    PLL Wakeup Interrupt		IVG7	    7
+	    DMA1 Error (generic)		IVG7	    8
+	    DMA2 Error (generic)		IVG7	    9
+	    IMDMA Error (generic)		IVG7	    10
+	    PPI1 Error Interrupt		IVG7	    11
+	    PPI2 Error Interrupt		IVG7	    12
+	    SPORT0 Error Interrupt		IVG7	    13
+	    SPORT1 Error Interrupt		IVG7	    14
+	    SPI Error Interrupt			IVG7	    15
+	    UART Error Interrupt		IVG7	    16
+	    Reserved Interrupt			IVG7        17
+
+	    DMA1 0  Interrupt(PPI1)	        IVG8	    18
+	    DMA1 1  Interrupt(PPI2)             IVG8	    19
+	    DMA1 2  Interrupt	                IVG8	    20
+	    DMA1 3  Interrupt	                IVG8	    21
+	    DMA1 4  Interrupt	                IVG8	    22
+	    DMA1 5  Interrupt	                IVG8	    23
+	    DMA1 6  Interrupt	                IVG8	    24
+	    DMA1 7  Interrupt	                IVG8	    25
+	    DMA1 8  Interrupt	                IVG8	    26
+	    DMA1 9  Interrupt	                IVG8	    27
+	    DMA1 10 Interrupt	                IVG8	    28
+	    DMA1 11 Interrupt	                IVG8	    29
+
+	    DMA2 0  (SPORT0 RX)		        IVG9	    30
+	    DMA2 1  (SPORT0 TX)	                IVG9	    31
+	    DMA2 2  (SPORT1 RX)	                IVG9	    32
+	    DMA2 3  (SPORT2 TX)	                IVG9	    33
+	    DMA2 4  (SPI)	                IVG9	    34
+	    DMA2 5  (UART RX)	                IVG9	    35
+	    DMA2 6  (UART TX)	                IVG9	    36
+	    DMA2 7  Interrupt	                IVG9	    37
+	    DMA2 8  Interrupt	                IVG9	    38
+	    DMA2 9  Interrupt	                IVG9	    39
+	    DMA2 10 Interrupt	                IVG9	    40
+	    DMA2 11 Interrupt	                IVG9	    41
+
+	    TIMER 0  Interrupt		        IVG10	    42
+	    TIMER 1  Interrupt	                IVG10	    43
+	    TIMER 2  Interrupt	                IVG10	    44
+	    TIMER 3  Interrupt	                IVG10	    45
+	    TIMER 4  Interrupt	                IVG10	    46
+	    TIMER 5  Interrupt	                IVG10	    47
+	    TIMER 6  Interrupt	                IVG10	    48
+	    TIMER 7  Interrupt	                IVG10	    49
+	    TIMER 8  Interrupt	                IVG10	    50
+	    TIMER 9  Interrupt	                IVG10	    51
+	    TIMER 10 Interrupt	                IVG10	    52
+	    TIMER 11 Interrupt	                IVG10	    53
+
+	    Programmable Flags0 A (8)	        IVG11	    54
+	    Programmable Flags0 B (8)           IVG11	    55
+	    Programmable Flags1 A (8)           IVG11	    56
+	    Programmable Flags1 B (8)           IVG11	    57
+	    Programmable Flags2 A (8)           IVG11	    58
+	    Programmable Flags2 B (8)           IVG11	    59
+
+	    MDMA1 0 write/read INT		IVG8	    60
+	    MDMA1 1 write/read INT		IVG8	    61
+
+	    MDMA2 0 write/read INT		IVG9	    62
+	    MDMA2 1 write/read INT		IVG9	    63
+
+	    IMDMA 0 write/read INT		IVG12	    64
+	    IMDMA 1 write/read INT		IVG12	    65
+
+	    Watch Dog Timer			IVG13	    66
+
+	    Reserved interrupt			IVG7	    67
+	    Reserved interrupt			IVG7	    68
+	    Supplemental interrupt 0		IVG7	    69
+	    supplemental interrupt 1		IVG7	    70
+
+            Software Interrupt 1		IVG14       71
+            Software Interrupt 2		IVG15       72 *
+						(lowest priority)
+ **********************************************************************/
+
+#define SYS_IRQS		72
+#define NR_PERI_INTS		64
+
+/*
+ * The ABSTRACT IRQ definitions
+ *  the first seven of the following are fixed,
+ *  the rest you change if you need to.
+ */
+/* IVG 0-6*/
+#define	IRQ_EMU			0	/* Emulation                */
+#define	IRQ_RST			1	/* Reset                    */
+#define	IRQ_NMI			2	/* Non Maskable Interrupt   */
+#define	IRQ_EVX			3	/* Exception                */
+#define	IRQ_UNUSED		4	/* Reserved interrupt       */
+#define	IRQ_HWERR		5	/* Hardware Error           */
+#define	IRQ_CORETMR		6	/* Core timer               */
+
+#define IVG_BASE		7
+/* IVG 7  */
+#define	IRQ_PLL_WAKEUP		(IVG_BASE + 0)	/* PLL Wakeup Interrupt	    */
+#define	IRQ_DMA1_ERROR		(IVG_BASE + 1)	/* DMA1	  Error (general)   */
+#define	IRQ_DMA_ERROR		IRQ_DMA1_ERROR	/* DMA1	  Error (general)   */
+#define	IRQ_DMA2_ERROR		(IVG_BASE + 2)	/* DMA2	  Error (general)   */
+#define IRQ_IMDMA_ERROR		(IVG_BASE + 3)	/* IMDMA  Error	Interrupt   */
+#define	IRQ_PPI1_ERROR		(IVG_BASE + 4)	/* PPI1	  Error Interrupt   */
+#define	IRQ_PPI_ERROR		IRQ_PPI1_ERROR	/* PPI1	  Error Interrupt   */
+#define	IRQ_PPI2_ERROR		(IVG_BASE + 5)	/* PPI2	  Error Interrupt   */
+#define	IRQ_SPORT0_ERROR	(IVG_BASE + 6) 	/* SPORT0 Error Interrupt   */
+#define	IRQ_SPORT1_ERROR	(IVG_BASE + 7)	/* SPORT1 Error Interrupt   */
+#define	IRQ_SPI_ERROR		(IVG_BASE + 8)	/* SPI    Error Interrupt   */
+#define	IRQ_UART_ERROR		(IVG_BASE + 9)	/* UART   Error Interrupt   */
+#define IRQ_RESERVED_ERROR	(IVG_BASE + 10)	/* Reversed     Interrupt   */
+/* IVG 8  */
+#define	IRQ_DMA1_0		(IVG_BASE + 11)	/* DMA1 0  Interrupt(PPI1)  */
+#define	IRQ_PPI			IRQ_DMA1_0	/* DMA1 0  Interrupt(PPI1)  */
+#define	IRQ_PPI0		IRQ_DMA1_0	/* DMA1 0  Interrupt(PPI1)  */
+#define	IRQ_DMA1_1		(IVG_BASE + 12)	/* DMA1 1  Interrupt(PPI2)  */
+#define	IRQ_PPI1		IRQ_DMA1_1	/* DMA1 1  Interrupt(PPI2)  */
+#define	IRQ_DMA1_2		(IVG_BASE + 13)	/* DMA1 2  Interrupt	    */
+#define	IRQ_DMA1_3		(IVG_BASE + 14)	/* DMA1 3  Interrupt	    */
+#define	IRQ_DMA1_4		(IVG_BASE + 15)	/* DMA1 4  Interrupt	    */
+#define	IRQ_DMA1_5		(IVG_BASE + 16)	/* DMA1 5  Interrupt	    */
+#define	IRQ_DMA1_6		(IVG_BASE + 17)	/* DMA1 6  Interrupt	    */
+#define	IRQ_DMA1_7		(IVG_BASE + 18)	/* DMA1 7  Interrupt	    */
+#define	IRQ_DMA1_8		(IVG_BASE + 19)	/* DMA1 8  Interrupt	    */
+#define	IRQ_DMA1_9		(IVG_BASE + 20)	/* DMA1 9  Interrupt	    */
+#define	IRQ_DMA1_10		(IVG_BASE + 21)	/* DMA1 10 Interrupt	    */
+#define	IRQ_DMA1_11		(IVG_BASE + 22)	/* DMA1 11 Interrupt	    */
+/* IVG 9  */
+#define	IRQ_DMA2_0		(IVG_BASE + 23)	/* DMA2 0  (SPORT0 RX)	    */
+#define	IRQ_SPORT0_RX		IRQ_DMA2_0	/* DMA2 0  (SPORT0 RX)	    */
+#define	IRQ_DMA2_1		(IVG_BASE + 24)	/* DMA2 1  (SPORT0 TX)	    */
+#define	IRQ_SPORT0_TX		IRQ_DMA2_1	/* DMA2 1  (SPORT0 TX)	    */
+#define	IRQ_DMA2_2		(IVG_BASE + 25)	/* DMA2 2  (SPORT1 RX)	    */
+#define	IRQ_SPORT1_RX		IRQ_DMA2_2	/* DMA2 2  (SPORT1 RX)	    */
+#define	IRQ_DMA2_3		(IVG_BASE + 26)	/* DMA2 3  (SPORT2 TX)	    */
+#define	IRQ_SPORT1_TX		IRQ_DMA2_3	/* DMA2 3  (SPORT2 TX)	    */
+#define	IRQ_DMA2_4		(IVG_BASE + 27)	/* DMA2 4  (SPI)	    */
+#define	IRQ_SPI			IRQ_DMA2_4	/* DMA2 4  (SPI)	    */
+#define	IRQ_DMA2_5		(IVG_BASE + 28)	/* DMA2 5  (UART RX)	    */
+#define	IRQ_UART_RX		IRQ_DMA2_5	/* DMA2 5  (UART RX)	    */
+#define	IRQ_DMA2_6		(IVG_BASE + 29)	/* DMA2 6  (UART TX)	    */
+#define	IRQ_UART_TX		IRQ_DMA2_6	/* DMA2 6  (UART TX)	    */
+#define	IRQ_DMA2_7		(IVG_BASE + 30)	/* DMA2 7  Interrupt	    */
+#define	IRQ_DMA2_8		(IVG_BASE + 31)	/* DMA2 8  Interrupt	    */
+#define	IRQ_DMA2_9		(IVG_BASE + 32)	/* DMA2 9  Interrupt	    */
+#define	IRQ_DMA2_10		(IVG_BASE + 33)	/* DMA2 10 Interrupt	    */
+#define	IRQ_DMA2_11		(IVG_BASE + 34)	/* DMA2 11 Interrupt	    */
+/* IVG 10 */
+#define IRQ_TIMER0		(IVG_BASE + 35)	/* TIMER 0  Interrupt       */
+#define IRQ_TIMER1		(IVG_BASE + 36)	/* TIMER 1  Interrupt       */
+#define IRQ_TIMER2		(IVG_BASE + 37)	/* TIMER 2  Interrupt       */
+#define IRQ_TIMER3		(IVG_BASE + 38)	/* TIMER 3  Interrupt       */
+#define IRQ_TIMER4		(IVG_BASE + 39)	/* TIMER 4  Interrupt       */
+#define IRQ_TIMER5		(IVG_BASE + 40)	/* TIMER 5  Interrupt       */
+#define IRQ_TIMER6		(IVG_BASE + 41)	/* TIMER 6  Interrupt       */
+#define IRQ_TIMER7		(IVG_BASE + 42)	/* TIMER 7  Interrupt       */
+#define IRQ_TIMER8		(IVG_BASE + 43)	/* TIMER 8  Interrupt       */
+#define IRQ_TIMER9		(IVG_BASE + 44)	/* TIMER 9  Interrupt       */
+#define IRQ_TIMER10		(IVG_BASE + 45)	/* TIMER 10 Interrupt       */
+#define IRQ_TIMER11		(IVG_BASE + 46)	/* TIMER 11 Interrupt       */
+/* IVG 11 */
+#define	IRQ_PROG0_INTA		(IVG_BASE + 47)	/* Programmable Flags0 A (8)*/
+#define	IRQ_PROG_INTA		IRQ_PROG0_INTA	/* Programmable Flags0 A (8)*/
+#define	IRQ_PROG0_INTB		(IVG_BASE + 48)	/* Programmable Flags0 B (8)*/
+#define	IRQ_PROG_INTB		IRQ_PROG0_INTB	/* Programmable Flags0 B (8)*/
+#define	IRQ_PROG1_INTA		(IVG_BASE + 49)	/* Programmable Flags1 A (8)*/
+#define	IRQ_PROG1_INTB		(IVG_BASE + 50)	/* Programmable Flags1 B (8)*/
+#define	IRQ_PROG2_INTA		(IVG_BASE + 51)	/* Programmable Flags2 A (8)*/
+#define	IRQ_PROG2_INTB		(IVG_BASE + 52)	/* Programmable Flags2 B (8)*/
+/* IVG 8  */
+#define IRQ_DMA1_WRRD0		(IVG_BASE + 53) /* MDMA1 0 write/read INT   */
+#define IRQ_DMA_WRRD0		IRQ_DMA1_WRRD0	/* MDMA1 0 write/read INT   */
+#define IRQ_MEM_DMA0		IRQ_DMA1_WRRD0
+#define IRQ_DMA1_WRRD1		(IVG_BASE + 54) /* MDMA1 1 write/read INT   */
+#define IRQ_DMA_WRRD1		IRQ_DMA1_WRRD1	/* MDMA1 1 write/read INT   */
+#define IRQ_MEM_DMA1		IRQ_DMA1_WRRD1
+/* IVG 9  */
+#define IRQ_DMA2_WRRD0		(IVG_BASE + 55)	/* MDMA2 0 write/read INT   */
+#define IRQ_MEM_DMA2		IRQ_DMA2_WRRD0
+#define IRQ_DMA2_WRRD1		(IVG_BASE + 56)	/* MDMA2 1 write/read INT   */
+#define IRQ_MEM_DMA3		IRQ_DMA2_WRRD1
+/* IVG 12 */
+#define IRQ_IMDMA_WRRD0		(IVG_BASE + 57)	/* IMDMA 0 write/read INT   */
+#define IRQ_IMEM_DMA0		IRQ_IMDMA_WRRD0
+#define IRQ_IMDMA_WRRD1		(IVG_BASE + 58)	/* IMDMA 1 write/read INT   */
+#define IRQ_IMEM_DMA1		IRQ_IMDMA_WRRD1
+/* IVG 13 */
+#define	IRQ_WATCH	   	(IVG_BASE + 59)	/* Watch Dog Timer          */
+/* IVG 7  */
+#define IRQ_RESERVED_1		(IVG_BASE + 60)	/* Reserved interrupt       */
+#define IRQ_RESERVED_2		(IVG_BASE + 61)	/* Reserved interrupt       */
+#define IRQ_SUPPLE_0		(IVG_BASE + 62)	/* Supplemental interrupt 0 */
+#define IRQ_SUPPLE_1		(IVG_BASE + 63)	/* supplemental interrupt 1 */
+#define	IRQ_SW_INT1		71	/* Software Interrupt 1     */
+#define	IRQ_SW_INT2		72	/* Software Interrupt 2     */
+						/* reserved for SYSCALL */
+#define IRQ_PF0			73
+#define IRQ_PF1			74
+#define IRQ_PF2			75
+#define IRQ_PF3			76
+#define IRQ_PF4			77
+#define IRQ_PF5			78
+#define IRQ_PF6			79
+#define IRQ_PF7			80
+#define IRQ_PF8			81
+#define IRQ_PF9			82
+#define IRQ_PF10		83
+#define IRQ_PF11		84
+#define IRQ_PF12		85
+#define IRQ_PF13		86
+#define IRQ_PF14		87
+#define IRQ_PF15		88
+#define IRQ_PF16		89
+#define IRQ_PF17		90
+#define IRQ_PF18		91
+#define IRQ_PF19		92
+#define IRQ_PF20		93
+#define IRQ_PF21		94
+#define IRQ_PF22		95
+#define IRQ_PF23		96
+#define IRQ_PF24		97
+#define IRQ_PF25		98
+#define IRQ_PF26		99
+#define IRQ_PF27		100
+#define IRQ_PF28		101
+#define IRQ_PF29		102
+#define IRQ_PF30		103
+#define IRQ_PF31		104
+#define IRQ_PF32		105
+#define IRQ_PF33		106
+#define IRQ_PF34		107
+#define IRQ_PF35		108
+#define IRQ_PF36		109
+#define IRQ_PF37		110
+#define IRQ_PF38		111
+#define IRQ_PF39		112
+#define IRQ_PF40		113
+#define IRQ_PF41		114
+#define IRQ_PF42		115
+#define IRQ_PF43		116
+#define IRQ_PF44		117
+#define IRQ_PF45		118
+#define IRQ_PF46		119
+#define IRQ_PF47		120
+
+#ifdef CONFIG_IRQCHIP_DEMUX_GPIO
+#define NR_IRQS			(IRQ_PF47 + 1)
+#else
+#define NR_IRQS			SYS_IRQS
+#endif
+
+#define IVG7			7
+#define IVG8			8
+#define IVG9			9
+#define IVG10			10
+#define IVG11			11
+#define IVG12			12
+#define IVG13			13
+#define IVG14			14
+#define IVG15			15
+
+/*
+ * DEFAULT PRIORITIES:
+ */
+
+#define	CONFIG_DEF_PLL_WAKEUP		7
+#define	CONFIG_DEF_DMA1_ERROR		7
+#define	CONFIG_DEF_DMA2_ERROR		7
+#define CONFIG_DEF_IMDMA_ERROR		7
+#define	CONFIG_DEF_PPI1_ERROR		7
+#define	CONFIG_DEF_PPI2_ERROR		7
+#define	CONFIG_DEF_SPORT0_ERROR		7
+#define	CONFIG_DEF_SPORT1_ERROR		7
+#define	CONFIG_DEF_SPI_ERROR		7
+#define	CONFIG_DEF_UART_ERROR		7
+#define CONFIG_DEF_RESERVED_ERROR	7
+#define	CONFIG_DEF_DMA1_0		8
+#define	CONFIG_DEF_DMA1_1		8
+#define	CONFIG_DEF_DMA1_2		8
+#define	CONFIG_DEF_DMA1_3		8
+#define	CONFIG_DEF_DMA1_4		8
+#define	CONFIG_DEF_DMA1_5		8
+#define	CONFIG_DEF_DMA1_6		8
+#define	CONFIG_DEF_DMA1_7		8
+#define	CONFIG_DEF_DMA1_8		8
+#define	CONFIG_DEF_DMA1_9		8
+#define	CONFIG_DEF_DMA1_10		8
+#define	CONFIG_DEF_DMA1_11		8
+#define	CONFIG_DEF_DMA2_0		9
+#define	CONFIG_DEF_DMA2_1		9
+#define	CONFIG_DEF_DMA2_2		9
+#define	CONFIG_DEF_DMA2_3		9
+#define	CONFIG_DEF_DMA2_4		9
+#define	CONFIG_DEF_DMA2_5		9
+#define	CONFIG_DEF_DMA2_6		9
+#define	CONFIG_DEF_DMA2_7		9
+#define	CONFIG_DEF_DMA2_8		9
+#define	CONFIG_DEF_DMA2_9		9
+#define	CONFIG_DEF_DMA2_10		9
+#define	CONFIG_DEF_DMA2_11		9
+#define CONFIG_DEF_TIMER0		10
+#define CONFIG_DEF_TIMER1		10
+#define CONFIG_DEF_TIMER2		10
+#define CONFIG_DEF_TIMER3		10
+#define CONFIG_DEF_TIMER4		10
+#define CONFIG_DEF_TIMER5		10
+#define CONFIG_DEF_TIMER6		10
+#define CONFIG_DEF_TIMER7		10
+#define CONFIG_DEF_TIMER8		10
+#define CONFIG_DEF_TIMER9		10
+#define CONFIG_DEF_TIMER10		10
+#define CONFIG_DEF_TIMER11		10
+#define	CONFIG_DEF_PROG0_INTA		11
+#define	CONFIG_DEF_PROG0_INTB		11
+#define	CONFIG_DEF_PROG1_INTA		11
+#define	CONFIG_DEF_PROG1_INTB		11
+#define	CONFIG_DEF_PROG2_INTA		11
+#define	CONFIG_DEF_PROG2_INTB		11
+#define CONFIG_DEF_DMA1_WRRD0		8
+#define CONFIG_DEF_DMA1_WRRD1		8
+#define CONFIG_DEF_DMA2_WRRD0		9
+#define CONFIG_DEF_DMA2_WRRD1		9
+#define CONFIG_DEF_IMDMA_WRRD0		12
+#define CONFIG_DEF_IMDMA_WRRD1		12
+#define	CONFIG_DEF_WATCH	   	13
+#define CONFIG_DEF_RESERVED_1		7
+#define CONFIG_DEF_RESERVED_2		7
+#define CONFIG_DEF_SUPPLE_0		7
+#define CONFIG_DEF_SUPPLE_1		7
+
+/* IAR0 BIT FIELDS */
+#define	IRQ_PLL_WAKEUP_POS			0
+#define	IRQ_DMA1_ERROR_POS			4
+#define	IRQ_DMA2_ERROR_POS			8
+#define IRQ_IMDMA_ERROR_POS			12
+#define	IRQ_PPI0_ERROR_POS			16
+#define	IRQ_PPI1_ERROR_POS			20
+#define	IRQ_SPORT0_ERROR_POS		24
+#define	IRQ_SPORT1_ERROR_POS		28
+/* IAR1 BIT FIELDS */
+#define	IRQ_SPI_ERROR_POS			0
+#define	IRQ_UART_ERROR_POS			4
+#define IRQ_RESERVED_ERROR_POS		8
+#define	IRQ_DMA1_0_POS			12
+#define	IRQ_DMA1_1_POS			16
+#define IRQ_DMA1_2_POS			20
+#define IRQ_DMA1_3_POS			24
+#define IRQ_DMA1_4_POS			28
+/* IAR2 BIT FIELDS */
+#define IRQ_DMA1_5_POS			0
+#define IRQ_DMA1_6_POS			4
+#define IRQ_DMA1_7_POS			8
+#define IRQ_DMA1_8_POS			12
+#define IRQ_DMA1_9_POS			16
+#define IRQ_DMA1_10_POS			20
+#define IRQ_DMA1_11_POS			24
+#define IRQ_DMA2_0_POS			28
+/* IAR3 BIT FIELDS */
+#define IRQ_DMA2_1_POS			0
+#define IRQ_DMA2_2_POS			4
+#define IRQ_DMA2_3_POS			8
+#define IRQ_DMA2_4_POS			12
+#define IRQ_DMA2_5_POS			16
+#define IRQ_DMA2_6_POS			20
+#define IRQ_DMA2_7_POS			24
+#define IRQ_DMA2_8_POS			28
+/* IAR4 BIT FIELDS */
+#define IRQ_DMA2_9_POS			0
+#define IRQ_DMA2_10_POS			4
+#define IRQ_DMA2_11_POS			8
+#define IRQ_TIMER0_POS			12
+#define IRQ_TIMER1_POS			16
+#define IRQ_TIMER2_POS			20
+#define IRQ_TIMER3_POS			24
+#define IRQ_TIMER4_POS			28
+/* IAR5 BIT FIELDS */
+#define IRQ_TIMER5_POS			0
+#define IRQ_TIMER6_POS			4
+#define IRQ_TIMER7_POS			8
+#define IRQ_TIMER8_POS			12
+#define IRQ_TIMER9_POS			16
+#define IRQ_TIMER10_POS			20
+#define IRQ_TIMER11_POS			24
+#define IRQ_PROG0_INTA_POS			28
+/* IAR6 BIT FIELDS */
+#define IRQ_PROG0_INTB_POS			0
+#define IRQ_PROG1_INTA_POS			4
+#define IRQ_PROG1_INTB_POS			8
+#define IRQ_PROG2_INTA_POS			12
+#define IRQ_PROG2_INTB_POS			16
+#define IRQ_DMA1_WRRD0_POS			20
+#define IRQ_DMA1_WRRD1_POS			24
+#define IRQ_DMA2_WRRD0_POS			28
+/* IAR7 BIT FIELDS */
+#define IRQ_DMA2_WRRD1_POS			0
+#define IRQ_IMDMA_WRRD0_POS			4
+#define IRQ_IMDMA_WRRD1_POS			8
+#define	IRQ_WDTIMER_POS			12
+#define IRQ_RESERVED_1_POS			16
+#define IRQ_RESERVED_2_POS			20
+#define IRQ_SUPPLE_0_POS			24
+#define IRQ_SUPPLE_1_POS			28
+
+#endif /* _BF561_IRQ_H_ */
Index: git/linux-2.6/include/asm-blackfin/mach-bf561/mem_init.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf561/mem_init.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,283 @@
+#if ( CONFIG_MEM_MT48LC16M16A2TG_75  ||  CONFIG_MEM_MT48LC64M4A2FB_7E  || CONFIG_MEM_GENERIC_BOARD)
+  #if ( CONFIG_SCLK_HZ > 119402985 )
+        #define SDRAM_tRP       TRP_2
+        #define SDRAM_tRP_num   2
+        #define SDRAM_tRAS      TRAS_7
+        #define SDRAM_tRAS_num  7
+        #define SDRAM_tRCD      TRCD_2
+        #define SDRAM_tWR       TWR_2
+  #endif
+  #if ( CONFIG_SCLK_HZ > 104477612 ) && ( CONFIG_SCLK_HZ <= 119402985 )
+        #define SDRAM_tRP       TRP_2
+        #define SDRAM_tRP_num   2
+        #define SDRAM_tRAS      TRAS_6
+        #define SDRAM_tRAS_num  6
+        #define SDRAM_tRCD      TRCD_2
+        #define SDRAM_tWR       TWR_2
+  #endif
+  #if ( CONFIG_SCLK_HZ >  89552239 ) && ( CONFIG_SCLK_HZ <= 104477612 )
+        #define SDRAM_tRP       TRP_2
+        #define SDRAM_tRP_num   2
+        #define SDRAM_tRAS      TRAS_5
+        #define SDRAM_tRAS_num  5
+        #define SDRAM_tRCD      TRCD_2
+        #define SDRAM_tWR       TWR_2
+  #endif
+  #if ( CONFIG_SCLK_HZ >  74626866 ) && ( CONFIG_SCLK_HZ <=  89552239 )
+        #define SDRAM_tRP       TRP_2
+        #define SDRAM_tRP_num   2
+        #define SDRAM_tRAS      TRAS_4
+        #define SDRAM_tRAS_num  4
+        #define SDRAM_tRCD      TRCD_2
+        #define SDRAM_tWR       TWR_2
+  #endif
+  #if ( CONFIG_SCLK_HZ >  66666667 ) && ( CONFIG_SCLK_HZ <= 74626866 )
+        #define SDRAM_tRP       TRP_2
+        #define SDRAM_tRP_num   2
+        #define SDRAM_tRAS      TRAS_3
+        #define SDRAM_tRAS_num  3
+        #define SDRAM_tRCD      TRCD_2
+        #define SDRAM_tWR       TWR_2
+  #endif
+  #if ( CONFIG_SCLK_HZ >  59701493 ) && ( CONFIG_SCLK_HZ <= 66666667 )
+        #define SDRAM_tRP       TRP_1
+        #define SDRAM_tRP_num   1
+        #define SDRAM_tRAS      TRAS_4
+        #define SDRAM_tRAS_num  3
+        #define SDRAM_tRCD      TRCD_1
+        #define SDRAM_tWR       TWR_2
+  #endif
+  #if ( CONFIG_SCLK_HZ >  44776119 ) && ( CONFIG_SCLK_HZ <=  59701493 )
+        #define SDRAM_tRP       TRP_1
+        #define SDRAM_tRP_num   1
+        #define SDRAM_tRAS      TRAS_3
+        #define SDRAM_tRAS_num  3
+        #define SDRAM_tRCD      TRCD_1
+        #define SDRAM_tWR       TWR_2
+  #endif
+  #if ( CONFIG_SCLK_HZ >  29850746 ) && ( CONFIG_SCLK_HZ <=  44776119 )
+        #define SDRAM_tRP       TRP_1
+        #define SDRAM_tRP_num   1
+        #define SDRAM_tRAS      TRAS_2
+        #define SDRAM_tRAS_num  2
+        #define SDRAM_tRCD      TRCD_1
+        #define SDRAM_tWR       TWR_2
+  #endif
+  #if ( CONFIG_SCLK_HZ <=  29850746 )
+        #define SDRAM_tRP       TRP_1
+        #define SDRAM_tRP_num   1
+        #define SDRAM_tRAS      TRAS_1
+        #define SDRAM_tRAS_num  1
+        #define SDRAM_tRCD      TRCD_1
+        #define SDRAM_tWR       TWR_2
+  #endif
+#endif
+
+#if (CONFIG_MEM_MT48LC16M16A2TG_75)
+  /*SDRAM INFORMATION: */
+  #define SDRAM_Tref  64       /* Refresh period in milliseconds   */
+  #define SDRAM_NRA   8192     /* Number of row addresses in SDRAM */
+  #define SDRAM_CL    CL_3
+#endif
+
+#if (CONFIG_MEM_MT48LC64M4A2FB_7E)
+  /*SDRAM INFORMATION: */
+  #define SDRAM_Tref  64       /* Refresh period in milliseconds   */
+  #define SDRAM_NRA   8192     /* Number of row addresses in SDRAM */
+  #define SDRAM_CL    CL_3
+#endif
+
+#if (CONFIG_MEM_GENERIC_BOARD)
+  /*SDRAM INFORMATION: Modify this for your board */
+  #define SDRAM_Tref  64       /* Refresh period in milliseconds   */
+  #define SDRAM_NRA   8192     /* Number of row addresses in SDRAM */
+  #define SDRAM_CL    CL_3
+#endif
+
+#if ( CONFIG_MEM_SIZE == 128 )
+        #define SDRAM_SIZE      EB0_SZ_128
+#endif
+#if ( CONFIG_MEM_SIZE == 64 )
+        #define SDRAM_SIZE      EB0_SZ_64
+#endif
+#if (  CONFIG_MEM_SIZE == 32 )
+        #define SDRAM_SIZE      EB0_SZ_32
+#endif
+#if ( CONFIG_MEM_SIZE == 16 )
+        #define SDRAM_SIZE      EB0_SZ_16
+#endif
+#if ( CONFIG_MEM_ADD_WIDTH == 11 )
+        #define SDRAM_WIDTH     EB0_CAW_11
+#endif
+#if ( CONFIG_MEM_ADD_WIDTH == 10 )
+        #define SDRAM_WIDTH     EB0_CAW_10
+#endif
+#if ( CONFIG_MEM_ADD_WIDTH == 9 )
+        #define SDRAM_WIDTH     EB0_CAW_9
+#endif
+#if ( CONFIG_MEM_ADD_WIDTH == 8 )
+        #define SDRAM_WIDTH     EB0_CAW_8
+#endif
+
+#define mem_SDBCTL      SDRAM_WIDTH | SDRAM_SIZE | EB0_E
+
+/* Equation from section 17 (p17-46) of BF533 HRM */
+#define mem_SDRRC       ((( CONFIG_SCLK_HZ / 1000) * SDRAM_Tref)  / SDRAM_NRA) - (SDRAM_tRAS_num + SDRAM_tRP_num)
+
+/* Enable SCLK Out */
+#define mem_SDGCTL        ( SCTLE | SDRAM_CL | SDRAM_tRAS | SDRAM_tRP | SDRAM_tRCD | SDRAM_tWR | PSS )
+
+#if defined CONFIG_CLKIN_HALF
+        #define CLKIN_HALF       1
+#else
+        #define CLKIN_HALF       0
+#endif
+
+#if defined CONFIG_PLL_BYPASS
+        #define PLL_BYPASS      1
+#else
+        #define PLL_BYPASS       0
+#endif
+
+/***************************************Currently Not Being Used *********************************/
+#define flash_EBIU_AMBCTL_WAT  ( ( CONFIG_FLASH_SPEED_BWAT * 4 )  / ( 4000000000 / CONFIG_SCLK_HZ ) ) + 1
+#define flash_EBIU_AMBCTL_RAT  ( ( CONFIG_FLASH_SPEED_BRAT * 4 )  / ( 4000000000 / CONFIG_SCLK_HZ ) ) + 1
+#define flash_EBIU_AMBCTL_HT   ( ( CONFIG_FLASH_SPEED_BHT  * 4 )  / ( 4000000000 / CONFIG_SCLK_HZ ) )
+#define flash_EBIU_AMBCTL_ST   ( ( CONFIG_FLASH_SPEED_BST  * 4 )  / ( 4000000000 / CONFIG_SCLK_HZ ) ) + 1
+#define flash_EBIU_AMBCTL_TT   ( ( CONFIG_FLASH_SPEED_BTT  * 4 )  / ( 4000000000 / CONFIG_SCLK_HZ ) ) + 1
+
+#if (flash_EBIU_AMBCTL_TT > 3 )
+        #define flash_EBIU_AMBCTL0_TT   B0TT_4
+#endif
+#if (flash_EBIU_AMBCTL_TT == 3 )
+        #define flash_EBIU_AMBCTL0_TT   B0TT_3
+#endif
+#if (flash_EBIU_AMBCTL_TT == 2 )
+        #define flash_EBIU_AMBCTL0_TT   B0TT_2
+#endif
+#if (flash_EBIU_AMBCTL_TT < 2 )
+        #define flash_EBIU_AMBCTL0_TT   B0TT_1
+#endif
+
+#if (flash_EBIU_AMBCTL_ST > 3 )
+        #define flash_EBIU_AMBCTL0_ST   B0ST_4
+#endif
+#if (flash_EBIU_AMBCTL_ST == 3 )
+        #define flash_EBIU_AMBCTL0_ST   B0ST_3
+#endif
+#if (flash_EBIU_AMBCTL_ST == 2 )
+        #define flash_EBIU_AMBCTL0_ST   B0ST_2
+#endif
+#if (flash_EBIU_AMBCTL_ST < 2 )
+        #define flash_EBIU_AMBCTL0_ST   B0ST_1
+#endif
+
+#if (flash_EBIU_AMBCTL_HT > 2 )
+        #define flash_EBIU_AMBCTL0_HT   B0HT_3
+#endif
+#if (flash_EBIU_AMBCTL_HT == 2 )
+        #define flash_EBIU_AMBCTL0_HT   B0HT_2
+#endif
+#if (flash_EBIU_AMBCTL_HT == 1 )
+        #define flash_EBIU_AMBCTL0_HT   B0HT_1
+#endif
+#if (flash_EBIU_AMBCTL_HT == 0  && CONFIG_FLASH_SPEED_BHT == 0)
+        #define flash_EBIU_AMBCTL0_HT   B0HT_0
+#endif
+#if (flash_EBIU_AMBCTL_HT == 0  && CONFIG_FLASH_SPEED_BHT != 0)
+        #define flash_EBIU_AMBCTL0_HT   B0HT_1
+#endif
+
+#if (flash_EBIU_AMBCTL_WAT > 14)
+        #define flash_EBIU_AMBCTL0_WAT  B0WAT_15
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 14)
+        #define flash_EBIU_AMBCTL0_WAT  B0WAT_14
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 13)
+        #define flash_EBIU_AMBCTL0_WAT  B0WAT_13
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 12)
+        #define flash_EBIU_AMBCTL0_WAT  B0WAT_12
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 11)
+        #define flash_EBIU_AMBCTL0_WAT  B0WAT_11
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 10)
+        #define flash_EBIU_AMBCTL0_WAT  B0WAT_10
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 9)
+        #define flash_EBIU_AMBCTL0_WAT  B0WAT_9
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 8)
+        #define flash_EBIU_AMBCTL0_WAT  B0WAT_8
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 7)
+        #define flash_EBIU_AMBCTL0_WAT  B0WAT_7
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 6)
+        #define flash_EBIU_AMBCTL0_WAT  B0WAT_6
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 5)
+        #define flash_EBIU_AMBCTL0_WAT  B0WAT_5
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 4)
+        #define flash_EBIU_AMBCTL0_WAT  B0WAT_4
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 3)
+        #define flash_EBIU_AMBCTL0_WAT  B0WAT_3
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 2)
+        #define flash_EBIU_AMBCTL0_WAT  B0WAT_2
+#endif
+#if (flash_EBIU_AMBCTL_WAT == 1)
+        #define flash_EBIU_AMBCTL0_WAT  B0WAT_1
+#endif
+
+#if (flash_EBIU_AMBCTL_RAT > 14)
+        #define flash_EBIU_AMBCTL0_RAT  B0RAT_15
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 14)
+        #define flash_EBIU_AMBCTL0_RAT  B0RAT_14
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 13)
+        #define flash_EBIU_AMBCTL0_RAT  B0RAT_13
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 12)
+        #define flash_EBIU_AMBCTL0_RAT  B0RAT_12
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 11)
+        #define flash_EBIU_AMBCTL0_RAT  B0RAT_11
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 10)
+        #define flash_EBIU_AMBCTL0_RAT  B0RAT_10
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 9)
+        #define flash_EBIU_AMBCTL0_RAT  B0RAT_9
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 8)
+        #define flash_EBIU_AMBCTL0_RAT  B0RAT_8
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 7)
+        #define flash_EBIU_AMBCTL0_RAT  B0RAT_7
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 6)
+        #define flash_EBIU_AMBCTL0_RAT  B0RAT_6
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 5)
+        #define flash_EBIU_AMBCTL0_RAT  B0RAT_5
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 4)
+        #define flash_EBIU_AMBCTL0_RAT  B0RAT_4
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 3)
+        #define flash_EBIU_AMBCTL0_RAT  B0RAT_3
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 2)
+        #define flash_EBIU_AMBCTL0_RAT  B0RAT_2
+#endif
+#if (flash_EBIU_AMBCTL_RAT == 1)
+        #define flash_EBIU_AMBCTL0_RAT  B0RAT_1
+#endif
+
+#define flash_EBIU_AMBCTL0  flash_EBIU_AMBCTL0_WAT | flash_EBIU_AMBCTL0_RAT | flash_EBIU_AMBCTL0_HT | flash_EBIU_AMBCTL0_ST | flash_EBIU_AMBCTL0_TT | CONFIG_FLASH_SPEED_RDYEN
Index: git/linux-2.6/include/asm-blackfin/mach-bf561/mem_map.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-bf561/mem_map.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,67 @@
+/*
+ * Memory MAP
+ * Common header file for blackfin BF561 of processors.
+ *
+ *
+ */
+
+
+#ifndef _MEM_MAP_561_H_
+#define _MEM_MAP_561_H_
+
+#define COREMMR_BASE           0xFFE00000     // Core MMRs
+#define SYSMMR_BASE            0xFFC00000     // System MMRs
+
+/* Level 3 SDRAM Memory */
+#define RAM_START		0x1000
+#define RAM_LENGTH		(CONFIG_MEM_SIZE * 1024 * 1024)
+#define RAM_END 		(CONFIG_MEM_SIZE * 1024 * 1024)
+
+/* Async Memory Banks */
+#define ASYNC_BANK3_BASE	0x2C000000	// Async Bank 3
+#define ASYNC_BANK3_SIZE	0x04000000	/* 1M */
+#define ASYNC_BANK2_BASE	0x28000000	// Async Bank 2
+#define ASYNC_BANK2_SIZE	0x04000000  /* 1M */
+#define ASYNC_BANK1_BASE	0x24000000	// Async Bank 1
+#define ASYNC_BANK1_SIZE	0x04000000	/* 1M */
+#define ASYNC_BANK0_BASE	0x20000000	// Async Bank 0
+#define ASYNC_BANK0_SIZE	0x04000000	/* 1M */
+
+/* Level 1 Memory */
+
+/* Memory Map for ADSP-BF561 processors */
+
+#ifdef CONFIG_BF561
+#define L1_CODE_START     0xFFA00000
+#define L1_DATA_A_START     0xFF800000
+#define L1_DATA_B_START     0xFF900000
+
+#define L1_CODE_LENGTH      0x4000
+
+#ifdef CONFIG_BLKFIN_DCACHE
+#define DMEM_CNTR (ACACHE_BCACHE | ENDCPLB | PORT_PREF0)
+#define L1_DATA_A_LENGTH      (0x8000 - 0x4000)
+#else
+#define DMEM_CNTR (ASRAM_BSRAM | ENDCPLB | PORT_PREF0)
+#define L1_DATA_A_LENGTH      0x8000
+#endif
+
+#ifdef CONFIG_BLKFIN_DCACHE
+#define L1_DATA_B_LENGTH      (0x8000 - 0x4000)
+#else
+#define L1_DATA_B_LENGTH      0x8000
+#endif
+#endif
+
+/* Level 2 Memory */
+#define L2_START		0xFEB00000
+#define L2_LENGTH		0x20000
+
+/* Scratch Pad Memory */
+
+#if defined(CONFIG_BF561)
+#define L1_SCRATCH_START	0xFFB00000
+#define L1_SCRATCH_LENGTH	0x1000
+#endif
+
+#endif /* _MEM_MAP_533_H_ */
Index: git/linux-2.6/include/asm-blackfin/mach-common/cdef_LPBlackfin.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-common/cdef_LPBlackfin.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,202 @@
+ /*
+  * File:        include/asm-blackfin/mach-common/cdef_LPBlackfin.h
+  * Based on:
+  * Author:      unknown
+  *              COPYRIGHT 2005 Analog Devices
+  * Created:     ?
+  * Description:
+  *
+  * Rev:        $Id$
+  *
+  * Modified:
+  *
+  *
+  * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.
+  * If not, write to the Free Software Foundation,
+  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+  */
+
+#ifndef _CDEF_LPBLACKFIN_H
+#define _CDEF_LPBLACKFIN_H
+
+/*#if !defined(__ADSPLPBLACKFIN__)
+#warning cdef_LPBlackfin.h should only be included for 532 compatible chips.
+#endif
+*/
+#include <asm/mach-common/def_LPBlackfin.h>
+
+/*Cache & SRAM Memory*/
+#define pSRAM_BASE_ADDRESS ((volatile void **)SRAM_BASE_ADDRESS)
+#define pDMEM_CONTROL ((volatile unsigned long *)DMEM_CONTROL)
+#define pDCPLB_STATUS ((volatile unsigned long *)DCPLB_STATUS)
+#define pDCPLB_FAULT_ADDR ((volatile void **)DCPLB_FAULT_ADDR)
+/*
+#define MMR_TIMEOUT            0xFFE00010
+*/
+#define pDCPLB_ADDR0 ((volatile void **)DCPLB_ADDR0)
+#define pDCPLB_ADDR1 ((volatile void **)DCPLB_ADDR1)
+#define pDCPLB_ADDR2 ((volatile void **)DCPLB_ADDR2)
+#define pDCPLB_ADDR3 ((volatile void **)DCPLB_ADDR3)
+#define pDCPLB_ADDR4 ((volatile void **)DCPLB_ADDR4)
+#define pDCPLB_ADDR5 ((volatile void **)DCPLB_ADDR5)
+#define pDCPLB_ADDR6 ((volatile void **)DCPLB_ADDR6)
+#define pDCPLB_ADDR7 ((volatile void **)DCPLB_ADDR7)
+#define pDCPLB_ADDR8 ((volatile void **)DCPLB_ADDR8)
+#define pDCPLB_ADDR9 ((volatile void **)DCPLB_ADDR9)
+#define pDCPLB_ADDR10 ((volatile void **)DCPLB_ADDR10)
+#define pDCPLB_ADDR11 ((volatile void **)DCPLB_ADDR11)
+#define pDCPLB_ADDR12 ((volatile void **)DCPLB_ADDR12)
+#define pDCPLB_ADDR13 ((volatile void **)DCPLB_ADDR13)
+#define pDCPLB_ADDR14 ((volatile void **)DCPLB_ADDR14)
+#define pDCPLB_ADDR15 ((volatile void **)DCPLB_ADDR15)
+#define pDCPLB_DATA0 ((volatile unsigned long *)DCPLB_DATA0)
+#define pDCPLB_DATA1 ((volatile unsigned long *)DCPLB_DATA1)
+#define pDCPLB_DATA2 ((volatile unsigned long *)DCPLB_DATA2)
+#define pDCPLB_DATA3 ((volatile unsigned long *)DCPLB_DATA3)
+#define pDCPLB_DATA4 ((volatile unsigned long *)DCPLB_DATA4)
+#define pDCPLB_DATA5 ((volatile unsigned long *)DCPLB_DATA5)
+#define pDCPLB_DATA6 ((volatile unsigned long *)DCPLB_DATA6)
+#define pDCPLB_DATA7 ((volatile unsigned long *)DCPLB_DATA7)
+#define pDCPLB_DATA8 ((volatile unsigned long *)DCPLB_DATA8)
+#define pDCPLB_DATA9 ((volatile unsigned long *)DCPLB_DATA9)
+#define pDCPLB_DATA10 ((volatile unsigned long *)DCPLB_DATA10)
+#define pDCPLB_DATA11 ((volatile unsigned long *)DCPLB_DATA11)
+#define pDCPLB_DATA12 ((volatile unsigned long *)DCPLB_DATA12)
+#define pDCPLB_DATA13 ((volatile unsigned long *)DCPLB_DATA13)
+#define pDCPLB_DATA14 ((volatile unsigned long *)DCPLB_DATA14)
+#define pDCPLB_DATA15 ((volatile unsigned long *)DCPLB_DATA15)
+#define pDTEST_COMMAND ((volatile unsigned long *)DTEST_COMMAND)
+/*
+#define DTEST_INDEX            0xFFE00304
+*/
+#define pDTEST_DATA0 ((volatile unsigned long *)DTEST_DATA0)
+#define pDTEST_DATA1 ((volatile unsigned long *)DTEST_DATA1)
+/*
+#define DTEST_DATA2            0xFFE00408
+#define DTEST_DATA3            0xFFE0040C
+*/
+#define pIMEM_CONTROL ((volatile unsigned long *)IMEM_CONTROL)
+#define pICPLB_STATUS ((volatile unsigned long *)ICPLB_STATUS)
+#define pICPLB_FAULT_ADDR ((volatile void **)ICPLB_FAULT_ADDR)
+#define pICPLB_ADDR0 ((volatile void **)ICPLB_ADDR0)
+#define pICPLB_ADDR1 ((volatile void **)ICPLB_ADDR1)
+#define pICPLB_ADDR2 ((volatile void **)ICPLB_ADDR2)
+#define pICPLB_ADDR3 ((volatile void **)ICPLB_ADDR3)
+#define pICPLB_ADDR4 ((volatile void **)ICPLB_ADDR4)
+#define pICPLB_ADDR5 ((volatile void **)ICPLB_ADDR5)
+#define pICPLB_ADDR6 ((volatile void **)ICPLB_ADDR6)
+#define pICPLB_ADDR7 ((volatile void **)ICPLB_ADDR7)
+#define pICPLB_ADDR8 ((volatile void **)ICPLB_ADDR8)
+#define pICPLB_ADDR9 ((volatile void **)ICPLB_ADDR9)
+#define pICPLB_ADDR10 ((volatile void **)ICPLB_ADDR10)
+#define pICPLB_ADDR11 ((volatile void **)ICPLB_ADDR11)
+#define pICPLB_ADDR12 ((volatile void **)ICPLB_ADDR12)
+#define pICPLB_ADDR13 ((volatile void **)ICPLB_ADDR13)
+#define pICPLB_ADDR14 ((volatile void **)ICPLB_ADDR14)
+#define pICPLB_ADDR15 ((volatile void **)ICPLB_ADDR15)
+#define pICPLB_DATA0 ((volatile unsigned long *)ICPLB_DATA0)
+#define pICPLB_DATA1 ((volatile unsigned long *)ICPLB_DATA1)
+#define pICPLB_DATA2 ((volatile unsigned long *)ICPLB_DATA2)
+#define pICPLB_DATA3 ((volatile unsigned long *)ICPLB_DATA3)
+#define pICPLB_DATA4 ((volatile unsigned long *)ICPLB_DATA4)
+#define pICPLB_DATA5 ((volatile unsigned long *)ICPLB_DATA5)
+#define pICPLB_DATA6 ((volatile unsigned long *)ICPLB_DATA6)
+#define pICPLB_DATA7 ((volatile unsigned long *)ICPLB_DATA7)
+#define pICPLB_DATA8 ((volatile unsigned long *)ICPLB_DATA8)
+#define pICPLB_DATA9 ((volatile unsigned long *)ICPLB_DATA9)
+#define pICPLB_DATA10 ((volatile unsigned long *)ICPLB_DATA10)
+#define pICPLB_DATA11 ((volatile unsigned long *)ICPLB_DATA11)
+#define pICPLB_DATA12 ((volatile unsigned long *)ICPLB_DATA12)
+#define pICPLB_DATA13 ((volatile unsigned long *)ICPLB_DATA13)
+#define pICPLB_DATA14 ((volatile unsigned long *)ICPLB_DATA14)
+#define pICPLB_DATA15 ((volatile unsigned long *)ICPLB_DATA15)
+#define pITEST_COMMAND ((volatile unsigned long *)ITEST_COMMAND)
+/*
+#define ITEST_INDEX            0xFFE01304  // Instruction Test Index Register
+*/
+#define pITEST_DATA0 ((volatile unsigned long *)ITEST_DATA0)
+#define pITEST_DATA1 ((volatile unsigned long *)ITEST_DATA1)
+
+/* Event/Interrupt Registers*/
+
+#define pEVT0 ((volatile void **)EVT0)
+#define pEVT1 ((volatile void **)EVT1)
+#define pEVT2 ((volatile void **)EVT2)
+#define pEVT3 ((volatile void **)EVT3)
+#define pEVT4 ((volatile void **)EVT4)
+#define pEVT5 ((volatile void **)EVT5)
+#define pEVT6 ((volatile void **)EVT6)
+#define pEVT7 ((volatile void **)EVT7)
+#define pEVT8 ((volatile void **)EVT8)
+#define pEVT9 ((volatile void **)EVT9)
+#define pEVT10 ((volatile void **)EVT10)
+#define pEVT11 ((volatile void **)EVT11)
+#define pEVT12 ((volatile void **)EVT12)
+#define pEVT13 ((volatile void **)EVT13)
+#define pEVT14 ((volatile void **)EVT14)
+#define pEVT15 ((volatile void **)EVT15)
+#define pIMASK ((volatile unsigned long *)IMASK)
+#define pIPEND ((volatile unsigned long *)IPEND)
+#define pILAT ((volatile unsigned long *)ILAT)
+
+/*Core Timer Registers*/
+#define pTCNTL ((volatile unsigned long *)TCNTL)
+#define pTPERIOD ((volatile unsigned long *)TPERIOD)
+#define pTSCALE ((volatile unsigned long *)TSCALE)
+#define pTCOUNT ((volatile unsigned long *)TCOUNT)
+
+/*Debug/MP/Emulation Registers*/
+#define pDSPID ((volatile unsigned long *)DSPID)
+#define pDBGCTL ((volatile unsigned long *)DBGCTL)
+#define pDBGSTAT ((volatile unsigned long *)DBGSTAT)
+#define pEMUDAT ((volatile unsigned long *)EMUDAT)
+
+/*Trace Buffer Registers*/
+#define pTBUFCTL ((volatile unsigned long *)TBUFCTL)
+#define pTBUFSTAT ((volatile unsigned long *)TBUFSTAT)
+#define pTBUF ((volatile void **)TBUF)
+
+/*Watch Point Control Registers*/
+#define pWPIACTL ((volatile unsigned long *)WPIACTL)
+#define pWPIA0 ((volatile void **)WPIA0)
+#define pWPIA1 ((volatile void **)WPIA1)
+#define pWPIA2 ((volatile void **)WPIA2)
+#define pWPIA3 ((volatile void **)WPIA3)
+#define pWPIA4 ((volatile void **)WPIA4)
+#define pWPIA5 ((volatile void **)WPIA5)
+#define pWPIACNT0 ((volatile unsigned long *)WPIACNT0)
+#define pWPIACNT1 ((volatile unsigned long *)WPIACNT1)
+#define pWPIACNT2 ((volatile unsigned long *)WPIACNT2)
+#define pWPIACNT3 ((volatile unsigned long *)WPIACNT3)
+#define pWPIACNT4 ((volatile unsigned long *)WPIACNT4)
+#define pWPIACNT5 ((volatile unsigned long *)WPIACNT5)
+#define pWPDACTL ((volatile unsigned long *)WPDACTL)
+#define pWPDA0 ((volatile void **)WPDA0)
+#define pWPDA1 ((volatile void **)WPDA1)
+#define pWPDACNT0 ((volatile unsigned long *)WPDACNT0)
+#define pWPDACNT1 ((volatile unsigned long *)WPDACNT1)
+#define pWPSTAT ((volatile unsigned long *)WPSTAT)
+
+/*Performance Monitor Registers*/
+#define pPFCTL ((volatile unsigned long *)PFCTL)
+#define pPFCNTR0 ((volatile unsigned long *)PFCNTR0)
+#define pPFCNTR1 ((volatile unsigned long *)PFCNTR1)
+
+/*
+#define IPRIO                  0xFFE02110
+*/
+
+#endif				/* _CDEF_LPBLACKFIN_H */
Index: git/linux-2.6/include/asm-blackfin/mach-common/def_LPBlackfin.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mach-common/def_LPBlackfin.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,645 @@
+ /*
+  * File:        include/asm-blackfin/mach-common/def_LPBlackfin.h
+  * Based on:
+  * Author:      unknown
+  *              COPYRIGHT 2005 Analog Devices
+  * Created:     ?
+  * Description:
+  *
+  * Rev:       $Id$
+  *
+  * Modified:
+  *
+  *
+  * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.
+  * If not, write to the Free Software Foundation,
+  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+  */
+
+/* LP Blackfin CORE REGISTER BIT & ADDRESS DEFINITIONS FOR ADSP-BF532/33 */
+
+#ifndef _DEF_LPBLACKFIN_H
+#define _DEF_LPBLACKFIN_H
+
+/*#if !defined(__ADSPLPBLACKFIN__)
+#warning def_LPBlackfin.h should only be included for 532 compatible chips.
+#endif
+*/
+
+#define MK_BMSK_( x ) (1<<x)    // Make a bit mask from a bit position
+
+/**************************************************
+ * System Register Bits
+ **************************************************/
+
+/**************************************************
+ * ASTAT register
+ **************************************************/
+
+/* definitions of ASTAT bit positions*/
+
+
+/*Result of last ALU0 or shifter operation is zero*/
+#define ASTAT_AZ_P         0x00000000
+/*Result of last ALU0 or shifter operation is negative*/
+#define ASTAT_AN_P         0x00000001
+/*Condition Code, used for holding comparison results*/
+#define ASTAT_CC_P         0x00000005
+/*Quotient Bit*/
+#define ASTAT_AQ_P         0x00000006
+/*Rounding mode, set for biased, clear for unbiased*/
+#define ASTAT_RND_MOD_P    0x00000008
+/*Result of last ALU0 operation generated a carry*/
+#define ASTAT_AC0_P        0x0000000C
+/*Result of last ALU0 operation generated a carry*/
+#define ASTAT_AC0_COPY_P   0x00000002
+/*Result of last ALU1 operation generated a carry*/
+#define ASTAT_AC1_P        0x0000000D
+/*Result of last ALU0 or MAC0 operation overflowed, sticky for MAC*/
+#define ASTAT_AV0_P        0x00000010
+/*Sticky version of ASTAT_AV0 */
+#define ASTAT_AV0S_P       0x00000011
+/*Result of last MAC1 operation overflowed, sticky for MAC*/
+#define ASTAT_AV1_P        0x00000012
+/*Sticky version of ASTAT_AV1 */
+#define ASTAT_AV1S_P       0x00000013
+/*Result of last ALU0 or MAC0 operation overflowed*/
+#define ASTAT_V_P          0x00000018
+/*Result of last ALU0 or MAC0 operation overflowed*/
+#define ASTAT_V_COPY_P     0x00000003
+/*Sticky version of ASTAT_V*/
+#define ASTAT_VS_P         0x00000019
+
+/* Masks */
+
+/*Result of last ALU0 or shifter operation is zero*/
+#define ASTAT_AZ           MK_BMSK_(ASTAT_AZ_P)
+/*Result of last ALU0 or shifter operation is negative*/
+#define ASTAT_AN           MK_BMSK_(ASTAT_AN_P)
+/*Result of last ALU0 operation generated a carry*/
+#define ASTAT_AC0          MK_BMSK_(ASTAT_AC0_P)
+/*Result of last ALU0 operation generated a carry*/
+#define ASTAT_AC0_COPY     MK_BMSK_(ASTAT_AC0_COPY_P)
+/*Result of last ALU0 operation generated a carry*/
+#define ASTAT_AC1          MK_BMSK_(ASTAT_AC1_P)
+/*Result of last ALU0 or MAC0 operation overflowed, sticky for MAC*/
+#define ASTAT_AV0          MK_BMSK_(ASTAT_AV0_P)
+/*Result of last MAC1 operation overflowed, sticky for MAC*/
+#define ASTAT_AV1          MK_BMSK_(ASTAT_AV1_P)
+/*Condition Code, used for holding comparison results*/
+#define ASTAT_CC           MK_BMSK_(ASTAT_CC_P)
+/*Quotient Bit*/
+#define ASTAT_AQ           MK_BMSK_(ASTAT_AQ_P)
+/*Rounding mode, set for biased, clear for unbiased*/
+#define ASTAT_RND_MOD      MK_BMSK_(ASTAT_RND_MOD_P)
+/*Overflow Bit*/
+#define ASTAT_V            MK_BMSK_(ASTAT_V_P)
+/*Overflow Bit*/
+#define ASTAT_V_COPY       MK_BMSK_(ASTAT_V_COPY_P)
+
+/**************************************************
+ *   SEQSTAT register
+ **************************************************/
+
+/* Bit Positions  */
+#define SEQSTAT_EXCAUSE0_P      0x00000000	/* Last exception cause bit 0 */
+#define SEQSTAT_EXCAUSE1_P      0x00000001	/* Last exception cause bit 1 */
+#define SEQSTAT_EXCAUSE2_P      0x00000002	/* Last exception cause bit 2 */
+#define SEQSTAT_EXCAUSE3_P      0x00000003	/* Last exception cause bit 3 */
+#define SEQSTAT_EXCAUSE4_P      0x00000004	/* Last exception cause bit 4 */
+#define SEQSTAT_EXCAUSE5_P      0x00000005	/* Last exception cause bit 5 */
+#define SEQSTAT_IDLE_REQ_P      0x0000000C	/* Pending idle mode request,
+						 * set by IDLE instruction.
+						 */
+#define SEQSTAT_SFTRESET_P      0x0000000D	/* Indicates whether the last
+						 * reset was a software reset
+						 * (=1)
+						 */
+#define SEQSTAT_HWERRCAUSE0_P   0x0000000E	/* Last hw error cause bit 0 */
+#define SEQSTAT_HWERRCAUSE1_P   0x0000000F	/* Last hw error cause bit 1 */
+#define SEQSTAT_HWERRCAUSE2_P   0x00000010	/* Last hw error cause bit 2 */
+#define SEQSTAT_HWERRCAUSE3_P   0x00000011	/* Last hw error cause bit 3 */
+#define SEQSTAT_HWERRCAUSE4_P   0x00000012	/* Last hw error cause bit 4 */
+#define SEQSTAT_HWERRCAUSE5_P   0x00000013	/* Last hw error cause bit 5 */
+#define SEQSTAT_HWERRCAUSE6_P   0x00000014	/* Last hw error cause bit 6 */
+#define SEQSTAT_HWERRCAUSE7_P   0x00000015	/* Last hw error cause bit 7 */
+/* Masks */
+/* Exception cause */
+#define SEQSTAT_EXCAUSE        MK_BMSK_(SEQSTAT_EXCAUSE0_P ) | \
+                               MK_BMSK_(SEQSTAT_EXCAUSE1_P ) | \
+                               MK_BMSK_(SEQSTAT_EXCAUSE2_P ) | \
+                               MK_BMSK_(SEQSTAT_EXCAUSE3_P ) | \
+                               MK_BMSK_(SEQSTAT_EXCAUSE4_P ) | \
+                               MK_BMSK_(SEQSTAT_EXCAUSE5_P ) | \
+                               0
+
+/* Indicates whether the last reset was a software reset (=1) */
+#define SEQSTAT_SFTRESET       MK_BMSK_(SEQSTAT_SFTRESET_P )
+
+/* Last hw error cause */
+#define SEQSTAT_HWERRCAUSE     MK_BMSK_(SEQSTAT_HWERRCAUSE0_P ) | \
+                               MK_BMSK_(SEQSTAT_HWERRCAUSE1_P ) | \
+                               MK_BMSK_(SEQSTAT_HWERRCAUSE2_P ) | \
+                               MK_BMSK_(SEQSTAT_HWERRCAUSE3_P ) | \
+                               MK_BMSK_(SEQSTAT_HWERRCAUSE4_P ) | \
+                               0
+
+/**************************************************
+ *   SYSCFG register
+ **************************************************/
+
+/* Bit Positions */
+#define SYSCFG_SSSTEP_P     0x00000000     /* Supervisor single step, when
+					    * set it forces an exception
+					    * for each instruction executed
+					    */
+#define SYSCFG_CCEN_P       0x00000001     /* Enable cycle counter (=1) */
+#define SYSCFG_SNEN_P       0x00000002     /* Self nesting Interrupt Enable */
+
+/* Masks */
+
+/* Supervisor single step, when set it forces an exception for each
+ *instruction executed
+ */
+#define SYSCFG_SSSTEP         MK_BMSK_(SYSCFG_SSSTEP_P )
+/* Enable cycle counter (=1) */
+#define SYSCFG_CCEN           MK_BMSK_(SYSCFG_CCEN_P )
+/* Self Nesting Interrupt Enable */
+#define SYSCFG_SNEN	       MK_BMSK_(SYSCFG_SNEN_P)
+/* Backward-compatibility for typos in prior releases */
+#define SYSCFG_SSSSTEP         SYSCFG_SSSTEP
+#define SYSCFG_CCCEN           SYSCFG_CCEN
+
+/****************************************************
+ * Core MMR Register Map
+ ****************************************************/
+
+/* Data Cache & SRAM Memory  (0xFFE00000 - 0xFFE00404) */
+
+#define SRAM_BASE_ADDRESS  0xFFE00000  /* SRAM Base Address Register */
+#define DMEM_CONTROL       0xFFE00004  /* Data memory control */
+#define DCPLB_STATUS       0xFFE00008  /* Data Cache Programmable Look-Aside
+					* Buffer Status
+					*/
+#define DCPLB_FAULT_STATUS 0xFFE00008  /* "" (older define) */
+#define DCPLB_FAULT_ADDR   0xFFE0000C  /* Data Cache Programmable Look-Aside
+					* Buffer Fault Address
+					*/
+#define DCPLB_ADDR0        0xFFE00100  /* Data Cache Protection Lookaside
+					* Buffer 0
+					*/
+#define DCPLB_ADDR1        0xFFE00104  /* Data Cache Protection Lookaside
+					* Buffer 1
+					*/
+#define DCPLB_ADDR2        0xFFE00108  /* Data Cache Protection Lookaside
+					* Buffer 2
+					*/
+#define DCPLB_ADDR3        0xFFE0010C  /* Data Cacheability Protection
+					* Lookaside Buffer 3
+					*/
+#define DCPLB_ADDR4        0xFFE00110  /* Data Cacheability Protection
+					* Lookaside Buffer 4
+					*/
+#define DCPLB_ADDR5        0xFFE00114  /* Data Cacheability Protection
+					* Lookaside Buffer 5
+					*/
+#define DCPLB_ADDR6        0xFFE00118  /* Data Cacheability Protection
+					* Lookaside Buffer 6
+					*/
+#define DCPLB_ADDR7        0xFFE0011C  /* Data Cacheability Protection
+					* Lookaside Buffer 7
+					*/
+#define DCPLB_ADDR8        0xFFE00120  /* Data Cacheability Protection
+					* Lookaside Buffer 8
+					*/
+#define DCPLB_ADDR9        0xFFE00124  /* Data Cacheability Protection
+					* Lookaside Buffer 9
+					*/
+#define DCPLB_ADDR10       0xFFE00128  /* Data Cacheability Protection
+					* Lookaside Buffer 10
+					*/
+#define DCPLB_ADDR11       0xFFE0012C  /* Data Cacheability Protection
+					* Lookaside Buffer 11
+					*/
+#define DCPLB_ADDR12       0xFFE00130  /* Data Cacheability Protection
+					* Lookaside Buffer 12
+					*/
+#define DCPLB_ADDR13       0xFFE00134  /* Data Cacheability Protection
+					* Lookaside Buffer 13
+					*/
+#define DCPLB_ADDR14       0xFFE00138  /* Data Cacheability Protection
+					* Lookaside Buffer 14
+					*/
+#define DCPLB_ADDR15       0xFFE0013C  /* Data Cacheability Protection
+					* Lookaside Buffer 15
+					*/
+#define DCPLB_DATA0        0xFFE00200  /* Data Cache 0 Status */
+#define DCPLB_DATA1        0xFFE00204  /* Data Cache 1 Status */
+#define DCPLB_DATA2        0xFFE00208  /* Data Cache 2 Status */
+#define DCPLB_DATA3        0xFFE0020C  /* Data Cache 3 Status */
+#define DCPLB_DATA4        0xFFE00210  /* Data Cache 4 Status */
+#define DCPLB_DATA5        0xFFE00214  /* Data Cache 5 Status */
+#define DCPLB_DATA6        0xFFE00218  /* Data Cache 6 Status */
+#define DCPLB_DATA7        0xFFE0021C  /* Data Cache 7 Status */
+#define DCPLB_DATA8        0xFFE00220  /* Data Cache 8 Status */
+#define DCPLB_DATA9        0xFFE00224  /* Data Cache 9 Status */
+#define DCPLB_DATA10       0xFFE00228  /* Data Cache 10 Status */
+#define DCPLB_DATA11       0xFFE0022C  /* Data Cache 11 Status */
+#define DCPLB_DATA12       0xFFE00230  /* Data Cache 12 Status */
+#define DCPLB_DATA13       0xFFE00234  /* Data Cache 13 Status */
+#define DCPLB_DATA14       0xFFE00238  /* Data Cache 14 Status */
+#define DCPLB_DATA15       0xFFE0023C  /* Data Cache 15 Status */
+#define DCPLB_DATA16       0xFFE00240  /* Extra Dummy entry */
+
+#define DTEST_COMMAND      0xFFE00300  /* Data Test Command Register */
+#define DTEST_DATA0        0xFFE00400  /* Data Test Data Register */
+#define DTEST_DATA1        0xFFE00404  /* Data Test Data Register */
+
+/* Instruction Cache & SRAM Memory  (0xFFE01004 - 0xFFE01404) */
+
+#define IMEM_CONTROL       0xFFE01004  /* Instruction Memory Control */
+#define ICPLB_STATUS       0xFFE01008 /* Instruction Cache miss status */
+#define CODE_FAULT_STATUS  0xFFE01008  /* "" (older define) */
+#define ICPLB_FAULT_ADDR   0xFFE0100C  /* Instruction Cache miss address */
+#define CODE_FAULT_ADDR    0xFFE0100C  /* "" (older define) */
+#define ICPLB_ADDR0        0xFFE01100  /* Instruction Cacheability
+					* Protection Lookaside Buffer 0
+					*/
+#define ICPLB_ADDR1        0xFFE01104  /* Instruction Cacheability
+					* Protection Lookaside Buffer 1
+					*/
+#define ICPLB_ADDR2        0xFFE01108  /* Instruction Cacheability
+					* Protection Lookaside Buffer 2
+					*/
+#define ICPLB_ADDR3        0xFFE0110C  /* Instruction Cacheability
+					* Protection Lookaside Buffer 3
+					*/
+#define ICPLB_ADDR4        0xFFE01110  /* Instruction Cacheability
+					* Protection Lookaside Buffer 4
+					*/
+#define ICPLB_ADDR5        0xFFE01114  /* Instruction Cacheability
+					* Protection Lookaside Buffer 5
+					*/
+#define ICPLB_ADDR6        0xFFE01118  /* Instruction Cacheability
+					* Protection Lookaside Buffer 6
+					*/
+#define ICPLB_ADDR7        0xFFE0111C  /* Instruction Cacheability
+					* Protection Lookaside Buffer 7
+					*/
+#define ICPLB_ADDR8        0xFFE01120  /* Instruction Cacheability
+					* Protection Lookaside Buffer 8
+					*/
+#define ICPLB_ADDR9        0xFFE01124  /* Instruction Cacheability
+					* Protection Lookaside Buffer 9
+					*/
+#define ICPLB_ADDR10       0xFFE01128  /* Instruction Cacheability
+					* Protection Lookaside Buffer 10
+					*/
+#define ICPLB_ADDR11       0xFFE0112C  /* Instruction Cacheability
+					* Protection Lookaside Buffer 11
+					*/
+#define ICPLB_ADDR12       0xFFE01130  /* Instruction Cacheability
+					* Protection Lookaside Buffer 12
+					*/
+#define ICPLB_ADDR13       0xFFE01134  /* Instruction Cacheability
+					* Protection Lookaside Buffer 13
+					*/
+#define ICPLB_ADDR14       0xFFE01138  /* Instruction Cacheability
+					* Protection Lookaside Buffer 14
+					*/
+#define ICPLB_ADDR15       0xFFE0113C  /* Instruction Cacheability
+					* Protection Lookaside Buffer 15
+					*/
+#define ICPLB_DATA0        0xFFE01200  /* Instruction Cache 0 Status */
+#define ICPLB_DATA1        0xFFE01204  /* Instruction Cache 1 Status */
+#define ICPLB_DATA2        0xFFE01208  /* Instruction Cache 2 Status */
+#define ICPLB_DATA3        0xFFE0120C  /* Instruction Cache 3 Status */
+#define ICPLB_DATA4        0xFFE01210  /* Instruction Cache 4 Status */
+#define ICPLB_DATA5        0xFFE01214  /* Instruction Cache 5 Status */
+#define ICPLB_DATA6        0xFFE01218  /* Instruction Cache 6 Status */
+#define ICPLB_DATA7        0xFFE0121C  /* Instruction Cache 7 Status */
+#define ICPLB_DATA8        0xFFE01220  /* Instruction Cache 8 Status */
+#define ICPLB_DATA9        0xFFE01224  /* Instruction Cache 9 Status */
+#define ICPLB_DATA10       0xFFE01228  /* Instruction Cache 10 Status */
+#define ICPLB_DATA11       0xFFE0122C  /* Instruction Cache 11 Status */
+#define ICPLB_DATA12       0xFFE01230  /* Instruction Cache 12 Status */
+#define ICPLB_DATA13       0xFFE01234  /* Instruction Cache 13 Status */
+#define ICPLB_DATA14       0xFFE01238  /* Instruction Cache 14 Status */
+#define ICPLB_DATA15       0xFFE0123C  /* Instruction Cache 15 Status */
+#define ITEST_COMMAND      0xFFE01300  /* Instruction Test Command Register */
+#define ITEST_DATA0        0xFFE01400  /* Instruction Test Data Register */
+#define ITEST_DATA1        0xFFE01404  /* Instruction Test Data Register */
+
+/* Event/Interrupt Controller Registers   (0xFFE02000 - 0xFFE02110) */
+
+#define EVT0               0xFFE02000  /* Event Vector 0 ESR Address */
+#define EVT1               0xFFE02004  /* Event Vector 1 ESR Address */
+#define EVT2               0xFFE02008  /* Event Vector 2 ESR Address */
+#define EVT3               0xFFE0200C  /* Event Vector 3 ESR Address */
+#define EVT4               0xFFE02010  /* Event Vector 4 ESR Address */
+#define EVT5               0xFFE02014  /* Event Vector 5 ESR Address */
+#define EVT6               0xFFE02018  /* Event Vector 6 ESR Address */
+#define EVT7               0xFFE0201C  /* Event Vector 7 ESR Address */
+#define EVT8               0xFFE02020  /* Event Vector 8 ESR Address */
+#define EVT9               0xFFE02024  /* Event Vector 9 ESR Address */
+#define EVT10              0xFFE02028  /* Event Vector 10 ESR Address */
+#define EVT11              0xFFE0202C  /* Event Vector 11 ESR Address */
+#define EVT12              0xFFE02030  /* Event Vector 12 ESR Address */
+#define EVT13              0xFFE02034  /* Event Vector 13 ESR Address */
+#define EVT14              0xFFE02038  /* Event Vector 14 ESR Address */
+#define EVT15              0xFFE0203C  /* Event Vector 15 ESR Address */
+#define IMASK              0xFFE02104  /* Interrupt Mask Register */
+#define IPEND              0xFFE02108  /* Interrupt Pending Register */
+#define ILAT               0xFFE0210C  /* Interrupt Latch Register */
+#define IPRIO              0xFFE02110  /* Core Interrupt Priority Register */
+
+/* Core Timer Registers     (0xFFE03000 - 0xFFE0300C) */
+
+#define TCNTL              0xFFE03000  /* Core Timer Control Register */
+#define TPERIOD            0xFFE03004  /* Core Timer Period Register */
+#define TSCALE             0xFFE03008  /* Core Timer Scale Register */
+#define TCOUNT             0xFFE0300C  /* Core Timer Count Register */
+
+/* Debug/MP/Emulation Registers     (0xFFE05000 - 0xFFE05008) */
+#define DSPID              0xFFE05000  /* DSP Processor ID Register for
+					* MP implementations
+					*/
+
+#define DBGSTAT            0xFFE05008  /* Debug Status Register */
+
+
+/* Trace Buffer Registers     (0xFFE06000 - 0xFFE06100) */
+
+#define TBUFCTL            0xFFE06000  /* Trace Buffer Control Register */
+#define TBUFSTAT           0xFFE06004  /* Trace Buffer Status Register */
+#define TBUF               0xFFE06100  /* Trace Buffer */
+
+/* Watchpoint Control Registers (0xFFE07000 - 0xFFE07200) */
+
+/* Watchpoint Instruction Address Control Register */
+#define WPIACTL            0xFFE07000
+/* Watchpoint Instruction Address Register 0 */
+#define WPIA0              0xFFE07040
+/* Watchpoint Instruction Address Register 1 */
+#define WPIA1              0xFFE07044
+/* Watchpoint Instruction Address Register 2 */
+#define WPIA2              0xFFE07048
+/* Watchpoint Instruction Address Register 3 */
+#define WPIA3              0xFFE0704C
+/* Watchpoint Instruction Address Register 4 */
+#define WPIA4              0xFFE07050
+/* Watchpoint Instruction Address Register 5 */
+#define WPIA5              0xFFE07054
+/* Watchpoint Instruction Address Count Register 0 */
+#define WPIACNT0           0xFFE07080
+/* Watchpoint Instruction Address Count Register 1 */
+#define WPIACNT1           0xFFE07084
+/* Watchpoint Instruction Address Count Register 2 */
+#define WPIACNT2           0xFFE07088
+/* Watchpoint Instruction Address Count Register 3 */
+#define WPIACNT3           0xFFE0708C
+/* Watchpoint Instruction Address Count Register 4 */
+#define WPIACNT4           0xFFE07090
+/* Watchpoint Instruction Address Count Register 5 */
+#define WPIACNT5           0xFFE07094
+/* Watchpoint Data Address Control Register */
+#define WPDACTL            0xFFE07100
+/* Watchpoint Data Address Register 0 */
+#define WPDA0              0xFFE07140
+/* Watchpoint Data Address Register 1 */
+#define WPDA1              0xFFE07144
+/* Watchpoint Data Address Count Value Register 0 */
+#define WPDACNT0           0xFFE07180
+/* Watchpoint Data Address Count Value Register 1 */
+#define WPDACNT1           0xFFE07184
+/* Watchpoint Status Register */
+#define WPSTAT             0xFFE07200
+
+/* Performance Monitor Registers    (0xFFE08000 - 0xFFE08104) */
+
+/* Performance Monitor Control Register */
+#define PFCTL              0xFFE08000
+/* Performance Monitor Counter Register 0 */
+#define PFCNTR0            0xFFE08100
+/* Performance Monitor Counter Register 1 */
+#define PFCNTR1            0xFFE08104
+
+/****************************************************
+ * Core MMR Register Bits
+ ****************************************************/
+
+/**************************************************
+ * EVT registers (ILAT, IMASK, and IPEND).
+ **************************************************/
+
+/* Bit Positions */
+#define EVT_EMU_P        0x00000000  /* Emulator interrupt bit position */
+#define EVT_RST_P        0x00000001  /* Reset interrupt bit position */
+#define EVT_NMI_P        0x00000002  /* Non Maskable interrupt bit position */
+#define EVT_EVX_P        0x00000003  /* Exception bit position */
+#define EVT_IRPTEN_P     0x00000004  /* Global interrupt enable bit position */
+#define EVT_IVHW_P       0x00000005  /* Hardware Error interrupt bit position */
+#define EVT_IVTMR_P      0x00000006  /* Timer interrupt bit position */
+#define EVT_IVG7_P       0x00000007  /* IVG7 interrupt bit position */
+#define EVT_IVG8_P       0x00000008  /* IVG8 interrupt bit position */
+#define EVT_IVG9_P       0x00000009  /* IVG9 interrupt bit position */
+#define EVT_IVG10_P      0x0000000a  /* IVG10 interrupt bit position */
+#define EVT_IVG11_P      0x0000000b  /* IVG11 interrupt bit position */
+#define EVT_IVG12_P      0x0000000c  /* IVG12 interrupt bit position */
+#define EVT_IVG13_P      0x0000000d  /* IVG13 interrupt bit position */
+#define EVT_IVG14_P      0x0000000e  /* IVG14 interrupt bit position */
+#define EVT_IVG15_P      0x0000000f  /* IVG15 interrupt bit position */
+
+/* Masks */
+#define EVT_EMU       MK_BMSK_(EVT_EMU_P   ) /* Emulator interrupt mask */
+#define EVT_RST       MK_BMSK_(EVT_RST_P   ) /* Reset interrupt mask */
+#define EVT_NMI       MK_BMSK_(EVT_NMI_P   ) /* Non Maskable interrupt mask */
+#define EVT_EVX       MK_BMSK_(EVT_EVX_P   ) /* Exception mask */
+#define EVT_IRPTEN    MK_BMSK_(EVT_IRPTEN_P) /* Global interrupt enable mask */
+#define EVT_IVHW      MK_BMSK_(EVT_IVHW_P  ) /* Hardware Error interrupt mask */
+#define EVT_IVTMR     MK_BMSK_(EVT_IVTMR_P ) /* Timer interrupt mask */
+#define EVT_IVG7      MK_BMSK_(EVT_IVG7_P  ) /* IVG7 interrupt mask */
+#define EVT_IVG8      MK_BMSK_(EVT_IVG8_P  ) /* IVG8 interrupt mask */
+#define EVT_IVG9      MK_BMSK_(EVT_IVG9_P  ) /* IVG9 interrupt mask */
+#define EVT_IVG10     MK_BMSK_(EVT_IVG10_P ) /* IVG10 interrupt mask */
+#define EVT_IVG11     MK_BMSK_(EVT_IVG11_P ) /* IVG11 interrupt mask */
+#define EVT_IVG12     MK_BMSK_(EVT_IVG12_P ) /* IVG12 interrupt mask */
+#define EVT_IVG13     MK_BMSK_(EVT_IVG13_P ) /* IVG13 interrupt mask */
+#define EVT_IVG14     MK_BMSK_(EVT_IVG14_P ) /* IVG14 interrupt mask */
+#define EVT_IVG15     MK_BMSK_(EVT_IVG15_P ) /* IVG15 interrupt mask */
+
+/**************************************************
+ *  DMEM_CONTROL Register
+ **************************************************/
+/* Bit Positions */
+#define ENDM_P			0x00	/* (doesn't really exist) Enable
+					 *Data Memory L1
+					 */
+#define DMCTL_ENDM_P		ENDM_P	/* "" (older define) */
+
+#define ENDCPLB_P		0x01	/* Enable DCPLBS */
+#define DMCTL_ENDCPLB_P		ENDCPLB_P  /* "" (older define) */
+#define DMC0_P			0x02	/* L1 Data Memory Configure bit 0 */
+#define DMCTL_DMC0_P		DMC0_P	/* "" (older define) */
+#define DMC1_P			0x03	/* L1 Data Memory Configure bit 1 */
+#define DMCTL_DMC1_P		DMC1_P	/* "" (older define) */
+#define DCBS_P			0x04	/* L1 Data Cache Bank Select */
+#define PORT_PREF0_P		0x12	/* DAG0 Port Preference */
+#define PORT_PREF1_P		0x13	/* DAG1 Port Preference */
+
+/* Masks */
+#define ENDM               0x00000001   /* (doesn't really exist) Enable
+					 * Data Memory L1
+					 */
+#define ENDCPLB            0x00000002   /* Enable DCPLB */
+#define ASRAM_BSRAM        0x00000000
+#define ACACHE_BSRAM       0x00000008
+#define ACACHE_BCACHE      0x0000000C
+#define DCBS               0x00000010   /*  L1 Data Cache Bank Select */
+#define PORT_PREF0	   0x00001000   /* DAG0 Port Preference */
+#define PORT_PREF1	   0x00002000   /* DAG1 Port Preference */
+
+/* IMEM_CONTROL Register */
+/* Bit Positions */
+#define ENIM_P			0x00   /* Enable L1 Code Memory  */
+#define IMCTL_ENIM_P            0x00   /* "" (older define) */
+#define ENICPLB_P		0x01   /* Enable ICPLB */
+#define IMCTL_ENICPLB_P		0x01   /* "" (older define) */
+#define IMC_P			0x02   /* Enable  */
+#define IMCTL_IMC_P		0x02   /* Configure L1 code memory as
+					* cache (0=SRAM)
+					*/
+#define ILOC0_P			0x03   /* Lock Way 0 */
+#define ILOC1_P			0x04   /* Lock Way 1 */
+#define ILOC2_P			0x05   /* Lock Way 2 */
+#define ILOC3_P			0x06   /* Lock Way 3 */
+#define LRUPRIORST_P		0x0D   /* Least Recently Used Replacement
+					* Priority
+					*/
+/* Masks */
+#define ENIM               0x00000001  /* Enable L1 Code Memory */
+#define ENICPLB            0x00000002  /* Enable ICPLB */
+#define IMC                0x00000004  /* Configure L1 code memory as
+					* cache (0=SRAM)
+					*/
+#define ILOC0		   0x00000008  /* Lock Way 0 */
+#define ILOC1		   0x00000010  /* Lock Way 1 */
+#define ILOC2		   0x00000020  /* Lock Way 2 */
+#define ILOC3		   0x00000040  /* Lock Way 3 */
+#define LRUPRIORST	   0x00002000  /* Least Recently Used Replacement
+					* Priority
+					*/
+
+/* TCNTL Masks */
+#define TMPWR              0x00000001  /* Timer Low Power Control,
+					* 0=low power mode, 1=active state
+					*/
+#define TMREN              0x00000002  /* Timer enable, 0=disable, 1=enable */
+#define TAUTORLD           0x00000004  /* Timer auto reload */
+#define TINT               0x00000008  /* Timer generated interrupt 0=no
+					* interrupt has been generated,
+					* 1=interrupt has been generated
+					* (sticky)
+					*/
+
+/* TCNTL Bit Positions */
+#define TMPWR_P             0x00000000  /* Timer Low Power Control, 0=low power
+					 * mode, 1=active state
+					 */
+#define TMREN_P             0x00000001  /* Timer enable, 0=disable, 1=enable */
+#define TAUTORLD_P          0x00000002  /* Timer auto reload */
+#define TINT_P              0x00000003  /* Timer generated interrupt 0=no
+					 * interrupt has been generated,
+					 * 1=interrupt has been generated
+					 * (sticky)
+					 */
+
+/* DCPLB_DATA and ICPLB_DATA Registers */
+/* Bit Positions */
+#define CPLB_VALID_P       0x00000000  /* 0=invalid entry, 1=valid entry */
+#define CPLB_LOCK_P        0x00000001  /* 0=entry may be replaced, 1=entry
+					* locked
+					*/
+#define CPLB_USER_RD_P     0x00000002  /* 0=no read access, 1=read access
+					* allowed (user mode)
+					*/
+/* Masks */
+#define CPLB_VALID         0x00000001  /* 0=invalid entry, 1=valid entry */
+#define CPLB_LOCK          0x00000002  /* 0=entry may be replaced, 1=entry
+					* locked
+					*/
+#define CPLB_USER_RD       0x00000004  /* 0=no read access, 1=read access
+					* allowed (user mode)
+					*/
+#define PAGE_SIZE_1KB      0x00000000  /* 1 KB page size */
+#define PAGE_SIZE_4KB      0x00010000  /* 4 KB page size */
+#define PAGE_SIZE_1MB      0x00020000  /* 1 MB page size */
+#define PAGE_SIZE_4MB      0x00030000  /* 4 MB page size */
+#define CPLB_L1SRAM        0x00000020  /* 0=SRAM mapped in L1, 0=SRAM not
+					* mapped to L1
+					*/
+#define CPLB_PORTPRIO	   0x00000200  /* 0=low priority port, 1= high
+					* priority port
+					*/
+#define CPLB_L1_CHBL       0x00001000  /* 0=non-cacheable in L1, 1=cacheable
+					* in L1
+					*/
+/* ICPLB_DATA only */
+#define CPLB_LRUPRIO	   0x00000100  /* 0=can be replaced by any line,
+					* 1=priority for non-replacement
+					*/
+/* DCPLB_DATA only */
+#define CPLB_USER_WR       0x00000008  /* 0=no write access, 0=write
+					* access allowed (user mode)
+					*/
+#define CPLB_SUPV_WR       0x00000010  /* 0=no write access, 0=write
+					* access allowed (supervisor mode)
+					*/
+#define CPLB_DIRTY         0x00000080  /* 1=dirty, 0=clean */
+#define CPLB_L1_AOW	   0x00008000  /* 0=do not allocate cache lines on
+					* write-through writes,
+					* 1= allocate cache lines on
+					* write-through writes.
+					*/
+#define CPLB_WT            0x00004000  /* 0=write-back, 1=write-through */
+
+
+
+/* ITEST_COMMAND and DTEST_COMMAND Registers */
+/* Masks */
+#define TEST_READ	   0x00000000  /* Read Access */
+#define TEST_WRITE	   0x00000002  /* Write Access */
+#define TEST_TAG	   0x00000000  /* Access TAG */
+#define TEST_DATA	   0x00000004  /* Access DATA */
+#define TEST_DW0	   0x00000000  /* Select Double Word 0 */
+#define TEST_DW1	   0x00000008  /* Select Double Word 1 */
+#define TEST_DW2	   0x00000010  /* Select Double Word 2 */
+#define TEST_DW3	   0x00000018  /* Select Double Word 3 */
+#define TEST_MB0	   0x00000000  /* Select Mini-Bank 0 */
+#define TEST_MB1	   0x00010000  /* Select Mini-Bank 1 */
+#define TEST_MB2	   0x00020000  /* Select Mini-Bank 2 */
+#define TEST_MB3	   0x00030000  /* Select Mini-Bank 3 */
+#define TEST_SET(x)	   ((x << 5) & 0x03E0)  /* Set Index 0->31 */
+#define TEST_WAY0	   0x00000000  /* Access Way0 */
+#define TEST_WAY1	   0x04000000  /* Access Way1 */
+/* ITEST_COMMAND only */
+#define TEST_WAY2	   0x08000000  /* Access Way2 */
+#define TEST_WAY3	   0x0C000000  /* Access Way3 */
+/* DTEST_COMMAND only */
+#define TEST_BNKSELA	   0x00000000  /* Access SuperBank A */
+#define TEST_BNKSELB	   0x00800000  /* Access SuperBank B */
+
+#endif	/* _DEF_LPBLACKFIN_H */
Index: git/linux-2.6/include/asm-blackfin/macros.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/macros.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,96 @@
+/************************************************************************
+ *
+ * macros.h
+ *
+ * (c) Copyright 2001-2003 Analog Devices, Inc.  All rights reserved.
+ *
+ ************************************************************************/
+
+/* Defines various assembly macros. */
+
+#ifndef _MACROS_H
+#define _MACROS_H
+
+#define LO(con32) ((con32) & 0xFFFF)
+#define lo(con32) ((con32) & 0xFFFF)
+#define HI(con32) (((con32) >> 16) & 0xFFFF)
+#define hi(con32) (((con32) >> 16) & 0xFFFF)
+
+/*
+ * Set the corresponding bits in a System Register (SR);
+ * All bits set in "mask" will be set in the system register
+ * specified by "sys_reg" bitset_SR(sys_reg, mask), where
+ * sys_reg is the system register and mask are the bits to be set.
+ */
+#define bitset_SR(sys_reg, mask)\
+		[--SP] = (R7:6);\
+		r7 = sys_reg;\
+		r6.l = (mask) & 0xffff;\
+		r6.h = (mask) >> 16;\
+		r7 = r7 | r6;\
+		sys_reg = r7;\
+		csync;\
+		(R7:6) = [SP++]
+
+/*
+ * Clear the corresponding bits in a System Register (SR);
+ * All bits set in "mask" will be cleared in the SR
+ * specified by "sys_reg" bitclr_SR(sys_reg, mask), where
+ * sys_reg is the SR and mask are the bits to be cleared.
+ */
+#define bitclr_SR(sys_reg, mask)\
+		[--SP] = (R7:6);\
+		r7 = sys_reg;\
+		r7 =~ r7;\
+		r6.l = (mask) & 0xffff;\
+		r6.h = (mask) >> 16;\
+		r7 = r7 | r6;\
+		r7 =~ r7;\
+		sys_reg = r7;\
+		csync;\
+		(R7:6) = [SP++]
+
+/*
+ * Set the corresponding bits in a Memory Mapped Register (MMR);
+ * All bits set in "mask" will be set in the MMR specified by "mmr_reg"
+ * bitset_MMR(mmr_reg, mask), where mmr_reg is the MMR and mask are
+ * the bits to be set.
+ */
+#define bitset_MMR(mmr_reg, mask)\
+		[--SP] = (R7:6);\
+		[--SP] = P5;\
+		p5.l = mmr_reg & 0xffff;\
+		p5.h = mmr_reg >> 16;\
+		r7 = [p5];\
+		r6.l = (mask) & 0xffff;\
+		r6.h = (mask) >> 16;\
+		r7 = r7 | r6;\
+		[p5] = r7;\
+		csync;\
+		p5 = [SP++];\
+		(R7:6) = [SP++]
+
+/*
+ * Clear the corresponding bits in a Memory Mapped Register (MMR);
+ * All bits set in "mask" will be cleared in the MMR specified by "mmr_reg"
+ * bitclr_MMRreg(mmr_reg, mask), where sys_reg is the MMR and mask are
+ * the bits to be cleared.
+ */
+#define bitclr_MMR(mmr_reg, mask)\
+		[--SP] = (R7:6);\
+		[--SP] = P5;\
+		p5.l = mmr_reg & 0xffff;\
+		p5.h = mmr_reg >> 16;\
+		r7 = [p5];\
+		r7 =~ r7;\
+		r6.l = (mask) & 0xffff;\
+		r6.h = (mask) >> 16;\
+		r7 = r7 | r6;\
+		r7 =~ r7;\
+		[p5] = r7;\
+		csync;\
+		p5 = [SP++];\
+		(R7:6) = [SP++]
+
+
+#endif /* _MACROS_H */
Index: git/linux-2.6/include/asm-blackfin/mem_map.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mem_map.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,13 @@
+/*
+ * mem_map.h
+ * Common header file for blackfin family of processors.
+ *
+ */
+
+#ifndef _MEM_MAP_H_
+#define _MEM_MAP_H_
+
+#include <linux/config.h>
+#include <asm/mach/mem_map.h>
+
+#endif				/* _MEM_MAP_H_ */
Index: git/linux-2.6/include/asm-blackfin/mman.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mman.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,43 @@
+#ifndef __BFIN_MMAN_H__
+#define __BFIN_MMAN_H__
+
+#define PROT_READ	0x1	/* page can be read */
+#define PROT_WRITE	0x2	/* page can be written */
+#define PROT_EXEC	0x4	/* page can be executed */
+#define PROT_SEM	0x8	/* page may be used for atomic ops */
+#define PROT_NONE	0x0	/* page can not be accessed */
+#define PROT_GROWSDOWN	0x01000000	/* mprotect flag: extend change to start of growsdown vma */
+#define PROT_GROWSUP	0x02000000	/* mprotect flag: extend change to end of growsup vma */
+
+#define MAP_SHARED	0x01	/* Share changes */
+#define MAP_PRIVATE	0x02	/* Changes are private */
+#define MAP_TYPE	0x0f	/* Mask for type of mapping */
+#define MAP_FIXED	0x10	/* Interpret addr exactly */
+#define MAP_ANONYMOUS	0x20	/* don't use a file */
+
+#define MAP_GROWSDOWN	0x0100	/* stack-like segment */
+#define MAP_DENYWRITE	0x0800	/* ETXTBSY */
+#define MAP_EXECUTABLE	0x1000	/* mark it as an executable */
+#define MAP_LOCKED	0x2000	/* pages are locked */
+#define MAP_NORESERVE	0x4000	/* don't check for reservations */
+#define MAP_POPULATE	0x8000	/* populate (prefault) pagetables */
+#define MAP_NONBLOCK	0x10000	/* do not block on IO */
+
+#define MS_ASYNC	1	/* sync memory asynchronously */
+#define MS_INVALIDATE	2	/* invalidate the caches */
+#define MS_SYNC		4	/* synchronous memory sync */
+
+#define MCL_CURRENT	1	/* lock all current mappings */
+#define MCL_FUTURE	2	/* lock all future mappings */
+
+#define MADV_NORMAL	0x0	/* default page-in behavior */
+#define MADV_RANDOM	0x1	/* page-in minimum required */
+#define MADV_SEQUENTIAL	0x2	/* read-ahead aggressively */
+#define MADV_WILLNEED	0x3	/* pre-fault pages */
+#define MADV_DONTNEED	0x4	/* discard these pages */
+
+/* compatibility flags */
+#define MAP_ANON	MAP_ANONYMOUS
+#define MAP_FILE	0
+
+#endif				/* __BFIN_MMAN_H__ */
Index: git/linux-2.6/include/asm-blackfin/mmu.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mmu.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,11 @@
+#ifndef __MMU_H
+#define __MMU_H
+
+/* Copyright (C) 2002, David McCullough <davidm@snapgear.com> */
+
+typedef struct {
+	struct vm_list_struct *vmlist;
+	unsigned long end_brk;
+} mm_context_t;
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/mmu_context.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/mmu_context.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,32 @@
+#ifndef __BLACKFIN_MMU_CONTEXT_H
+#define __BLACKFIN_MMU_CONTEXT_H
+
+#include <linux/config.h>
+#include <asm/setup.h>
+#include <asm/page.h>
+#include <asm/pgalloc.h>
+static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
+{
+}
+
+static inline int
+init_new_context(struct task_struct *tsk, struct mm_struct *mm)
+{
+	return (0);
+}
+
+#define destroy_context(mm)		do { } while(0)
+
+static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,
+			     struct task_struct *tsk)
+{
+}
+
+#define deactivate_mm(tsk,mm)	do { } while (0)
+
+static inline void activate_mm(struct mm_struct *prev_mm,
+			       struct mm_struct *next_mm)
+{
+}
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/module.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/module.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,13 @@
+#ifndef _ASM_BFIN_MODULE_H
+#define _ASM_BFIN_MODULE_H
+
+#define MODULE_SYMBOL_PREFIX "_"
+
+struct mod_arch_specific {
+};
+
+#define Elf_Shdr	Elf32_Shdr
+#define Elf_Sym		Elf32_Sym
+#define Elf_Ehdr	Elf32_Ehdr
+
+#endif				/* _ASM_BFIN_MODULE_H */
Index: git/linux-2.6/include/asm-blackfin/msgbuf.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/msgbuf.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,31 @@
+#ifndef _BFIN_MSGBUF_H
+#define _BFIN_MSGBUF_H
+
+/*
+ * The msqid64_ds structure for bfin architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct msqid64_ds {
+	struct ipc64_perm msg_perm;
+	__kernel_time_t msg_stime;	/* last msgsnd time */
+	unsigned long __unused1;
+	__kernel_time_t msg_rtime;	/* last msgrcv time */
+	unsigned long __unused2;
+	__kernel_time_t msg_ctime;	/* last change time */
+	unsigned long __unused3;
+	unsigned long msg_cbytes;	/* current number of bytes on queue */
+	unsigned long msg_qnum;	/* number of messages in queue */
+	unsigned long msg_qbytes;	/* max number of bytes on queue */
+	__kernel_pid_t msg_lspid;	/* pid of last msgsnd */
+	__kernel_pid_t msg_lrpid;	/* last receive pid */
+	unsigned long __unused4;
+	unsigned long __unused5;
+};
+
+#endif				/* _BFIN_MSGBUF_H */
Index: git/linux-2.6/include/asm-blackfin/namei.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/namei.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,19 @@
+/*
+ * linux/include/asm/namei.h
+ *
+ * Included from linux/fs/namei.c
+ *
+ * Changes made by Lineo Inc.    May 2001
+ */
+
+#ifndef __BFIN_NAMEI_H
+#define __BFIN_NAMEI_H
+
+/* This dummy routine maybe changed to something useful
+ * for /usr/gnemul/ emulation stuff.
+ * Look at asm-sparc/namei.h for details.
+ */
+
+#define __emul_prefix() NULL
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/page.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/page.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,85 @@
+#ifndef _BLACKFIN_PAGE_H
+#define _BLACKFIN_PAGE_H
+
+/* PAGE_SHIFT determines the page size */
+#define PAGE_SHIFT	(12)
+#define PAGE_SIZE	(1UL << PAGE_SHIFT)
+#define PAGE_MASK	(~(PAGE_SIZE-1))
+
+#ifdef __KERNEL__
+#ifndef __ASSEMBLY__
+
+#define get_user_page(vaddr)		__get_free_page(GFP_KERNEL)
+#define free_user_page(page, addr)	free_page(addr)
+
+#define clear_page(page)	memset((page), 0, PAGE_SIZE)
+#define copy_page(to,from)	memcpy((to), (from), PAGE_SIZE)
+
+#define clear_user_page(page, vaddr,pg)	clear_page(page)
+#define copy_user_page(to, from, vaddr,pg)	copy_page(to, from)
+
+/*
+ * These are used to make use of C type-checking..
+ */
+typedef struct {
+	unsigned long pte;
+} pte_t;
+typedef struct {
+	unsigned long pmd[16];
+} pmd_t;
+typedef struct {
+	unsigned long pgd;
+} pgd_t;
+typedef struct {
+	unsigned long pgprot;
+} pgprot_t;
+
+#define pte_val(x)	((x).pte)
+#define pmd_val(x)	((&x)->pmd[0])
+#define pgd_val(x)	((x).pgd)
+#define pgprot_val(x)	((x).pgprot)
+
+#define __pte(x)	((pte_t) { (x) } )
+#define __pmd(x)	((pmd_t) { (x) } )
+#define __pgd(x)	((pgd_t) { (x) } )
+#define __pgprot(x)	((pgprot_t) { (x) } )
+
+/* to align the pointer to the (next) page boundary */
+#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
+
+extern unsigned long memory_start;
+extern unsigned long memory_end;
+
+#endif				/* !__ASSEMBLY__ */
+
+#include <asm/page_offset.h>
+#include <asm/io.h>
+
+#define PAGE_OFFSET		(PAGE_OFFSET_RAW)
+
+#ifndef __ASSEMBLY__
+
+#define __pa(vaddr)		virt_to_phys((void *)(vaddr))
+#define __va(paddr)		phys_to_virt((unsigned long)(paddr))
+
+#define MAP_NR(addr)		(((unsigned long)(addr)-PAGE_OFFSET) >> PAGE_SHIFT)
+
+#define virt_to_pfn(kaddr)	(__pa(kaddr) >> PAGE_SHIFT)
+#define pfn_to_virt(pfn)	__va((pfn) << PAGE_SHIFT)
+#define virt_to_page(addr)	(mem_map + (((unsigned long)(addr)-PAGE_OFFSET) >> PAGE_SHIFT))
+#define page_to_virt(page)	((((page) - mem_map) << PAGE_SHIFT) + PAGE_OFFSET)
+#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
+
+#define pfn_to_page(pfn)	virt_to_page(pfn_to_virt(pfn))
+#define page_to_pfn(page)	virt_to_pfn(page_to_virt(page))
+
+#define	virt_addr_valid(kaddr)	(((void *)(kaddr) >= (void *)PAGE_OFFSET) && \
+				((void *)(kaddr) < (void *)memory_end))
+#define pfn_valid(pfn)		virt_addr_valid(pfn_to_virt(pfn))
+
+#include <asm-generic/page.h>
+
+#endif				/* __ASSEMBLY__ */
+#endif				/* __KERNEL__ */
+
+#endif				/* _BLACKFIN_PAGE_H */
Index: git/linux-2.6/include/asm-blackfin/page_offset.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/page_offset.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,7 @@
+#include <linux/config.h>
+
+/* This handles the memory map.. */
+
+#ifdef CONFIG_BFIN
+#define PAGE_OFFSET_RAW		0x00000000
+#endif
Index: git/linux-2.6/include/asm-blackfin/param.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/param.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,22 @@
+#ifndef _BLACKFIN_PARAM_H
+#define _BLACKFIN_PARAM_H
+
+#ifdef __KERNEL__
+#define HZ 		100
+#define	USER_HZ		HZ
+#define	CLOCKS_PER_SEC	(USER_HZ)
+#endif
+
+#ifndef HZ
+#define HZ 100
+#endif
+
+#define EXEC_PAGESIZE	4096
+
+#ifndef NOGROUP
+#define NOGROUP		(-1)
+#endif
+
+#define MAXHOSTNAMELEN	64	/* max length of hostname */
+
+#endif				/* _BLACKFIN_PARAM_H */
Index: git/linux-2.6/include/asm-blackfin/pci.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/pci.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,154 @@
+/* Changed from asm-m68k version, Lineo Inc. 	May 2001	*/
+
+#ifndef _ASM_BFIN_PCI_H
+#define _ASM_BFIN_PCI_H
+
+#include <asm/scatterlist.h>
+
+/*
+ *
+ * Written by Wout Klaren.
+ */
+
+/* Added by Chang Junxiao */
+#define PCIBIOS_MIN_IO 0x00001000
+#define PCIBIOS_MIN_MEM 0x10000000
+
+#define PCI_DMA_BUS_IS_PHYS       (1)
+    struct pci_ops;
+
+/*
+ * Structure with hardware dependent information and functions of the
+ * PCI bus.
+ */
+struct pci_bus_info  {
+
+	    /*
+	     * Resources of the PCI bus.
+	     */
+	struct resource mem_space;
+	struct resource io_space;
+
+	    /*
+	     * System dependent functions.
+	     */
+	struct pci_ops *bfin_pci_ops;
+	void (*fixup) (int pci_modify);
+	void (*conf_device) (unsigned char bus, unsigned char device_fn);
+};
+
+#define pcibios_assign_all_busses()	0
+static inline void pcibios_set_master(struct pci_dev *dev)
+{
+
+	    /* No special bus mastering setup handling */
+}
+static inline void pcibios_penalize_isa_irq(int irq)
+{
+
+	    /* We don't do dynamic PCI IRQ allocation */
+}
+static inline dma_addr_t pci_map_single(struct pci_dev *hwdev, void *ptr,
+					     size_t size, int direction)
+{
+	if (direction == PCI_DMA_NONE)
+		BUG();
+
+	    // return virt_to_bus(ptr);
+	    return (dma_addr_t) ptr;
+}
+
+
+/* Unmap a single streaming mode DMA translation.  The dma_addr and size
+ * must match what was provided for in a previous pci_map_single call.  All
+ * other usages are undefined.
+ *
+ * After this call, reads by the cpu to the buffer are guarenteed to see
+ * whatever the device wrote there.
+ */
+static inline void pci_unmap_single(struct pci_dev *hwdev, dma_addr_t dma_addr,
+				    size_t size, int direction)
+{
+	if (direction == PCI_DMA_NONE)
+		BUG();
+
+	    /* Nothing to do */
+}
+
+
+/* Map a set of buffers described by scatterlist in streaming
+ * mode for DMA.  This is the scather-gather version of the
+ * above pci_map_single interface.  Here the scatter gather list
+ * elements are each tagged with the appropriate dma address
+ * and length.  They are obtained via sg_dma_{address,length}(SG).
+ *
+ * NOTE: An implementation may be able to use a smaller number of
+ *       DMA address/length pairs than there are SG table elements.
+ *       (for example via virtual mapping capabilities)
+ *       The routine returns the number of addr/length pairs actually
+ *       used, at most nents.
+ *
+ * Device ownership issues as mentioned above for pci_map_single are
+ * the same here.
+ */
+static inline int pci_map_sg(struct pci_dev *hwdev, struct scatterlist *sg,
+			     int nents, int direction)
+{
+	if (direction == PCI_DMA_NONE)
+		BUG();
+	return nents;
+}
+
+
+/* Unmap a set of streaming mode DMA translations.
+ * Again, cpu read rules concerning calls here are the same as for
+ * pci_unmap_single() above.
+ */
+static inline void pci_unmap_sg(struct pci_dev *hwdev, struct scatterlist *sg,
+				int nents, int direction)
+{
+	if (direction == PCI_DMA_NONE)
+		BUG();
+
+	    /* Nothing to do */
+}
+
+
+/* Make physical memory consistent for a single
+ * streaming mode DMA translation after a transfer.
+ *
+ * If you perform a pci_map_single() but wish to interrogate the
+ * buffer using the cpu, yet do not wish to teardown the PCI dma
+ * mapping, you must call this function before doing so.  At the
+ * next point you give the PCI dma address back to the card, the
+ * device again owns the buffer.
+ */
+static inline void pci_dma_sync_single(struct pci_dev *hwdev,
+				       dma_addr_t dma_handle, size_t size,
+				       int direction)
+{
+	if (direction == PCI_DMA_NONE)
+		BUG();
+
+	    /* Nothing to do */
+}
+
+
+/* Make physical memory consistent for a set of streaming
+ * mode DMA translations after a transfer.
+ *
+ * The same as pci_dma_sync_single but for a scatter-gather list,
+ * same rules and usage.
+ */
+static inline void pci_dma_sync_sg(struct pci_dev *hwdev,
+				   struct scatterlist *sg, int nelems,
+				   int direction)
+{
+	if (direction == PCI_DMA_NONE)
+		BUG();
+
+	    /* Nothing to do */
+}
+
+
+#endif	/* _ASM_BFIN_PCI_H */
Index: git/linux-2.6/include/asm-blackfin/percpu.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/percpu.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,6 @@
+#ifndef __ARCH_BLACKFIN_PERCPU__
+#define __ARCH_BLACKFIN_PERCPU__
+
+#include <asm-generic/percpu.h>
+
+#endif				/* __ARCH_BLACKFIN_PERCPU__ */
Index: git/linux-2.6/include/asm-blackfin/pgalloc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/pgalloc.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,8 @@
+#ifndef _BLACKFIN_PGALLOC_H
+#define _BLACKFIN_PGALLOC_H
+
+#include <asm/setup.h>
+
+#define check_pgt_cache()	do { } while (0)
+
+#endif				/* _BLACKFIN_PGALLOC_H */
Index: git/linux-2.6/include/asm-blackfin/pgtable.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/pgtable.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,63 @@
+#ifndef _BLACKFIN_PGTABLE_H
+#define _BLACKFIN_PGTABLE_H
+
+#include <asm-generic/4level-fixup.h>
+
+#include <linux/config.h>
+#include <asm/setup.h>
+
+typedef pte_t *pte_addr_t;
+/*
+* Trivial page table functions.
+*/
+#define pgd_present(pgd)	(1)
+#define pgd_none(pgd)		(0)
+#define pgd_bad(pgd)		(0)
+#define pgd_clear(pgdp)
+#define kern_addr_valid(addr)	(1)
+#define	pmd_offset(a, b)	((void *)0)
+
+#define kern_addr_valid(addr) (1)
+
+#define PAGE_NONE		__pgprot(0)	/* these mean nothing to NO_MM */
+#define PAGE_SHARED		__pgprot(0)	/* these mean nothing to NO_MM */
+#define PAGE_COPY		__pgprot(0)	/* these mean nothing to NO_MM */
+#define PAGE_READONLY		__pgprot(0)	/* these mean nothing to NO_MM */
+#define PAGE_KERNEL		__pgprot(0)	/* these mean nothing to NO_MM */
+
+extern void paging_init(void);
+
+#define __swp_type(x)		(0)
+#define __swp_offset(x)		(0)
+#define __swp_entry(typ,off)	((swp_entry_t) { ((typ) | ((off) << 7)) })
+#define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })
+#define __swp_entry_to_pte(x)	((pte_t) { (x).val })
+
+static inline int pte_file(pte_t pte)
+{
+	return 0;
+}
+
+/*
+ * ZERO_PAGE is a global shared page that is always zero: used
+ * for zero-mapped memory areas etc..
+ */
+#define ZERO_PAGE(vaddr)	(virt_to_page(0))
+
+extern unsigned int kobjsize(const void *objp);
+
+#define swapper_pg_dir ((pgd_t *) 0)
+/*
+ * No page table caches to initialise.
+ */
+#define pgtable_cache_init()	do { } while (0)
+#define io_remap_pfn_range      remap_pfn_range
+
+/*
+ * All 32bit addresses are effectively valid for vmalloc...
+ * Sort of meaningless for non-VM targets.
+ */
+#define	VMALLOC_START	0
+#define	VMALLOC_END	0xffffffff
+
+#endif				/* _BLACKFIN_PGTABLE_H */
Index: git/linux-2.6/include/asm-blackfin/poll.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/poll.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,23 @@
+#ifndef __BFIN_POLL_H
+#define __BFIN_POLL_H
+
+#define POLLIN		  1
+#define POLLPRI		  2
+#define POLLOUT		  4
+#define POLLERR		  8
+#define POLLHUP		 16
+#define POLLNVAL	 32
+#define POLLRDNORM	 64
+#define POLLWRNORM	POLLOUT
+#define POLLRDBAND	128
+#define POLLWRBAND	256
+#define POLLMSG		0x0400
+#define POLLREMOVE	0x1000
+
+struct pollfd {
+	int fd;
+	short events;
+	short revents;
+};
+
+#endif				/* __BFIN_POLL_H */
Index: git/linux-2.6/include/asm-blackfin/posix_types.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/posix_types.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,65 @@
+#ifndef __ARCH_BFIN_POSIX_TYPES_H
+#define __ARCH_BFIN_POSIX_TYPES_H
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned long __kernel_ino_t;
+typedef unsigned short __kernel_mode_t;
+typedef unsigned short __kernel_nlink_t;
+typedef long __kernel_off_t;
+typedef int __kernel_pid_t;
+typedef unsigned short __kernel_ipc_pid_t;
+typedef unsigned short __kernel_uid_t;
+typedef unsigned short __kernel_gid_t;
+typedef unsigned int __kernel_size_t;
+typedef int __kernel_ssize_t;
+typedef int __kernel_ptrdiff_t;
+typedef long __kernel_time_t;
+typedef long __kernel_suseconds_t;
+typedef long __kernel_clock_t;
+typedef int __kernel_timer_t;
+typedef int __kernel_clockid_t;
+typedef int __kernel_daddr_t;
+typedef char *__kernel_caddr_t;
+typedef unsigned short __kernel_uid16_t;
+typedef unsigned short __kernel_gid16_t;
+typedef unsigned int __kernel_uid32_t;
+typedef unsigned int __kernel_gid32_t;
+
+typedef unsigned short __kernel_old_uid_t;
+typedef unsigned short __kernel_old_gid_t;
+typedef unsigned short __kernel_old_dev_t;
+
+#ifdef __GNUC__
+typedef long long __kernel_loff_t;
+#endif
+
+typedef struct {
+#if defined(__KERNEL__) || defined(__USE_ALL)
+	int val[2];
+#else				/* !defined(__KERNEL__) && !defined(__USE_ALL) */
+	int __val[2];
+#endif				/* !defined(__KERNEL__) && !defined(__USE_ALL) */
+} __kernel_fsid_t;
+
+#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
+
+#undef	__FD_SET
+#define	__FD_SET(d, set)	((set)->fds_bits[__FDELT(d)] |= __FDMASK(d))
+
+#undef	__FD_CLR
+#define	__FD_CLR(d, set)	((set)->fds_bits[__FDELT(d)] &= ~__FDMASK(d))
+
+#undef	__FD_ISSET
+#define	__FD_ISSET(d, set)	((set)->fds_bits[__FDELT(d)] & __FDMASK(d))
+
+#undef	__FD_ZERO
+#define __FD_ZERO(fdsetp) (memset (fdsetp, 0, sizeof(*(fd_set *)fdsetp)))
+
+#endif				/* defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2) */
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/processor.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/processor.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,96 @@
+#ifndef __ASM_BFIN_PROCESSOR_H
+#define __ASM_BFIN_PROCESSOR_H
+
+/*
+ * Default implementation of macro that returns current
+ * instruction pointer ("program counter").
+ */
+#define current_text_addr() ({ __label__ _l; _l: &&_l;})
+
+#include <asm/segment.h>
+
+static inline unsigned long rdusp(void)
+{
+	unsigned long usp;
+
+	__asm__ __volatile__("%0 = usp;\n\t":"=da"(usp));
+	return usp;
+}
+
+static inline void wrusp(unsigned long usp)
+{
+	__asm__ __volatile__("usp = %0;\n\t"::"da"(usp));
+}
+
+/*
+ * User space process size: 1st byte beyond user address space.
+ */
+extern unsigned long memory_end;
+#define TASK_SIZE	(memory_end)
+
+#define TASK_UNMAPPED_BASE	0
+
+struct thread_struct {
+	unsigned long ksp;	/* kernel stack pointer */
+	unsigned long usp;	/* user stack pointer */
+	unsigned short seqstat;	/* saved status register */
+	unsigned long esp0;	/* points to SR of stack frame pt_regs */
+	unsigned long pc;	/* instruction pointer */
+};
+
+#define INIT_THREAD  {						\
+	sizeof(init_stack) + (unsigned long) init_stack, 0,	\
+	PS_S, 0, 0						\
+}
+
+/*
+ * Do necessary setup to start up a newly executed thread.
+ *
+ * pass the data segment into user programs if it exists,
+ * it can't hurt anything as far as I can tell
+ */
+#define start_thread(_regs, _pc, _usp)			\
+do {							\
+	(_regs)->pc = (_pc);				\
+        if (current->mm)				\
+                (_regs)->p5 = current->mm->start_data;	\
+	wrusp(_usp);					\
+} while(0)
+
+/* Forward declaration, a strange C thing */
+struct task_struct;
+
+/* Free all resources held by a thread. */
+static inline void release_thread(struct task_struct *dead_task)
+{
+}
+
+#define prepare_to_copy(tsk)	do { } while (0)
+
+extern int kernel_thread(int (*fn) (void *), void *arg, unsigned long flags);
+
+/*
+ * Free current thread data structures etc..
+ */
+static inline void exit_thread(void)
+{
+}
+
+/*
+ * Return saved PC of a blocked thread.
+ */
+#define thread_saved_pc(tsk)	(tsk->thread.pc)
+
+unsigned long get_wchan(struct task_struct *p);
+
+#define	KSTK_EIP(tsk)							\
+    ({									\
+	unsigned long eip = 0;						\
+	if ((tsk)->thread.esp0 > PAGE_SIZE &&				\
+	    MAP_NR((tsk)->thread.esp0) < max_mapnr)			\
+	      eip = ((struct pt_regs *) (tsk)->thread.esp0)->pc;	\
+	eip; })
+#define	KSTK_ESP(tsk)	((tsk) == current ? rdusp() : (tsk)->thread.usp)
+
+#define cpu_relax()    do { } while (0)
+#endif
Index: git/linux-2.6/include/asm-blackfin/ptrace.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/ptrace.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,94 @@
+#ifndef _BFIN_PTRACE_H
+#define _BFIN_PTRACE_H
+
+/*
+ * GCC defines register number like this:
+ * -----------------------------
+ *       0 - 7 are data registers R0-R7
+ *       8 - 15 are address registers P0-P7
+ *      16 - 31 dsp registers I/B/L0 -- I/B/L3 & M0--M3
+ *      32 - 33 A registers A0 & A1
+ *      34 -    status register
+ * -----------------------------
+ *
+ * We follows above, except:
+ *      32-33 --- Low 32-bit of A0&1
+ *      34-35 --- High 8-bit of A0&1
+ */
+
+#ifndef __ASSEMBLY__
+
+/* this struct defines the way the registers are stored on the
+   stack during a system call. */
+
+struct pt_regs {
+	long orig_pc;
+	long ipend;
+	long seqstat;
+	long rete;
+	long retn;
+	long retx;
+	long pc;		/* PC == RETI */
+	long rets;
+	long reserved;		/* Used as scratch during system calls */
+	long astat;
+	long lb1;
+	long lb0;
+	long lt1;
+	long lt0;
+	long lc1;
+	long lc0;
+	long a1w;
+	long a1x;
+	long a0w;
+	long a0x;
+	long b3;
+	long b2;
+	long b1;
+	long b0;
+	long l3;
+	long l2;
+	long l1;
+	long l0;
+	long m3;
+	long m2;
+	long m1;
+	long m0;
+	long i3;
+	long i2;
+	long i1;
+	long i0;
+	long usp;
+	long fp;
+	long p5;
+	long p4;
+	long p3;
+	long p2;
+	long p1;
+	long p0;
+	long r7;
+	long r6;
+	long r5;
+	long r4;
+	long r3;
+	long r2;
+	long r1;
+	long r0;
+	long orig_r0;
+	long orig_p0;
+	long syscfg;
+};
+
+/* Arbitrarily choose the same ptrace numbers as used by the Sparc code. */
+#define PTRACE_GETREGS            12
+#define PTRACE_SETREGS            13	/* ptrace signal  */
+
+#define PS_S  (0x0002)
+
+#define user_mode(regs) (!((regs)->ipend & ((regs)->ipend -1)))
+#define instruction_pointer(regs) ((regs)->pc)
+#define profile_pc(regs) instruction_pointer(regs)
+extern void show_regs(struct pt_regs *);
+
+#endif				/* __ASSEMBLY__ */
+#endif				/* _BFIN_PTRACE_H */
Index: git/linux-2.6/include/asm-blackfin/resource.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/resource.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,6 @@
+#ifndef _BFIN_RESOURCE_H
+#define _BFIN_RESOURCE_H
+
+#include <asm-generic/resource.h>
+
+#endif				/* _BFIN_RESOURCE_H */
Index: git/linux-2.6/include/asm-blackfin/scatterlist.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/scatterlist.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,27 @@
+#ifndef _BLACKFIN_SCATTERLIST_H
+#define _BLACKFIN_SCATTERLIST_H
+
+#include <linux/mm.h>
+
+struct scatterlist {
+	struct page *page;
+	unsigned int offset;
+	dma_addr_t dma_address;
+	unsigned int length;
+};
+
+/*
+ * These macros should be used after a pci_map_sg call has been done
+ * to get bus addresses of each of the SG entries and their lengths.
+ * You should only work with the number of sg entries pci_map_sg
+ * returns, or alternatively stop on the first sg_dma_len(sg) which
+ * is 0.
+ */
+#define sg_address(sg) (page_address((sg)->page) + (sg)->offset
+#define sg_dma_address(sg)      ((sg)->dma_address)
+#define sg_dma_len(sg)          ((sg)->length)
+
+
+#define ISA_DMA_THRESHOLD	(0xffffffff)
+
+#endif				/* !(_BLACKFIN_SCATTERLIST_H) */
Index: git/linux-2.6/include/asm-blackfin/sections.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/sections.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,7 @@
+#ifndef _BLACKFIN_SECTIONS_H
+#define _BLACKFIN_SECTIONS_H
+
+/* nothing to see, move along */
+#include <asm-generic/sections.h>
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/segment.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/segment.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,33 @@
+#ifndef _BFIN_SEGMENT_H
+#define _BFIN_SEGMENT_H
+
+#define __KERNEL_DS   0x5
+#define __USER_DS     0x1
+
+#ifndef __ASSEMBLY__
+
+/* define constants */
+typedef unsigned long mm_segment_t;	/* domain register      */
+
+#define KERNEL_DS   0x5
+#define USER_DS     0x1
+
+static inline mm_segment_t get_fs(void)
+{
+	return USER_DS;
+}
+
+static inline mm_segment_t get_ds(void)
+{
+	return KERNEL_DS;
+}
+
+static inline void set_fs(mm_segment_t val)
+{
+}
+
+#define segment_eq(a,b) ((a) == (b))
+
+#endif				/* __ASSEMBLY__ */
+
+#endif				/* _BFIN_SEGMENT_H */
Index: git/linux-2.6/include/asm-blackfin/semaphore-helper.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/semaphore-helper.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,83 @@
+/* Based on M68K version,	Lineo Inc.	May 2001 */
+
+#ifndef _BFIN_SEMAPHORE_HELPER_H
+#define _BFIN_SEMAPHORE_HELPER_H
+
+/*
+ * SMP- and interrupt-safe semaphores helper functions.
+ *
+ * (C) Copyright 1996 Linus Torvalds
+ *
+ */
+
+#include <linux/config.h>
+#include <asm/errno.h>
+
+/*
+ * These two _must_ execute atomically wrt each other.
+ */
+static inline void wake_one_more(struct semaphore *sem)
+{
+	atomic_inc(&sem->waking);
+}
+
+static inline int waking_non_zero(struct semaphore *sem)
+{
+	int ret;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&semaphore_wake_lock, flags);
+	ret = 0;
+	if (atomic_read(&sem->waking) > 0) {
+		atomic_dec(&sem->waking);
+		ret = 1;
+	}
+	spin_unlock_irqrestore(&semaphore_wake_lock, flags);
+	return ret;
+}
+
+/*
+ * waking_non_zero_interruptible:
+ *	1	got the lock
+ *	0	go to sleep
+ *	-EINTR	interrupted
+ */
+static inline int waking_non_zero_interruptible(struct semaphore *sem,
+						struct task_struct *tsk)
+{
+	int ret = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&semaphore_wake_lock, flags);
+	if (atomic_read(&sem->waking) > 0) {
+		atomic_dec(&sem->waking);
+		ret = 1;
+	} else if (signal_pending(tsk)) {
+		atomic_inc(&sem->count);
+		ret = -EINTR;
+	}
+	spin_unlock_irqrestore(&semaphore_wake_lock, flags);
+	return ret;
+}
+
+/*
+ * waking_non_zero_trylock:
+ *	1	failed to lock
+ *	0	got the lock
+ */
+static inline int waking_non_zero_trylock(struct semaphore *sem)
+{
+	int ret = 1;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&semaphore_wake_lock, flags);
+	if (atomic_read(&sem->waking) > 0) {
+		atomic_dec(&sem->waking);
+		ret = 0;
+	} else
+		atomic_inc(&sem->count);
+	spin_unlock_irqrestore(&semaphore_wake_lock, flags);
+	return ret;
+}
+
+#endif				/* _BFIN_SEMAPHORE_HELPER_H */
Index: git/linux-2.6/include/asm-blackfin/semaphore.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/semaphore.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,100 @@
+#ifndef _BFIN_SEMAPHORE_H
+#define _BFIN_SEMAPHORE_H
+
+#ifndef __ASSEMBLY__
+
+#include <linux/wait.h>
+#include <linux/rwsem.h>
+#include <asm/atomic.h>
+
+/*
+ * Interrupt-safe semaphores..
+ *
+ * (C) Copyright 1996 Linus Torvalds
+ *
+ * BFIN version by akbar hussain Lineo Inc  April 2001
+ *
+ */
+
+struct semaphore {
+	atomic_t count;
+	atomic_t waking;
+	wait_queue_head_t wait;
+};
+
+#define __SEMAPHORE_INITIALIZER(name,count) \
+{ ATOMIC_INIT(count), ATOMIC_INIT(0), __WAIT_QUEUE_HEAD_INITIALIZER((name).wait) }
+
+#define __DECLARE_SEMAPHORE_GENERIC(name,count) \
+	struct semaphore name = __SEMAPHORE_INITIALIZER(name,count)
+
+#define DECLARE_MUTEX(name)		__DECLARE_SEMAPHORE_GENERIC(name,1)
+#define DECLARE_MUTEX_LOCKED(name)	__DECLARE_SEMAPHORE_GENERIC(name,0)
+
+static inline void sema_init(struct semaphore *sem, int val)
+{
+	*sem = (struct semaphore)__SEMAPHORE_INITIALIZER(*sem, val);
+}
+
+static inline void init_MUTEX(struct semaphore *sem)
+{
+	sema_init(sem, 1);
+}
+
+static inline void init_MUTEX_LOCKED(struct semaphore *sem)
+{
+	sema_init(sem, 0);
+}
+
+asmlinkage void __down(struct semaphore *sem);
+asmlinkage int __down_interruptible(struct semaphore *sem);
+asmlinkage int __down_trylock(struct semaphore *sem);
+asmlinkage void __up(struct semaphore *sem);
+
+extern spinlock_t semaphore_wake_lock;
+
+/*
+ * This is ugly, but we want the default case to fall through.
+ * "down_failed" is a special asm handler that calls the C
+ * routine that actually waits.
+ */
+static inline void down(struct semaphore *sem)
+{
+	might_sleep();
+	if (atomic_dec_return(&sem->count) < 0)
+		__down(sem);
+}
+
+static inline int down_interruptible(struct semaphore *sem)
+{
+	int ret = 0;
+
+	might_sleep();
+	if (atomic_dec_return(&sem->count) < 0)
+		ret = __down_interruptible(sem);
+	return (ret);
+}
+
+static inline int down_trylock(struct semaphore *sem)
+{
+	int ret = 0;
+
+	if (atomic_dec_return(&sem->count) < 0)
+		ret = __down_trylock(sem);
+	return ret;
+}
+
+/*
+ * Note! This is subtle. We jump to wake people up only if
+ * the semaphore was negative (== somebody was waiting on it).
+ * The default case (no contention) will result in NO
+ * jumps for both down() and up().
+ */
+static inline void up(struct semaphore *sem)
+{
+	if (atomic_inc_return(&sem->count) <= 0)
+		__up(sem);
+}
+
+#endif				/* __ASSEMBLY__ */
+#endif				/* _BFIN_SEMAPHORE_H */
Index: git/linux-2.6/include/asm-blackfin/sembuf.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/sembuf.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,25 @@
+#ifndef _BFIN_SEMBUF_H
+#define _BFIN_SEMBUF_H
+
+/*
+ * The semid64_ds structure for bfin architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct semid64_ds {
+	struct ipc64_perm sem_perm;	/* permissions .. see ipc.h */
+	__kernel_time_t sem_otime;	/* last semop time */
+	unsigned long __unused1;
+	__kernel_time_t sem_ctime;	/* last change time */
+	unsigned long __unused2;
+	unsigned long sem_nsems;	/* no. of semaphores in array */
+	unsigned long __unused3;
+	unsigned long __unused4;
+};
+
+#endif				/* _BFIN_SEMBUF_H */
Index: git/linux-2.6/include/asm-blackfin/setup.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/setup.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,17 @@
+/*
+** asm/setup.h -- Definition of the Linux/bfin setup information
+**
+** This file is subject to the terms and conditions of the GNU General Public
+** License.  See the file COPYING in the main directory of this archive
+** for more details.
+**
+** Copyright Lineo, Inc 2001          Tony Kou
+**
+*/
+
+#ifndef _BFIN_SETUP_H
+#define _BFIN_SETUP_H
+
+#define COMMAND_LINE_SIZE	512
+
+#endif				/* _BFIN_SETUP_H */
Index: git/linux-2.6/include/asm-blackfin/shmbuf.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/shmbuf.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,42 @@
+#ifndef _BFIN_SHMBUF_H
+#define _BFIN_SHMBUF_H
+
+/*
+ * The shmid64_ds structure for bfin architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct shmid64_ds {
+	struct ipc64_perm shm_perm;	/* operation perms */
+	size_t shm_segsz;	/* size of segment (bytes) */
+	__kernel_time_t shm_atime;	/* last attach time */
+	unsigned long __unused1;
+	__kernel_time_t shm_dtime;	/* last detach time */
+	unsigned long __unused2;
+	__kernel_time_t shm_ctime;	/* last change time */
+	unsigned long __unused3;
+	__kernel_pid_t shm_cpid;	/* pid of creator */
+	__kernel_pid_t shm_lpid;	/* pid of last operator */
+	unsigned long shm_nattch;	/* no. of current attaches */
+	unsigned long __unused4;
+	unsigned long __unused5;
+};
+
+struct shminfo64 {
+	unsigned long shmmax;
+	unsigned long shmmin;
+	unsigned long shmmni;
+	unsigned long shmseg;
+	unsigned long shmall;
+	unsigned long __unused1;
+	unsigned long __unused2;
+	unsigned long __unused3;
+	unsigned long __unused4;
+};
+
+#endif				/* _BFIN_SHMBUF_H */
Index: git/linux-2.6/include/asm-blackfin/shmparam.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/shmparam.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,6 @@
+#ifndef _BFIN_SHMPARAM_H
+#define _BFIN_SHMPARAM_H
+
+#define	SHMLBA PAGE_SIZE	/* attach addr a multiple of this */
+
+#endif				/* _BFIN_SHMPARAM_H */
Index: git/linux-2.6/include/asm-blackfin/sigcontext.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/sigcontext.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,25 @@
+#ifndef _ASM_BLACKFIN_SIGCONTEXT_H
+#define _ASM_BLACKFIN_SIGCONTEXT_H
+
+/* Add new entries at the end of the structure only.  */
+struct sigcontext {
+	unsigned long sc_mask;	/* old sigmask */
+	unsigned long sc_usp;	/* old user stack pointer */
+	unsigned long sc_r0;
+	unsigned long sc_r1;
+	unsigned long sc_p0;
+	unsigned long sc_p1;
+	unsigned short sc_seqstat;
+	unsigned long sc_pc;
+	unsigned long sc_retx;
+	unsigned long sc_rets;
+	unsigned long sc_r2;
+	unsigned long sc_r3;
+	unsigned long sc_r4;
+	unsigned long sc_l0;
+	unsigned long sc_l1;
+	unsigned long sc_l2;
+	unsigned long sc_l3;
+};
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/siginfo.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/siginfo.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,35 @@
+#ifndef _BFIN_SIGINFO_H
+#define _BFIN_SIGINFO_H
+
+#include <linux/types.h>
+#include <asm-generic/siginfo.h>
+
+#define UID16_SIGINFO_COMPAT_NEEDED
+
+#define si_uid16	_sifields._kill._uid
+
+#define ILL_ILLPARAOP	(__SI_FAULT|2)	/* illegal opcode combine ********** */
+#define ILL_ILLEXCPT	(__SI_FAULT|4)	/* unrecoverable exception ********** */
+#define ILL_CPLB_VI	(__SI_FAULT|9)	/* D/I CPLB protect violation ******** */
+#define IlL_CPLB_MISS	(__SI_FAULT|10)	/* D/I CPLB miss ******** */
+#define ILL_CPLB_MULHIT	(__SI_FAULT|11)	/* D/I CPLB multiple hit ******** */
+
+/*
+ * SIGBUS si_codes
+ */
+#define BUS_OPFETCH	(__SI_FAULT|4)	/* error from instruction fetch ******** */
+
+/*
+ * SIGTRAP si_codes
+ */
+#define TRAP_STEP	(__SI_FAULT|1)	/* single-step breakpoint************* */
+#define TRAP_TRACEFLOW	(__SI_FAULT|2)	/* trace buffer overflow ************* */
+#define TRAP_WATCHPT	(__SI_FAULT|3)	/* watchpoint match      ************* */
+#define TRAP_ILLTRAP	(__SI_FAULT|4)	/* illegal trap          ************* */
+
+/*
+ * SIGSEGV si_codes
+ */
+#define SEGV_STACKFLOW	(__SI_FAULT|3)	/* stack overflow */
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/signal.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/signal.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,183 @@
+#ifndef _BLACKFIN_SIGNAL_H
+#define _BLACKFIN_SIGNAL_H
+
+#include <linux/types.h>
+
+/* Avoid too many header ordering problems.  */
+struct siginfo;
+
+#ifdef __KERNEL__
+/* Most things should be clean enough to redefine this at will, if care
+   is taken to make libc match.  */
+
+#define _NSIG		64
+#define _NSIG_BPW	32
+#define _NSIG_WORDS	(_NSIG / _NSIG_BPW)
+
+typedef unsigned long old_sigset_t;	/* at least 32 bits */
+
+typedef struct {
+	unsigned long sig[_NSIG_WORDS];
+} sigset_t;
+
+#else
+/* Here we must cater to libcs that poke about in kernel headers.  */
+
+#define NSIG		32
+typedef unsigned long sigset_t;
+
+#endif				/* __KERNEL__ */
+
+#define SIGHUP		 1
+#define SIGINT		 2
+#define SIGQUIT		 3
+#define SIGILL		 4
+#define SIGTRAP		 5
+#define SIGABRT		 6
+#define SIGIOT		 6
+#define SIGBUS		 7
+#define SIGFPE		 8
+#define SIGKILL		 9
+#define SIGUSR1		10
+#define SIGSEGV		11
+#define SIGUSR2		12
+#define SIGPIPE		13
+#define SIGALRM		14
+#define SIGTERM		15
+#define SIGSTKFLT	16
+#define SIGCHLD		17
+#define SIGCONT		18
+#define SIGSTOP		19
+#define SIGTSTP		20
+#define SIGTTIN		21
+#define SIGTTOU		22
+#define SIGURG		23
+#define SIGXCPU		24
+#define SIGXFSZ		25
+#define SIGVTALRM	26
+#define SIGPROF		27
+#define SIGWINCH	28
+#define SIGIO		29
+#define SIGPOLL		SIGIO
+/*
+#define SIGLOST		29
+*/
+#define SIGPWR		30
+#define SIGSYS		31
+#define	SIGUNUSED	31
+
+/* These should not be considered constants from userland.  */
+#define SIGRTMIN	32
+#define SIGRTMAX	_NSIG
+
+/*
+ * SA_FLAGS values:
+ *
+ * SA_ONSTACK indicates that a registered stack_t will be used.
+ * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
+ * SA_RESTART flag to get restarting signals (which were the default long ago)
+ * SA_NOCLDSTOP flag to turn off SIGCHLD when children stop.
+ * SA_RESETHAND clears the handler when the signal is delivered.
+ * SA_NOCLDWAIT flag on SIGCHLD to inhibit zombies.
+ * SA_NODEFER prevents the current signal from being masked in the handler.
+ *
+ * SA_ONESHOT and SA_NOMASK are the historical Linux names for the Single
+ * Unix names RESETHAND and NODEFER respectively.
+ */
+#define SA_NOCLDSTOP	0x00000001
+#define SA_NOCLDWAIT	0x00000002	/* not supported yet */
+#define SA_SIGINFO	0x00000004
+#define SA_ONSTACK	0x08000000
+#define SA_RESTART	0x10000000
+#define SA_NODEFER	0x40000000
+#define SA_RESETHAND	0x80000000
+
+#define SA_NOMASK	SA_NODEFER
+#define SA_ONESHOT	SA_RESETHAND
+#define SA_INTERRUPT	0x20000000	/* dummy -- ignored */
+
+/*
+ * sigaltstack controls
+ */
+#define SS_ONSTACK	1
+#define SS_DISABLE	2
+
+#define MINSIGSTKSZ	2048
+#define SIGSTKSZ	8192
+
+#ifdef __KERNEL__
+/*
+ * These values of sa_flags are used only by the kernel as part of the
+ * irq handling routines.
+ *
+ * SA_INTERRUPT is also used by the irq handling routines.
+ * SA_SHIRQ is for shared interrupt support on PCI and EISA.
+ */
+#define SA_PROBE		SA_ONESHOT
+#define SA_SAMPLE_RANDOM	SA_RESTART
+#define SA_SHIRQ		0x04000000
+#endif
+
+#define SIG_BLOCK          0	/* for blocking signals */
+#define SIG_UNBLOCK        1	/* for unblocking signals */
+#define SIG_SETMASK        2	/* for setting the signal mask */
+
+/* Type of a signal handler.  */
+typedef void (*__sighandler_t) (int);
+
+#define SIG_DFL	((__sighandler_t)0)	/* default signal handling */
+#define SIG_IGN	((__sighandler_t)1)	/* ignore signal */
+#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
+
+#ifdef __KERNEL__
+struct old_sigaction {
+	__sighandler_t sa_handler;
+	old_sigset_t sa_mask;
+	unsigned long sa_flags;
+	void (*sa_restorer) (void);
+};
+
+struct sigaction {
+	__sighandler_t sa_handler;
+	unsigned long sa_flags;
+	void (*sa_restorer) (void);
+	sigset_t sa_mask;	/* mask last for extensibility */
+};
+
+struct k_sigaction {
+	struct sigaction sa;
+};
+#else
+/* Here we must cater to libcs that poke about in kernel headers.  */
+
+struct sigaction {
+	union {
+		__sighandler_t _sa_handler;
+		void (*_sa_sigaction) (int, struct siginfo *, void *);
+	} _u;
+	sigset_t sa_mask;
+	unsigned long sa_flags;
+	void (*sa_restorer) (void);
+};
+
+#define sa_handler	_u._sa_handler
+#define sa_sigaction	_u._sa_sigaction
+
+#endif				/* __KERNEL__ */
+
+typedef struct sigaltstack {
+	void *ss_sp;
+	int ss_flags;
+	size_t ss_size;
+} stack_t;
+
+#ifdef __KERNEL__
+
+#include <asm/sigcontext.h>
+#undef __HAVE_ARCH_SIG_BITOPS
+
+#define ptrace_signal_deliver(regs, cookie) do { } while (0)
+
+#endif				/* __KERNEL__ */
+
+#endif				/* _BLACKFIN_SIGNAL_H */
Index: git/linux-2.6/include/asm-blackfin/socket.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/socket.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,51 @@
+#ifndef _ASM_SOCKET_H
+#define _ASM_SOCKET_H
+
+#include <asm/sockios.h>
+
+/* For setsockoptions(2) */
+#define SOL_SOCKET	1
+
+#define SO_DEBUG	1
+#define SO_REUSEADDR	2
+#define SO_TYPE		3
+#define SO_ERROR	4
+#define SO_DONTROUTE	5
+#define SO_BROADCAST	6
+#define SO_SNDBUF	7
+#define SO_RCVBUF	8
+#define SO_SNDBUFFORCE	32
+#define SO_RCVBUFFORCE	33
+#define SO_KEEPALIVE	9
+#define SO_OOBINLINE	10
+#define SO_NO_CHECK	11
+#define SO_PRIORITY	12
+#define SO_LINGER	13
+#define SO_BSDCOMPAT	14
+/* To add :#define SO_REUSEPORT 15 */
+#define SO_PASSCRED	16
+#define SO_PEERCRED	17
+#define SO_RCVLOWAT	18
+#define SO_SNDLOWAT	19
+#define SO_RCVTIMEO	20
+#define SO_SNDTIMEO	21
+
+/* Security levels - as per NRL IPv6 - don't actually do anything */
+#define SO_SECURITY_AUTHENTICATION		22
+#define SO_SECURITY_ENCRYPTION_TRANSPORT	23
+#define SO_SECURITY_ENCRYPTION_NETWORK		24
+
+#define SO_BINDTODEVICE	25
+
+/* Socket filtering */
+#define SO_ATTACH_FILTER        26
+#define SO_DETACH_FILTER        27
+
+#define SO_PEERNAME             28
+#define SO_TIMESTAMP		29
+#define SCM_TIMESTAMP		SO_TIMESTAMP
+
+#define SO_ACCEPTCONN		30
+#define SO_PEERSEC             31
+
+#endif				/* _ASM_SOCKET_H */
Index: git/linux-2.6/include/asm-blackfin/sockios.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/sockios.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,12 @@
+#ifndef __ARCH_BFIN_SOCKIOS__
+#define __ARCH_BFIN_SOCKIOS__
+
+/* Socket-level I/O control calls. */
+#define FIOSETOWN 	0x8901
+#define SIOCSPGRP	0x8902
+#define FIOGETOWN	0x8903
+#define SIOCGPGRP	0x8904
+#define SIOCATMARK	0x8905
+#define SIOCGSTAMP	0x8906	/* Get stamp */
+
+#endif				/* __ARCH_BFIN_SOCKIOS__ */
Index: git/linux-2.6/include/asm-blackfin/spinlock.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/spinlock.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,6 @@
+#ifndef __BFIN_SPINLOCK_H
+#define __BFIN_SPINLOCK_H
+
+#error blackfin architecture does not support SMP spin lock yet
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/stat.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/stat.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,78 @@
+#ifndef _BFIN_STAT_H
+#define _BFIN_STAT_H
+
+struct __old_kernel_stat {
+	unsigned short st_dev;
+	unsigned short st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+	unsigned short st_rdev;
+	unsigned long st_size;
+	unsigned long st_atime;
+	unsigned long st_mtime;
+	unsigned long st_ctime;
+};
+
+struct stat {
+	unsigned short st_dev;
+	unsigned short __pad1;
+	unsigned long st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+	unsigned short st_rdev;
+	unsigned short __pad2;
+	unsigned long st_size;
+	unsigned long st_blksize;
+	unsigned long st_blocks;
+	unsigned long st_atime;
+	unsigned long __unused1;
+	unsigned long st_mtime;
+	unsigned long __unused2;
+	unsigned long st_ctime;
+	unsigned long __unused3;
+	unsigned long __unused4;
+	unsigned long __unused5;
+};
+
+/* This matches struct stat64 in glibc2.1, hence the absolutely
+ * insane amounts of padding around dev_t's.
+ */
+struct stat64 {
+	unsigned long long st_dev;
+	unsigned char __pad1[2];
+
+#define STAT64_HAS_BROKEN_ST_INO	1
+	unsigned long __st_ino;
+
+	unsigned int st_mode;
+	unsigned int st_nlink;
+
+	unsigned long st_uid;
+	unsigned long st_gid;
+
+	unsigned long long st_rdev;
+	unsigned char __pad3[2];
+
+	long long st_size;
+	unsigned long st_blksize;
+
+	unsigned long __pad4;	/* future possible st_blocks high bits */
+	unsigned long st_blocks;	/* Number 512-byte blocks allocated. */
+
+	unsigned long st_atime;
+	unsigned long st_atime_nsec;
+
+	unsigned long st_mtime;
+	unsigned long st_mtime_nsec;
+
+	unsigned long st_ctime;
+	unsigned long st_ctime_nsec;
+
+	unsigned long long st_ino;
+} __attribute__((packed));
+
+#endif				/* _BFIN_STAT_H */
Index: git/linux-2.6/include/asm-blackfin/statfs.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/statfs.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,6 @@
+#ifndef _BFIN_STATFS_H
+#define _BFIN_STATFS_H
+
+#include <asm-generic/statfs.h>
+
+#endif				/* _BFIN_STATFS_H */
Index: git/linux-2.6/include/asm-blackfin/string.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/string.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,104 @@
+#ifndef _BLACKFIN_STRING_H_
+#define _BLACKFIN_STRING_H_
+
+#ifdef __KERNEL__		/* only set these up for kernel code */
+
+#define __HAVE_ARCH_STRCPY
+static inline char *strcpy(char *dest, const char *src)
+{
+	char *xdest = dest;
+	char temp = 0;
+
+	__asm__ __volatile__
+	    ("1:\t%2 = B [%1++] (Z);\n\t"
+	     "B [%0++] = %2;\n\t"
+	     "CC = %2;\n\t"
+        "if cc jump 1b (bp);\n"
+	: "+&a" (dest), "+&a" (src), "=&d" (temp)
+	     ::"memory", "CC");
+	return xdest;
+}
+
+#define __HAVE_ARCH_STRNCPY
+static inline char *strncpy(char *dest, const char *src, size_t n)
+{
+	char *xdest = dest;
+	char temp = 0;
+
+	if (n == 0)
+		return xdest;
+
+	__asm__ __volatile__
+	    ("1:\t%3 = B [%1++] (Z);\n\t"
+	     "B [%0++] = %3;\n\t"
+	     "CC = %3;\n\t"
+	     "if ! cc jump 2f;\n\t"
+	     "%2 += -1;\n\t"
+	     "CC = %2 == 0;\n\t"
+	     "if ! cc jump 1b (bp);\n"
+        "2:\n"
+	: "+&a" (dest), "+&a" (src), "+&da" (n), "=&d" (temp)
+	     ::"memory", "CC");
+	return xdest;
+}
+
+#define __HAVE_ARCH_STRCMP
+static inline int strcmp(const char *cs, const char *ct)
+{
+	char __res1, __res2;
+
+  __asm__
+       ("1:\t%2 = B[%0++] (Z);\n\t" /* get *cs */
+		"%3 = B[%1++] (Z);\n\t"	/* get *ct */
+		"CC = %2 == %3;\n\t"	/* compare a byte */
+		"if ! cc jump 2f;\n\t"	/* not equal, break out */
+		"CC = %2;\n\t"	/* at end of cs? */
+		"if cc jump 1b (bp);\n\t"	/* no, keep going */
+		"jump.s 3f;\n"	/* strings are equal */
+		"2:\t%2 = %2 - %3;\n"	/* *cs - *ct */
+        "3:\n"
+	: "+&a" (cs), "+&a" (ct), "=&d" (__res1), "=&d" (__res2)
+      : :	"CC");
+
+	return __res1;
+}
+
+#define __HAVE_ARCH_STRNCMP
+static inline int strncmp(const char *cs, const char *ct, size_t count)
+{
+	char __res1, __res2;
+
+	if (!count)
+		return 0;
+  __asm__
+       ("1:\t%3 = B[%0++] (Z);\n\t"        /* get *cs */
+		"%4 = B[%1++] (Z);\n\t"	/* get *ct */
+		"CC = %3 == %4;\n\t"	/* compare a byte */
+		"if ! cc jump 3f;\n\t"	/* not equal, break out */
+		"CC = %3;\n\t"	/* at end of cs? */
+		"if ! cc jump 4f;\n\t"	/* yes, all done */
+		"%2 += -1;\n\t"	/* no, adjust count */
+	"CC = %2 == 0;\n\t"
+        "if ! cc jump 1b;\n"                 /* more to do, keep going */
+		"2:\t%3 = 0;\n\t"	/* strings are equal */
+        "jump.s    4f;\n"
+        "3:\t%3 = %3 - %4;\n"          /* *cs - *ct */
+        "4:"
+	: "+&a" (cs), "+&a" (ct), "+&da" (count), "=&d" (__res1), "=&d" (__res2)
+      : :	"CC");
+	return __res1;
+}
+
+#define __HAVE_ARCH_MEMSET
+extern void *memset(void *s, int c, size_t count);
+#define __HAVE_ARCH_MEMCPY
+extern void *memcpy(void *d, const void *s, size_t count);
+#define __HAVE_ARCH_MEMCMP
+extern int memcmp(const void *, const void *, __kernel_size_t);
+#define	__HAVE_ARCH_MEMCHR
+extern void *memchr(const void *s, int c, size_t n);
+#define	__HAVE_ARCH_MEMMOVE
+extern void *memmove(void *dest, const void *src, size_t count);
+
+#endif /*__KERNEL__*/
+#endif				/* _BLACKFIN_STRING_H_ */
Index: git/linux-2.6/include/asm-blackfin/system.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/system.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,215 @@
+#ifndef _BLACKFIN_SYSTEM_H
+#define _BLACKFIN_SYSTEM_H
+
+#include <linux/linkage.h>
+#include <asm/blackfin.h>
+#include <linux/compiler.h>
+
+#define prepare_to_switch()	do { } while(0)
+
+/*
+ * switch_to(n) should switch tasks to task ptr, first checking that
+ * ptr isn't the current task, in which case it does nothing.  This
+ * also clears the TS-flag if the task we switched to has used the
+ * math co-processor latest.
+ *
+ * 05/25/01 - Tony Kou (tonyko@lineo.ca)
+ *
+ * Adapted for BlackFin (ADI) by Ted Ma, Metrowerks, and Motorola GSG
+ * Copyright (c) 2002 Arcturus Networks Inc. (www.arcturusnetworks.com)
+ * Copyright (c) 2003 Metrowerks (www.metrowerks.com)
+ * Copyright (c) 2004 Analog Device Inc.
+ */
+
+/**************
+MACRO definitions
+***************/
+
+asmlinkage void resume(void);
+#define switch_to(prev,next,last) { \
+  void *_last;								\
+  __asm__ __volatile__(							\
+  			"r0 = %1;\n\t"					\
+			"r1 = %2;\n\t"					\
+			"call resume;\n\t" 				\
+			"%0 = r0;\n\t"					\
+		       : "=d" (_last)					\
+		       : "d" (prev),					\
+			 "d" (next)					\
+		       : "CC", "R0", "R1", "P0", "P1");			\
+  (last) = _last; 							\
+}
+
+/*
+ * Interrupt configuring macros.
+ */
+
+extern volatile unsigned long irq_flags;
+
+#define local_irq_enable() do {		\
+	__asm__ __volatile__ (		\
+		"sti %0;"		\
+		::"d"(irq_flags));	\
+} while (0)
+
+#define local_irq_disable() do {		\
+	int _tmp_dummy;			\
+	__asm__ __volatile__ (		\
+		"cli %0;"		\
+		:"=d" (_tmp_dummy):);		\
+} while (0)
+
+#ifdef CONFIG_DEBUG_HWERR
+#define __save_and_cli(x) do {			\
+	__asm__ __volatile__ (			\
+		"cli %0;\n\tsti %1;"		\
+		:"=&d"(x): "d" (0x3F));		\
+} while (0)
+#else
+#define __save_and_cli(x) do {		\
+	__asm__ __volatile__ (          \
+		"cli %0;"		\
+		:"=&d"(x):);		\
+} while (0)
+#endif
+
+#define local_save_flags(x) asm volatile ("cli %0;"     \
+					  "sti %0;"     \
+				    	  :"=d"(x):);
+
+#ifdef CONFIG_DEBUG_HWERR
+#define irqs_enabled_from_flags(x) (((x) & ~0x3f) != 0)
+#else
+#define irqs_enabled_from_flags(x) ((x) != 0x1f)
+#endif
+
+#define local_irq_restore(x) do {			\
+	if (irqs_enabled_from_flags(x))			\
+		local_irq_enable ();			\
+} while (0)
+
+/* For spinlocks etc */
+#define local_irq_save(x) __save_and_cli(x)
+
+#define	irqs_disabled()				\
+({						\
+	unsigned long flags;			\
+	local_save_flags(flags);		\
+	!irqs_enabled_from_flags(flags);	\
+})
+
+/*
+ * Force strict CPU ordering.
+ */
+#define nop()  asm volatile ("nop;\n\t"::)
+#define mb()   asm volatile (""   : : :"memory")
+#define rmb()  asm volatile (""   : : :"memory")
+#define wmb()  asm volatile (""   : : :"memory")
+#define set_rmb(var, value)    do { xchg(&var, value); } while (0)
+#define set_mb(var, value)     set_rmb(var, value)
+#define set_wmb(var, value)    do { var = value; wmb(); } while (0)
+
+#define read_barrier_depends() 		do { } while(0)
+
+#ifdef CONFIG_SMP
+#define smp_mb()	mb()
+#define smp_rmb()	rmb()
+#define smp_wmb()	wmb()
+#define smp_read_barrier_depends()	read_barrier_depends()
+#else
+#define smp_mb()	barrier()
+#define smp_rmb()	barrier()
+#define smp_wmb()	barrier()
+#define smp_read_barrier_depends()	do { } while(0)
+#endif
+
+#define xchg(ptr,x) ((__typeof__(*(ptr)))__xchg((unsigned long)(x),(ptr),sizeof(*(ptr))))
+#define tas(ptr) (xchg((ptr),1))
+
+struct __xchg_dummy {
+	unsigned long a[100];
+};
+#define __xg(x) ((volatile struct __xchg_dummy *)(x))
+
+static inline unsigned long __xchg(unsigned long x, volatile void *ptr,
+				   int size)
+{
+	unsigned long tmp = 0;
+	unsigned long flags = 0;
+
+	local_irq_save(flags);
+
+	switch (size) {
+	case 1:
+    __asm__ __volatile__
+    ("%0 = b%2 (z);\n\t"
+     "b%2 = %1;\n\t"
+    : "=&d" (tmp) : "d" (x), "m" (*__xg(ptr)) : "memory");
+		break;
+	case 2:
+    __asm__ __volatile__
+    ("%0 = w%2 (z);\n\t"
+     "w%2 = %1;\n\t"
+    : "=&d" (tmp) : "d" (x), "m" (*__xg(ptr)) : "memory");
+		break;
+	case 4:
+    __asm__ __volatile__
+    ("%0 = %2;\n\t"
+     "%2 = %1;\n\t"
+    : "=&d" (tmp) : "d" (x), "m" (*__xg(ptr)) : "memory");
+		break;
+	}
+	local_irq_restore(flags);
+	return tmp;
+}
+
+/*
+ * Atomic compare and exchange.  Compare OLD with MEM, if identical,
+ * store NEW in MEM.  Return the initial value in MEM.  Success is
+ * indicated by comparing RETURN with OLD.
+ */
+static inline unsigned long __cmpxchg(volatile void *ptr, unsigned long old,
+				      unsigned long new, int size)
+{
+	unsigned long tmp = 0;
+	unsigned long flags = 0;
+
+	local_irq_save(flags);
+
+	switch (size) {
+	case 1:
+    __asm__ __volatile__
+    ("%0 = b%3 (z);\n\t"
+     "CC = %1 == %0;\n\t"
+     "IF !CC JUMP 1f;\n\t"
+     "b%3 = %2;\n\t"
+     "1:\n\t"
+    : "=&d" (tmp) : "d" (old), "d" (new), "m" (*__xg(ptr)) : "memory");
+		break;
+	case 2:
+    __asm__ __volatile__
+    ("%0 = w%3 (z);\n\t"
+     "CC = %1 == %0;\n\t"
+     "IF !CC JUMP 1f;\n\t"
+     "w%3 = %2;\n\t"
+     "1:\n\t"
+    : "=&d" (tmp) : "d" (old), "d" (new), "m" (*__xg(ptr)) : "memory");
+		break;
+	case 4:
+    __asm__ __volatile__
+    ("%0 = %3;\n\t"
+     "CC = %1 == %0;\n\t"
+     "IF !CC JUMP 1f;\n\t"
+     "%3 = %2;\n\t"
+     "1:\n\t"
+    : "=&d" (tmp) : "d" (old), "d" (new), "m" (*__xg(ptr)) : "memory");
+		break;
+	}
+	local_irq_restore(flags);
+	return tmp;
+}
+
+#define cmpxchg(ptr,o,n)\
+        ((__typeof__(*(ptr)))__cmpxchg((ptr),(unsigned long)(o),\
+                                        (unsigned long)(n),sizeof(*(ptr))))
+#endif				/* _BLACKFIN_SYSTEM_H */
Index: git/linux-2.6/include/asm-blackfin/termbits.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/termbits.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,173 @@
+#ifndef __ARCH_BFIN_TERMBITS_H__
+#define __ARCH_BFIN_TERMBITS_H__
+
+#include <linux/posix_types.h>
+
+typedef unsigned char cc_t;
+typedef unsigned int speed_t;
+typedef unsigned int tcflag_t;
+
+#define NCCS 19
+struct termios {
+	tcflag_t c_iflag;	/* input mode flags */
+	tcflag_t c_oflag;	/* output mode flags */
+	tcflag_t c_cflag;	/* control mode flags */
+	tcflag_t c_lflag;	/* local mode flags */
+	cc_t c_line;		/* line discipline */
+	cc_t c_cc[NCCS];	/* control characters */
+};
+
+/* c_cc characters */
+#define VINTR 0
+#define VQUIT 1
+#define VERASE 2
+#define VKILL 3
+#define VEOF 4
+#define VTIME 5
+#define VMIN 6
+#define VSWTC 7
+#define VSTART 8
+#define VSTOP 9
+#define VSUSP 10
+#define VEOL 11
+#define VREPRINT 12
+#define VDISCARD 13
+#define VWERASE 14
+#define VLNEXT 15
+#define VEOL2 16
+
+/* c_iflag bits */
+#define IGNBRK	0000001
+#define BRKINT	0000002
+#define IGNPAR	0000004
+#define PARMRK	0000010
+#define INPCK	0000020
+#define ISTRIP	0000040
+#define INLCR	0000100
+#define IGNCR	0000200
+#define ICRNL	0000400
+#define IUCLC	0001000
+#define IXON	0002000
+#define IXANY	0004000
+#define IXOFF	0010000
+#define IMAXBEL	0020000
+#define IUTF8	0040000
+
+/* c_oflag bits */
+#define OPOST	0000001
+#define OLCUC	0000002
+#define ONLCR	0000004
+#define OCRNL	0000010
+#define ONOCR	0000020
+#define ONLRET	0000040
+#define OFILL	0000100
+#define OFDEL	0000200
+#define NLDLY	0000400
+#define   NL0	0000000
+#define   NL1	0000400
+#define CRDLY	0003000
+#define   CR0	0000000
+#define   CR1	0001000
+#define   CR2	0002000
+#define   CR3	0003000
+#define TABDLY	0014000
+#define   TAB0	0000000
+#define   TAB1	0004000
+#define   TAB2	0010000
+#define   TAB3	0014000
+#define   XTABS	0014000
+#define BSDLY	0020000
+#define   BS0	0000000
+#define   BS1	0020000
+#define VTDLY	0040000
+#define   VT0	0000000
+#define   VT1	0040000
+#define FFDLY	0100000
+#define   FF0	0000000
+#define   FF1	0100000
+
+/* c_cflag bit meaning */
+#define CBAUD	0010017
+#define  B0	0000000		/* hang up */
+#define  B50	0000001
+#define  B75	0000002
+#define  B110	0000003
+#define  B134	0000004
+#define  B150	0000005
+#define  B200	0000006
+#define  B300	0000007
+#define  B600	0000010
+#define  B1200	0000011
+#define  B1800	0000012
+#define  B2400	0000013
+#define  B4800	0000014
+#define  B9600	0000015
+#define  B19200	0000016
+#define  B38400	0000017
+#define EXTA B19200
+#define EXTB B38400
+#define CSIZE	0000060
+#define   CS5	0000000
+#define   CS6	0000020
+#define   CS7	0000040
+#define   CS8	0000060
+#define CSTOPB	0000100
+#define CREAD	0000200
+#define PARENB	0000400
+#define PARODD	0001000
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define CBAUDEX 0010000
+#define    B57600 0010001
+#define   B115200 0010002
+#define   B230400 0010003
+#define   B460800 0010004
+#define   B500000 0010005
+#define   B576000 0010006
+#define   B921600 0010007
+#define  B1000000 0010010
+#define  B1152000 0010011
+#define  B1500000 0010012
+#define  B2000000 0010013
+#define  B2500000 0010014
+#define  B3000000 0010015
+#define  B3500000 0010016
+#define  B4000000 0010017
+#define CIBAUD	  002003600000	/* input baud rate (not used) */
+#define CMSPAR	  010000000000	/* mark or space (stick) parity */
+#define CRTSCTS	  020000000000	/* flow control */
+
+/* c_lflag bits */
+#define ISIG	0000001
+#define ICANON	0000002
+#define XCASE	0000004
+#define ECHO	0000010
+#define ECHOE	0000020
+#define ECHOK	0000040
+#define ECHONL	0000100
+#define NOFLSH	0000200
+#define TOSTOP	0000400
+#define ECHOCTL	0001000
+#define ECHOPRT	0002000
+#define ECHOKE	0004000
+#define FLUSHO	0010000
+#define PENDIN	0040000
+#define IEXTEN	0100000
+
+/* tcflow() and TCXONC use these */
+#define	TCOOFF		0
+#define	TCOON		1
+#define	TCIOFF		2
+#define	TCION		3
+
+/* tcflush() and TCFLSH use these */
+#define	TCIFLUSH	0
+#define	TCOFLUSH	1
+#define	TCIOFLUSH	2
+
+/* tcsetattr uses these */
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
+
+#endif				/* __ARCH_BFIN_TERMBITS_H__ */
Index: git/linux-2.6/include/asm-blackfin/termios.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/termios.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,106 @@
+#ifndef __BFIN_TERMIOS_H__
+#define __BFIN_TERMIOS_H__
+
+#include <asm/termbits.h>
+#include <asm/ioctls.h>
+
+struct winsize {
+	unsigned short ws_row;
+	unsigned short ws_col;
+	unsigned short ws_xpixel;
+	unsigned short ws_ypixel;
+};
+
+#define NCC 8
+struct termio {
+	unsigned short c_iflag;	/* input mode flags */
+	unsigned short c_oflag;	/* output mode flags */
+	unsigned short c_cflag;	/* control mode flags */
+	unsigned short c_lflag;	/* local mode flags */
+	unsigned char c_line;	/* line discipline */
+	unsigned char c_cc[NCC];	/* control characters */
+};
+
+/* modem lines */
+#define TIOCM_LE	0x001
+#define TIOCM_DTR	0x002
+#define TIOCM_RTS	0x004
+#define TIOCM_ST	0x008
+#define TIOCM_SR	0x010
+#define TIOCM_CTS	0x020
+#define TIOCM_CAR	0x040
+#define TIOCM_RNG	0x080
+#define TIOCM_DSR	0x100
+#define TIOCM_CD	TIOCM_CAR
+#define TIOCM_RI	TIOCM_RNG
+#define TIOCM_OUT1	0x2000
+#define TIOCM_OUT2	0x4000
+#define TIOCM_LOOP	0x8000
+
+/* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */
+
+/* line disciplines */
+#define N_TTY		0
+#define N_SLIP		1
+#define N_MOUSE		2
+#define N_PPP		3
+#define N_STRIP		4
+#define N_AX25		5
+#define N_X25		6	/* X.25 async */
+#define N_6PACK		7
+#define N_MASC		8	/* Reserved for Mobitex module <kaz@cafe.net> */
+#define N_R3964		9	/* Reserved for Simatic R3964 module */
+#define N_PROFIBUS_FDL	10	/* Reserved for Profibus <Dave@mvhi.com> */
+#define N_IRDA		11	/* Linux IR - http://irda.sourceforge.net/ */
+#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
+#define N_HDLC		13	/* synchronous HDLC */
+#define N_SYNC_PPP	14	/* synchronous PPP */
+#define N_HCI		15	/* Bluetooth HCI UART */
+
+#ifdef __KERNEL__
+
+/*	intr=^C		quit=^\		erase=del	kill=^U
+	eof=^D		vtime=\0	vmin=\1		sxtc=\0
+	start=^Q	stop=^S		susp=^Z		eol=\0
+	reprint=^R	discard=^U	werase=^W	lnext=^V
+	eol2=\0
+*/
+#define INIT_C_CC "\003\034\177\025\004\0\1\0\021\023\032\0\022\017\027\026\0"
+
+/*
+ * Translate a "termio" structure into a "termios". Ugh.
+ */
+#define SET_LOW_TERMIOS_BITS(termios, termio, x) { \
+	unsigned short __tmp; \
+	get_user(__tmp,&(termio)->x); \
+	*(unsigned short *) &(termios)->x = __tmp; \
+}
+
+#define user_termio_to_kernel_termios(termios, termio) \
+({ \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_iflag); \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_oflag); \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_cflag); \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_lflag); \
+	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
+})
+
+/*
+ * Translate a "termios" structure into a "termio". Ugh.
+ */
+#define kernel_termios_to_user_termio(termio, termios) \
+({ \
+	put_user((termios)->c_iflag, &(termio)->c_iflag); \
+	put_user((termios)->c_oflag, &(termio)->c_oflag); \
+	put_user((termios)->c_cflag, &(termio)->c_cflag); \
+	put_user((termios)->c_lflag, &(termio)->c_lflag); \
+	put_user((termios)->c_line,  &(termio)->c_line); \
+	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
+})
+
+#define user_termios_to_kernel_termios(k, u) copy_from_user(k, u, sizeof(struct termios))
+#define kernel_termios_to_user_termios(u, k) copy_to_user(u, k, sizeof(struct termios))
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __BFIN_TERMIOS_H__ */
Index: git/linux-2.6/include/asm-blackfin/thread_info.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/thread_info.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,137 @@
+/*
+ * File:         include/asm-blackfin/thread_info.h
+ * Based on:     include/asm-m68knommu/thread_info.h
+ * Author:       LG Soft India
+ *               Copyright (C) 2004-2005 Analog Devices Inc.
+ * Created:      Tue Sep 21 2004
+ * Description:  Blackfin low-level thread information
+ * Rev:          $Id$
+ * Modified:
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _ASM_THREAD_INFO_H
+#define _ASM_THREAD_INFO_H
+
+#include <asm/page.h>
+#include <asm/entry.h>
+#include <linux/compiler.h>
+
+#ifdef __KERNEL__
+
+/* Thread Align Mask to reach to the top of the stack
+ * for any process
+ */
+#define ALIGN_PAGE_MASK         0xffffe000
+
+#ifndef __ASSEMBLY__
+
+/*
+ * low level task data.
+ * If you change this, change the TI_* offsets below to match.
+ */
+
+struct thread_info {
+	struct task_struct *task;	/* main task structure */
+	struct exec_domain *exec_domain;	/* execution domain */
+	unsigned long flags;	/* low level flags */
+	int cpu;		/* cpu we're on */
+	int preempt_count;	/* 0 => preemptable, <0 => BUG */
+	struct restart_block restart_block;
+};
+
+/*
+ * macros/functions for gaining access to the thread information structure
+ */
+#define INIT_THREAD_INFO(tsk)			\
+{						\
+	.task		= &tsk,			\
+	.exec_domain	= &default_exec_domain,	\
+	.flags		= 0,			\
+	.cpu		= 0,			\
+	.preempt_count  = 1,                    \
+	.restart_block	= {			\
+		.fn = do_no_restart_syscall,	\
+	},					\
+}
+#define init_thread_info	(init_thread_union.thread_info)
+#define init_stack		(init_thread_union.stack)
+
+/*
+ * Size of kernel stack for each process. This must be a power of 2...
+ */
+#define THREAD_SIZE		8192	/* 2 pages */
+
+/* How to get the thread information struct from C */
+
+static inline struct thread_info *current_thread_info(void)
+    __attribute__ ((__const__));
+
+/* Given a task stack pointer, you can find it's task structure
+ * just by masking it to the 8K boundary.
+ */
+static inline struct thread_info *current_thread_info(void)
+{
+	struct thread_info *ti;
+      __asm__("%0 = sp;": "=&d"(ti):
+	);
+	return (struct thread_info *)((long)ti & ~8191UL);
+}
+
+/* thread information allocation */
+#define alloc_thread_info(tsk) ((struct thread_info *) \
+				__get_free_pages(GFP_KERNEL, 1))
+#define free_thread_info(ti)	free_pages((unsigned long) (ti), 1)
+#define get_thread_info(ti)	get_task_struct((ti)->task)
+#define put_thread_info(ti)	put_task_struct((ti)->task)
+#endif				/* __ASSEMBLY__ */
+
+/*
+ * Offsets in thread_info structure, used in assembly code
+ */
+#define TI_TASK		0
+#define TI_EXECDOMAIN	4
+#define TI_FLAGS	8
+#define TI_CPU		12
+#define TI_PREEMPT	16
+
+#define	PREEMPT_ACTIVE	0x4000000
+
+/*
+ * thread information flag bit numbers
+ */
+#define TIF_SYSCALL_TRACE	0	/* syscall trace active */
+#define TIF_NOTIFY_RESUME	1	/* resumption notification requested */
+#define TIF_SIGPENDING		2	/* signal pending */
+#define TIF_NEED_RESCHED	3	/* rescheduling necessary */
+#define TIF_POLLING_NRFLAG	4	/* true if poll_idle() is polling
+					   TIF_NEED_RESCHED */
+#define TIF_MEMDIE                5
+
+/* as above, but as bit values */
+#define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
+#define _TIF_NOTIFY_RESUME	(1<<TIF_NOTIFY_RESUME)
+#define _TIF_SIGPENDING		(1<<TIF_SIGPENDING)
+#define _TIF_NEED_RESCHED	(1<<TIF_NEED_RESCHED)
+#define _TIF_POLLING_NRFLAG	(1<<TIF_POLLING_NRFLAG)
+
+#define _TIF_WORK_MASK		0x0000FFFE	/* work to do on interrupt/exception return */
+
+#endif				/* __KERNEL__ */
+
+#endif				/* _ASM_THREAD_INFO_H */
Index: git/linux-2.6/include/asm-blackfin/timex.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/timex.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,18 @@
+/* blackfin architecture timex specifications: Lineo Inc. 2001
+ *
+ * Based on: include/asm-m68knommu/timex.h
+ */
+
+#ifndef _ASMBLACKFIN_TIMEX_H
+#define _ASMBLACKFIN_TIMEX_H
+
+#define CLOCK_TICK_RATE	1000000	/* Underlying HZ */
+
+typedef unsigned long cycles_t;
+
+static inline cycles_t get_cycles(void)
+{
+	return 0;
+}
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/tlb.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/tlb.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,16 @@
+#ifndef _BLACKFIN_TLB_H
+#define _BLACKFIN_TLB_H
+
+#define tlb_start_vma(tlb, vma)	do { } while (0)
+#define tlb_end_vma(tlb, vma)	do { } while (0)
+#define __tlb_remove_tlb_entry(tlb, ptep, address)	do { } while (0)
+
+/*
+ * .. because we flush the whole mm when it
+ * fills up.
+ */
+#define tlb_flush(tlb)		flush_tlb_mm((tlb)->mm)
+
+#include <asm-generic/tlb.h>
+
+#endif				/* _BLACKFIN_TLB_H */
Index: git/linux-2.6/include/asm-blackfin/tlbflush.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/tlbflush.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,62 @@
+#ifndef _BLACKFIN_TLBFLUSH_H
+#define _BLACKFIN_TLBFLUSH_H
+
+/*
+ * Copyright (C) 2000 Lineo, David McCullough <davidm@uclinux.org>
+ * Copyright (C) 2000-2002, Greg Ungerer <gerg@snapgear.com>
+ */
+
+#include <asm/setup.h>
+
+/*
+ * flush all user-space atc entries.
+ */
+static inline void __flush_tlb(void)
+{
+	BUG();
+}
+
+static inline void __flush_tlb_one(unsigned long addr)
+{
+	BUG();
+}
+
+#define flush_tlb() __flush_tlb()
+
+/*
+ * flush all atc entries (both kernel and user-space entries).
+ */
+static inline void flush_tlb_all(void)
+{
+	BUG();
+}
+
+static inline void flush_tlb_mm(struct mm_struct *mm)
+{
+	BUG();
+}
+
+static inline void flush_tlb_page(struct vm_area_struct *vma,
+				  unsigned long addr)
+{
+	BUG();
+}
+
+static inline void flush_tlb_range(struct mm_struct *mm,
+				   unsigned long start, unsigned long end)
+{
+	BUG();
+}
+
+static inline void flush_tlb_kernel_page(unsigned long addr)
+{
+	BUG();
+}
+
+static inline void flush_tlb_pgtables(struct mm_struct *mm,
+				      unsigned long start, unsigned long end)
+{
+	BUG();
+}
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/topology.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/topology.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,6 @@
+#ifndef _ASM_BLACKFIN_TOPOLOGY_H
+#define _ASM_BLACKFIN_TOPOLOGY_H
+
+#include <asm-generic/topology.h>
+
+#endif				/* _ASM_BLACKFIN_TOPOLOGY_H */
Index: git/linux-2.6/include/asm-blackfin/traps.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/traps.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,75 @@
+/*
+ *  linux/include/asm/traps.h
+ *
+ *  Copyright (C) 1993        Hamish Macdonald
+ *
+ *  Lineo, Inc    Jul 2001    Tony Kou
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+
+#ifndef _BFIN_TRAPS_H
+#define _BFIN_TRAPS_H
+
+#define VEC_SYS		(0)
+#define VEC_EXCPT01	(1)
+#define VEC_EXCPT02	(2)
+#define VEC_EXCPT03	(3)
+#define VEC_EXCPT04	(4)
+#define VEC_EXCPT05	(5)
+#define VEC_EXCPT06	(6)
+#define VEC_EXCPT07	(7)
+#define VEC_EXCPT08	(8)
+#define VEC_EXCPT09	(9)
+#define VEC_EXCPT10	(10)
+#define VEC_EXCPT11	(11)
+#define VEC_EXCPT12	(12)
+#define VEC_EXCPT13	(13)
+#define VEC_EXCPT14	(14)
+#define VEC_EXCPT15	(15)
+#define VEC_STEP	(16)
+#define VEC_OVFLOW	(17)
+#define VEC_UNDEF_I	(33)
+#define VEC_ILGAL_I	(34)
+#define VEC_CPLB_VL	(35)
+#define VEC_MISALI_D	(36)
+#define VEC_UNCOV	(37)
+#define VEC_CPLB_M	(38)
+#define VEC_CPLB_MHIT	(39)
+#define VEC_WATCH	(40)
+#define VEC_ISTRU_VL	(41)	/*ADSP-BF535 only (MH) */
+#define VEC_MISALI_I	(42)
+#define VEC_CPLB_I_VL	(43)
+#define VEC_CPLB_I_M	(44)
+#define VEC_CPLB_I_MHIT	(45)
+#define VEC_ILL_RES	(46)	/* including unvalid supervisor mode insn */
+
+#ifndef __ASSEMBLY__
+
+#define HWC_x2 "System MMR Error \nAn error can occured due to an invalid access to an System MMR location\nPossible reason: a 32-bit register is accessed with a 16-bit instruction,\nor a 16-bit register is accessed with a 32-bit instruction.\n"
+#define HWC_x3 "External Memory Addressing Error\n"
+#define HWC_x12 "Performance Monitor Overflow\n"
+#define HWC_x18 "RAISE 5 instruction\n Software issued a RAISE 5 instruction to invoke the Hardware\n"
+#define HWC_default "Reserved\n"
+
+#define EXC_0x03 "Application stack overflow\n - Please increase the stack size of the application using elf2flt -s option,\n and/or reduce the stack use of the application.\n"
+#define EXC_0x10 "Single step\n - When the processor is in single step mode, every instruction\n generates an exception. Primarily used for debugging.\n"
+#define EXC_0x11 "Exception caused by a trace buffer full condition\n - The processor takes this exception when the trace\n buffer overflows (only when enabled by the Trace Unit Control register).\n"
+#define EXC_0x21 "Undefined instruction\n - May be used to emulate instructions that are not defined for\n a particular processor implementation.\n"
+#define EXC_0x22 "Illegal instruction combination\n - See section for multi-issue rules in the ADSP-BF53x Blackfin\n Processor Instruction Set Reference.\n"
+#define EXC_0x23 "Data access CPLB protection violation\n - Attempted read or write to Supervisor resource,\n or illegal data memory access. \n"
+#define EXC_0x24 "Data access misaligned address violation\n - Attempted misaligned data memory or data cache access.\n"
+#define EXC_0x25 "Unrecoverable event\n - For example, an exception generated while processing a previous exception.\n"
+#define EXC_0x26 "Data access CPLB miss\n - Used by the MMU to signal a CPLB miss on a data access.\n"
+#define EXC_0x27 "Data access multiple CPLB hits\n - More than one CPLB entry matches data fetch address.\n"
+#define EXC_0x28 "Program Sequencer Exception caused by an emulation watchpoint match\n - There is a watchpoint match, and one of the EMUSW\n bits in the Watchpoint Instruction Address Control register (WPIACTL) is set.\n"
+#define EXC_0x2A "Instruction fetch misaligned address violation\n - Attempted misaligned instruction cache fetch. On a misaligned instruction fetch exception,\n the return address provided in RETX is the destination address which is misaligned, rather than the address of the offending instruction.\n"
+#define EXC_0x2B "CPLB protection violation\n - Illegal instruction fetch access (memory protection violation).\n"
+#define EXC_0x2C "Instruction fetch CPLB miss\n - CPLB miss on an instruction fetch.\n"
+#define EXC_0x2D "Instruction fetch multiple CPLB hits\n - More than one CPLB entry matches instruction fetch address.\n"
+#define EXC_0x2E "Illegal use of supervisor resource\n - Attempted to use a Supervisor register or instruction from User mode.\n Supervisor resources are registers and instructions that are reserved\n for Supervisor use: Supervisor only registers, all MMRs, and Supervisor\n only instructions.\n"
+
+#endif				/* __ASSEMBLY__ */
+#endif				/* _BFIN_TRAPS_H */
Index: git/linux-2.6/include/asm-blackfin/types.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/types.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,66 @@
+#ifndef _BFIN_TYPES_H
+#define _BFIN_TYPES_H
+
+/*
+ * This file is never included by application software unless
+ * explicitly requested (e.g., via linux/types.h) in which case the
+ * application is Linux specific so (user-) name space pollution is
+ * not a major issue.  However, for interoperability, libraries still
+ * need to be careful to avoid a name clashes.
+ */
+#ifndef __ASSEMBLY__
+
+typedef unsigned short umode_t;
+
+/*
+ * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
+ * header files exported to user space
+ */
+
+typedef __signed__ char __s8;
+typedef unsigned char __u8;
+
+typedef __signed__ short __s16;
+typedef unsigned short __u16;
+
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+
+/* HK0617   -- Changes to unsigned long temporarily */
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
+typedef __signed__ long long __s64;
+typedef unsigned long long __u64;
+#endif
+
+#endif				/* __ASSEMBLY__ */
+/*
+ * These aren't exported outside the kernel to avoid name space clashes
+ */
+#ifdef __KERNEL__
+
+#define BITS_PER_LONG 32
+
+#ifndef __ASSEMBLY__
+
+typedef signed char s8;
+typedef unsigned char u8;
+
+typedef signed short s16;
+typedef unsigned short u16;
+
+typedef signed int s32;
+typedef unsigned int u32;
+
+typedef signed long long s64;
+typedef unsigned long long u64;
+
+/* Dma addresses are 32-bits wide.  */
+
+typedef u32 dma_addr_t;
+typedef u32 dma64_addr_t;
+
+#endif				/* __ASSEMBLY__ */
+
+#endif				/* __KERNEL__ */
+
+#endif				/* _BFIN_TYPES_H */
Index: git/linux-2.6/include/asm-blackfin/uaccess.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/uaccess.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,190 @@
+/* Changes made by Lineo Inc.    May 2001
+ *
+ * Based on: include/asm-m68knommu/uaccess.h
+ */
+
+#ifndef __BLACKFIN_UACCESS_H
+#define __BLACKFIN_UACCESS_H
+
+/*
+ * User space memory access functions
+ */
+#include <linux/mm.h>
+
+#define VERIFY_READ	0
+#define VERIFY_WRITE	1
+
+#define access_ok(type,addr,size)	_access_ok((unsigned long)(addr),(size))
+
+extern int is_in_rom(unsigned long);
+static inline int _access_ok(unsigned long addr, unsigned long size)
+{
+	extern unsigned long memory_end;
+	return (((addr >= memory_start) && (addr + size <= memory_end)) ||
+		(is_in_rom(addr) && is_in_rom(addr + size)));
+
+}
+
+/*
+ * The exception table consists of pairs of addresses: the first is the
+ * address of an instruction that is allowed to fault, and the second is
+ * the address at which the program should continue.  No registers are
+ * modified, so it is entirely up to the continuation code to figure out
+ * what to do.
+ *
+ * All the routines below use bits of fixup code that are out of line
+ * with the main instruction path.  This means when everything is well,
+ * we don't even have to jump over them.  Further, they do not intrude
+ * on our cache or tlb entries.
+ */
+
+struct exception_table_entry {
+	unsigned long insn, fixup;
+};
+
+/* Returns 0 if exception not found and fixup otherwise.  */
+extern unsigned long search_exception_table(unsigned long);
+
+/*
+ * These are the main single-value transfer routines.  They automatically
+ * use the right size if we just have the right pointer type.
+ */
+
+#define put_user(x, ptr)				\
+({							\
+    int __pu_err = 0;					\
+    typeof(*(ptr)) __pu_val = (x);			\
+    switch (sizeof (*(ptr))) {				\
+    case 1:						\
+	__put_user_asm(__pu_val, ptr, B);		\
+	break;						\
+    case 2:						\
+	__put_user_asm(__pu_val, ptr, W);		\
+	break;						\
+    case 4:						\
+	__put_user_asm(__pu_val, ptr,  );		\
+	break;						\
+    case 8: { long __pu_vall, __pu_valh;		\
+         __pu_vall = ((long *)&__pu_val)[0]; \
+        __pu_valh = ((long *)&__pu_val)[1]; \
+	__put_user_asm(__pu_vall, ((long *)ptr)+0, );	\
+	__put_user_asm(__pu_valh, ((long *)ptr)+1, );	\
+    } break;						\
+    default:						\
+	__pu_err = __put_user_bad();			\
+	break;						\
+    }							\
+    __pu_err;						\
+})
+
+#define __put_user(x, ptr) put_user(x, ptr)
+static inline int bad_user_access_length(void)
+{
+	panic("bad_user_access_length");
+	return -1;
+}
+
+#define __put_user_bad() (printk("put_user_bad %s:%d %s\n", __FILE__, __LINE__, __FUNCTION__), bad_user_access_length(), (-EFAULT))
+
+/*
+ * Tell gcc we read from memory instead of writing: this is because
+ * we do not write to any memory gcc knows about, so there are no
+ * aliasing issues.
+ */
+
+#define __ptr(x) ((unsigned long *)(x))
+
+#define __put_user_asm(x,ptr,bhw)			\
+	__asm__ (#bhw"[%1] = %0;\n\t"			\
+		: /* no outputs */			\
+		:"d" (x),"a" (__ptr(ptr)) : "memory")
+
+#define get_user(x, ptr)				\
+({							\
+    int __gu_err = 0;					\
+    typeof(*(ptr)) __gu_val = 0;			\
+    switch (sizeof(*(ptr))) {				\
+    case 1:						\
+	__get_user_asm(__gu_val, ptr, B,(Z));		\
+	break;						\
+    case 2:						\
+	__get_user_asm(__gu_val, ptr, W,(Z));		\
+	break;						\
+    case 4:						\
+	__get_user_asm(__gu_val, ptr,  , );		\
+	break;						\
+    case 8: { long __gu_vall, __gu_valh;		\
+	__get_user_asm(__gu_vall, ((long *)ptr)+0,  , );	\
+	__get_user_asm(__gu_valh, ((long *)ptr)+1,  , );	\
+        ((long *)&__gu_val)[0] = __gu_vall; \
+        ((long *)&__gu_val)[1] = __gu_valh; \
+    } break;						\
+    default:						\
+	__gu_val = 0;					\
+        printk("get_user_bad: %s:%d %s\n", __FILE__, __LINE__, __FUNCTION__); \
+	__gu_err = __get_user_bad();			\
+	break;						\
+    }							\
+    (x) = __gu_val;					\
+    __gu_err;						\
+})
+
+#define __get_user(x, ptr) get_user(x, ptr)
+
+#define __get_user_bad() (bad_user_access_length(), (-EFAULT))
+
+#define __get_user_asm(x,ptr,bhw,option)		\
+	__asm__ ("%0 =" #bhw "[%1]"#option";\n\t"	\
+		 : "=d" (x)				\
+		 : "a" (__ptr(ptr)))
+
+#define copy_from_user(to, from, n)		(memcpy(to, from, n), 0)
+#define copy_to_user(to, from, n)		(memcpy(to, from, n), 0)
+
+#define __copy_from_user(to, from, n) copy_from_user(to, from, n)
+#define __copy_to_user(to, from, n) copy_to_user(to, from, n)
+#define __copy_to_user_inatomic __copy_to_user
+#define __copy_from_user_inatomic __copy_from_user
+
+#define copy_to_user_ret(to,from,n,retval) ({ if (copy_to_user(to,from,n)) return retval; })
+
+#define copy_from_user_ret(to,from,n,retval) ({ if (copy_from_user(to,from,n)) return retval; })
+
+/*
+ * Copy a null terminated string from userspace.
+ */
+
+static inline long strncpy_from_user(char *dst, const char *src, long count)
+{
+	char *tmp;
+	if ((unsigned long)src > memory_end) {
+		return -EFAULT;
+	}
+	strncpy(dst, src, count);
+	for (tmp = dst; *tmp && count > 0; tmp++, count--) ;
+	return (tmp - dst);
+}
+
+/*
+ * Return the size of a string (including the ending 0)
+ *
+ * Return 0 on exception, a value greater than N if too long
+ */
+static inline long strnlen_user(const char *src, long n)
+{
+	return (strlen(src) + 1);
+}
+
+#define strlen_user(str) strnlen_user(str, 32767)
+
+/*
+ * Zero Userspace
+ */
+
+static inline unsigned long clear_user(void *to, unsigned long n)
+{
+	memset(to, 0, n);
+	return (0);
+}
+
+#endif				/* _BLACKFIN_UACCESS_H */
Index: git/linux-2.6/include/asm-blackfin/ucontext.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/ucontext.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,30 @@
+/** Changes made by Tony Kou   Lineo Inc.    May 2001
+ *
+ *  Based on: include/m68knommu/ucontext.h
+ */
+
+#ifndef _BLACKFIN_UCONTEXT_H
+#define _BLACKFIN_UCONTEXT_H
+
+typedef int greg_t;
+#define NGREG 47
+/* including: r0-7, p0-5, a0/1w, a0/1x, astat, rets, reti, retx */
+/* fp, m0-3, l0-3, b0-3, lc0/1, lt0/1, lb0/1, seqstat */
+typedef greg_t gregset_t[NGREG];
+
+struct mcontext {
+	int version;
+	gregset_t gregs;
+};
+
+#define MCONTEXT_VERSION 2
+
+struct ucontext {
+	unsigned long uc_flags;	/* the others are necessary */
+	struct ucontext *uc_link;
+	stack_t uc_stack;
+	struct mcontext uc_mcontext;
+	sigset_t uc_sigmask;	/* mask last for extensibility */
+};
+
+#endif				/* _BLACKFIN_UCONTEXT_H */
Index: git/linux-2.6/include/asm-blackfin/unaligned.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/unaligned.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,6 @@
+#ifndef __BFIN_UNALIGNED_H
+#define __BFIN_UNALIGNED_H
+
+#include <asm-generic/unaligned.h>
+
+#endif				/* __BFIN_UNALIGNED_H */
Index: git/linux-2.6/include/asm-blackfin/unistd.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/unistd.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,458 @@
+#ifndef __ASM_BFIN_UNISTD_H
+#define __ASM_BFIN_UNISTD_H
+/*
+ * This file contains the system call numbers.
+ */
+#define __NR_exit		  1
+#define __NR_fork		  2
+#define __NR_read		  3
+#define __NR_write		  4
+#define __NR_open		  5
+#define __NR_close		  6
+#define __NR_waitpid		  7
+#define __NR_creat		  8
+#define __NR_link		  9
+#define __NR_unlink		 10
+#define __NR_execve		 11
+#define __NR_chdir		 12
+#define __NR_time		 13
+#define __NR_mknod		 14
+#define __NR_chmod		 15
+#define __NR_chown		 16
+#define __NR_dump		 17
+#define __NR_oldstat		 18
+#define __NR_lseek		 19
+#define __NR_getpid		 20
+#define __NR_mount		 21
+#define __NR_umount		 22
+#define __NR_setuid		 23
+#define __NR_getuid		 24
+#define __NR_stime		 25
+#define __NR_ptrace		 26
+#define __NR_alarm		 27
+#define __NR_oldfstat		 28
+#define __NR_pause		 29
+#define __NR_utime		 30
+#define __NR_stty		 31
+#define __NR_gtty		 32
+#define __NR_access		 33
+#define __NR_nice		 34
+#define __NR_ftime		 35
+#define __NR_sync		 36
+#define __NR_kill		 37
+#define __NR_rename		 38
+#define __NR_mkdir		 39
+#define __NR_rmdir		 40
+#define __NR_dup		 41
+#define __NR_pipe		 42
+#define __NR_times		 43
+#define __NR_prof		 44
+#define __NR_brk		 45
+#define __NR_setgid		 46
+#define __NR_getgid		 47
+#define __NR_signal		 48
+#define __NR_geteuid		 49
+#define __NR_getegid		 50
+#define __NR_acct		 51
+#define __NR_umount2		 52
+#define __NR_lock		 53
+#define __NR_ioctl		 54
+#define __NR_fcntl		 55
+#define __NR_mpx		 56
+#define __NR_setpgid		 57
+#define __NR_ulimit		 58
+#define __NR_oldolduname	 59
+#define __NR_umask		 60
+#define __NR_chroot		 61
+#define __NR_ustat		 62
+#define __NR_dup2		 63
+#define __NR_getppid		 64
+#define __NR_getpgrp		 65
+#define __NR_setsid		 66
+#define __NR_sigaction		 67
+#define __NR_sgetmask		 68
+#define __NR_ssetmask		 69
+#define __NR_setreuid		 70
+#define __NR_setregid		 71
+#define __NR_sigsuspend		 72
+#define __NR_sigpending		 73
+#define __NR_sethostname	 74
+#define __NR_setrlimit		 75
+#define __NR_old_getrlimit	 76
+#define __NR_getrusage		 77
+#define __NR_gettimeofday	 78
+#define __NR_settimeofday	 79
+#define __NR_getgroups		 80
+#define __NR_setgroups		 81
+#define __NR_select		 82
+#define __NR_symlink		 83
+#define __NR_oldlstat		 84
+#define __NR_readlink		 85
+#define __NR_uselib		 86
+#define __NR_swapon		 87
+#define __NR_reboot		 88
+#define __NR_readdir		 89
+#define __NR_mmap		 90
+#define __NR_munmap		 91
+#define __NR_truncate		 92
+#define __NR_ftruncate		 93
+#define __NR_fchmod		 94
+#define __NR_fchown		 95
+#define __NR_getpriority	 96
+#define __NR_setpriority	 97
+#define __NR_profil		 98
+#define __NR_statfs		 99
+#define __NR_fstatfs		100
+#define __NR_ioperm		101
+#define __NR_socketcall		102
+#define __NR_syslog		103
+#define __NR_setitimer		104
+#define __NR_getitimer		105
+#define __NR_stat		106
+#define __NR_lstat		107
+#define __NR_fstat		108
+#define __NR_olduname		109
+#define __NR_vhangup		111
+#define __NR_wait4		114
+#define __NR_swapoff		115
+#define __NR_sysinfo		116
+#define __NR_ipc		117
+#define __NR_fsync		118
+#define __NR_sigreturn		119
+#define __NR_clone		120
+#define __NR_setdomainname	121
+#define __NR_uname		122
+#define __NR_cacheflush		123
+#define __NR_adjtimex		124
+#define __NR_mprotect		125
+#define __NR_sigprocmask	126
+#define __NR_create_module	127
+#define __NR_init_module	128
+#define __NR_delete_module	129
+#define __NR_get_kernel_syms	130
+#define __NR_quotactl		131
+#define __NR_getpgid		132
+#define __NR_fchdir		133
+#define __NR_bdflush		134
+#define __NR_sysfs		135
+#define __NR_personality	136
+#define __NR_afs_syscall	137	/* Syscall for Andrew File System */
+#define __NR_setfsuid		138
+#define __NR_setfsgid		139
+#define __NR__llseek		140
+#define __NR_getdents		141
+#define __NR__newselect		142
+#define __NR_flock		143
+#define __NR_msync		144
+#define __NR_readv		145
+#define __NR_writev		146
+#define __NR_getsid		147
+#define __NR_fdatasync		148
+#define __NR__sysctl		149
+#define __NR_mlock		150
+#define __NR_munlock		151
+#define __NR_mlockall		152
+#define __NR_munlockall		153
+#define __NR_sched_setparam		154
+#define __NR_sched_getparam		155
+#define __NR_sched_setscheduler		156
+#define __NR_sched_getscheduler		157
+#define __NR_sched_yield		158
+#define __NR_sched_get_priority_max	159
+#define __NR_sched_get_priority_min	160
+#define __NR_sched_rr_get_interval	161
+#define __NR_nanosleep		162
+#define __NR_mremap		163
+#define __NR_setresuid		164
+#define __NR_getresuid		165
+#define __NR_query_module	167
+#define __NR_poll		168
+#define __NR_nfsservctl		169
+#define __NR_setresgid		170
+#define __NR_getresgid		171
+#define __NR_prctl		172
+#define __NR_rt_sigreturn	173
+#define __NR_rt_sigaction	174
+#define __NR_rt_sigprocmask	175
+#define __NR_rt_sigpending	176
+#define __NR_rt_sigtimedwait	177
+#define __NR_rt_sigqueueinfo	178
+#define __NR_rt_sigsuspend	179
+#define __NR_pread		180
+#define __NR_pwrite		181
+#define __NR_lchown		182
+#define __NR_getcwd		183
+#define __NR_capget		184
+#define __NR_capset		185
+#define __NR_sigaltstack	186
+#define __NR_sendfile		187
+#define __NR_getpmsg		188
+#define __NR_putpmsg		189
+#define __NR_vfork		190
+#define __NR_getrlimit		191
+#define __NR_mmap2		192
+#define __NR_truncate64		193
+#define __NR_ftruncate64	194
+#define __NR_stat64		195
+#define __NR_lstat64		196
+#define __NR_fstat64		197
+#define __NR_chown32		198
+#define __NR_getuid32		199
+#define __NR_getgid32		200
+#define __NR_geteuid32		201
+#define __NR_getegid32		202
+#define __NR_setreuid32		203
+#define __NR_setregid32		204
+#define __NR_getgroups32	205
+#define __NR_setgroups32	206
+#define __NR_fchown32		207
+#define __NR_setresuid32	208
+#define __NR_getresuid32	209
+#define __NR_setresgid32	210
+#define __NR_getresgid32	211
+#define __NR_lchown32		212
+#define __NR_setuid32		213
+#define __NR_setgid32		214
+#define __NR_setfsuid32		215
+#define __NR_setfsgid32		216
+#define __NR_pivot_root		217
+#define __NR_mincore		218
+#define __NR_madvise		219
+#define __NR_getdents64		220
+#define __NR_fcntl64		221
+#define __NR_gettid		224
+#define __NR_readahead		225
+#define __NR_setxattr		226
+#define __NR_lsetxattr		227
+#define __NR_fsetxattr		228
+#define __NR_getxattr		229
+#define __NR_lgetxattr		230
+#define __NR_fgetxattr		231
+#define __NR_listxattr		232
+#define __NR_llistxattr		233
+#define __NR_flistxattr		234
+#define __NR_removexattr	235
+#define __NR_lremovexattr	236
+#define __NR_fremovexattr	237
+#define __NR_tkill		238
+#define __NR_sendfile64		239
+#define __NR_futex		240
+#define __NR_sched_setaffinity	241
+#define __NR_sched_getaffinity	242
+#define __NR_set_thread_area	243
+#define __NR_get_thread_area	244
+#define __NR_io_setup		245
+#define __NR_io_destroy		246
+#define __NR_io_getevents	247
+#define __NR_io_submit		248
+#define __NR_io_cancel		249
+#define __NR_fadvise64		250
+#define __NR_exit_group		252
+#define __NR_lookup_dcookie     253
+#define __NR_bfin_spinlock      254
+#define __NR_syscall		256
+#define NR_syscalls		__NR_syscall
+
+#define __syscall_return(type, res)					\
+do {									\
+	if ((unsigned long)(res) >= (unsigned long)(-125)) 		\
+	{	errno = -(res);						\
+		res = -1;						\
+	}								\
+	return (type) (res);						\
+} while (0)
+
+#define _syscall0(type,name)						\
+type name(void) {							\
+  long __res;								\
+  __asm__ __volatile__ (						\
+  "p0 = %1;\n\t"							\
+  "excpt 0;\n\t" 							\
+  "%0=r0;\n\t"								\
+  : "=da" (__res) 							\
+  : "i" (__NR_##name)							\
+  : "CC", "P0");							\
+__syscall_return(type,__res);						\
+}
+
+#define _syscall1(type,name,type1,arg1)					\
+type name(type1 arg1) {							\
+  long __res;								\
+  __asm__ __volatile__ (						\
+  "r0=%2;\n\t"								\
+  "p0=%1;\n\t"								\
+  "excpt 0;\n\t" 							\
+  "%0=r0;\n\t"								\
+        : "=da" (__res)							\
+        : "i" (__NR_##name),						\
+	  "a" ((long)(arg1))						\
+	: "CC", "R0", "P0");						\
+__syscall_return(type,__res);						\
+}
+
+#define _syscall2(type,name,type1,arg1,type2,arg2)			\
+type name(type1 arg1,type2 arg2) {					\
+  long __res;								\
+  __asm__ __volatile__ (						\
+  "r1=%3;\n\t"								\
+  "r0=%2;\n\t"								\
+  "p0=%1;\n\t"								\
+  "excpt 0;\n\t" 							\
+  "%0=r0;\n\t"								\
+        : "=da" (__res)							\
+        : "i" (__NR_##name),						\
+	  "a" ((long)(arg1)),						\
+	  "a" ((long)(arg2))						\
+	: "CC", "R0","R1", "P0");					\
+__syscall_return(type,__res);						\
+}
+
+#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3)		\
+type name(type1 arg1,type2 arg2,type3 arg3) {				\
+  long __res;								\
+  __asm__ __volatile__ (						\
+  "r2=%4;\n\t"								\
+  "r1=%3;\n\t"								\
+  "r0=%2;\n\t"								\
+  "p0=%1;\n\t"								\
+  "excpt 0;\n\t" 							\
+  "%0=r0;\n\t"								\
+        : "=da" (__res)							\
+        : "i"   (__NR_##name),						\
+	  "a"   ((long)(arg1)),						\
+	  "a"   ((long)(arg2)),						\
+	  "a"   ((long)(arg3))						\
+        : "CC", "R0","R1","R2", "P0");					\
+__syscall_return(type,__res);						\
+}
+
+#define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)\
+type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {		\
+  long __res;								\
+  __asm__ __volatile__ (						\
+  "[--sp] = r3;\n\t"							\
+  "r3=%5;\n\t"								\
+  "r2=%4;\n\t"								\
+  "r1=%3;\n\t"								\
+  "r0=%2;\n\t"								\
+  "p0=%1;\n\t"								\
+  "excpt 0;\n\t" 							\
+  "%0=r0;\n\t"								\
+  "r3 = [sp++];\n\t"							\
+  	: "=da" (__res)							\
+  	: "i"  (__NR_##name),						\
+	  "a"  ((long)(arg1)),						\
+	  "a"  ((long)(arg2)),						\
+	  "a"  ((long)(arg3)),						\
+	  "a"  ((long)(arg4))						\
+  	: "CC", "R0","R1","R2","R3", "P0");				\
+__syscall_return(type,__res);						\
+}
+
+#define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,type5,arg5)	\
+type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5) {	\
+  long __res;								\
+  __asm__ __volatile__ (						\
+  "[--sp] = r4;\n\t"                                                    \
+  "[--sp] = r3;\n\t"                                                    \
+  "r4=%6;\n\t"								\
+  "r3=%5;\n\t"								\
+  "r2=%4;\n\t"								\
+  "r1=%3;\n\t"								\
+  "r0=%2;\n\t"								\
+  "P0=%1;\n\t"								\
+  "excpt 0;\n\t" 							\
+  "%0=r0;\n\t"								\
+  "r3 = [sp++];\n\t" 							\
+  "r4 = [sp++];\n\t"                                                    \
+  	: "=da" (__res)							\
+  	: "i"  (__NR_##name),						\
+	  "rm"  ((long)(arg1)),						\
+	  "rm"  ((long)(arg2)),						\
+	  "rm"  ((long)(arg3)),						\
+	  "rm"  ((long)(arg4)),						\
+	  "rm"  ((long)(arg5))						\
+	: "CC","R0","R1","R2","R3","R4","P0");				\
+__syscall_return(type,__res);						\
+}
+
+#ifdef __KERNEL__
+#define __ARCH_WANT_IPC_PARSE_VERSION
+#define __ARCH_WANT_OLD_READDIR
+#define __ARCH_WANT_OLD_STAT
+#define __ARCH_WANT_STAT64
+#define __ARCH_WANT_SYS_ALARM
+#define __ARCH_WANT_SYS_GETHOSTNAME
+#define __ARCH_WANT_SYS_PAUSE
+#define __ARCH_WANT_SYS_SGETMASK
+#define __ARCH_WANT_SYS_SIGNAL
+#define __ARCH_WANT_SYS_TIME
+#define __ARCH_WANT_SYS_UTIME
+#define __ARCH_WANT_SYS_WAITPID
+#define __ARCH_WANT_SYS_SOCKETCALL
+#define __ARCH_WANT_SYS_FADVISE64
+#define __ARCH_WANT_SYS_GETPGRP
+#define __ARCH_WANT_SYS_LLSEEK
+#define __ARCH_WANT_SYS_NICE
+#define __ARCH_WANT_SYS_OLD_GETRLIMIT
+#define __ARCH_WANT_SYS_OLDUMOUNT
+#define __ARCH_WANT_SYS_SIGPENDING
+#define __ARCH_WANT_SYS_SIGPROCMASK
+#define __ARCH_WANT_SYS_RT_SIGACTION
+#endif
+
+#ifdef __KERNEL_SYSCALLS__
+
+#include <linux/interrupt.h>
+
+#define __NR__exit __NR_exit
+#if 0
+static inline _syscall0(int, pause)
+static inline _syscall0(int, sync)
+static inline _syscall0(pid_t, setsid)
+static inline _syscall3(int, write, int, fd, const char *, buf, off_t, count)
+static inline _syscall3(int, read, int, fd, char *, buf, off_t, count)
+static inline _syscall3(off_t, lseek, int, fd, off_t, offset, int, count)
+static inline _syscall1(int, dup, int, fd)
+//static inline _syscall3(int,execve,const char *,file,char **,argv,char **,envp)
+static inline _syscall3(int, open, const char *, file, int, flag, int, mode)
+static inline _syscall1(int, close, int, fd)
+static inline _syscall1(int, _exit, int, exitcode)
+static inline _syscall3(pid_t, waitpid, pid_t, pid, int *, wait_stat, int,
+			options)
+static inline _syscall1(int, delete_module, const char *, name)
+
+static inline pid_t wait(int *wait_stat)
+{
+	return waitpid(-1, wait_stat, 0);
+}
+#endif
+
+asmlinkage long execve(char *, char **, char **);
+
+asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
+			  unsigned long prot, unsigned long flags,
+			  unsigned long fd, unsigned long pgoff);
+asmlinkage int sys_execve(char *name, char **argv, char **envp);
+asmlinkage int sys_pipe(unsigned long *fildes);
+struct pt_regs;
+int sys_request_irq(unsigned int,
+		    irqreturn_t(*)(int, void *, struct pt_regs *),
+		    unsigned long, const char *, void *);
+void sys_free_irq(unsigned int, void *);
+struct sigaction;
+asmlinkage long sys_rt_sigaction(int sig,
+				 const struct sigaction __user * act,
+				 struct sigaction __user * oact,
+				 size_t sigsetsize);
+
+#endif				/* __KERNEL_SYSCALLS__ */
+/*
+ * "Conditional" syscalls
+ *
+ * What we want is __attribute__((weak,alias("sys_ni_syscall"))),
+ * but it doesn't work on all toolchains, so we just do it by hand
+ */
+#define cond_syscall(x) asm(".weak\t_" #x "\n\t.set\t_" #x ",_sys_ni_syscall");
+
+#endif				/* __ASM_BFIN_UNISTD_H */
Index: git/linux-2.6/include/asm-blackfin/user.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/user.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,91 @@
+#ifndef _BFIN_USER_H
+#define _BFIN_USER_H
+
+/* Changes by Tony Kou   Lineo, Inc.  July, 2001
+ *
+ * Based include/asm-m68knommu/user.h
+ *
+ */
+
+#include <asm/page.h>
+
+/* Core file format: The core file is written in such a way that gdb
+   can understand it and provide useful information to the user (under
+   linux we use the 'trad-core' bfd).  There are quite a number of
+   obstacles to being able to view the contents of the floating point
+   registers, and until these are solved you will not be able to view the
+   contents of them.  Actually, you can read in the core file and look at
+   the contents of the user struct to find out what the floating point
+   registers contain.
+   The actual file contents are as follows:
+   UPAGE: 1 page consisting of a user struct that tells gdb what is present
+   in the file.  Directly after this is a copy of the task_struct, which
+   is currently not used by gdb, but it may come in useful at some point.
+   All of the registers are stored as part of the upage.  The upage should
+   always be only one page.
+   DATA: The data area is stored.  We use current->end_text to
+   current->brk to pick up all of the user variables, plus any memory
+   that may have been malloced.  No attempt is made to determine if a page
+   is demand-zero or if a page is totally unused, we just cover the entire
+   range.  All of the addresses are rounded in such a way that an integral
+   number of pages is written.
+   STACK: We need the stack information in order to get a meaningful
+   backtrace.  We need to write the data from (esp) to
+   current->start_stack, so we round each of these off in order to be able
+   to write an integer number of pages.
+   The minimum core file size is 3 pages, or 12288 bytes.
+*/
+struct user_bfinfp_struct {
+};
+
+/* This is the old layout of "struct pt_regs" as of Linux 1.x, and
+   is still the layout used by user (the new pt_regs doesn't have
+   all registers). */
+struct user_regs_struct {
+	long r0, r1, r2, r3, r4, r5, r6, r7;
+	long p0, p1, p2, p3, p4, p5, usp, fp;
+	long i0, i1, i2, i3;
+	long l0, l1, l2, l3;
+	long b0, b1, b2, b3;
+	long m0, m1, m2, m3;
+	long a0w, a1w;
+	long a0x, a1x;
+	unsigned long rets;
+	unsigned long astat;
+	unsigned long pc;
+	unsigned long orig_p0;
+};
+
+/* When the kernel dumps core, it starts by dumping the user struct -
+   this will be used by gdb to figure out where the data and stack segments
+   are within the file, and what virtual addresses to use. */
+
+struct user {
+/* We start with the registers, to mimic the way that "memory" is returned
+   from the ptrace(3,...) function.  */
+
+	struct user_regs_struct regs;	/* Where the registers are actually stored */
+
+/* The rest of this junk is to help gdb figure out what goes where */
+	unsigned long int u_tsize;	/* Text segment size (pages). */
+	unsigned long int u_dsize;	/* Data segment size (pages). */
+	unsigned long int u_ssize;	/* Stack segment size (pages). */
+	unsigned long start_code;	/* Starting virtual address of text. */
+	unsigned long start_stack;	/* Starting virtual address of stack area.
+					   This is actually the bottom of the stack,
+					   the top of the stack is always found in the
+					   esp register.  */
+	long int signal;	/* Signal that caused the core dump. */
+	int reserved;		/* No longer used */
+	struct user_regs_struct *u_ar0;
+	/* Used by gdb to help find the values for */
+	/* the registers. */
+	unsigned long magic;	/* To uniquely identify a core file */
+	char u_comm[32];	/* User command that was responsible */
+};
+#define NBPG PAGE_SIZE
+#define UPAGES 1
+#define HOST_TEXT_START_ADDR (u.start_code)
+#define HOST_STACK_END_ADDR (u.start_stack + u.u_ssize * NBPG)
+
+#endif
Index: git/linux-2.6/include/asm-blackfin/auxvec.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/linux-2.6/include/asm-blackfin/auxvec.h	2005-12-21 15:11:13.000000000 +0800
@@ -0,0 +1,4 @@
+#ifndef __ASMBFIN_AUXVEC_H
+#define __ASMBFIN_AUXVEC_H
+
+#endif
Index: git/linux-2.6/include/linux/elf.h
===================================================================
--- git.orig/linux-2.6/include/linux/elf.h	2005-12-21 14:47:37.000000000 +0800
+++ git/linux-2.6/include/linux/elf.h	2005-12-21 15:11:13.000000000 +0800
@@ -94,6 +94,8 @@
 
 #define EM_H8_300       46      /* Renesas H8/300,300H,H8S */
 
+#define EM_BLACKFIN     106   /* ADI Blackfin Processor*/
+
 /*
  * This is an interim value that we will use until the committee comes
  * up with a final number.
Index: git/linux-2.6/scripts/mod/mk_elfconfig.c
===================================================================
--- git.orig/linux-2.6/scripts/mod/mk_elfconfig.c	2005-12-21 14:47:37.000000000 +0800
+++ git/linux-2.6/scripts/mod/mk_elfconfig.c	2005-12-21 15:11:13.000000000 +0800
@@ -55,7 +55,8 @@
 	else
 		abort();
 
-	if ((strcmp(argv[1], "v850") == 0) || (strcmp(argv[1], "h8300") == 0))
+	if ((strcmp(argv[1], "v850") == 0) || (strcmp(argv[1], "h8300") == 0)
+	    || (strcmp(argv[1], "blackfin") == 0))
 		printf("#define MODULE_SYMBOL_PREFIX \"_\"\n");
 	else 
 		printf("#define MODULE_SYMBOL_PREFIX \"\"\n");
