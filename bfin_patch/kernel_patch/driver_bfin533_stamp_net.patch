Index: git/linux-2.6/drivers/net/Kconfig
===================================================================
--- git.orig/linux-2.6/drivers/net/Kconfig	2005-12-21 10:02:34.000000000 +0800
+++ git/linux-2.6/drivers/net/Kconfig	2005-12-21 15:06:24.000000000 +0800
@@ -812,7 +812,7 @@
 	tristate "SMC 91C9x/91C1xxx support"
 	select CRC32
 	select MII
-	depends on NET_ETHERNET && (ARM || REDWOOD_5 || REDWOOD_6 || M32R || SUPERH || SOC_AU1X00)
+	depends on NET_ETHERNET && (ARM || REDWOOD_5 || REDWOOD_6 || M32R || SUPERH || SOC_AU1X00 || BFIN)
 	help
 	  This is a driver for SMC's 91x series of Ethernet chipsets,
 	  including the SMC91C94 and the SMC91C111. Say Y if you want it
Index: git/linux-2.6/drivers/net/smc91x.c
===================================================================
--- git.orig/linux-2.6/drivers/net/smc91x.c	2005-12-21 10:02:36.000000000 +0800
+++ git/linux-2.6/drivers/net/smc91x.c	2005-12-21 15:08:12.000000000 +0800
@@ -89,6 +89,9 @@
 
 #include <asm/io.h>
 #include <asm/irq.h>
+#if defined(CONFIG_BFIN)
+#include <asm/dma.h>
+#endif /* CONFIG_BFIN */
 
 #include "smc91x.h"
 
@@ -119,6 +122,15 @@
 
 #endif  /* CONFIG_ISA */
 
+#if defined(CONFIG_BFIN)
+/*
+ *  irq_pfx comes from platform_device and tells us which flag pin is used
+ *    IRQ_PF0 <= irq_pfx <= IRQ_PF15
+ *  irq_pfx is used as the irq if CONFIG_IRQCHIP_DEMUX_GPIO is enabled.
+ */
+static int irq_pfx;
+#endif /* CONFIG_BFIN */
+
 #ifndef SMC_NOWAIT
 # define SMC_NOWAIT		0
 #endif
@@ -156,7 +168,7 @@
 
 /*
  * The maximum number of processing loops allowed for each call to the
- * IRQ handler.  
+ * IRQ handler.
  */
 #define MAX_IRQ_LOOPS		8
 
@@ -312,6 +324,102 @@
 	}								\
 } while (0)
 
+#if defined(CONFIG_BFIN_SHARED_FLASH_ENET)
+static void bfin_cpld_setup(void)
+{
+
+	__builtin_bfin_ssync();
+	*pFIO_DIR |= CONFIG_ENET_FLASH_PIN;
+	__builtin_bfin_ssync();
+	*pFIO_FLAG_S = CONFIG_ENET_FLASH_PIN;
+	__builtin_bfin_ssync();
+
+}
+#endif
+
+#if defined(CONFIG_BFIN)
+static void bfin_SMC_interrupt_setup(int irq)
+{
+#ifdef CONFIG_IRQCHIP_DEMUX_GPIO
+	/* fix a floating input on the USB-LAN EZ-Extender */
+# if defined (CONFIG_BF561)
+	*pFIO0_DIR |= (1 << 12);
+# endif /* defined (CONFIG_BF561) */
+	printk("Blackfin SMC91x interrupt setup: DEMUX_GPIO irq %d\n", irq);
+	set_irq_type(irq, IRQT_HIGH);
+#else
+# if defined (CONFIG_BF561)
+	unsigned short flag;
+	unsigned short LAN_FIO_PATTERN;
+
+	if (irq_pfx < IRQ_PF0 || irq_pfx > IRQ_PF15) {
+		printk(CARDNAME "irq_pfx out of range: %d\n", irq_pfx);
+		return;
+	}
+
+	flag = irq_pfx - IRQ_PF0;
+	LAN_FIO_PATTERN = (1 << flag);
+
+	printk("Blackfin BF561 SMC91x interrupt setup: flag PF%d, irq %d\n", flag, irq);
+	if (irq == IRQ_PROG0_INTA || irq == IRQ_PROG0_INTB)
+	{
+		int ixab = (irq - IRQ_PROG0_INTA) * (pFIO0_MASKB_D - pFIO0_MASKA_D);
+
+		__builtin_bfin_csync();
+		pFIO0_MASKA_C[ixab] = LAN_FIO_PATTERN; /* disable int */
+		__builtin_bfin_ssync();
+
+		*pFIO0_POLAR	&= ~LAN_FIO_PATTERN; /* active high (input) */
+		*pFIO0_EDGE	&= ~LAN_FIO_PATTERN; /* by level (input) */
+		*pFIO0_BOTH	&= ~LAN_FIO_PATTERN;
+
+		*pFIO0_DIR	&= ~LAN_FIO_PATTERN; /* input */
+		*pFIO0_DIR	|= (1 << 12);	     /* fix a floating input */
+		*pFIO0_FLAG_C	=   LAN_FIO_PATTERN; /* clear output */
+		*pFIO0_INEN	|=  LAN_FIO_PATTERN; /* enable pin */
+
+		__builtin_bfin_ssync();
+		pFIO0_MASKA_S[ixab] = LAN_FIO_PATTERN; /* enable int */
+	}
+# else
+    unsigned short flag;
+    unsigned short LAN_FIO_PATTERN;
+
+    if (irq_pfx < IRQ_PF0 || irq_pfx > IRQ_PF15) {
+	printk(CARDNAME "irq_pfx out of range: %d\n", irq_pfx);
+	return;
+    }
+
+    flag = irq_pfx - IRQ_PF0;
+    LAN_FIO_PATTERN = (1 << flag);
+
+    printk("Blackfin SMC91x interrupt setup: flag PF%d, irq %d\n", flag, irq);
+  /* 26 = IRQ_PROG_INTA => FIO_MASKA
+     27 = IRQ_PROG_INTB => FIO_MASKB */
+  if (irq == IRQ_PROG_INTA/*26*/ ||
+      irq == IRQ_PROG_INTB/*27*/)
+    {
+      int ixab = (irq - IRQ_PROG_INTA) * (pFIO_MASKB_D - pFIO_MASKA_D);
+
+      __builtin_bfin_csync();
+      pFIO_MASKA_C[ixab] = LAN_FIO_PATTERN; /* disable int */
+      __builtin_bfin_ssync();
+
+      *pFIO_POLAR &= ~LAN_FIO_PATTERN; /* active high (input) */
+      *pFIO_EDGE  &= ~LAN_FIO_PATTERN; /* by level (input) */
+      *pFIO_BOTH  &= ~LAN_FIO_PATTERN;
+
+      *pFIO_DIR  &= ~LAN_FIO_PATTERN;   /* input */
+      *pFIO_FLAG_C = LAN_FIO_PATTERN;   /* clear output */
+      *pFIO_INEN |=  LAN_FIO_PATTERN;   /* enable pin */
+
+      __builtin_bfin_ssync();
+      pFIO_MASKA_S[ixab] = LAN_FIO_PATTERN; /* enable int */
+    }
+# endif /* defined(CONFIG_BF561) */
+#endif /*CONFIG_IRQCHIP_DEMUX_GPIO*/
+}
+#endif
 
 /*
  * this does a soft reset on the device
@@ -770,7 +878,7 @@
 		/*
 		 * Allocation succeeded: push packet to the chip's own memory
 		 * immediately.
-		 */  
+		 */
 		smc_hardware_send_pkt((unsigned long)dev);
 	}
 
@@ -1923,6 +2031,14 @@
 	SMC_SELECT_BANK(1);
 	SMC_GET_MAC_ADDR(dev->dev_addr);
 
+#if defined(CONFIG_BFIN)
+	/* check if the mac already in reg is valid */
+	if (*(u32 *)(&dev->dev_addr[0]) == 0xFFFFFFFF) {
+		random_ether_addr(dev->dev_addr);
+		SMC_SET_MAC_ADDR(dev->dev_addr);
+	}
+#endif
+
 	/* now, reset the chip, and put it into a known state */
 	smc_reset(dev);
 
@@ -2010,8 +2126,11 @@
       	retval = request_irq(dev->irq, &smc_interrupt, 0, dev->name, dev);
       	if (retval)
       		goto err_out;
-
+#ifdef CONFIG_BFIN
+	bfin_SMC_interrupt_setup(dev->irq);
+#else
 	set_irq_type(dev->irq, SMC_IRQ_TRIGGER_TYPE);
+#endif
 
 #ifdef SMC_USE_PXA_DMA
 	{
@@ -2220,6 +2339,10 @@
 		goto out_release_io;
 	}
 	SET_MODULE_OWNER(ndev);
+#if defined(CONFIG_BFIN_SHARED_FLASH_ENET)
+	/* setup BF533_STAMP CPLD to route AMS3 to Ethernet MAC */
+	bfin_cpld_setup();
+#endif
 	SET_NETDEV_DEV(ndev, &pdev->dev);
 
 	ndev->dma = (unsigned char)-1;
@@ -2242,6 +2365,20 @@
 	}
 
 	platform_set_drvdata(pdev, ndev);
+
+#if defined(CONFIG_BFIN)
+	/*
+	 *  We're using the second IRQ (index 1) in the platform resources
+	 *  to store the flag pin info.  The second IRQ is also the correct
+	 *  IRQ_PFx value to use if we have CONFIG_IRQCHIP_DEMUX_GPIO enabled.
+	 */
+	irq_pfx = platform_get_irq(pdev, 1);
+
+#if defined(CONFIG_IRQCHIP_DEMUX_GPIO)
+	ndev->irq = irq_pfx;
+#endif
+#endif
+
 	ret = smc_probe(ndev, addr);
 	if (ret != 0)
 		goto out_iounmap;
@@ -2349,7 +2486,7 @@
 #ifdef MODULE
 #ifdef CONFIG_ISA
 	if (io == -1)
-		printk(KERN_WARNING 
+		printk(KERN_WARNING
 			"%s: You shouldn't use auto-probing with insmod!\n",
 			CARDNAME);
 #endif
Index: git/linux-2.6/drivers/net/smc91x.h
===================================================================
--- git.orig/linux-2.6/drivers/net/smc91x.h	2005-12-21 10:02:36.000000000 +0800
+++ git/linux-2.6/drivers/net/smc91x.h	2005-12-21 15:03:44.000000000 +0800
@@ -55,6 +55,36 @@
 #define SMC_insw(a, r, p, l)	readsw((a) + (r), p, l)
 #define SMC_outsw(a, r, p, l)	writesw((a) + (r), p, l)
 
+#elif defined(CONFIG_BFIN)
+# if defined (CONFIG_BF561)
+#define SMC_CAN_USE_8BIT	0
+#define SMC_CAN_USE_16BIT	1
+#define SMC_CAN_USE_32BIT	1
+#define SMC_IO_SHIFT		0
+#define SMC_NOWAIT      	1
+#define SMC_USE_BFIN_DMA	0
+
+
+#define SMC_inw(a, r)       	readw((a) + (r))
+#define SMC_outw(v, a, r)   	writew(v, (a) + (r))
+#define SMC_inl(a, r)       	readl((a) + (r))
+#define SMC_outl(v, a, r)   	writel(v, (a) + (r))
+#define SMC_outsl(a, r, p, l)	outsl((unsigned long)((a) + (r)), p, l)
+#define SMC_insl(a, r, p, l) 	insl ((unsigned long)((a) + (r)), p, l)
+# else
+#define SMC_CAN_USE_8BIT	0
+#define SMC_CAN_USE_16BIT	1
+#define SMC_CAN_USE_32BIT	0
+#define SMC_IO_SHIFT		0
+#define SMC_NOWAIT      	1
+#define SMC_USE_BFIN_DMA	0
+
+
+#define SMC_inw(a, r)       	readw((a) + (r))
+#define SMC_outw(v, a, r)   	writew(v, (a) + (r))
+#define SMC_outsw(a, r, p, l)	outsw((unsigned long)((a) + (r)), p, l)
+#define SMC_insw(a, r, p, l) 	insw ((unsigned long)((a) + (r)), p, l)
+# endif
 #elif defined(CONFIG_REDWOOD_5) || defined(CONFIG_REDWOOD_6)
 
 /* We can only do 16-bit reads and writes in the static memory space. */
