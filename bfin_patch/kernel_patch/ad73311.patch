diff -uNr linux-old/sound/blackfin/ad73311.c linux-2.6.x/sound/blackfin/ad73311.c
--- linux-old/sound/blackfin/ad73311.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.x/sound/blackfin/ad73311.c	2006-02-09 17:29:56.000000000 +0800
@@ -0,0 +1,799 @@
+/*
+ * File:         ad73311.c 
+ * Description:  Driver for AD73311 sound chip connected to bf53x sport
+ * Rev:          $Id$
+ * Created:      Wed Jan 11 2006
+ * Author:       Roy Huang
+ * Email:        Roy.Huang@analog.com
+ * 
+ * Copyright (C) 2006 Analog Device Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* AD73311 only support one channel ADC and one channel DAC, both are 16 bits.
+ * SPORT is used to set AD73311's register during initialization, then set
+ * AD73311 to data mode. SPORT is used to transfer data and no register can be
+ * modified until reset chip.
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+
+#include <asm/blackfin.h>
+#include <asm/cacheflush.h>
+#include <asm/irq.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+
+#include "ad73311.h"
+#include "bf53x_sport.h"
+
+#ifndef CONFIG_BFIN_DMA_5XX
+#error "The sound driver requires the Blackfin Simple DMA"
+#endif
+
+#ifdef CONFIG_SND_DEBUG
+#define snd_printk_marker() snd_printk( KERN_INFO "%s\n", __FUNCTION__ )
+#else
+#define snd_printk_marker() 
+#endif
+
+#define GPIO_SE CONFIG_SND_BFIN_AD73311_SE
+#define GPIO_RESET CONFIG_SND_BFIN_AD73311_RESET
+
+#undef CONFIG_SND_DEBUG_CURRPTR  /* causes output every frame! */
+
+#define PCM_BUFFER_MAX	0x10000	/* 64KB */
+#define FRAGMENT_SIZE_MIN	(4 * 1024)
+#define FRAGMENTS_MIN	2
+#define FRAGMENTS_MAX	16
+
+#define CHIP_NAME "Analog Devices AD73311L"
+
+/* ALSA boilerplate */
+static int   index[SNDRV_CARDS]  = SNDRV_DEFAULT_IDX;
+static char* id[SNDRV_CARDS]     = SNDRV_DEFAULT_STR;
+static int   enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+
+
+#define ad73311_t_magic  0xa5a73311
+
+typedef struct snd_ad73311 {
+	snd_card_t*         card;
+	struct bf53x_sport* sport;
+	spinlock_t    ad73311_lock;
+
+	snd_pcm_t* pcm;
+
+	snd_pcm_substream_t* rx_substream;
+	snd_pcm_substream_t* tx_substream;
+
+	int runmode;
+#define RUN_RX 0x1
+#define RUN_TX 0x2
+} ad73311_t;
+
+#if L1_DATA_A_LENGTH != 0
+extern unsigned long l1_data_A_sram_alloc(unsigned long size);
+extern int l1_data_A_sram_free(unsigned long addr);
+#else
+#error "This driver need L1 data cache"
+#endif
+
+static int snd_ad73311_configure(struct bf53x_sport *sport);
+static int snd_ad73311_startup(ad73311_t *chip);
+static void snd_ad73311_stop(ad73311_t *chip);
+
+
+/*************************************************************
+ *                pcm methods 
+ *************************************************************/
+
+static snd_pcm_hardware_t snd_ad73311_play_hw = {
+	.info = (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+			SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =          SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =            SNDRV_PCM_RATE_8000,
+	.rate_min =         8000,
+	.rate_max =         8000,
+	.channels_min =     1,
+	.channels_max =     1,
+	.buffer_bytes_max = PCM_BUFFER_MAX,
+	.period_bytes_min = FRAGMENT_SIZE_MIN,
+	.period_bytes_max = PCM_BUFFER_MAX/2,
+	.periods_min =      FRAGMENTS_MIN,
+	.periods_max =      FRAGMENTS_MAX,
+};
+static snd_pcm_hardware_t snd_ad73311_cap_hw = {
+	.info = (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED | 
+			SNDRV_PCM_INFO_BLOCK_TRANSFER |  SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =          SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =            SNDRV_PCM_RATE_8000,
+	.rate_min =         8000,
+	.rate_max =         8000,
+	.channels_min =     1,
+	.channels_max =     1,
+	.buffer_bytes_max = PCM_BUFFER_MAX,
+	.period_bytes_min = FRAGMENT_SIZE_MIN,
+	.period_bytes_max = PCM_BUFFER_MAX/2,
+	.periods_min =      FRAGMENTS_MIN,
+	.periods_max =      FRAGMENTS_MAX,
+};
+
+static int snd_ad73311_play_open(snd_pcm_substream_t* substream)
+{
+	ad73311_t* chip = snd_pcm_substream_chip(substream);
+
+	snd_printk_marker();
+
+	substream->runtime->hw = snd_ad73311_play_hw;
+	chip->tx_substream = substream;
+
+	return 0;
+}
+
+static int snd_ad73311_cap_open(snd_pcm_substream_t* substream)
+{ 
+	ad73311_t* chip = snd_pcm_substream_chip(substream);
+
+	snd_printk_marker();
+
+	substream->runtime->hw = snd_ad73311_cap_hw;
+	chip->rx_substream = substream;
+
+	return 0;
+}
+
+
+static int snd_ad73311_play_close(snd_pcm_substream_t* substream)
+{
+	ad73311_t* chip = snd_pcm_substream_chip(substream);
+	snd_printk_marker();
+	chip->tx_substream = NULL;
+
+	return 0;
+}
+
+
+static int snd_ad73311_cap_close(snd_pcm_substream_t* substream)
+{
+	ad73311_t* chip = snd_pcm_substream_chip(substream);
+
+	snd_printk_marker();
+	chip->rx_substream = NULL;
+
+	return 0;
+}
+
+
+static int snd_ad73311_hw_params( snd_pcm_substream_t* substream, snd_pcm_hw_params_t* hwparams)
+{
+	snd_printk_marker();
+	if( snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hwparams)) < 0 )
+		return -ENOMEM;
+
+	return 0;
+}
+
+static int snd_ad73311_hw_free(snd_pcm_substream_t * substream)
+{
+	snd_printk_marker();
+	snd_pcm_lib_free_pages(substream);
+
+	return 0;
+}
+
+static int snd_ad73311_play_pre( snd_pcm_substream_t* substream )
+{
+
+	ad73311_t* chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t* runtime = substream->runtime;
+	int period_bytes = frames_to_bytes(runtime, runtime->period_size);
+
+	snd_assert( (substream == chip->tx_substream), return -EINVAL );
+
+	snd_printk_marker();
+	snd_printd(KERN_INFO "%s channels:%d, period_bytes:0x%x, periods:%d\n",
+				__FUNCTION__, runtime->channels, period_bytes,
+							runtime->periods);
+	return bf53x_sport_config_tx_dma( chip->sport, runtime->dma_area, 
+			runtime->periods, period_bytes);
+}
+
+static int snd_ad73311_cap_pre( snd_pcm_substream_t* substream )
+{
+
+	ad73311_t* chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t* runtime = substream->runtime;
+	int  period_bytes = frames_to_bytes(runtime, runtime->period_size);
+
+	snd_printk_marker();
+	snd_assert( (substream == chip->rx_substream), return -EINVAL );
+
+	snd_printd(KERN_INFO "%s channels:%d, period_bytes:%d, frag_count:%d\n",
+				__FUNCTION__, runtime->channels, period_bytes,
+							runtime->periods);
+	return bf53x_sport_config_rx_dma( chip->sport, runtime->dma_area, 
+					runtime->periods, period_bytes);
+}
+
+
+static int snd_ad73311_play_trigger( snd_pcm_substream_t* substream, 
+								int cmd)
+{
+	ad73311_t* chip = snd_pcm_substream_chip(substream);
+
+	spin_lock(&chip->ad73311_lock);
+	switch(cmd){
+		case SNDRV_PCM_TRIGGER_START: 
+			bf53x_sport_hook_tx_desc(chip->sport, 0);
+			if(!(chip->runmode & (RUN_RX | RUN_TX))) {
+				snd_ad73311_startup(chip);
+				bf53x_sport_hook_rx_desc(chip->sport, 1);
+				bf53x_sport_start(chip->sport);
+			}
+			chip->runmode |= RUN_TX;
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+			chip->runmode &= ~RUN_TX;
+			if (!(chip->runmode & (RUN_RX | RUN_TX))) {
+				bf53x_sport_stop(chip->sport);
+				snd_ad73311_stop(chip);
+			} else
+				bf53x_sport_hook_tx_desc(chip->sport, 1);
+			/*      printk("stop tx\n");*/
+			break;
+		default:
+			spin_unlock(&chip->ad73311_lock);
+			return -EINVAL;
+	}
+	spin_unlock(&chip->ad73311_lock);
+
+	snd_printd(KERN_INFO"cmd:%s,runmode:0x%x\n", cmd?"start":"stop", 
+								chip->runmode);
+	return 0;
+}
+
+static int snd_ad73311_cap_trigger( snd_pcm_substream_t* substream, int cmd)
+{
+
+	ad73311_t* chip = snd_pcm_substream_chip(substream);
+
+	spin_lock(&chip->ad73311_lock);
+	snd_assert(substream == chip->rx_substream, return -EINVAL);
+	switch(cmd){
+		case SNDRV_PCM_TRIGGER_START: 
+			bf53x_sport_hook_rx_desc(chip->sport, 0);
+			if (!(chip->runmode & (RUN_RX | RUN_TX))) { /* Sport isn't running  */
+				snd_ad73311_startup(chip);
+				bf53x_sport_hook_tx_desc(chip->sport, 1);
+				bf53x_sport_start(chip->sport);
+			}
+			chip->runmode |= RUN_RX;
+			printk("start rx\n");
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+			chip->runmode &= ~RUN_RX;
+			if (!(chip->runmode & (RUN_RX | RUN_TX))) {
+				bf53x_sport_stop(chip->sport);
+				snd_ad73311_stop(chip);
+			} else 
+				bf53x_sport_hook_rx_desc(chip->sport, 1);
+			printk("stop rx\n");
+			break;
+		default:
+			spin_unlock(&chip->ad73311_lock);
+			return -EINVAL;
+	}
+	spin_unlock(&chip->ad73311_lock);
+
+	printk(KERN_INFO"cmd:%s,runmode:0x%x\n", cmd?"start":"stop", chip->runmode); 
+	return 0;
+}
+
+static snd_pcm_uframes_t snd_ad73311_play_ptr( snd_pcm_substream_t* substream )
+{
+	ad73311_t* chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t* runtime = substream->runtime;
+
+	char* buf  = (char*) runtime->dma_area;
+	char* curr = (char*) bf53x_sport_curr_addr_tx(chip->sport);
+	unsigned long diff = curr - buf;
+	unsigned long bytes_per_frame = runtime->frame_bits/8;
+	size_t frames = diff / bytes_per_frame;
+
+	if( frames >= runtime->buffer_size ) 
+		frames = 0;
+
+	return frames;
+}
+
+static snd_pcm_uframes_t snd_ad73311_cap_ptr( snd_pcm_substream_t* substream )
+{
+	ad73311_t* chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t* runtime = substream->runtime;
+
+	char* buf  = (char*) runtime->dma_area;
+	char* curr = (char*) bf53x_sport_curr_addr_rx(chip->sport);
+	unsigned long diff = curr - buf;
+	unsigned long bytes_per_frame = runtime->frame_bits/8;
+	size_t frames = diff / bytes_per_frame;
+
+#ifdef CONFIG_SND_DEBUG_CURRPTR
+	snd_printk( KERN_INFO " cap pos: 0x%04lx / %lx\n", frames, runtime->buffer_size);
+#endif 
+
+	/* the loose syncing used here is accurate enough for alsa, but 
+	   due to latency in the dma, the following may happen occasionally, 
+	   and pcm_lib shouldn't complain */
+	if( frames >= runtime->buffer_size ) 
+		frames = 0;
+
+	return frames;
+}
+
+/* pcm method tables */
+
+static snd_pcm_ops_t snd_ad73311_play_ops = {
+	.open      = snd_ad73311_play_open,
+	.close     = snd_ad73311_play_close,
+	.ioctl     = snd_pcm_lib_ioctl,
+	.hw_params = snd_ad73311_hw_params,
+	.hw_free   = snd_ad73311_hw_free,
+	.prepare   = snd_ad73311_play_pre,
+	.trigger   = snd_ad73311_play_trigger,
+	.pointer   = snd_ad73311_play_ptr,
+};
+
+
+static snd_pcm_ops_t snd_ad73311_cap_ops = {
+	.open  = snd_ad73311_cap_open,
+	.close = snd_ad73311_cap_close,
+	.ioctl = snd_pcm_lib_ioctl,  
+	.hw_params = snd_ad73311_hw_params,
+	.hw_free   = snd_ad73311_hw_free,
+	.prepare   = snd_ad73311_cap_pre,
+	.trigger   = snd_ad73311_cap_trigger,
+	.pointer   = snd_ad73311_cap_ptr,
+};
+
+
+/************************************************************* 
+ *      card and device 
+ *************************************************************/
+static int snd_ad73311_free(ad73311_t *chip)
+{
+	/* TODO reset AD73311 by assert reset pin */
+	kfree(chip);
+	return 0;
+}
+
+/* component-destructor, wraps snd_ad73311_free for use in snd_device_ops_t
+ */
+static int snd_ad73311_dev_free(snd_device_t *device)
+{
+	ad73311_t *chip = (ad73311_t *)device->device_data;
+
+	return snd_ad73311_free(chip);
+}
+
+static snd_device_ops_t snd_ad73311_ops = {
+	.dev_free = snd_ad73311_dev_free,
+};
+
+static int snd_ad73311_startup(ad73311_t *chip)
+{
+	snd_printd(KERN_INFO "%s is called\n", __FUNCTION__);
+
+	snd_ad73311_configure(chip->sport);
+	
+	return 0;
+}
+
+static void snd_ad73311_stop(ad73311_t *chip)
+{
+	snd_printd(KERN_INFO "%s is called\n", __FUNCTION__);
+
+	/* Pull down SE pin on AD73311 */
+	*(unsigned short*)FIO_FLAG_C |= (1 << GPIO_SE);
+	*(unsigned short*)FIO_FLAG_S |= (1 << GPIO_RESET);
+
+	__builtin_bfin_ssync();
+}
+
+static void snd_ad73311_proc_read( snd_info_entry_t * entry, snd_info_buffer_t * buffer)
+{
+	ad73311_t *chip = entry->private_data;
+	snd_ad73311_configure(chip->sport);
+	snd_iprintf(buffer, "proc is read\n");
+	
+	return;
+}
+
+
+/* create the card struct, 
+ *   add - low-level device, 
+ *       - spi sport and registers, 
+ *       - a proc entry, 
+ *       - and a pcm device 
+ */
+
+static int __devinit snd_ad73311_create(snd_card_t *card,
+		struct bf53x_sport* sport, 
+		ad73311_t **rchip)
+{
+
+	ad73311_t *chip;
+	int err;
+
+	*rchip = NULL;
+
+	chip = (ad73311_t*)kcalloc(1, sizeof(ad73311_t), GFP_KERNEL);
+	if (chip == NULL)
+		return -ENOMEM;
+
+	chip->card  = card;
+	chip->sport = sport;
+	spin_lock_init(&chip->ad73311_lock);
+
+	if ((sport->dummy_buf=l1_data_A_sram_alloc(DUMMY_BUF_LEN)) == 0) {
+		printk(KERN_ERR "Unable to allocate dummy buffer in sram\n");
+		err = -ENODEV;
+		goto create_err1;
+	}
+	memset((void*)sport->dummy_buf, 0, DUMMY_BUF_LEN);
+
+	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &snd_ad73311_ops);
+	if(err) {
+		printk(KERN_ERR "Failed to create sound card device\n");
+		goto create_err2;
+	}
+	
+	/* 1 playback and 1 capture substream */
+	if ((err = snd_pcm_new(card, CHIP_NAME, 0, 1, 1, &chip->pcm))) {
+		printk(KERN_ERR "Failed to create PCM device \n");
+		goto create_err2;
+	}
+
+	chip->pcm->private_data = chip;
+	strcpy(chip->pcm->name, CHIP_NAME);
+	snd_pcm_set_ops(chip->pcm, SNDRV_PCM_STREAM_PLAYBACK,
+						&snd_ad73311_play_ops);
+	snd_pcm_set_ops(chip->pcm, SNDRV_PCM_STREAM_CAPTURE,
+						&snd_ad73311_cap_ops);
+
+	/* uncached DMA buffers */
+	err = snd_pcm_lib_preallocate_pages_for_all(chip->pcm, 
+				SNDRV_DMA_TYPE_DEV,NULL, PCM_BUFFER_MAX,
+				PCM_BUFFER_MAX);
+	if (err) {
+		printk(KERN_ERR "Failed to allocate memory\n");
+		goto create_err2;
+	}
+
+	err = sport_config_rx_dummy( sport);
+	err = err || sport_config_tx_dummy( sport );
+	if (err) {
+		printk(KERN_ERR "Failed to configure dummy buffer\n");
+		goto create_err2;
+	}
+
+	/* Debug purpose */
+	{
+		snd_info_entry_t* proc_entry;
+		snd_card_proc_new(card, "start", &proc_entry); 
+		snd_info_set_text_ops( proc_entry, chip, 1024, snd_ad73311_proc_read);
+	}
+
+	*rchip = chip;
+
+	return 0;
+	
+create_err2:
+	l1_data_A_sram_free((unsigned long)sport->dummy_buf);
+create_err1:
+	kfree(chip);
+
+	return err;
+}
+
+/************************************************************* 
+ *                 ALSA Card Level 
+ *************************************************************/
+
+static int snd_ad73311_configure(struct bf53x_sport *sport)
+{
+	int err = 0;
+	unsigned short ctrl_regs[6];
+	unsigned short status = 0;
+	int count = 0;
+	
+	/* Configure sport */
+	err = err || bf53x_sport_config_rx(sport, RFSR, 0xF, 0, 0);
+	err = err || bf53x_sport_config_tx(sport, TFSR, 0xF, 0, 0);
+	if(err) {
+		snd_printk( KERN_ERR "Unable to set sport configuration\n");
+		return err;
+	}
+	
+	*(unsigned short*)FIO_DIR |= (1 << GPIO_SE) | (1 << GPIO_RESET);
+	__builtin_bfin_ssync();
+
+	/* Hold reset# as low for 50us */
+	*(unsigned short*)FIO_FLAG_C |= (1 << GPIO_RESET);
+	*(unsigned short*)FIO_FLAG_S |= (1 << GPIO_SE);
+	__builtin_bfin_ssync();
+	udelay(50);
+	/* Pull reset# high */
+	*(unsigned short*)FIO_FLAG_S |= (1 << GPIO_RESET);
+	__builtin_bfin_ssync();
+	udelay(50);
+
+	/* Pull SE high to enable AD73311 */
+	*(unsigned short*)FIO_FLAG_S |= (1 << GPIO_SE);
+	__builtin_bfin_ssync();
+
+	/* Set registers on AD73311 through SPORT.  */
+	/* DMCLK = MCLK/4 = 16.384/4 = 4.096 MHz
+	   SCLK = DMCLK/8 = 512 KHz
+	   Sample Rate = DMCLK % 512 = 8 KHz */
+	ctrl_regs[0] = AD_CONTROL | AD_WRITE | CTRL_REG_B | MCDIV(0x3) | DIRATE(0x2);
+	/* Set Input gain to 20dB (0b100) */
+	ctrl_regs[1] = AD_CONTROL | AD_WRITE | CTRL_REG_D | IGS(4);
+	ctrl_regs[2] = AD_CONTROL | AD_WRITE | CTRL_REG_C | PUDEV | PUADC | \
+				PUDAC | PUREF | REFUSE | 0x80 ;/* Register C */
+	/* Put AD73311 to data mode */
+	ctrl_regs[3] = AD_CONTROL | AD_WRITE | CTRL_REG_A | MODE_DATA;
+
+	snd_printd(KERN_INFO "0x%04x 0x%04x 0x%04x 0x%04x\n", ctrl_regs[0],
+			ctrl_regs[1], ctrl_regs[2], ctrl_regs[3]);
+
+	local_irq_disable();
+#if CONFIG_SND_BFIN_SPORT == 0
+	/* SPORT Tx Register is a 8 x 16 FIFO, all the data can be put to
+	 * FIFO before enable SPORT to transfer the data */
+	*(unsigned short*)SPORT0_TX = ctrl_regs[0];
+	*(unsigned short*)SPORT0_TX = ctrl_regs[1];
+	*(unsigned short*)SPORT0_TX = ctrl_regs[2];
+	*(unsigned short*)SPORT0_TX = ctrl_regs[3];
+	__builtin_bfin_ssync();
+
+	*(unsigned short*)SPORT0_TCR1 |= TSPEN;	
+	__builtin_bfin_ssync();
+
+	/* When TUVF is set, the data is already send out */
+	while(! (status & TUVF) && count++ < 10000) {
+		udelay(1);
+		status = *(unsigned short *)SPORT0_STAT;
+		__builtin_bfin_ssync();
+//		printk(KERN_INFO "it is here! status:0x%04x\n", status);
+	}
+	*(unsigned short*)SPORT0_TCR1 &= ~TSPEN;
+	__builtin_bfin_ssync();
+#else
+	*(unsigned short*)SPORT1_TX = ctrl_regs[0];
+	*(unsigned short*)SPORT1_TX = ctrl_regs[1];
+	*(unsigned short*)SPORT1_TX = ctrl_regs[2];
+	*(unsigned short*)SPORT1_TX = ctrl_regs[3];
+	__builtin_bfin_ssync();
+
+	*(unsigned short*)SPORT1_TCR1 |= TSPEN;	
+	__builtin_bfin_ssync();
+
+	/* When TUVF is set, the data is already send out */
+	while(! (status & TUVF) && count++ < 10000) {
+		udelay(1);
+		status = *(unsigned short *)SPORT1_STAT;
+		__builtin_bfin_ssync();
+	}
+	*(unsigned short*)SPORT1_TCR1 &= ~TSPEN;
+	__builtin_bfin_ssync();
+#endif
+
+	local_irq_enable();
+
+	if (count == 10000)
+		return -1;
+
+	return 0;
+
+}
+
+static int __devinit snd_ad73311_probe(struct bf53x_sport* sport, 
+						snd_card_t** the_card)
+{
+	static int dev=0;
+	snd_card_t *card;
+	ad73311_t *chip;    
+	int err;
+
+	if (dev >= SNDRV_CARDS)  return -ENODEV;
+
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	card = snd_card_new( index[dev], id[dev], THIS_MODULE, 0 );
+	if( card == NULL ) {
+		err = -ENOMEM;
+		goto probe_err1;
+	}
+	
+	/* Initialize GPIO 2 & 3, GPIO2 is SE pin, GPIO3 is reset# pin*/
+	
+	if( (err = snd_ad73311_create(card, sport, &chip)) < 0 ) {
+		printk(KERN_ERR "Failed to call create\n");
+		goto probe_err2;
+	}
+
+	card->private_data = chip;
+	strcpy(card->driver, "ad73311");
+	strcpy(card->shortname, CHIP_NAME);
+	sprintf(card->longname, "%s at SPORT%d rx/tx dma %d/%d err irq /%d ", 
+			card->shortname, CONFIG_SND_BFIN_SPORT,
+			SPORT_DMA_RX, SPORT_DMA_TX, SPORT_ERR_IRQ);
+
+	if ((err = snd_card_register(card)) < 0) {
+		printk(KERN_ERR "Failed to register card\n");
+		goto probe_err2;
+	}
+
+	++dev;
+	*the_card = card;
+
+	return 0;
+probe_err2:
+	snd_card_free(card);
+probe_err1:
+	return err;
+}
+
+MODULE_AUTHOR("Roy Huang <roy.huang@analog.com>");
+MODULE_DESCRIPTION("Blackfin/ADI AD73311");
+MODULE_LICENSE("GPL");
+
+static snd_card_t*         card=NULL;
+static struct bf53x_sport* sport=NULL;
+
+static __devexit void snd_ad73311_remove(snd_card_t* card)
+{
+	l1_data_A_sram_free((unsigned long)sport->dummy_buf);
+	snd_card_free(card);
+
+	return;
+}
+
+
+static irqreturn_t sport_rx_hdlr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned int rx_stat;
+	ad73311_t *chip = card->private_data;
+	
+//	printk(KERN_INFO "sport rx interrupt happened\n");
+	bf53x_sport_check_status( chip->sport, NULL, &rx_stat, NULL );  
+	if( !(rx_stat & DMA_DONE) ) {
+		snd_printk(KERN_ERR"Error - RX DMA is already stopped\n");
+		return IRQ_HANDLED;
+	}
+
+	if( (chip->rx_substream) && (chip->runmode & RUN_RX ))
+		snd_pcm_period_elapsed(chip->rx_substream);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t sport_tx_hdlr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned int tx_stat;
+	ad73311_t *chip = card->private_data;
+
+//	printk(KERN_INFO "sport tx interrupt happened\n");
+	bf53x_sport_check_status( chip->sport, NULL, NULL, &tx_stat );  
+	if( !(tx_stat & DMA_DONE)) {
+		snd_printk(KERN_ERR"Error - TX DMA is already stopped\n");
+		return IRQ_HANDLED;
+	}
+	if( (chip->tx_substream) && (chip->runmode & RUN_TX)) {
+		snd_pcm_period_elapsed(chip->tx_substream);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t sport_err_hdlr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned int status;
+
+	if(!sport) return IRQ_NONE;
+	if( bf53x_sport_check_status(sport, &status, NULL, NULL) ){
+		snd_printk( KERN_ERR "error checking status ??" );
+		return IRQ_NONE;
+	}
+
+	if( status & (TOVF|TUVF|ROVF|RUVF) ){
+		snd_printk( KERN_WARNING  "sport status error:%s%s%s%s\n", 
+				status & TOVF ? " TOVF" : "", 
+				status & TUVF ? " TUVF" : "", 
+				status & ROVF ? " ROVF" : "", 
+				status & RUVF ? " RUVF" : "" );
+		bf53x_sport_stop(sport);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int __init snd_ad73311_init(void)
+{
+	int err;
+
+	if( (sport = bf53x_sport_init(CONFIG_SND_BFIN_SPORT,  
+			SPORT_DMA_RX, sport_rx_hdlr,
+			SPORT_DMA_TX, sport_tx_hdlr, 2) ) == NULL ){ 
+		printk(KERN_ERR"Initialize sport failed\n");
+		err = -EFAULT;
+		goto init_err1;
+	}
+
+	if( request_irq(SPORT_ERR_IRQ, sport_err_hdlr, SA_SHIRQ, 
+						"SPORT Error", sport )){
+		printk(KERN_ERR"Request sport error IRQ failed:%d\n", 
+							SPORT_ERR_IRQ);
+		err = -ENODEV;
+		goto init_err2;
+	}
+
+	if((err = snd_ad73311_probe(sport, &card)))
+		goto init_err3;
+
+	return 0;
+
+init_err3:
+	free_irq(SPORT_ERR_IRQ, sport);
+init_err2:
+	bf53x_sport_done(sport);
+init_err1:
+
+	return err;
+}
+
+static void __exit snd_ad73311_exit(void)
+{
+	if( card ){
+		snd_ad73311_remove(card);
+		card = NULL;
+	}
+
+	if( sport ){
+		free_irq(SPORT_ERR_IRQ, sport);
+		bf53x_sport_done(sport);
+		sport = NULL;
+	}
+
+	return;
+}
+
+module_init(snd_ad73311_init);
+module_exit(snd_ad73311_exit);
diff -uNr linux-old/sound/blackfin/ad73311.h linux-2.6.x/sound/blackfin/ad73311.h
--- linux-old/sound/blackfin/ad73311.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.x/sound/blackfin/ad73311.h	2006-02-09 15:17:58.000000000 +0800
@@ -0,0 +1,89 @@
+/*
+ * File:         ad73311.h 
+ * Description:  definitions for AD73311 registers
+ * Rev:          $Id$
+ * Created:      Wed Jan 11, 2006
+ * Author:       Roy Huang
+ * mail:         Roy.Huang@analog.com
+ * 
+ * Copyright (C) 2006 Analog Device Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#if CONFIG_SND_BFIN_SPORT == 0
+#define SPORT_ERR_IRQ	IRQ_SPORT0_ERROR
+#define SPORT_DMA_RX	CH_SPORT0_RX
+#define SPORT_DMA_TX	CH_SPORT0_TX
+#else
+#define SPORT_ERR_IRQ	IRQ_SPORT1_ERROR
+#define SPORT_DMA_RX	CH_SPORT1_RX
+#define SPORT_DMA_TX	CH_SPORT1_TX
+#endif
+
+#define AD_CONTROL	0x8000
+#define AD_DATA		0x0000
+#define AD_READ		0x4000
+#define AD_WRITE	0x0000
+
+/* Control register A */
+#define CTRL_REG_A	(0 << 8)
+
+#define MODE_PRO	0x00
+#define MODE_DATA	0x01
+#define MODE_MIXED	0x03
+#define DLB		0x04
+#define SLB		0x08
+#define DC(x)		((x & 0x7) << 4)
+#define RESET		0x80
+
+/* Control register B */
+#define CTRL_REG_B	(1 << 8)
+
+#define DIRATE(x)	(x & 0x3)
+#define SCDIV(x)	((x & 0x3) << 2)
+#define MCDIV(x)	((x & 0x7) << 4)
+#define CEE		(1 << 7)
+
+/* Control register C */
+#define CTRL_REG_C	(2 << 8)
+
+#define PUDEV		( 1 << 1 )
+#define PUADC		( 1 << 3 )
+#define PUDAC		( 1 << 4 )
+#define PUREF		( 1 << 5 )
+#define REFUSE		( 1 << 6 )
+
+/* Control register D */
+#define CTRL_REG_D	(3 << 8)
+
+#define IGS(x)		(x & 0x7)
+#define RMOD		( 1 << 3 )
+#define OGS(x)		((x & 0x7) << 4)
+#define MUTE		(x << 7)
+
+/* Control register E */
+#define CTRL_REG_E	(4 << 8)
+
+#define DA(x)		(x & 0x1f)
+#define IBYP		( 1 << 5 )
+
+/* Control register F */
+#define CTRL_REG_F	(5 << 8)
+
+#define SEEN		( 1 << 5 )
+#define INV		( 1 << 6 )
+#define ALB		( 1 << 7 )
diff -uNr linux-old/sound/blackfin/bf53x_sport.c linux-2.6.x/sound/blackfin/bf53x_sport.c
--- linux-old/sound/blackfin/bf53x_sport.c	2005-12-19 12:15:29.000000000 +0800
+++ linux-2.6.x/sound/blackfin/bf53x_sport.c	2006-02-10 13:37:01.000000000 +0800
@@ -99,7 +99,7 @@
 struct bf53x_sport* 
 bf53x_sport_init(int sport_chan, 
 		int dma_rx, dma_interrupt_t rx_handler,
-		int dma_tx, dma_interrupt_t tx_handler){
+		int dma_tx, dma_interrupt_t tx_handler, int word_len){
 
   struct bf53x_sport* sport = (struct bf53x_sport*) kmalloc( sizeof(struct bf53x_sport), GFP_KERNEL );
  
@@ -157,6 +157,10 @@
   sport->curr_rx_desc = NULL;
   sport->curr_tx_desc = NULL;
 
+  sport->word_len = word_len;
+
+  printk(KERN_ERR "Sport word length:%d\n", word_len);
+
 #if defined(CONFIG_BF534)|defined(CONFIG_BF536)|defined(CONFIG_BF537)
   if(sport->sport_chan) {
     *pPORT_MUX |= PGTE|PGRE|PGSE;
@@ -289,9 +293,8 @@
 }
 
 
-
 static void setup_desc(dmasg_t* desc, void* buf, int fragcount, size_t fragsize_bytes,
-		unsigned int cfg, unsigned int x_count, unsigned int ycount){
+		unsigned int cfg, unsigned int xcount, unsigned int ycount, unsigned int modify){
 
   int i;
 
@@ -299,10 +302,10 @@
     desc[i].next_desc_addr  = (unsigned long)&( desc[i + 1] );
     desc[i].start_addr = (unsigned long)buf + i*fragsize_bytes;
     desc[i].cfg = cfg;
-    desc[i].x_count = x_count;
-    desc[i].x_modify = sizeof(long);
+    desc[i].x_count = xcount;
+    desc[i].x_modify = modify;
     desc[i].y_count = ycount;
-    desc[i].y_modify = sizeof(long);
+    desc[i].y_modify = modify;
   }
 
   desc[fragcount-1].next_desc_addr = (unsigned long)desc; /* make circular */
@@ -386,8 +389,9 @@
 		sport->curr_rx_desc = sport->dummy_rx_desc;
 	else
 		sport->curr_rx_desc = sport->dma_rx_desc;
+
 	dma->next_desc_ptr = (unsigned int)(sport->curr_rx_desc);
-	dma->cfg           = FLOW | NDSIZE | WDSIZE_32 | WNR;
+	dma->cfg           = FLOW | NDSIZE | WNR | WDSIZE_32;
 	dma->x_count       = 0;
 	dma->x_modify      = 0;
 	dma->y_count       = 0;
@@ -456,7 +460,7 @@
 		sport->curr_tx_desc = sport->dma_tx_desc;
  
 	dma->next_desc_ptr = (unsigned int)(sport->curr_tx_desc);
-	dma->cfg           = FLOW | NDSIZE |WDSIZE_32 ;
+	dma->cfg = FLOW | NDSIZE | WDSIZE_32;
 	dma->x_count       = 0;
 	dma->x_modify      = 0;
 	dma->y_count       = 0;
@@ -484,7 +488,7 @@
      the line below is the cheapest test I could think of :-) 
   */
 
-  if( fragsize_bytes > 0x8000*sizeof(long) )
+  if( fragsize_bytes > 0x8000*sport->word_len )
     if( (fragsize_bytes | (fragsize_bytes-1) ) != (2*fragsize_bytes - 1) )
       return -EINVAL;
 
@@ -499,9 +503,10 @@
     return -ENOMEM;
   }
 
-  x_count = fragsize_bytes/sizeof(long);
+  x_count = fragsize_bytes/sport->word_len;
   y_count = 0;
-  cfg     = 0x7000 | DI_EN | WDSIZE_32 | WNR | (DESC_ELEMENT_COUNT << 8); /* large descriptor mode */
+  cfg     = 0x7000 | DI_EN | WNR | (DESC_ELEMENT_COUNT << 8); /* large descriptor mode */
+  cfg |= (sport->word_len / 2) << 2;
 
   if( x_count > 0x8000 ){
     y_count = x_count >> 15;
@@ -509,7 +514,7 @@
     cfg |= DMA2D;
   }
 
-  setup_desc( sport->dma_rx_desc, buf, fragcount, fragsize_bytes , cfg|DMAEN, x_count, y_count);
+  setup_desc( sport->dma_rx_desc, buf, fragcount, fragsize_bytes , cfg|DMAEN, x_count, y_count, sport->word_len);
 
   return 0;
 
@@ -528,7 +533,7 @@
 
   /* fragsize must be a power of two (line below is the cheapest test I could think of :-) */
 
-  if( fragsize_bytes > 0x8000*sizeof(long) )
+  if( fragsize_bytes > 0x8000*sport->word_len )
     if( (fragsize_bytes | (fragsize_bytes-1) ) != (2*fragsize_bytes - 1) )
       return -EINVAL;
 
@@ -542,9 +547,10 @@
     return -ENOMEM;
   }
 
-  x_count = fragsize_bytes/sizeof(long);
+  x_count = fragsize_bytes/sport->word_len;
   y_count = 0;
-  cfg     = 0x7000 | DI_EN | WDSIZE_32 | ( DESC_ELEMENT_COUNT << 8); /* large descriptor mode */
+  cfg     = 0x7000 | DI_EN | ( DESC_ELEMENT_COUNT << 8); /* large descriptor mode */
+  cfg |= (sport->word_len / 2) << 2;
 
   if( x_count > 0x8000 ){
     y_count = x_count >> 15;
@@ -552,7 +558,7 @@
     cfg |= DMA2D;
   }
 
-  setup_desc( sport->dma_tx_desc, buf, fragcount, fragsize_bytes, cfg|DMAEN, x_count, y_count);
+  setup_desc( sport->dma_tx_desc, buf, fragcount, fragsize_bytes, cfg|DMAEN, x_count, y_count, sport->word_len);
 
   return 0;
 
@@ -581,7 +587,8 @@
 
 	desc->next_desc_addr = (unsigned long)desc;
 	desc->start_addr = sport->dummy_buf;
-	config = FLOW | NDSIZE | WDSIZE_32 | WNR ;
+	config = FLOW | NDSIZE | WNR ;
+	config |= (sport->word_len / 2) << 2;
 	desc->cfg = config | DMAEN;
 	desc->x_count = 0x80;
 	desc->x_modify = 0;
@@ -616,7 +623,8 @@
 
 	desc->next_desc_addr = (unsigned long)desc;
 	desc->start_addr = sport->dummy_buf;
-	config = FLOW | NDSIZE |WDSIZE_32;
+	config = FLOW | NDSIZE ;
+	config |= (sport->word_len / 2) << 2;
 	desc->cfg = config | DMAEN;
 	desc->x_count = 0x80;
 	desc->x_modify = 0;
diff -uNr linux-old/sound/blackfin/bf53x_sport.h linux-2.6.x/sound/blackfin/bf53x_sport.h
--- linux-old/sound/blackfin/bf53x_sport.h	2005-12-13 11:50:29.000000000 +0800
+++ linux-2.6.x/sound/blackfin/bf53x_sport.h	2006-02-08 17:54:51.000000000 +0800
@@ -106,6 +106,8 @@
   unsigned int tcr2;
   int tx_tdm_count;
 
+  int word_len; /* Word length of one DMA transfer */
+
 #ifdef BF53X_ANOMALY_29
   int is_running;   /* little kludge to work around anomaly 29: DMA_RUN bit unreliable */
 #endif
@@ -114,7 +116,7 @@
 
 struct bf53x_sport* bf53x_sport_init(int sport_chan,  
                 int dma_rx, dma_interrupt_t rx_handler,
-                int dma_tx, dma_interrupt_t tx_handler);
+                int dma_tx, dma_interrupt_t tx_handler, int word_len);
 void bf53x_sport_done(struct bf53x_sport* sport);
 
 /* first use these ...*/
diff -uNr linux-old/sound/blackfin/Kconfig linux-2.6.x/sound/blackfin/Kconfig
--- linux-old/sound/blackfin/Kconfig	2006-02-08 09:24:09.000000000 +0800
+++ linux-2.6.x/sound/blackfin/Kconfig	2006-02-09 17:12:27.000000000 +0800
@@ -92,5 +92,38 @@
 	  Enter the Blackfin SPI channel to which your sound chip is connected
 	  acceptable values are 0 to 7
 
+config SND_BFIN_AD73311
+	tristate "AD73311 Audio support for BF53x"
+	depends on BFIN
+	select SND_PCM
+	help
+	  Select this if you have an AD73311 or AD73311L connected to SPORT0 ports
+
+	  If unsure, say N.
+
+config SND_BFIN_SPORT
+	int "Blackfin Audio SPORT port"
+	depends on SND_BFIN_AD73311
+	default 0
+	help
+	  Enter the Blackfin SPORT port to which your sound chip is connected
+	  acceptable values are 0 or 1
+
+config SND_BFIN_AD73311_SE
+	int "GPIO for AD73311 SE pin"
+	depends on SND_BFIN_AD73311
+	default 2
+	help
+	  Enter the GPIO used to control AD73311's SE pin. Acceptable 
+	  values are 0 to 7
+
+config SND_BFIN_AD73311_RESET
+	int "GPIO for AD73311 reset pin"
+	depends on SND_BFIN_AD73311
+	default 3
+	help
+	  Enter the GPIO used to control AD73311's reset pin. Acceptable 
+	  values are 0 to 7
+
 endmenu
 
diff -uNr linux-old/sound/blackfin/Makefile linux-2.6.x/sound/blackfin/Makefile
--- linux-old/sound/blackfin/Makefile	2006-02-08 09:24:09.000000000 +0800
+++ linux-2.6.x/sound/blackfin/Makefile	2006-02-09 14:40:30.000000000 +0800
@@ -3,9 +3,11 @@
 #
 
 snd-adi1836-objs  := adi1836.o  bf53x_sport.o bf53x_spi.o 
+snd-ad73311-objs := ad73311.o bf53x_sport.o
 snd-adi1981b-objs := adi1981b.o bf53x_sport.o 
 
 obj-$(CONFIG_SND_BLACKFIN_ADI1836)	+= snd-adi1836.o
+obj-$(CONFIG_SND_BFIN_AD73311)		+= snd-ad73311.o
 obj-$(CONFIG_SND_BLACKFIN_ADI1981B)	+= snd-adi1981b.o
 
 
