diff --width=180 -x .rcc -x .uic -x .moc -x '*~' -x '*.prl' -x '*.pc' -x '*.la' -x 'Makefile*' -Ndru qtopia-core-opensource-src-4.2.2-newest-toolchain/include/Qt/qatomic_bfin.h qtcore/include/Qt/qatomic_bfin.h
--- qtopia-core-opensource-src-4.2.2-newest-toolchain/include/Qt/qatomic_bfin.h	1970-01-01 01:00:00.000000000 +0100
+++ qtcore/include/Qt/qatomic_bfin.h	2007-06-25 13:11:30.000000000 +0200
@@ -0,0 +1 @@
+#include "../../src/corelib/arch/qatomic_bfin.h"
diff --width=180 -x .rcc -x .uic -x .moc -x '*~' -x '*.prl' -x '*.pc' -x '*.la' -x 'Makefile*' -Ndru qtopia-core-opensource-src-4.2.2-newest-toolchain/include/QtCore/qatomic_bfin.h qtcore/include/QtCore/qatomic_bfin.h
--- qtopia-core-opensource-src-4.2.2-newest-toolchain/include/QtCore/qatomic_bfin.h	1970-01-01 01:00:00.000000000 +0100
+++ qtcore/include/QtCore/qatomic_bfin.h	2007-06-25 13:11:36.000000000 +0200
@@ -0,0 +1 @@
+#include "../../src/corelib/arch/qatomic_bfin.h"
diff --width=180 -x .rcc -x .uic -x .moc -x '*~' -x '*.prl' -x '*.pc' -x '*.la' -x 'Makefile*' -Ndru qtopia-core-opensource-src-4.2.2-newest-toolchain/src/corelib/arch/bfin/arch.pri qtcore/src/corelib/arch/bfin/arch.pri
--- qtopia-core-opensource-src-4.2.2-newest-toolchain/src/corelib/arch/bfin/arch.pri	1970-01-01 01:00:00.000000000 +0100
+++ qtcore/src/corelib/arch/bfin/arch.pri	2007-06-25 13:06:21.000000000 +0200
@@ -0,0 +1,3 @@
+# 
+# bfin architecture
+#
diff --width=180 -x .rcc -x .uic -x .moc -x '*~' -x '*.prl' -x '*.pc' -x '*.la' -x 'Makefile*' -Ndru qtopia-core-opensource-src-4.2.2-newest-toolchain/src/corelib/arch/qatomic_arch.h qtcore/src/corelib/arch/qatomic_arch.h
--- qtopia-core-opensource-src-4.2.2-newest-toolchain/src/corelib/arch/qatomic_arch.h	2007-01-03 16:07:35.000000000 +0100
+++ qtcore/src/corelib/arch/qatomic_arch.h	2007-06-25 13:04:38.000000000 +0200
@@ -32,6 +32,8 @@
 #  include "QtCore/qatomic_alpha.h"
 #elif defined(QT_ARCH_ARM)
 #  include "QtCore/qatomic_arm.h"
+#elif defined(QT_ARCH_BFIN)
+#  include "QtCore/qatomic_bfin.h"
 #elif defined(QT_ARCH_BOUNDSCHECKER)
 #  include "QtCore/qatomic_boundschecker.h"
 #elif defined(QT_ARCH_GENERIC)
diff --width=180 -x .rcc -x .uic -x .moc -x '*~' -x '*.prl' -x '*.pc' -x '*.la' -x 'Makefile*' -Ndru qtopia-core-opensource-src-4.2.2-newest-toolchain/src/corelib/arch/qatomic_bfin.h qtcore/src/corelib/arch/qatomic_bfin.h
--- qtopia-core-opensource-src-4.2.2-newest-toolchain/src/corelib/arch/qatomic_bfin.h	1970-01-01 01:00:00.000000000 +0100
+++ qtcore/src/corelib/arch/qatomic_bfin.h	2007-06-25 13:00:17.000000000 +0200
@@ -0,0 +1,139 @@
+/****************************************************************************
+**
+** Copyright (C) 1992-2006 Trolltech ASA. All rights reserved.
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** This file may be used under the terms of the GNU General Public
+** License version 2.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of
+** this file.  Please review the following information to ensure GNU
+** General Public Licensing requirements will be met:
+** http://www.trolltech.com/products/qt/opensource.html
+**
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://www.trolltech.com/products/qt/licensing.html or contact the
+** sales department at sales@trolltech.com.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+****************************************************************************/
+
+#ifndef BFIN_QATOMIC_H
+#define BFIN_QATOMIC_H
+
+#include <QtCore/qglobal.h>
+
+#include <asm/fixed_code.h>
+
+QT_BEGIN_HEADER
+
+#if defined(Q_CC_GNU) || defined(Q_CC_INTEL)
+
+inline int q_atomic_test_and_set_int(volatile int *ptr, int expected, int newval)
+{
+    long int readval;
+    asm volatile ("P0 = %2;\n\t"
+		  "R1 = %3;\n\t"
+		  "R2 = %4;\n\t"
+		  "CALL (%5);\n\t"
+		  "%0 = R0;\n\t"
+		  : "=da" (readval), "=m" (*ptr)
+		  : "da" (ptr),
+		  "da" (expected),
+		  "da" (newval),
+		  "a" (ATOMIC_CAS32),
+		  "m" (*ptr)
+		  : "P0", "R0", "R1", "R2", "RETS", "memory", "cc");
+    return readval == expected;
+}
+
+inline int q_atomic_test_and_set_acquire_int(volatile int *ptr, int expected, int newval)
+{
+    return q_atomic_test_and_set_int(ptr, expected, newval);
+}
+
+inline int q_atomic_test_and_set_release_int(volatile int *ptr, int expected, int newval)
+{
+    return q_atomic_test_and_set_int(ptr, expected, newval);
+}
+
+inline int q_atomic_test_and_set_ptr(volatile void *ptr, void *expected, void *newval)
+{
+    return q_atomic_test_and_set_int(reinterpret_cast<volatile int *>(ptr),
+                                     reinterpret_cast<int>(expected),
+                                     reinterpret_cast<int>(newval));
+}
+
+inline int q_atomic_increment(volatile int *ptr)
+{
+    int ret;
+    asm volatile("R0 = 1;\n\t"
+		 "P0 = %3;\n\t"
+                 "CALL (%2);\n\t"
+                 "%0 = R0;"
+                 : "=da" (ret), "=m" (*ptr)
+                 : "a" (ATOMIC_ADD32), "da" (ptr), "m" (*ptr)
+                 : "R0", "R1", "P0", "RETS", "memory");
+    return ret;
+}
+
+inline int q_atomic_decrement(volatile int *ptr)
+{
+    int ret;
+    asm volatile("R0 = 1;\n\t"
+		 "P0 = %3;\n\t"
+                 "CALL (%2);\n\t"
+                 "%0 = R0;"
+                 : "=da" (ret), "=m" (*ptr)
+                 : "a" (ATOMIC_SUB32), "da" (ptr), "m" (*ptr)
+                 : "R0", "R1", "P0", "RETS", "memory");
+    return ret;
+}
+
+inline int q_atomic_set_int(volatile int *ptr, int newval)
+{
+    asm volatile("R1 = %2;\n\t"
+		 "P0 = %4;\n\t"
+                 "CALL (%3);\n\t"
+                 "%0 = R0;"
+                 : "=da" (newval), "=m" (*ptr)
+                 : "da" (newval), "a" (ATOMIC_XCHG32), "da" (ptr), "m" (*ptr)
+                 : "R0", "R1", "P0", "RETS", "memory");
+    return newval;
+}
+
+inline void *q_atomic_set_ptr(volatile void *ptr, void *newval)
+{
+    return reinterpret_cast<void *>(q_atomic_set_int(reinterpret_cast<volatile int *>(ptr),
+                                                     reinterpret_cast<int>(newval)));
+}
+
+#else
+
+extern "C" {
+    Q_CORE_EXPORT int q_atomic_test_and_set_int(volatile int *ptr, int expected, int newval);
+    Q_CORE_EXPORT int q_atomic_test_and_set_ptr(volatile void *ptr, void *expected, void *newval);
+    Q_CORE_EXPORT int q_atomic_increment(volatile int *ptr);
+    Q_CORE_EXPORT int q_atomic_decrement(volatile int *ptr);
+    Q_CORE_EXPORT int q_atomic_set_int(volatile int *ptr, int newval);
+    Q_CORE_EXPORT void *q_atomic_set_ptr(volatile void *ptr, void *newval);
+} // extern "C"
+
+inline int q_atomic_test_and_set_acquire_int(volatile int *ptr, int expected, int newval)
+{
+    return q_atomic_test_and_set_int(ptr, expected, newval);
+}
+
+inline int q_atomic_test_and_set_release_int(volatile int *ptr, int expected, int newval)
+{
+    return q_atomic_test_and_set_int(ptr, expected, newval);
+}
+
+#endif
+
+QT_END_HEADER
+
+#endif // BFIN_QATOMIC_H
