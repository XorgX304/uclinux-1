Index: sound/soc/blackfin/bf5xx-sport.h
===================================================================
--- sound/soc/blackfin/bf5xx-sport.h	(revision 4191)
+++ sound/soc/blackfin/bf5xx-sport.h	(working copy)
@@ -114,7 +114,17 @@
 	void *tx_data;
 	void (*err_callback)(void *data);
 	void *err_data;
-
+	unsigned char *tx_dma_buf;
+	unsigned char *rx_dma_buf;
+	dma_addr_t tx_dma_phy;
+	dma_addr_t rx_dma_phy;
+	/*
+	int tx_hw_ptr;
+	int rx_hw_ptr;
+	*/
+	int tx_pos;/*pcm sample count*/
+	int rx_pos;
+	
 	void *private_data;
 };
 
Index: sound/soc/blackfin/bf5xx-pcm.c
===================================================================
--- sound/soc/blackfin/bf5xx-pcm.c	(revision 4191)
+++ sound/soc/blackfin/bf5xx-pcm.c	(working copy)
@@ -27,12 +27,36 @@
 #include "bf5xx-ac97.h"
 #include "bf5xx-sport.h"
 
+static void bf5xx_mmap_copy(struct snd_pcm_substream *substream,
+	 snd_pcm_uframes_t count)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sport_device *sport = runtime->private_data;
+		
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			bf5xx_ac97_pcm32_to_frame(
+					(struct ac97_frame *)sport->tx_dma_buf + sport->tx_pos,
+					(__u32*)runtime->dma_area+sport->tx_pos, count);
+			sport->tx_pos += runtime->period_size;
+			if (sport->tx_pos >= runtime->buffer_size)
+				sport->tx_pos %= runtime->buffer_size;
+			
+		} else {
+			bf5xx_ac97_frame_to_pcm32(
+					(struct ac97_frame *)sport->rx_dma_buf + sport->rx_pos,
+					(__u32*)runtime->dma_area+sport->rx_pos, count);
+			sport->rx_pos += runtime->period_size;
+			if (sport->rx_pos >= runtime->buffer_size)
+				sport->rx_pos %= runtime->buffer_size;
+		}	
+}
 
 static void bf5xx_dma_irq(void *data)
 {
 	struct snd_pcm_substream *pcm = data;
-
+	struct snd_pcm_runtime *runtime = pcm->runtime;
 	pr_debug("%s enter \n", __FUNCTION__);
+	bf5xx_mmap_copy(pcm, runtime->period_size);
 	snd_pcm_period_elapsed(pcm);
 }
 
@@ -42,12 +66,14 @@
  */
 static const struct snd_pcm_hardware bf5xx_pcm_hardware = {
 	.info			= SNDRV_PCM_INFO_INTERLEAVED |
-				  SNDRV_PCM_INFO_BLOCK_TRANSFER,
+				   SNDRV_PCM_INFO_MMAP |
+				   SNDRV_PCM_INFO_MMAP_VALID |
+				   SNDRV_PCM_INFO_BLOCK_TRANSFER,
 	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
-	.period_bytes_min	= 32,
-	.period_bytes_max	= 0x10000,
-	.periods_min		= 1,
-	.periods_max		= PAGE_SIZE/32,
+	.period_bytes_min	= 2048,
+	.period_bytes_max	= 2048,
+	.periods_min		= 16,
+	.periods_max		= 16,
 	.buffer_bytes_max	= 0x20000, /* 128 kbytes */
 	.fifo_size		= 16,
 };
@@ -57,7 +83,6 @@
 {
 	size_t size = bf5xx_pcm_hardware.buffer_bytes_max * \
 			sizeof(struct ac97_frame) / 4;
-
 	snd_pcm_lib_malloc_pages(substream, size);
 
 	return 0;
@@ -73,14 +98,35 @@
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct sport_device *sport = runtime->private_data;
-
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (!sport->tx_dma_buf) {
+			sport->tx_dma_buf = dma_alloc_coherent(NULL, \
+				runtime->buffer_size * sizeof(struct ac97_frame), &sport->tx_dma_phy, GFP_KERNEL);
+			if (!sport->tx_dma_buf) {
+				printk(KERN_ERR "Failed to allocate memory for tx dma buf\n");
+				return -ENOMEM;
+			} else
+				memset(sport->tx_dma_buf,0,runtime->buffer_size * sizeof(struct ac97_frame));
+		}
+	} else {
+		if (!sport->rx_dma_buf) {
+			sport->rx_dma_buf = dma_alloc_coherent(NULL, \
+				runtime->buffer_size * sizeof(struct ac97_frame), &sport->rx_dma_phy, GFP_KERNEL);
+			if (!sport->rx_dma_buf) {
+				printk(KERN_ERR "Failed to allocate memory for rx dma buf\n");
+				return -ENOMEM;
+			} else
+				memset(sport->rx_dma_buf,0,runtime->buffer_size * sizeof(struct ac97_frame));
+		}
+	}
+	memset(runtime->dma_area,0,runtime->buffer_size * sizeof(struct ac97_frame));
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		sport_set_tx_callback(sport, bf5xx_dma_irq, substream);
-		sport_config_tx_dma(sport, runtime->dma_area, runtime->periods,
+		sport_config_tx_dma(sport, sport->tx_dma_buf, runtime->periods,
 				runtime->period_size * sizeof(struct ac97_frame));
 	} else {
 		sport_set_rx_callback(sport, bf5xx_dma_irq, substream);
-		sport_config_rx_dma(sport, runtime->dma_area, runtime->periods,
+		sport_config_rx_dma(sport, sport->rx_dma_buf, runtime->periods,
 				runtime->period_size * sizeof(struct ac97_frame));
 	}
 	return 0;
@@ -88,17 +134,27 @@
 
 static int bf5xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 {
-	struct sport_device *sport = substream->runtime->private_data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sport_device *sport = runtime->private_data;
 	int ret = 0;
 
 	pr_debug("%s %s\n", substream->stream?"Capture":"Playback", \
 			cmd?" start":" stop");
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			bf5xx_mmap_copy(substream, runtime->period_size);
+			snd_pcm_period_elapsed(substream);
 			sport_tx_start(sport);
-		else
+			bf5xx_mmap_copy(substream, runtime->period_size);
+			snd_pcm_period_elapsed(substream);
+		}
+		else {
 			sport_rx_start(sport);
+			bf5xx_mmap_copy(substream, runtime->period_size);
+			snd_pcm_period_elapsed(substream);
+			
+		}
 		break;
 
 	case SNDRV_PCM_TRIGGER_STOP:
@@ -106,9 +162,12 @@
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 			pr_debug("stop dma\n");
+			sport->tx_pos = 0;
 			sport_tx_stop(sport);
-		} else
+		} else {
+			sport->rx_pos = 0;
 			sport_rx_stop(sport);
+		}
 		break;
 
 	default:
@@ -124,9 +183,13 @@
 	struct sport_device *sport = runtime->private_data;
 	unsigned int curr;
 
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			
 		curr = sport_curr_offset_tx(sport) / sizeof(struct ac97_frame);
+	}
+		
 	else
+		
 		curr = sport_curr_offset_rx(sport) / sizeof(struct ac97_frame);
 	pr_debug("%s pointer curr:0x%0x\n", substream->stream ? \
 			"Capture":"Playback", curr);
@@ -134,26 +197,6 @@
 	return curr;
 }
 
-static	int bf5xx_pcm_copy(struct snd_pcm_substream *substream, int channel,
-		    snd_pcm_uframes_t pos,
-		    void __user *buf, snd_pcm_uframes_t count)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-
-	pr_debug("%s copy pos:0x%lx count:0x%lx\n",
-			substream->stream?"Capture":"Playback", pos, count);
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		bf5xx_ac97_pcm32_to_frame(
-				(struct ac97_frame *)runtime->dma_area + pos,
-				buf, count);
-	} else
-		bf5xx_ac97_frame_to_pcm32(
-				(struct ac97_frame *)runtime->dma_area + pos,
-				buf, count);
-
-	return 0;
-}
-
 static int bf5xx_pcm_open(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -181,9 +224,29 @@
 
 static int bf5xx_pcm_close(struct snd_pcm_substream *substream)
 {
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sport_device *sport = runtime->private_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		sport->tx_pos = 0;
+	} else {
+		sport->rx_pos = 0;
+	}
 	return 0;
 }
 
+static int bf5xx_pcm_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma)
+{	
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	size_t size = vma->vm_end - vma->vm_start;
+	vma->vm_start = (unsigned long)runtime->dma_area;
+	vma->vm_end = vma->vm_start + size;
+	vma->vm_flags |=  VM_SHARED;
+	return 0 ;
+}
+
+
 struct snd_pcm_ops bf5xx_pcm_ops = {
 	.open		= bf5xx_pcm_open,
 	.close		= bf5xx_pcm_close,
@@ -193,7 +256,7 @@
 	.prepare	= bf5xx_pcm_prepare,
 	.trigger	= bf5xx_pcm_trigger,
 	.pointer	= bf5xx_pcm_pointer,
-	.copy		= bf5xx_pcm_copy,
+	.mmap		= bf5xx_pcm_mmap,
 };
 
 static int bf5xx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
@@ -226,6 +289,7 @@
 {
 	struct snd_pcm_substream *substream;
 	struct snd_dma_buffer *buf;
+	struct snd_pcm_runtime *runtime;
 	int stream;
 
 	for (stream = 0; stream < 2; stream++) {
@@ -236,7 +300,19 @@
 		buf = &substream->dma_buffer;
 		if (!buf->area)
 			continue;
-
+		
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			runtime = substream->runtime;
+			dma_free_coherent(NULL, runtime->buffer_size * sizeof(struct ac97_frame),\
+				sport_handle->tx_dma_buf, 0);
+			sport_handle->tx_dma_buf = NULL;
+		} else {
+			runtime = substream->runtime;
+			dma_free_coherent(NULL, runtime->buffer_size * sizeof(struct ac97_frame), \
+				sport_handle->rx_dma_buf, 0);
+			sport_handle->rx_dma_buf = NULL;
+		}
+		
 		dma_free_coherent(NULL, buf->bytes, buf->area, 0);
 		buf->area = NULL;
 	}
Index: mm/nommu.c
===================================================================
--- mm/nommu.c	(revision 4191)
+++ mm/nommu.c	(working copy)
@@ -672,8 +672,10 @@
 
 		/* eliminate any capabilities that we can't support on this
 		 * device */
+		/*
 		if (!file->f_op->get_unmapped_area)
 			capabilities &= ~BDI_CAP_MAP_DIRECT;
+		*/
 		if (!file->f_op->read)
 			capabilities &= ~BDI_CAP_MAP_COPY;
 
@@ -1202,6 +1204,7 @@
 			if (err)
 				return err;
 		}
+		
 		if (vma->vm_end > end) {
 			err = split_nommu_vma(mm, vma, end, 0, &(*parent)->next);
 			if (err == -EINVAL)
@@ -1209,11 +1212,10 @@
 			if (err)
 				return err;
 		}
-
+		
 		/* Set up another round for the remaining area to unmap.  */
 		addr = vma->vm_end;
 		len -= vma->vm_end - vma->vm_start;
-
 		unmap_one_vma(mm, vma, parent);
 
 		if (!len)
